/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const SHRT_WIDTH: u32 = 16;
pub type khronos_uint64_t = u64;
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u64;
pub type std_array_difference_type = u64;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ShShaderSpec {
    SH_GLES2_SPEC = 0,
    SH_WEBGL_SPEC = 1,
    SH_GLES3_SPEC = 2,
    SH_WEBGL2_SPEC = 3,
    SH_GLES3_1_SPEC = 4,
    SH_WEBGL3_SPEC = 5,
    SH_GLES3_2_SPEC = 6,
    SH_GL_CORE_SPEC = 7,
    SH_GL_COMPATIBILITY_SPEC = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ShShaderOutput {
    SH_ESSL_OUTPUT = 35653,
    SH_GLSL_COMPATIBILITY_OUTPUT = 35654,
    SH_GLSL_130_OUTPUT = 35655,
    SH_GLSL_140_OUTPUT = 35712,
    SH_GLSL_150_CORE_OUTPUT = 35713,
    SH_GLSL_330_CORE_OUTPUT = 35714,
    SH_GLSL_400_CORE_OUTPUT = 35715,
    SH_GLSL_410_CORE_OUTPUT = 35716,
    SH_GLSL_420_CORE_OUTPUT = 35717,
    SH_GLSL_430_CORE_OUTPUT = 35718,
    SH_GLSL_440_CORE_OUTPUT = 35719,
    SH_GLSL_450_CORE_OUTPUT = 35720,
    SH_HLSL_3_0_OUTPUT = 35656,
    SH_HLSL_4_1_OUTPUT = 35657,
    SH_HLSL_4_0_FL9_3_OUTPUT = 35658,
    SH_SPIRV_VULKAN_OUTPUT = 35659,
    SH_SPIRV_METAL_OUTPUT = 35660,
    SH_MSL_METAL_OUTPUT = 35661,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ShPixelLocalStorageType {
    NotSupported = 0,
    ImageStoreR32PackedFormats = 1,
    ImageStoreNativeFormats = 2,
    FramebufferFetch = 3,
}
impl ShFragmentSynchronizationType {
    pub const EnumCount: ShFragmentSynchronizationType = ShFragmentSynchronizationType::InvalidEnum;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ShFragmentSynchronizationType {
    NotSupported = 0,
    Automatic = 1,
    FragmentShaderInterlock_NV_GL = 2,
    FragmentShaderOrdering_INTEL_GL = 3,
    FragmentShaderInterlock_ARB_GL = 4,
    RasterizerOrderViews_D3D = 5,
    RasterOrderGroups_Metal = 6,
    InvalidEnum = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShCompileOptionsMetal {
    pub driverUniformsBindingIndex: ::std::os::raw::c_int,
    pub defaultUniformsBindingIndex: ::std::os::raw::c_int,
    pub UBOArgumentBufferBindingIndex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ShCompileOptionsMetal"][::std::mem::size_of::<ShCompileOptionsMetal>() - 12usize];
    ["Alignment of ShCompileOptionsMetal"]
        [::std::mem::align_of::<ShCompileOptionsMetal>() - 4usize];
    ["Offset of field: ShCompileOptionsMetal::driverUniformsBindingIndex"]
        [::std::mem::offset_of!(ShCompileOptionsMetal, driverUniformsBindingIndex) - 0usize];
    ["Offset of field: ShCompileOptionsMetal::defaultUniformsBindingIndex"]
        [::std::mem::offset_of!(ShCompileOptionsMetal, defaultUniformsBindingIndex) - 4usize];
    ["Offset of field: ShCompileOptionsMetal::UBOArgumentBufferBindingIndex"]
        [::std::mem::offset_of!(ShCompileOptionsMetal, UBOArgumentBufferBindingIndex) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShCompileOptionsPLS {
    pub type_: ShPixelLocalStorageType,
    pub fragmentSynchronizationType: ShFragmentSynchronizationType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ShCompileOptionsPLS"][::std::mem::size_of::<ShCompileOptionsPLS>() - 8usize];
    ["Alignment of ShCompileOptionsPLS"][::std::mem::align_of::<ShCompileOptionsPLS>() - 4usize];
    ["Offset of field: ShCompileOptionsPLS::type_"]
        [::std::mem::offset_of!(ShCompileOptionsPLS, type_) - 0usize];
    ["Offset of field: ShCompileOptionsPLS::fragmentSynchronizationType"]
        [::std::mem::offset_of!(ShCompileOptionsPLS, fragmentSynchronizationType) - 4usize];
};
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ShCompileOptions {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub metal: ShCompileOptionsMetal,
    pub pls: ShCompileOptionsPLS,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ShCompileOptions"][::std::mem::size_of::<ShCompileOptions>() - 32usize];
    ["Alignment of ShCompileOptions"][::std::mem::align_of::<ShCompileOptions>() - 8usize];
    ["Offset of field: ShCompileOptions::metal"]
        [::std::mem::offset_of!(ShCompileOptions, metal) - 8usize];
    ["Offset of field: ShCompileOptions::pls"]
        [::std::mem::offset_of!(ShCompileOptions, pls) - 20usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN16ShCompileOptionsC1Ev"]
    pub fn ShCompileOptions_ShCompileOptions(this: *mut ShCompileOptions);
}
extern "C" {
    #[link_name = "\u{1}_ZN16ShCompileOptionsC1ERKS_"]
    pub fn ShCompileOptions_ShCompileOptions1(
        this: *mut ShCompileOptions,
        other: *const ShCompileOptions,
    );
}
impl ShCompileOptions {
    #[inline]
    pub fn objectCode(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_objectCode(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn objectCode_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_objectCode_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn variables(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_variables(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn variables_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_variables_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sourcePath(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sourcePath(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sourcePath_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_sourcePath_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn intermediateTree(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_intermediateTree(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn intermediateTree_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_intermediateTree_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn validateAST(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_validateAST(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn validateAST_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_validateAST_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn validateLoopIndexing(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_validateLoopIndexing(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn validateLoopIndexing_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_validateLoopIndexing_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lineDirectives(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_lineDirectives(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lineDirectives_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_lineDirectives_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn removeInvariantAndCentroidForESSL3(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_removeInvariantAndCentroidForESSL3(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn removeInvariantAndCentroidForESSL3_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_removeInvariantAndCentroidForESSL3_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn emulateAbsIntFunction(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_emulateAbsIntFunction(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn emulateAbsIntFunction_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_emulateAbsIntFunction_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn enforcePackingRestrictions(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enforcePackingRestrictions(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn enforcePackingRestrictions_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_enforcePackingRestrictions_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clampIndirectArrayBounds(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clampIndirectArrayBounds(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clampIndirectArrayBounds_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_clampIndirectArrayBounds_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn limitExpressionComplexity(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_limitExpressionComplexity(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn limitExpressionComplexity_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_limitExpressionComplexity_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn limitCallStackDepth(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_limitCallStackDepth(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn limitCallStackDepth_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_limitCallStackDepth_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initGLPosition(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_initGLPosition(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initGLPosition_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_initGLPosition_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initGLPointSize(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_initGLPointSize(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initGLPointSize_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_initGLPointSize_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unfoldShortCircuit(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_unfoldShortCircuit(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unfoldShortCircuit_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_unfoldShortCircuit_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initOutputVariables(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_initOutputVariables(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initOutputVariables_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_initOutputVariables_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scalarizeVecAndMatConstructorArgs(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_scalarizeVecAndMatConstructorArgs(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scalarizeVecAndMatConstructorArgs_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_scalarizeVecAndMatConstructorArgs_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn regenerateStructNames(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_regenerateStructNames(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn regenerateStructNames_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_regenerateStructNames_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rewriteDoWhileLoops(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rewriteDoWhileLoops(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rewriteDoWhileLoops_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rewriteDoWhileLoops_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn expandSelectHLSLIntegerPowExpressions(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_expandSelectHLSLIntegerPowExpressions(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn expandSelectHLSLIntegerPowExpressions_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_expandSelectHLSLIntegerPowExpressions_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flattenPragmaSTDGLInvariantAll(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_flattenPragmaSTDGLInvariantAll(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flattenPragmaSTDGLInvariantAll_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_flattenPragmaSTDGLInvariantAll_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HLSLGetDimensionsIgnoresBaseLevel(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HLSLGetDimensionsIgnoresBaseLevel(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HLSLGetDimensionsIgnoresBaseLevel_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_HLSLGetDimensionsIgnoresBaseLevel_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rewriteTexelFetchOffsetToTexelFetch(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rewriteTexelFetchOffsetToTexelFetch(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rewriteTexelFetchOffsetToTexelFetch_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rewriteTexelFetchOffsetToTexelFetch_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addAndTrueToLoopCondition(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addAndTrueToLoopCondition(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addAndTrueToLoopCondition_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addAndTrueToLoopCondition_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rewriteIntegerUnaryMinusOperator(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rewriteIntegerUnaryMinusOperator(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rewriteIntegerUnaryMinusOperator_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                25usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rewriteIntegerUnaryMinusOperator_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                25usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn emulateIsnanFloatFunction(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_emulateIsnanFloatFunction(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn emulateIsnanFloatFunction_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_emulateIsnanFloatFunction_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn useUnusedStandardSharedBlocks(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_useUnusedStandardSharedBlocks(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useUnusedStandardSharedBlocks_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_useUnusedStandardSharedBlocks_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rewriteFloatUnaryMinusOperator(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rewriteFloatUnaryMinusOperator(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rewriteFloatUnaryMinusOperator_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rewriteFloatUnaryMinusOperator_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn emulateAtan2FloatFunction(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_emulateAtan2FloatFunction(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn emulateAtan2FloatFunction_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_emulateAtan2FloatFunction_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initializeUninitializedLocals(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_initializeUninitializedLocals(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initializeUninitializedLocals_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_initializeUninitializedLocals_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initializeBuiltinsForInstancedMultiview(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_initializeBuiltinsForInstancedMultiview(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initializeBuiltinsForInstancedMultiview_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_initializeBuiltinsForInstancedMultiview_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn selectViewInNvGLSLVertexShader(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_selectViewInNvGLSLVertexShader(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn selectViewInNvGLSLVertexShader_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_selectViewInNvGLSLVertexShader_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clampPointSize(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clampPointSize(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clampPointSize_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_clampPointSize_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addAdvancedBlendEquationsEmulation(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addAdvancedBlendEquationsEmulation(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addAdvancedBlendEquationsEmulation_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addAdvancedBlendEquationsEmulation_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dontUseLoopsToInitializeVariables(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_dontUseLoopsToInitializeVariables(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dontUseLoopsToInitializeVariables_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_dontUseLoopsToInitializeVariables_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skipD3DConstantRegisterZero(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_skipD3DConstantRegisterZero(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skipD3DConstantRegisterZero_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_skipD3DConstantRegisterZero_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn clampFragDepth(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_clampFragDepth(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn clampFragDepth_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_clampFragDepth_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rewriteRepeatedAssignToSwizzled(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rewriteRepeatedAssignToSwizzled(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rewriteRepeatedAssignToSwizzled_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rewriteRepeatedAssignToSwizzled_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn emulateGLDrawID(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_emulateGLDrawID(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn emulateGLDrawID_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_emulateGLDrawID_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initSharedVariables(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_initSharedVariables(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initSharedVariables_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_initSharedVariables_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn forceAtomicValueResolution(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_forceAtomicValueResolution(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn forceAtomicValueResolution_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_forceAtomicValueResolution_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn emulateGLBaseVertexBaseInstance(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_emulateGLBaseVertexBaseInstance(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn emulateGLBaseVertexBaseInstance_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_emulateGLBaseVertexBaseInstance_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn emulateSeamfulCubeMapSampling(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_emulateSeamfulCubeMapSampling(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn emulateSeamfulCubeMapSampling_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_emulateSeamfulCubeMapSampling_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn takeVideoTextureAsExternalOES(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_takeVideoTextureAsExternalOES(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn takeVideoTextureAsExternalOES_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_takeVideoTextureAsExternalOES_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addBaseVertexToVertexID(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addBaseVertexToVertexID(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addBaseVertexToVertexID_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                45usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addBaseVertexToVertexID_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                45usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn removeDynamicIndexingOfSwizzledVector(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_removeDynamicIndexingOfSwizzledVector(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn removeDynamicIndexingOfSwizzledVector_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                46usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_removeDynamicIndexingOfSwizzledVector_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                46usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allowTranslateUniformBlockToStructuredBuffer(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_allowTranslateUniformBlockToStructuredBuffer(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allowTranslateUniformBlockToStructuredBuffer_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                47usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_allowTranslateUniformBlockToStructuredBuffer_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                47usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addVulkanYUVLayoutQualifier(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addVulkanYUVLayoutQualifier(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addVulkanYUVLayoutQualifier_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addVulkanYUVLayoutQualifier_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn disableARBTextureRectangle(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_disableARBTextureRectangle(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disableARBTextureRectangle_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_disableARBTextureRectangle_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rewriteRowMajorMatrices(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_rewriteRowMajorMatrices(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rewriteRowMajorMatrices_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                50usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_rewriteRowMajorMatrices_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                50usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ignorePrecisionQualifiers(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ignorePrecisionQualifiers(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignorePrecisionQualifiers_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                51usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_ignorePrecisionQualifiers_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                51usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addVulkanDepthCorrection(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addVulkanDepthCorrection(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addVulkanDepthCorrection_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addVulkanDepthCorrection_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn forceShaderPrecisionHighpToMediump(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_forceShaderPrecisionHighpToMediump(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn forceShaderPrecisionHighpToMediump_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_forceShaderPrecisionHighpToMediump_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn useSpecializationConstant(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_useSpecializationConstant(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn useSpecializationConstant_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_useSpecializationConstant_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addVulkanXfbEmulationSupportCode(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addVulkanXfbEmulationSupportCode(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addVulkanXfbEmulationSupportCode_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                55usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addVulkanXfbEmulationSupportCode_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                55usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addVulkanXfbExtensionSupportCode(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addVulkanXfbExtensionSupportCode(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addVulkanXfbExtensionSupportCode_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addVulkanXfbExtensionSupportCode_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn initFragmentOutputVariables(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_initFragmentOutputVariables(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn initFragmentOutputVariables_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                57usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_initFragmentOutputVariables_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                57usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn generateSpirvThroughGlslang(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_generateSpirvThroughGlslang(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn generateSpirvThroughGlslang_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                58usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_generateSpirvThroughGlslang_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                58usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn addExplicitBoolCasts(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_addExplicitBoolCasts(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn addExplicitBoolCasts_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_addExplicitBoolCasts_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn roundOutputAfterDithering(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_roundOutputAfterDithering(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn roundOutputAfterDithering_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                60usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_roundOutputAfterDithering_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                60usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn precisionSafeDivision(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_precisionSafeDivision(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn precisionSafeDivision_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_precisionSafeDivision_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn passHighpToPackUnormSnormBuiltins(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_passHighpToPackUnormSnormBuiltins(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn passHighpToPackUnormSnormBuiltins_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_passHighpToPackUnormSnormBuiltins_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        objectCode: u64,
        variables: u64,
        sourcePath: u64,
        intermediateTree: u64,
        validateAST: u64,
        validateLoopIndexing: u64,
        lineDirectives: u64,
        removeInvariantAndCentroidForESSL3: u64,
        emulateAbsIntFunction: u64,
        enforcePackingRestrictions: u64,
        clampIndirectArrayBounds: u64,
        limitExpressionComplexity: u64,
        limitCallStackDepth: u64,
        initGLPosition: u64,
        initGLPointSize: u64,
        unfoldShortCircuit: u64,
        initOutputVariables: u64,
        scalarizeVecAndMatConstructorArgs: u64,
        regenerateStructNames: u64,
        rewriteDoWhileLoops: u64,
        expandSelectHLSLIntegerPowExpressions: u64,
        flattenPragmaSTDGLInvariantAll: u64,
        HLSLGetDimensionsIgnoresBaseLevel: u64,
        rewriteTexelFetchOffsetToTexelFetch: u64,
        addAndTrueToLoopCondition: u64,
        rewriteIntegerUnaryMinusOperator: u64,
        emulateIsnanFloatFunction: u64,
        useUnusedStandardSharedBlocks: u64,
        rewriteFloatUnaryMinusOperator: u64,
        emulateAtan2FloatFunction: u64,
        initializeUninitializedLocals: u64,
        initializeBuiltinsForInstancedMultiview: u64,
        selectViewInNvGLSLVertexShader: u64,
        clampPointSize: u64,
        addAdvancedBlendEquationsEmulation: u64,
        dontUseLoopsToInitializeVariables: u64,
        skipD3DConstantRegisterZero: u64,
        clampFragDepth: u64,
        rewriteRepeatedAssignToSwizzled: u64,
        emulateGLDrawID: u64,
        initSharedVariables: u64,
        forceAtomicValueResolution: u64,
        emulateGLBaseVertexBaseInstance: u64,
        emulateSeamfulCubeMapSampling: u64,
        takeVideoTextureAsExternalOES: u64,
        addBaseVertexToVertexID: u64,
        removeDynamicIndexingOfSwizzledVector: u64,
        allowTranslateUniformBlockToStructuredBuffer: u64,
        addVulkanYUVLayoutQualifier: u64,
        disableARBTextureRectangle: u64,
        rewriteRowMajorMatrices: u64,
        ignorePrecisionQualifiers: u64,
        addVulkanDepthCorrection: u64,
        forceShaderPrecisionHighpToMediump: u64,
        useSpecializationConstant: u64,
        addVulkanXfbEmulationSupportCode: u64,
        addVulkanXfbExtensionSupportCode: u64,
        initFragmentOutputVariables: u64,
        generateSpirvThroughGlslang: u64,
        addExplicitBoolCasts: u64,
        roundOutputAfterDithering: u64,
        precisionSafeDivision: u64,
        passHighpToPackUnormSnormBuiltins: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let objectCode: u64 = unsafe { ::std::mem::transmute(objectCode) };
            objectCode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let variables: u64 = unsafe { ::std::mem::transmute(variables) };
            variables as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sourcePath: u64 = unsafe { ::std::mem::transmute(sourcePath) };
            sourcePath as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let intermediateTree: u64 = unsafe { ::std::mem::transmute(intermediateTree) };
            intermediateTree as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let validateAST: u64 = unsafe { ::std::mem::transmute(validateAST) };
            validateAST as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let validateLoopIndexing: u64 = unsafe { ::std::mem::transmute(validateLoopIndexing) };
            validateLoopIndexing as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let lineDirectives: u64 = unsafe { ::std::mem::transmute(lineDirectives) };
            lineDirectives as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let removeInvariantAndCentroidForESSL3: u64 =
                unsafe { ::std::mem::transmute(removeInvariantAndCentroidForESSL3) };
            removeInvariantAndCentroidForESSL3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let emulateAbsIntFunction: u64 =
                unsafe { ::std::mem::transmute(emulateAbsIntFunction) };
            emulateAbsIntFunction as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enforcePackingRestrictions: u64 =
                unsafe { ::std::mem::transmute(enforcePackingRestrictions) };
            enforcePackingRestrictions as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let clampIndirectArrayBounds: u64 =
                unsafe { ::std::mem::transmute(clampIndirectArrayBounds) };
            clampIndirectArrayBounds as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let limitExpressionComplexity: u64 =
                unsafe { ::std::mem::transmute(limitExpressionComplexity) };
            limitExpressionComplexity as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let limitCallStackDepth: u64 = unsafe { ::std::mem::transmute(limitCallStackDepth) };
            limitCallStackDepth as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let initGLPosition: u64 = unsafe { ::std::mem::transmute(initGLPosition) };
            initGLPosition as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let initGLPointSize: u64 = unsafe { ::std::mem::transmute(initGLPointSize) };
            initGLPointSize as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let unfoldShortCircuit: u64 = unsafe { ::std::mem::transmute(unfoldShortCircuit) };
            unfoldShortCircuit as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let initOutputVariables: u64 = unsafe { ::std::mem::transmute(initOutputVariables) };
            initOutputVariables as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let scalarizeVecAndMatConstructorArgs: u64 =
                unsafe { ::std::mem::transmute(scalarizeVecAndMatConstructorArgs) };
            scalarizeVecAndMatConstructorArgs as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let regenerateStructNames: u64 =
                unsafe { ::std::mem::transmute(regenerateStructNames) };
            regenerateStructNames as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rewriteDoWhileLoops: u64 = unsafe { ::std::mem::transmute(rewriteDoWhileLoops) };
            rewriteDoWhileLoops as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let expandSelectHLSLIntegerPowExpressions: u64 =
                unsafe { ::std::mem::transmute(expandSelectHLSLIntegerPowExpressions) };
            expandSelectHLSLIntegerPowExpressions as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let flattenPragmaSTDGLInvariantAll: u64 =
                unsafe { ::std::mem::transmute(flattenPragmaSTDGLInvariantAll) };
            flattenPragmaSTDGLInvariantAll as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let HLSLGetDimensionsIgnoresBaseLevel: u64 =
                unsafe { ::std::mem::transmute(HLSLGetDimensionsIgnoresBaseLevel) };
            HLSLGetDimensionsIgnoresBaseLevel as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rewriteTexelFetchOffsetToTexelFetch: u64 =
                unsafe { ::std::mem::transmute(rewriteTexelFetchOffsetToTexelFetch) };
            rewriteTexelFetchOffsetToTexelFetch as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let addAndTrueToLoopCondition: u64 =
                unsafe { ::std::mem::transmute(addAndTrueToLoopCondition) };
            addAndTrueToLoopCondition as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let rewriteIntegerUnaryMinusOperator: u64 =
                unsafe { ::std::mem::transmute(rewriteIntegerUnaryMinusOperator) };
            rewriteIntegerUnaryMinusOperator as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let emulateIsnanFloatFunction: u64 =
                unsafe { ::std::mem::transmute(emulateIsnanFloatFunction) };
            emulateIsnanFloatFunction as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let useUnusedStandardSharedBlocks: u64 =
                unsafe { ::std::mem::transmute(useUnusedStandardSharedBlocks) };
            useUnusedStandardSharedBlocks as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rewriteFloatUnaryMinusOperator: u64 =
                unsafe { ::std::mem::transmute(rewriteFloatUnaryMinusOperator) };
            rewriteFloatUnaryMinusOperator as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let emulateAtan2FloatFunction: u64 =
                unsafe { ::std::mem::transmute(emulateAtan2FloatFunction) };
            emulateAtan2FloatFunction as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let initializeUninitializedLocals: u64 =
                unsafe { ::std::mem::transmute(initializeUninitializedLocals) };
            initializeUninitializedLocals as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let initializeBuiltinsForInstancedMultiview: u64 =
                unsafe { ::std::mem::transmute(initializeBuiltinsForInstancedMultiview) };
            initializeBuiltinsForInstancedMultiview as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let selectViewInNvGLSLVertexShader: u64 =
                unsafe { ::std::mem::transmute(selectViewInNvGLSLVertexShader) };
            selectViewInNvGLSLVertexShader as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let clampPointSize: u64 = unsafe { ::std::mem::transmute(clampPointSize) };
            clampPointSize as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let addAdvancedBlendEquationsEmulation: u64 =
                unsafe { ::std::mem::transmute(addAdvancedBlendEquationsEmulation) };
            addAdvancedBlendEquationsEmulation as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let dontUseLoopsToInitializeVariables: u64 =
                unsafe { ::std::mem::transmute(dontUseLoopsToInitializeVariables) };
            dontUseLoopsToInitializeVariables as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let skipD3DConstantRegisterZero: u64 =
                unsafe { ::std::mem::transmute(skipD3DConstantRegisterZero) };
            skipD3DConstantRegisterZero as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let clampFragDepth: u64 = unsafe { ::std::mem::transmute(clampFragDepth) };
            clampFragDepth as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let rewriteRepeatedAssignToSwizzled: u64 =
                unsafe { ::std::mem::transmute(rewriteRepeatedAssignToSwizzled) };
            rewriteRepeatedAssignToSwizzled as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let emulateGLDrawID: u64 = unsafe { ::std::mem::transmute(emulateGLDrawID) };
            emulateGLDrawID as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let initSharedVariables: u64 = unsafe { ::std::mem::transmute(initSharedVariables) };
            initSharedVariables as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let forceAtomicValueResolution: u64 =
                unsafe { ::std::mem::transmute(forceAtomicValueResolution) };
            forceAtomicValueResolution as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let emulateGLBaseVertexBaseInstance: u64 =
                unsafe { ::std::mem::transmute(emulateGLBaseVertexBaseInstance) };
            emulateGLBaseVertexBaseInstance as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let emulateSeamfulCubeMapSampling: u64 =
                unsafe { ::std::mem::transmute(emulateSeamfulCubeMapSampling) };
            emulateSeamfulCubeMapSampling as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let takeVideoTextureAsExternalOES: u64 =
                unsafe { ::std::mem::transmute(takeVideoTextureAsExternalOES) };
            takeVideoTextureAsExternalOES as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let addBaseVertexToVertexID: u64 =
                unsafe { ::std::mem::transmute(addBaseVertexToVertexID) };
            addBaseVertexToVertexID as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let removeDynamicIndexingOfSwizzledVector: u64 =
                unsafe { ::std::mem::transmute(removeDynamicIndexingOfSwizzledVector) };
            removeDynamicIndexingOfSwizzledVector as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let allowTranslateUniformBlockToStructuredBuffer: u64 =
                unsafe { ::std::mem::transmute(allowTranslateUniformBlockToStructuredBuffer) };
            allowTranslateUniformBlockToStructuredBuffer as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let addVulkanYUVLayoutQualifier: u64 =
                unsafe { ::std::mem::transmute(addVulkanYUVLayoutQualifier) };
            addVulkanYUVLayoutQualifier as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let disableARBTextureRectangle: u64 =
                unsafe { ::std::mem::transmute(disableARBTextureRectangle) };
            disableARBTextureRectangle as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let rewriteRowMajorMatrices: u64 =
                unsafe { ::std::mem::transmute(rewriteRowMajorMatrices) };
            rewriteRowMajorMatrices as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let ignorePrecisionQualifiers: u64 =
                unsafe { ::std::mem::transmute(ignorePrecisionQualifiers) };
            ignorePrecisionQualifiers as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let addVulkanDepthCorrection: u64 =
                unsafe { ::std::mem::transmute(addVulkanDepthCorrection) };
            addVulkanDepthCorrection as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let forceShaderPrecisionHighpToMediump: u64 =
                unsafe { ::std::mem::transmute(forceShaderPrecisionHighpToMediump) };
            forceShaderPrecisionHighpToMediump as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let useSpecializationConstant: u64 =
                unsafe { ::std::mem::transmute(useSpecializationConstant) };
            useSpecializationConstant as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let addVulkanXfbEmulationSupportCode: u64 =
                unsafe { ::std::mem::transmute(addVulkanXfbEmulationSupportCode) };
            addVulkanXfbEmulationSupportCode as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let addVulkanXfbExtensionSupportCode: u64 =
                unsafe { ::std::mem::transmute(addVulkanXfbExtensionSupportCode) };
            addVulkanXfbExtensionSupportCode as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let initFragmentOutputVariables: u64 =
                unsafe { ::std::mem::transmute(initFragmentOutputVariables) };
            initFragmentOutputVariables as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let generateSpirvThroughGlslang: u64 =
                unsafe { ::std::mem::transmute(generateSpirvThroughGlslang) };
            generateSpirvThroughGlslang as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let addExplicitBoolCasts: u64 = unsafe { ::std::mem::transmute(addExplicitBoolCasts) };
            addExplicitBoolCasts as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let roundOutputAfterDithering: u64 =
                unsafe { ::std::mem::transmute(roundOutputAfterDithering) };
            roundOutputAfterDithering as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let precisionSafeDivision: u64 =
                unsafe { ::std::mem::transmute(precisionSafeDivision) };
            precisionSafeDivision as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let passHighpToPackUnormSnormBuiltins: u64 =
                unsafe { ::std::mem::transmute(passHighpToPackUnormSnormBuiltins) };
            passHighpToPackUnormSnormBuiltins as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ShCompileOptions_ShCompileOptions(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(other: *const ShCompileOptions) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ShCompileOptions_ShCompileOptions1(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
pub type ShHashFunction64 = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: usize) -> khronos_uint64_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShBuiltInResources {
    pub MaxVertexAttribs: ::std::os::raw::c_int,
    pub MaxVertexUniformVectors: ::std::os::raw::c_int,
    pub MaxVaryingVectors: ::std::os::raw::c_int,
    pub MaxVertexTextureImageUnits: ::std::os::raw::c_int,
    pub MaxCombinedTextureImageUnits: ::std::os::raw::c_int,
    pub MaxTextureImageUnits: ::std::os::raw::c_int,
    pub MaxFragmentUniformVectors: ::std::os::raw::c_int,
    pub MaxDrawBuffers: ::std::os::raw::c_int,
    pub OES_standard_derivatives: ::std::os::raw::c_int,
    pub OES_EGL_image_external: ::std::os::raw::c_int,
    pub OES_EGL_image_external_essl3: ::std::os::raw::c_int,
    pub NV_EGL_stream_consumer_external: ::std::os::raw::c_int,
    pub ARB_texture_rectangle: ::std::os::raw::c_int,
    pub EXT_blend_func_extended: ::std::os::raw::c_int,
    pub EXT_draw_buffers: ::std::os::raw::c_int,
    pub EXT_frag_depth: ::std::os::raw::c_int,
    pub EXT_shader_texture_lod: ::std::os::raw::c_int,
    pub EXT_shader_framebuffer_fetch: ::std::os::raw::c_int,
    pub EXT_shader_framebuffer_fetch_non_coherent: ::std::os::raw::c_int,
    pub NV_shader_framebuffer_fetch: ::std::os::raw::c_int,
    pub NV_shader_noperspective_interpolation: ::std::os::raw::c_int,
    pub ARM_shader_framebuffer_fetch: ::std::os::raw::c_int,
    pub OVR_multiview: ::std::os::raw::c_int,
    pub OVR_multiview2: ::std::os::raw::c_int,
    pub EXT_multisampled_render_to_texture: ::std::os::raw::c_int,
    pub EXT_multisampled_render_to_texture2: ::std::os::raw::c_int,
    pub EXT_YUV_target: ::std::os::raw::c_int,
    pub EXT_geometry_shader: ::std::os::raw::c_int,
    pub OES_geometry_shader: ::std::os::raw::c_int,
    pub OES_shader_io_blocks: ::std::os::raw::c_int,
    pub EXT_shader_io_blocks: ::std::os::raw::c_int,
    pub EXT_gpu_shader5: ::std::os::raw::c_int,
    pub EXT_shader_non_constant_global_initializers: ::std::os::raw::c_int,
    pub OES_texture_storage_multisample_2d_array: ::std::os::raw::c_int,
    pub OES_texture_3D: ::std::os::raw::c_int,
    pub ANGLE_shader_pixel_local_storage: ::std::os::raw::c_int,
    pub ANGLE_texture_multisample: ::std::os::raw::c_int,
    pub ANGLE_multi_draw: ::std::os::raw::c_int,
    pub ANGLE_base_vertex_base_instance: ::std::os::raw::c_int,
    pub WEBGL_video_texture: ::std::os::raw::c_int,
    pub APPLE_clip_distance: ::std::os::raw::c_int,
    pub OES_texture_cube_map_array: ::std::os::raw::c_int,
    pub EXT_texture_cube_map_array: ::std::os::raw::c_int,
    pub EXT_shadow_samplers: ::std::os::raw::c_int,
    pub OES_shader_multisample_interpolation: ::std::os::raw::c_int,
    pub OES_shader_image_atomic: ::std::os::raw::c_int,
    pub EXT_tessellation_shader: ::std::os::raw::c_int,
    pub OES_texture_buffer: ::std::os::raw::c_int,
    pub EXT_texture_buffer: ::std::os::raw::c_int,
    pub OES_sample_variables: ::std::os::raw::c_int,
    pub EXT_clip_cull_distance: ::std::os::raw::c_int,
    pub EXT_primitive_bounding_box: ::std::os::raw::c_int,
    pub OES_primitive_bounding_box: ::std::os::raw::c_int,
    pub ANGLE_base_vertex_base_instance_shader_builtin: ::std::os::raw::c_int,
    pub ANDROID_extension_pack_es31a: ::std::os::raw::c_int,
    pub KHR_blend_equation_advanced: ::std::os::raw::c_int,
    pub NV_draw_buffers: ::std::os::raw::c_int,
    pub FragmentPrecisionHigh: ::std::os::raw::c_int,
    pub MaxVertexOutputVectors: ::std::os::raw::c_int,
    pub MaxFragmentInputVectors: ::std::os::raw::c_int,
    pub MinProgramTexelOffset: ::std::os::raw::c_int,
    pub MaxProgramTexelOffset: ::std::os::raw::c_int,
    pub MaxDualSourceDrawBuffers: ::std::os::raw::c_int,
    pub MaxViewsOVR: ::std::os::raw::c_int,
    pub HashFunction: ShHashFunction64,
    pub MaxExpressionComplexity: ::std::os::raw::c_int,
    pub MaxCallStackDepth: ::std::os::raw::c_int,
    pub MaxFunctionParameters: ::std::os::raw::c_int,
    pub MinProgramTextureGatherOffset: ::std::os::raw::c_int,
    pub MaxProgramTextureGatherOffset: ::std::os::raw::c_int,
    pub MaxImageUnits: ::std::os::raw::c_int,
    pub MaxSamples: ::std::os::raw::c_int,
    pub MaxVertexImageUniforms: ::std::os::raw::c_int,
    pub MaxFragmentImageUniforms: ::std::os::raw::c_int,
    pub MaxComputeImageUniforms: ::std::os::raw::c_int,
    pub MaxCombinedImageUniforms: ::std::os::raw::c_int,
    pub MaxUniformLocations: ::std::os::raw::c_int,
    pub MaxCombinedShaderOutputResources: ::std::os::raw::c_int,
    pub MaxComputeWorkGroupCount: __BindgenOpaqueArray<u32, 3usize>,
    pub MaxComputeWorkGroupSize: __BindgenOpaqueArray<u32, 3usize>,
    pub MaxComputeUniformComponents: ::std::os::raw::c_int,
    pub MaxComputeTextureImageUnits: ::std::os::raw::c_int,
    pub MaxComputeAtomicCounters: ::std::os::raw::c_int,
    pub MaxComputeAtomicCounterBuffers: ::std::os::raw::c_int,
    pub MaxVertexAtomicCounters: ::std::os::raw::c_int,
    pub MaxFragmentAtomicCounters: ::std::os::raw::c_int,
    pub MaxCombinedAtomicCounters: ::std::os::raw::c_int,
    pub MaxAtomicCounterBindings: ::std::os::raw::c_int,
    pub MaxVertexAtomicCounterBuffers: ::std::os::raw::c_int,
    pub MaxFragmentAtomicCounterBuffers: ::std::os::raw::c_int,
    pub MaxCombinedAtomicCounterBuffers: ::std::os::raw::c_int,
    pub MaxAtomicCounterBufferSize: ::std::os::raw::c_int,
    pub MaxUniformBufferBindings: ::std::os::raw::c_int,
    pub MaxShaderStorageBufferBindings: ::std::os::raw::c_int,
    pub MaxPointSize: f32,
    pub MaxGeometryUniformComponents: ::std::os::raw::c_int,
    pub MaxGeometryUniformBlocks: ::std::os::raw::c_int,
    pub MaxGeometryInputComponents: ::std::os::raw::c_int,
    pub MaxGeometryOutputComponents: ::std::os::raw::c_int,
    pub MaxGeometryOutputVertices: ::std::os::raw::c_int,
    pub MaxGeometryTotalOutputComponents: ::std::os::raw::c_int,
    pub MaxGeometryTextureImageUnits: ::std::os::raw::c_int,
    pub MaxGeometryAtomicCounterBuffers: ::std::os::raw::c_int,
    pub MaxGeometryAtomicCounters: ::std::os::raw::c_int,
    pub MaxGeometryShaderStorageBlocks: ::std::os::raw::c_int,
    pub MaxGeometryShaderInvocations: ::std::os::raw::c_int,
    pub MaxGeometryImageUniforms: ::std::os::raw::c_int,
    pub MaxTessControlInputComponents: ::std::os::raw::c_int,
    pub MaxTessControlOutputComponents: ::std::os::raw::c_int,
    pub MaxTessControlTextureImageUnits: ::std::os::raw::c_int,
    pub MaxTessControlUniformComponents: ::std::os::raw::c_int,
    pub MaxTessControlTotalOutputComponents: ::std::os::raw::c_int,
    pub MaxTessControlImageUniforms: ::std::os::raw::c_int,
    pub MaxTessControlAtomicCounters: ::std::os::raw::c_int,
    pub MaxTessControlAtomicCounterBuffers: ::std::os::raw::c_int,
    pub MaxTessPatchComponents: ::std::os::raw::c_int,
    pub MaxPatchVertices: ::std::os::raw::c_int,
    pub MaxTessGenLevel: ::std::os::raw::c_int,
    pub MaxTessEvaluationInputComponents: ::std::os::raw::c_int,
    pub MaxTessEvaluationOutputComponents: ::std::os::raw::c_int,
    pub MaxTessEvaluationTextureImageUnits: ::std::os::raw::c_int,
    pub MaxTessEvaluationUniformComponents: ::std::os::raw::c_int,
    pub MaxTessEvaluationImageUniforms: ::std::os::raw::c_int,
    pub MaxTessEvaluationAtomicCounters: ::std::os::raw::c_int,
    pub MaxTessEvaluationAtomicCounterBuffers: ::std::os::raw::c_int,
    pub SubPixelBits: ::std::os::raw::c_int,
    pub MaxClipDistances: ::std::os::raw::c_int,
    pub MaxCullDistances: ::std::os::raw::c_int,
    pub MaxCombinedClipAndCullDistances: ::std::os::raw::c_int,
    pub MaxPixelLocalStoragePlanes: ::std::os::raw::c_int,
    pub MaxColorAttachmentsWithActivePixelLocalStorage: ::std::os::raw::c_int,
    pub MaxCombinedDrawBuffersAndPixelLocalStoragePlanes: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ShBuiltInResources"][::std::mem::size_of::<ShBuiltInResources>() - 552usize];
    ["Alignment of ShBuiltInResources"][::std::mem::align_of::<ShBuiltInResources>() - 8usize];
    ["Offset of field: ShBuiltInResources::MaxVertexAttribs"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVertexAttribs) - 0usize];
    ["Offset of field: ShBuiltInResources::MaxVertexUniformVectors"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVertexUniformVectors) - 4usize];
    ["Offset of field: ShBuiltInResources::MaxVaryingVectors"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVaryingVectors) - 8usize];
    ["Offset of field: ShBuiltInResources::MaxVertexTextureImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVertexTextureImageUnits) - 12usize];
    ["Offset of field: ShBuiltInResources::MaxCombinedTextureImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCombinedTextureImageUnits) - 16usize];
    ["Offset of field: ShBuiltInResources::MaxTextureImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTextureImageUnits) - 20usize];
    ["Offset of field: ShBuiltInResources::MaxFragmentUniformVectors"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxFragmentUniformVectors) - 24usize];
    ["Offset of field: ShBuiltInResources::MaxDrawBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxDrawBuffers) - 28usize];
    ["Offset of field: ShBuiltInResources::OES_standard_derivatives"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_standard_derivatives) - 32usize];
    ["Offset of field: ShBuiltInResources::OES_EGL_image_external"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_EGL_image_external) - 36usize];
    ["Offset of field: ShBuiltInResources::OES_EGL_image_external_essl3"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_EGL_image_external_essl3) - 40usize];
    ["Offset of field: ShBuiltInResources::NV_EGL_stream_consumer_external"]
        [::std::mem::offset_of!(ShBuiltInResources, NV_EGL_stream_consumer_external) - 44usize];
    ["Offset of field: ShBuiltInResources::ARB_texture_rectangle"]
        [::std::mem::offset_of!(ShBuiltInResources, ARB_texture_rectangle) - 48usize];
    ["Offset of field: ShBuiltInResources::EXT_blend_func_extended"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_blend_func_extended) - 52usize];
    ["Offset of field: ShBuiltInResources::EXT_draw_buffers"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_draw_buffers) - 56usize];
    ["Offset of field: ShBuiltInResources::EXT_frag_depth"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_frag_depth) - 60usize];
    ["Offset of field: ShBuiltInResources::EXT_shader_texture_lod"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_shader_texture_lod) - 64usize];
    ["Offset of field: ShBuiltInResources::EXT_shader_framebuffer_fetch"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_shader_framebuffer_fetch) - 68usize];
    ["Offset of field: ShBuiltInResources::EXT_shader_framebuffer_fetch_non_coherent"][::std::mem::offset_of!(
        ShBuiltInResources,
        EXT_shader_framebuffer_fetch_non_coherent
    ) - 72usize];
    ["Offset of field: ShBuiltInResources::NV_shader_framebuffer_fetch"]
        [::std::mem::offset_of!(ShBuiltInResources, NV_shader_framebuffer_fetch) - 76usize];
    ["Offset of field: ShBuiltInResources::NV_shader_noperspective_interpolation"][::std::mem::offset_of!(
        ShBuiltInResources,
        NV_shader_noperspective_interpolation
    ) - 80usize];
    ["Offset of field: ShBuiltInResources::ARM_shader_framebuffer_fetch"]
        [::std::mem::offset_of!(ShBuiltInResources, ARM_shader_framebuffer_fetch) - 84usize];
    ["Offset of field: ShBuiltInResources::OVR_multiview"]
        [::std::mem::offset_of!(ShBuiltInResources, OVR_multiview) - 88usize];
    ["Offset of field: ShBuiltInResources::OVR_multiview2"]
        [::std::mem::offset_of!(ShBuiltInResources, OVR_multiview2) - 92usize];
    ["Offset of field: ShBuiltInResources::EXT_multisampled_render_to_texture"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_multisampled_render_to_texture) - 96usize];
    ["Offset of field: ShBuiltInResources::EXT_multisampled_render_to_texture2"][::std::mem::offset_of!(
        ShBuiltInResources,
        EXT_multisampled_render_to_texture2
    ) - 100usize];
    ["Offset of field: ShBuiltInResources::EXT_YUV_target"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_YUV_target) - 104usize];
    ["Offset of field: ShBuiltInResources::EXT_geometry_shader"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_geometry_shader) - 108usize];
    ["Offset of field: ShBuiltInResources::OES_geometry_shader"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_geometry_shader) - 112usize];
    ["Offset of field: ShBuiltInResources::OES_shader_io_blocks"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_shader_io_blocks) - 116usize];
    ["Offset of field: ShBuiltInResources::EXT_shader_io_blocks"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_shader_io_blocks) - 120usize];
    ["Offset of field: ShBuiltInResources::EXT_gpu_shader5"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_gpu_shader5) - 124usize];
    ["Offset of field: ShBuiltInResources::EXT_shader_non_constant_global_initializers"][::std::mem::offset_of!(
        ShBuiltInResources,
        EXT_shader_non_constant_global_initializers
    )
        - 128usize];
    ["Offset of field: ShBuiltInResources::OES_texture_storage_multisample_2d_array"][::std::mem::offset_of!(
        ShBuiltInResources,
        OES_texture_storage_multisample_2d_array
    ) - 132usize];
    ["Offset of field: ShBuiltInResources::OES_texture_3D"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_texture_3D) - 136usize];
    ["Offset of field: ShBuiltInResources::ANGLE_shader_pixel_local_storage"]
        [::std::mem::offset_of!(ShBuiltInResources, ANGLE_shader_pixel_local_storage) - 140usize];
    ["Offset of field: ShBuiltInResources::ANGLE_texture_multisample"]
        [::std::mem::offset_of!(ShBuiltInResources, ANGLE_texture_multisample) - 144usize];
    ["Offset of field: ShBuiltInResources::ANGLE_multi_draw"]
        [::std::mem::offset_of!(ShBuiltInResources, ANGLE_multi_draw) - 148usize];
    ["Offset of field: ShBuiltInResources::ANGLE_base_vertex_base_instance"]
        [::std::mem::offset_of!(ShBuiltInResources, ANGLE_base_vertex_base_instance) - 152usize];
    ["Offset of field: ShBuiltInResources::WEBGL_video_texture"]
        [::std::mem::offset_of!(ShBuiltInResources, WEBGL_video_texture) - 156usize];
    ["Offset of field: ShBuiltInResources::APPLE_clip_distance"]
        [::std::mem::offset_of!(ShBuiltInResources, APPLE_clip_distance) - 160usize];
    ["Offset of field: ShBuiltInResources::OES_texture_cube_map_array"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_texture_cube_map_array) - 164usize];
    ["Offset of field: ShBuiltInResources::EXT_texture_cube_map_array"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_texture_cube_map_array) - 168usize];
    ["Offset of field: ShBuiltInResources::EXT_shadow_samplers"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_shadow_samplers) - 172usize];
    ["Offset of field: ShBuiltInResources::OES_shader_multisample_interpolation"][::std::mem::offset_of!(
        ShBuiltInResources,
        OES_shader_multisample_interpolation
    ) - 176usize];
    ["Offset of field: ShBuiltInResources::OES_shader_image_atomic"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_shader_image_atomic) - 180usize];
    ["Offset of field: ShBuiltInResources::EXT_tessellation_shader"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_tessellation_shader) - 184usize];
    ["Offset of field: ShBuiltInResources::OES_texture_buffer"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_texture_buffer) - 188usize];
    ["Offset of field: ShBuiltInResources::EXT_texture_buffer"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_texture_buffer) - 192usize];
    ["Offset of field: ShBuiltInResources::OES_sample_variables"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_sample_variables) - 196usize];
    ["Offset of field: ShBuiltInResources::EXT_clip_cull_distance"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_clip_cull_distance) - 200usize];
    ["Offset of field: ShBuiltInResources::EXT_primitive_bounding_box"]
        [::std::mem::offset_of!(ShBuiltInResources, EXT_primitive_bounding_box) - 204usize];
    ["Offset of field: ShBuiltInResources::OES_primitive_bounding_box"]
        [::std::mem::offset_of!(ShBuiltInResources, OES_primitive_bounding_box) - 208usize];
    ["Offset of field: ShBuiltInResources::ANGLE_base_vertex_base_instance_shader_builtin"][::std::mem::offset_of!(
        ShBuiltInResources,
        ANGLE_base_vertex_base_instance_shader_builtin
    )
        - 212usize];
    ["Offset of field: ShBuiltInResources::ANDROID_extension_pack_es31a"]
        [::std::mem::offset_of!(ShBuiltInResources, ANDROID_extension_pack_es31a) - 216usize];
    ["Offset of field: ShBuiltInResources::KHR_blend_equation_advanced"]
        [::std::mem::offset_of!(ShBuiltInResources, KHR_blend_equation_advanced) - 220usize];
    ["Offset of field: ShBuiltInResources::NV_draw_buffers"]
        [::std::mem::offset_of!(ShBuiltInResources, NV_draw_buffers) - 224usize];
    ["Offset of field: ShBuiltInResources::FragmentPrecisionHigh"]
        [::std::mem::offset_of!(ShBuiltInResources, FragmentPrecisionHigh) - 228usize];
    ["Offset of field: ShBuiltInResources::MaxVertexOutputVectors"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVertexOutputVectors) - 232usize];
    ["Offset of field: ShBuiltInResources::MaxFragmentInputVectors"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxFragmentInputVectors) - 236usize];
    ["Offset of field: ShBuiltInResources::MinProgramTexelOffset"]
        [::std::mem::offset_of!(ShBuiltInResources, MinProgramTexelOffset) - 240usize];
    ["Offset of field: ShBuiltInResources::MaxProgramTexelOffset"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxProgramTexelOffset) - 244usize];
    ["Offset of field: ShBuiltInResources::MaxDualSourceDrawBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxDualSourceDrawBuffers) - 248usize];
    ["Offset of field: ShBuiltInResources::MaxViewsOVR"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxViewsOVR) - 252usize];
    ["Offset of field: ShBuiltInResources::HashFunction"]
        [::std::mem::offset_of!(ShBuiltInResources, HashFunction) - 256usize];
    ["Offset of field: ShBuiltInResources::MaxExpressionComplexity"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxExpressionComplexity) - 264usize];
    ["Offset of field: ShBuiltInResources::MaxCallStackDepth"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCallStackDepth) - 268usize];
    ["Offset of field: ShBuiltInResources::MaxFunctionParameters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxFunctionParameters) - 272usize];
    ["Offset of field: ShBuiltInResources::MinProgramTextureGatherOffset"]
        [::std::mem::offset_of!(ShBuiltInResources, MinProgramTextureGatherOffset) - 276usize];
    ["Offset of field: ShBuiltInResources::MaxProgramTextureGatherOffset"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxProgramTextureGatherOffset) - 280usize];
    ["Offset of field: ShBuiltInResources::MaxImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxImageUnits) - 284usize];
    ["Offset of field: ShBuiltInResources::MaxSamples"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxSamples) - 288usize];
    ["Offset of field: ShBuiltInResources::MaxVertexImageUniforms"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVertexImageUniforms) - 292usize];
    ["Offset of field: ShBuiltInResources::MaxFragmentImageUniforms"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxFragmentImageUniforms) - 296usize];
    ["Offset of field: ShBuiltInResources::MaxComputeImageUniforms"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxComputeImageUniforms) - 300usize];
    ["Offset of field: ShBuiltInResources::MaxCombinedImageUniforms"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCombinedImageUniforms) - 304usize];
    ["Offset of field: ShBuiltInResources::MaxUniformLocations"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxUniformLocations) - 308usize];
    ["Offset of field: ShBuiltInResources::MaxCombinedShaderOutputResources"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCombinedShaderOutputResources) - 312usize];
    ["Offset of field: ShBuiltInResources::MaxComputeWorkGroupCount"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxComputeWorkGroupCount) - 316usize];
    ["Offset of field: ShBuiltInResources::MaxComputeWorkGroupSize"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxComputeWorkGroupSize) - 328usize];
    ["Offset of field: ShBuiltInResources::MaxComputeUniformComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxComputeUniformComponents) - 340usize];
    ["Offset of field: ShBuiltInResources::MaxComputeTextureImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxComputeTextureImageUnits) - 344usize];
    ["Offset of field: ShBuiltInResources::MaxComputeAtomicCounters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxComputeAtomicCounters) - 348usize];
    ["Offset of field: ShBuiltInResources::MaxComputeAtomicCounterBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxComputeAtomicCounterBuffers) - 352usize];
    ["Offset of field: ShBuiltInResources::MaxVertexAtomicCounters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVertexAtomicCounters) - 356usize];
    ["Offset of field: ShBuiltInResources::MaxFragmentAtomicCounters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxFragmentAtomicCounters) - 360usize];
    ["Offset of field: ShBuiltInResources::MaxCombinedAtomicCounters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCombinedAtomicCounters) - 364usize];
    ["Offset of field: ShBuiltInResources::MaxAtomicCounterBindings"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxAtomicCounterBindings) - 368usize];
    ["Offset of field: ShBuiltInResources::MaxVertexAtomicCounterBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxVertexAtomicCounterBuffers) - 372usize];
    ["Offset of field: ShBuiltInResources::MaxFragmentAtomicCounterBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxFragmentAtomicCounterBuffers) - 376usize];
    ["Offset of field: ShBuiltInResources::MaxCombinedAtomicCounterBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCombinedAtomicCounterBuffers) - 380usize];
    ["Offset of field: ShBuiltInResources::MaxAtomicCounterBufferSize"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxAtomicCounterBufferSize) - 384usize];
    ["Offset of field: ShBuiltInResources::MaxUniformBufferBindings"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxUniformBufferBindings) - 388usize];
    ["Offset of field: ShBuiltInResources::MaxShaderStorageBufferBindings"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxShaderStorageBufferBindings) - 392usize];
    ["Offset of field: ShBuiltInResources::MaxPointSize"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxPointSize) - 396usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryUniformComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryUniformComponents) - 400usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryUniformBlocks"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryUniformBlocks) - 404usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryInputComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryInputComponents) - 408usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryOutputComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryOutputComponents) - 412usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryOutputVertices"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryOutputVertices) - 416usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryTotalOutputComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryTotalOutputComponents) - 420usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryTextureImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryTextureImageUnits) - 424usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryAtomicCounterBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryAtomicCounterBuffers) - 428usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryAtomicCounters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryAtomicCounters) - 432usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryShaderStorageBlocks"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryShaderStorageBlocks) - 436usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryShaderInvocations"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryShaderInvocations) - 440usize];
    ["Offset of field: ShBuiltInResources::MaxGeometryImageUniforms"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxGeometryImageUniforms) - 444usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlInputComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessControlInputComponents) - 448usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlOutputComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessControlOutputComponents) - 452usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlTextureImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessControlTextureImageUnits) - 456usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlUniformComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessControlUniformComponents) - 460usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlTotalOutputComponents"][::std::mem::offset_of!(
        ShBuiltInResources,
        MaxTessControlTotalOutputComponents
    ) - 464usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlImageUniforms"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessControlImageUniforms) - 468usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlAtomicCounters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessControlAtomicCounters) - 472usize];
    ["Offset of field: ShBuiltInResources::MaxTessControlAtomicCounterBuffers"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessControlAtomicCounterBuffers) - 476usize];
    ["Offset of field: ShBuiltInResources::MaxTessPatchComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessPatchComponents) - 480usize];
    ["Offset of field: ShBuiltInResources::MaxPatchVertices"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxPatchVertices) - 484usize];
    ["Offset of field: ShBuiltInResources::MaxTessGenLevel"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessGenLevel) - 488usize];
    ["Offset of field: ShBuiltInResources::MaxTessEvaluationInputComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessEvaluationInputComponents) - 492usize];
    ["Offset of field: ShBuiltInResources::MaxTessEvaluationOutputComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessEvaluationOutputComponents) - 496usize];
    ["Offset of field: ShBuiltInResources::MaxTessEvaluationTextureImageUnits"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessEvaluationTextureImageUnits) - 500usize];
    ["Offset of field: ShBuiltInResources::MaxTessEvaluationUniformComponents"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessEvaluationUniformComponents) - 504usize];
    ["Offset of field: ShBuiltInResources::MaxTessEvaluationImageUniforms"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessEvaluationImageUniforms) - 508usize];
    ["Offset of field: ShBuiltInResources::MaxTessEvaluationAtomicCounters"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxTessEvaluationAtomicCounters) - 512usize];
    ["Offset of field: ShBuiltInResources::MaxTessEvaluationAtomicCounterBuffers"][::std::mem::offset_of!(
        ShBuiltInResources,
        MaxTessEvaluationAtomicCounterBuffers
    ) - 516usize];
    ["Offset of field: ShBuiltInResources::SubPixelBits"]
        [::std::mem::offset_of!(ShBuiltInResources, SubPixelBits) - 520usize];
    ["Offset of field: ShBuiltInResources::MaxClipDistances"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxClipDistances) - 524usize];
    ["Offset of field: ShBuiltInResources::MaxCullDistances"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCullDistances) - 528usize];
    ["Offset of field: ShBuiltInResources::MaxCombinedClipAndCullDistances"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxCombinedClipAndCullDistances) - 532usize];
    ["Offset of field: ShBuiltInResources::MaxPixelLocalStoragePlanes"]
        [::std::mem::offset_of!(ShBuiltInResources, MaxPixelLocalStoragePlanes) - 536usize];
    ["Offset of field: ShBuiltInResources::MaxColorAttachmentsWithActivePixelLocalStorage"][::std::mem::offset_of!(
        ShBuiltInResources,
        MaxColorAttachmentsWithActivePixelLocalStorage
    )
        - 540usize];
    ["Offset of field: ShBuiltInResources::MaxCombinedDrawBuffersAndPixelLocalStoragePlanes"][::std::mem::offset_of!(
        ShBuiltInResources,
        MaxCombinedDrawBuffersAndPixelLocalStoragePlanes
    )
        - 544usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN18ShBuiltInResourcesC1Ev"]
    pub fn ShBuiltInResources_ShBuiltInResources(this: *mut ShBuiltInResources);
}
extern "C" {
    #[link_name = "\u{1}_ZN18ShBuiltInResourcesC1ERKS_"]
    pub fn ShBuiltInResources_ShBuiltInResources1(
        this: *mut ShBuiltInResources,
        other: *const ShBuiltInResources,
    );
}
impl ShBuiltInResources {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ShBuiltInResources_ShBuiltInResources(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(other: *const ShBuiltInResources) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ShBuiltInResources_ShBuiltInResources1(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
pub type ShHandle = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn GLSLangInitialize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GLSLangFinalize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GLSLangInitBuiltInResources(resources: *mut ShBuiltInResources);
}
extern "C" {
    pub fn GLSLangConstructCompiler(
        type_: ::std::os::raw::c_uint,
        spec: ::std::os::raw::c_uint,
        output: ::std::os::raw::c_uint,
        resources: *const ShBuiltInResources,
    ) -> ShHandle;
}
extern "C" {
    pub fn GLSLangDestructCompiler(handle: ShHandle);
}
extern "C" {
    pub fn GLSLangCompile(
        handle: ShHandle,
        shaderStrings: *const *const ::std::os::raw::c_char,
        numStrings: usize,
        compileOptions: *const ShCompileOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GLSLangClearResults(handle: ShHandle);
}
extern "C" {
    pub fn GLSLangGetShaderVersion(handle: ShHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GLSLangGetShaderOutputType(handle: ShHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GLSLangGetInfoLog(handle: ShHandle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn GLSLangGetObjectCode(handle: ShHandle) -> *const ::std::os::raw::c_char;
}
pub type StrPairFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn GLSLangIterUniformNameMapping(
        handle: ShHandle,
        each: StrPairFunction,
        closure_each: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GLSLangGetNumUnpackedVaryingVectors(handle: ShHandle) -> ::std::os::raw::c_int;
}
