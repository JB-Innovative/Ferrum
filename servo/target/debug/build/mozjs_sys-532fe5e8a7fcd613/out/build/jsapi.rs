/* automatically generated by rust-bindgen 0.72.1 */

unsafe impl Sync for root::JSClass {}
unsafe impl Sync for root::JSFunctionSpec {}
unsafe impl Sync for root::JSNativeWrapper {}
unsafe impl Sync for root::JSPropertySpec {}
unsafe impl Sync for root::JSTypedMethodJitInfo {}

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        fn extract_bit(byte: u8, index: usize) -> bool {
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            Self::extract_bit(byte, index)
        }
        #[inline]
        pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
            debug_assert!(index / 8 < core::mem::size_of::<Storage>());
            let byte_index = index / 8;
            let byte = unsafe {
                *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
            };
            Self::extract_bit(byte, index)
        }
        #[inline]
        fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                byte | mask
            } else {
                byte & !mask
            }
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            *byte = Self::change_bit(*byte, index, val);
        }
        #[inline]
        pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
            debug_assert!(index / 8 < core::mem::size_of::<Storage>());
            let byte_index = index / 8;
            let byte = unsafe {
                (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
            };
            unsafe { *byte = Self::change_bit(*byte, index, val) };
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
            debug_assert!(
                (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>()
            );
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
        #[inline]
        pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
            debug_assert!(
                (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>()
            );
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
            }
        }
    }
    #[doc = r" If Bindgen could only determine the size and alignment of a"]
    #[doc = r" type, it is represented like this."]
    #[derive(PartialEq, Copy, Clone, Debug, Hash)]
    #[repr(C)]
    pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
    impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
        fn default() -> Self {
            Self([<T as Default>::default(); N])
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub type FILE = ::libc::FILE;
    pub const JS_64BIT: u32 = 1;
    pub const JS_CODEGEN_X64: u32 = 1;
    pub const JS_DEFAULT_JITREPORT_GRANULARITY: u32 = 3;
    pub const JS_HAS_INTL_API: u32 = 1;
    pub const JS_PUNBOX64: u32 = 1;
    pub const JS_STANDALONE: u32 = 1;
    pub const JS_WITHOUT_NSPR: u32 = 1;
    pub const JS_BITS_PER_WORD: u32 = 64;
    pub const JS_STRUCTURED_CLONE_VERSION: u32 = 8;
    pub const JS_SCERR_RECURSION: u32 = 0;
    pub const JS_SCERR_TRANSFERABLE: u32 = 1;
    pub const JS_SCERR_DUP_TRANSFERABLE: u32 = 2;
    pub const JS_SCERR_UNSUPPORTED_TYPE: u32 = 3;
    pub const JS_SCERR_SHMEM_TRANSFERABLE: u32 = 4;
    pub const JS_SCERR_TYPED_ARRAY_DETACHED: u32 = 5;
    pub const JS_SCERR_WASM_NO_TRANSFER: u32 = 6;
    pub const JS_SCERR_NOT_CLONABLE: u32 = 7;
    pub const JS_SCERR_NOT_CLONABLE_WITH_COOP_COEP: u32 = 8;
    pub const JS_SCERR_TRANSFERABLE_TWICE: u32 = 9;
    pub const JSITER_PRIVATE: u32 = 4;
    pub const JSITER_OWNONLY: u32 = 8;
    pub const JSITER_HIDDEN: u32 = 16;
    pub const JSITER_SYMBOLS: u32 = 32;
    pub const JSITER_SYMBOLSONLY: u32 = 64;
    pub const JSITER_FORAWAITOF: u32 = 128;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type nullptr_t = u64;
        pub type integral_constant_value_type = u8;
        pub type integral_constant_type = u8;
        pub type false_type = u8;
        pub type remove_const_t = u8;
        pub type remove_cv_t = u8;
        pub type remove_reference_t = u8;
        pub type make_signed_t = u8;
        pub type make_unsigned_t = u8;
        pub type add_pointer_t = u8;
        pub type enable_if_t = u8;
        pub type conditional_t = u8;
        pub type underlying_type_t = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct input_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of input_iterator_tag"][::std::mem::size_of::<input_iterator_tag>() - 1usize];
            ["Alignment of input_iterator_tag"]
                [::std::mem::align_of::<input_iterator_tag>() - 1usize];
        };
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct output_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of output_iterator_tag"][::std::mem::size_of::<output_iterator_tag>() - 1usize];
            ["Alignment of output_iterator_tag"]
                [::std::mem::align_of::<output_iterator_tag>() - 1usize];
        };
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct forward_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of forward_iterator_tag"]
                [::std::mem::size_of::<forward_iterator_tag>() - 1usize];
            ["Alignment of forward_iterator_tag"]
                [::std::mem::align_of::<forward_iterator_tag>() - 1usize];
        };
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct random_access_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of random_access_iterator_tag"]
                [::std::mem::size_of::<random_access_iterator_tag>() - 1usize];
            ["Alignment of random_access_iterator_tag"]
                [::std::mem::align_of::<random_access_iterator_tag>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct reverse_iterator {
            pub _address: u8,
        }
        pub type reverse_iterator___traits_type = u8;
        pub type reverse_iterator_iterator_type = u8;
        pub type reverse_iterator_pointer = u8;
        pub type reverse_iterator_difference_type = u8;
        pub type reverse_iterator_reference = u8;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct nothrow_t {
            pub _bindgen_opaque_blob: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of nothrow_t"][::std::mem::size_of::<nothrow_t>() - 1usize];
            ["Alignment of nothrow_t"][::std::mem::align_of::<nothrow_t>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__Inherited = u8;
        pub type tuple__TCC = u8;
        pub type tuple__ImplicitDefaultCtor = u8;
        pub type tuple__ExplicitDefaultCtor = u8;
        pub type tuple__ImplicitCtor = u8;
        pub type tuple__ExplicitCtor = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__UseOtherCtor {
            pub _address: u8,
        }
        pub type string = root::__BindgenOpaqueArray<u64, 4usize>;
        pub type ostream = root::__BindgenOpaqueArray<u64, 34usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct numeric_limits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct basic_string_view {
            pub _address: u8,
        }
        pub type basic_string_view_traits_type = u8;
        pub type basic_string_view_value_type = u8;
        pub type basic_string_view_pointer = u8;
        pub type basic_string_view_const_pointer = u8;
        pub type basic_string_view_reference = u8;
        pub type basic_string_view_const_reference = u8;
        pub type basic_string_view_const_iterator = u8;
        pub type basic_string_view_iterator = u8;
        pub type basic_string_view_const_reverse_iterator = u8;
        pub type basic_string_view_reverse_iterator = u8;
        pub type basic_string_view_size_type = u64;
        pub type basic_string_view_difference_type = u64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Base = u8;
        pub type vector__Tp_alloc_type = u8;
        pub type vector__Alloc_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_size_type = u64;
        pub type vector_difference_type = u64;
        pub type vector_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct vector__Temporary_value {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Copy, Clone)]
        pub union vector__Temporary_value__Storage {
            pub _bindgen_opaque_blob: u8,
        }
        pub type array_value_type = u8;
        pub type array_pointer = u8;
        pub type array_const_pointer = u8;
        pub type array_reference = u8;
        pub type array_const_reference = u8;
        pub type array_iterator = u8;
        pub type array_const_iterator = u8;
        pub type array_size_type = u64;
        pub type array_difference_type = u64;
        pub type array_reverse_iterator = u8;
        pub type array_const_reverse_iterator = u8;
        pub type array__AT_Type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic_value_type = u8;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type __off_t = ::std::os::raw::c_long;
    pub type __off64_t = ::std::os::raw::c_long;
    pub type uint_fast8_t = ::std::os::raw::c_uchar;
    pub type __gnuc_va_list = root::__builtin_va_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_marker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_codecvt {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_wide_data {
        _unused: [u8; 0],
    }
    pub type _IO_lock_t = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct _IO_FILE {
        pub _flags: ::std::os::raw::c_int,
        pub _IO_read_ptr: *mut ::std::os::raw::c_char,
        pub _IO_read_end: *mut ::std::os::raw::c_char,
        pub _IO_read_base: *mut ::std::os::raw::c_char,
        pub _IO_write_base: *mut ::std::os::raw::c_char,
        pub _IO_write_ptr: *mut ::std::os::raw::c_char,
        pub _IO_write_end: *mut ::std::os::raw::c_char,
        pub _IO_buf_base: *mut ::std::os::raw::c_char,
        pub _IO_buf_end: *mut ::std::os::raw::c_char,
        pub _IO_save_base: *mut ::std::os::raw::c_char,
        pub _IO_backup_base: *mut ::std::os::raw::c_char,
        pub _IO_save_end: *mut ::std::os::raw::c_char,
        pub _markers: *mut root::_IO_marker,
        pub _chain: *mut root::_IO_FILE,
        pub _fileno: ::std::os::raw::c_int,
        pub _flags2: ::std::os::raw::c_int,
        pub _old_offset: root::__off_t,
        pub _cur_column: ::std::os::raw::c_ushort,
        pub _vtable_offset: ::std::os::raw::c_schar,
        pub _shortbuf: [::std::os::raw::c_char; 1usize],
        pub _lock: *mut root::_IO_lock_t,
        pub _offset: root::__off64_t,
        pub _codecvt: *mut root::_IO_codecvt,
        pub _wide_data: *mut root::_IO_wide_data,
        pub _freeres_list: *mut root::_IO_FILE,
        pub _freeres_buf: *mut ::std::os::raw::c_void,
        pub __pad5: usize,
        pub _mode: ::std::os::raw::c_int,
        pub _unused2: [::std::os::raw::c_char; 20usize],
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
        ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
        ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
        ["Offset of field: _IO_FILE::_IO_read_ptr"]
            [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
        ["Offset of field: _IO_FILE::_IO_read_end"]
            [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
        ["Offset of field: _IO_FILE::_IO_read_base"]
            [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
        ["Offset of field: _IO_FILE::_IO_write_base"]
            [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
        ["Offset of field: _IO_FILE::_IO_write_ptr"]
            [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
        ["Offset of field: _IO_FILE::_IO_write_end"]
            [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
        ["Offset of field: _IO_FILE::_IO_buf_base"]
            [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
        ["Offset of field: _IO_FILE::_IO_buf_end"]
            [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
        ["Offset of field: _IO_FILE::_IO_save_base"]
            [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
        ["Offset of field: _IO_FILE::_IO_backup_base"]
            [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
        ["Offset of field: _IO_FILE::_IO_save_end"]
            [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
        ["Offset of field: _IO_FILE::_markers"]
            [::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
        ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
        ["Offset of field: _IO_FILE::_fileno"]
            [::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
        ["Offset of field: _IO_FILE::_flags2"]
            [::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
        ["Offset of field: _IO_FILE::_old_offset"]
            [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
        ["Offset of field: _IO_FILE::_cur_column"]
            [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
        ["Offset of field: _IO_FILE::_vtable_offset"]
            [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
        ["Offset of field: _IO_FILE::_shortbuf"]
            [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
        ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
        ["Offset of field: _IO_FILE::_offset"]
            [::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
        ["Offset of field: _IO_FILE::_codecvt"]
            [::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
        ["Offset of field: _IO_FILE::_wide_data"]
            [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
        ["Offset of field: _IO_FILE::_freeres_list"]
            [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
        ["Offset of field: _IO_FILE::_freeres_buf"]
            [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
        ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
        ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
        ["Offset of field: _IO_FILE::_unused2"]
            [::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
    };
    pub type va_list = root::__gnuc_va_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct __pthread_rwlock_arch_t {
        pub __readers: ::std::os::raw::c_uint,
        pub __writers: ::std::os::raw::c_uint,
        pub __wrphase_futex: ::std::os::raw::c_uint,
        pub __writers_futex: ::std::os::raw::c_uint,
        pub __pad3: ::std::os::raw::c_uint,
        pub __pad4: ::std::os::raw::c_uint,
        pub __cur_writer: ::std::os::raw::c_int,
        pub __shared: ::std::os::raw::c_int,
        pub __rwelision: ::std::os::raw::c_schar,
        pub __pad1: [::std::os::raw::c_uchar; 7usize],
        pub __pad2: ::std::os::raw::c_ulong,
        pub __flags: ::std::os::raw::c_uint,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of __pthread_rwlock_arch_t"]
            [::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
        ["Alignment of __pthread_rwlock_arch_t"]
            [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
        ["Offset of field: __pthread_rwlock_arch_t::__readers"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
        ["Offset of field: __pthread_rwlock_arch_t::__writers"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
        ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
        ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
        ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
        ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
        ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
        ["Offset of field: __pthread_rwlock_arch_t::__shared"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
        ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
        ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
        ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
        ["Offset of field: __pthread_rwlock_arch_t::__flags"]
            [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_rwlock_t {
        pub __data: root::__pthread_rwlock_arch_t,
        pub __size: [::std::os::raw::c_char; 56usize],
        pub __align: ::std::os::raw::c_long,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
        ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
        ["Offset of field: pthread_rwlock_t::__data"]
            [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
        ["Offset of field: pthread_rwlock_t::__size"]
            [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
        ["Offset of field: pthread_rwlock_t::__align"]
            [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
    };
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AssertionConditionType {
                pub _address: u8,
            }
            pub type AssertionConditionType_ValueT = u8;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum StorageType {
                AsBase = 0,
                AsMember = 1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasPointerTypeHelper {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of HasPointerTypeHelper"]
                    [::std::mem::size_of::<HasPointerTypeHelper>() - 1usize];
                ["Alignment of HasPointerTypeHelper"]
                    [::std::mem::align_of::<HasPointerTypeHelper>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasPointerType {
                pub _address: u8,
            }
            pub type PointerTypeImpl_Type = root::__BindgenOpaqueArray<u8, 0usize>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct PointerType {
                pub _address: u8,
            }
            pub type PointerType_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
            pub type UniqueSelector_SingleObject = u8;
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct TempPtrToSetterT<T, UniquePtrT> {
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<UniquePtrT>>,
                pub mDest: *mut UniquePtrT,
                pub mNewVal: *mut T,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AllocPolicyBasedFreePolicy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct SprintfAppend {
                pub _base: root::mozilla::PrintfTarget,
                pub mBuf: *mut ::std::os::raw::c_char,
                pub mBufLen: usize,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of SprintfAppend"][::std::mem::size_of::<SprintfAppend>() - 32usize];
                ["Alignment of SprintfAppend"][::std::mem::align_of::<SprintfAppend>() - 8usize];
                ["Offset of field: SprintfAppend::mBuf"]
                    [::std::mem::offset_of!(SprintfAppend, mBuf) - 16usize];
                ["Offset of field: SprintfAppend::mBufLen"]
                    [::std::mem::offset_of!(SprintfAppend, mBufLen) - 24usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct LazyAssertedCastT<From> {
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<From>>,
                pub mVal: From,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AllowDeprecatedAbsFixed {
                pub _base: root::std::false_type,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: AllowDeprecatedAbsFixed_open0_int_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>()
                        - 1usize];
                ["Align of template specialization: AllowDeprecatedAbsFixed_open0_int_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>()
                        - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: AllowDeprecatedAbsFixed_open0_long_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>()
                        - 1usize];
                ["Align of template specialization: AllowDeprecatedAbsFixed_open0_long_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>()
                        - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AllowDeprecatedAbs {
                pub _base: root::mozilla::detail::AllowDeprecatedAbsFixed,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: AllowDeprecatedAbs_open0_int_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbs>() - 1usize];
                ["Align of template specialization: AllowDeprecatedAbs_open0_int_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbs>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: AllowDeprecatedAbs_open0_long_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbs>() - 1usize];
                ["Align of template specialization: AllowDeprecatedAbs_open0_long_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbs>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AbsReturnType {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct FloatingPointTrait {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: FloatingPointTrait_open0_float_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::FloatingPointTrait>() - 1usize];
                ["Align of template specialization: FloatingPointTrait_open0_float_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::FloatingPointTrait>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: FloatingPointTrait_open0_double_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::FloatingPointTrait>() - 1usize];
                ["Align of template specialization: FloatingPointTrait_open0_double_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::FloatingPointTrait>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct FuzzyEqualsEpsilon {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: FuzzyEqualsEpsilon_open0_float_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::FuzzyEqualsEpsilon>() - 1usize];
                ["Align of template specialization: FuzzyEqualsEpsilon_open0_float_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::FuzzyEqualsEpsilon>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: FuzzyEqualsEpsilon_open0_double_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::FuzzyEqualsEpsilon>() - 1usize];
                ["Align of template specialization: FuzzyEqualsEpsilon_open0_double_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::FuzzyEqualsEpsilon>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct MaybePoisoner {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsMaybeImpl {
                pub _base: root::std::false_type,
            }
            pub type IsMaybe = root::mozilla::detail::IsMaybeImpl;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AlignedChecker {
                pub _address: u8,
            }
            pub type supports_os<T> = T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct MakeUnsignedChar {
                pub _address: u8,
            }
            pub type MakeUnsignedChar_Type = u8;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: MakeUnsignedChar_open0_char16_t_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::MakeUnsignedChar>() - 1usize];
                ["Align of template specialization: MakeUnsignedChar_open0_char16_t_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::MakeUnsignedChar>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: MakeUnsignedChar_open0_char32_t_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::MakeUnsignedChar>() - 1usize];
                ["Align of template specialization: MakeUnsignedChar_open0_char32_t_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::MakeUnsignedChar>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrapToSignedHelper {
                pub _address: u8,
            }
            pub type WrapToSignedHelper_SignedType = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrappingAddHelper {
                pub _address: u8,
            }
            pub type WrappingAddHelper_UnsignedT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrappingSubtractHelper {
                pub _address: u8,
            }
            pub type WrappingSubtractHelper_UnsignedT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrappingMultiplyHelper {
                pub _address: u8,
            }
            pub type WrappingMultiplyHelper_UnsignedT = u8;
            #[doc = " SelectVariantTypeHelper is used in the implementation of SelectVariantType."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SelectVariantTypeHelper {
                pub _address: u8,
            }
            #[doc = " SelectVariantType takes a type T and a list of variant types Variants and\n yields a type Type, selected from Variants, that can store a value of type T\n or a reference to type T. If no such type was found, Type is not defined.\n SelectVariantType also has a `count` member that contains the total number of\n selectable types (which will be used to check that a requested type is not\n ambiguously present twice.)"]
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SelectVariantType {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct VariantTag {
                pub _address: u8,
            }
            pub type VariantTag_Type = root::std::conditional_t;
            #[doc = " AsVariantTemporary stores a value of type T to allow construction of a\n Variant value via type inference. Because T is copied and there's no\n guarantee that the copy can be elided, AsVariantTemporary is best used with\n primitive or very small types."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AsVariantTemporary {
                pub mValue: root::std::remove_const_t,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum PackingStrategy {
                Variant = 0,
                NullIsOk = 1,
                LowBitTagIsError = 2,
                PackedVariant = 3,
                ZeroIsEmptyError = 4,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct EmptyWrapper<V> {
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _base: V,
            }
            pub type AlignedStorageOrEmpty = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ResultImplementationNullIsOkBase {
                pub mValue: root::mozilla::CompactPair,
            }
            pub type ResultImplementationNullIsOkBase_ErrorStorageType =
                root::mozilla::detail::UnusedZero;
            pub type UnsignedIntType = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsPackableVariant {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsPackableVariant_VEbool<V, E> {
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
                pub v: V,
                pub e: E,
                pub ok: bool,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsPackableVariant_EVbool<V, E> {
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
                pub e: E,
                pub v: V,
                pub ok: bool,
            }
            pub type IsPackableVariant_Impl = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UnusedZero {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UnusedZeroEnum {
                pub _address: u8,
            }
            pub type UnusedZeroEnum_StorageType = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasFreeLSB {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: HasFreeLSB_open0_ptr_void_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
                ["Align of template specialization: HasFreeLSB_open0_ptr_void_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SelectResultImpl {
                pub _address: u8,
            }
            pub type SelectResultImpl_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsResult {
                pub _base: root::std::false_type,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: UnusedZero_open0_Error_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::UnusedZero>() - 1usize];
                ["Align of template specialization: UnusedZero_open0_Error_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::UnusedZero>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: UnusedZero_open0_OOM_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::UnusedZero>() - 1usize];
                ["Align of template specialization: UnusedZero_open0_OOM_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::UnusedZero>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: HasFreeLSB_open0_Error_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
                ["Align of template specialization: HasFreeLSB_open0_Error_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: HasFreeLSB_open0_OOM_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
                ["Align of template specialization: HasFreeLSB_open0_OOM_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
            };
            pub type IntrinsicBase_ValueType = u8;
            pub type IntrinsicBase_OrderedOp = u8;
            pub type IntrinsicMemoryOps_Base = u8;
            pub type IntrinsicAddSub_Base = u8;
            pub type IntrinsicIncDec_Base = u8;
            pub type AtomicIntrinsics_Base = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ToStorageTypeArgument {
                pub _address: u8,
            }
            pub type AtomicBase_Intrinsics = u8;
            pub type AtomicBase_ValueType = root::mozilla::detail::AtomicBase_Intrinsics;
            pub type AtomicBaseIncDec_Base = u8;
            #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct LinkedListElementTraits {
                pub _address: u8,
            }
            pub type LinkedListElementTraits_RawType<T> = *mut T;
            pub type LinkedListElementTraits_ConstRawType<T> = *const T;
            pub type LinkedListElementTraits_ClientType<T> = *mut T;
            pub type LinkedListElementTraits_ConstClientType<T> = *const T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UnwrapMaybeAtomic {
                pub _address: u8,
            }
            pub type UnwrapMaybeAtomic_Type<T> = T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTableEntry {
                pub _address: u8,
            }
            pub type HashTableEntry_NonConstT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct EntrySlot {
                pub mEntry: *mut root::mozilla::detail::EntrySlot_Entry,
                pub mKeyHash: *mut root::mozilla::HashNumber,
            }
            pub type EntrySlot_NonConstT = u8;
            pub type EntrySlot_Entry = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable {
                pub _address: u8,
            }
            pub type HashTable_NonConstT = u8;
            pub type HashTable_Key = u8;
            pub type HashTable_Lookup = u8;
            pub type HashTable_Entry = u8;
            pub type HashTable_Slot = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_Ptr {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_AddPtr {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_Iterator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_ModIterator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_Range {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_Enum {
                pub _address: u8,
            }
            impl root::mozilla::detail::HashTable_FailureBehavior {
                pub const ReportFailure: root::mozilla::detail::HashTable_FailureBehavior =
                    HashTable_FailureBehavior::DontReportFailure;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum HashTable_FailureBehavior {
                DontReportFailure = 0,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_FakeSlot {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable_DoubleHash {
                pub _address: u8,
            }
            impl root::mozilla::detail::HashTable_LookupReason {
                pub const ForAdd: root::mozilla::detail::HashTable_LookupReason =
                    HashTable_LookupReason::ForNonAdd;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum HashTable_LookupReason {
                ForNonAdd = 0,
            }
            impl root::mozilla::detail::HashTable_RebuildStatus {
                pub const Rehashed: root::mozilla::detail::HashTable_RebuildStatus =
                    HashTable_RebuildStatus::NotOverloaded;
            }
            impl root::mozilla::detail::HashTable_RebuildStatus {
                pub const RehashFailed: root::mozilla::detail::HashTable_RebuildStatus =
                    HashTable_RebuildStatus::NotOverloaded;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum HashTable_RebuildStatus {
                NotOverloaded = 0,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct VectorTesting {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct CopyablePtr<T> {
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
                pub mPtr: T,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct PointedTo {
                pub _address: u8,
            }
            pub type PointedTo_Type = root::std::remove_reference_t;
            pub type PointedTo_NonConstType = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct RefCountLogger {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct RefCountLogger_ReleaseLogger {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of RefCountLogger_ReleaseLogger"]
                    [::std::mem::size_of::<RefCountLogger_ReleaseLogger>() - 1usize];
                ["Alignment of RefCountLogger_ReleaseLogger"]
                    [::std::mem::align_of::<RefCountLogger_ReleaseLogger>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of RefCountLogger"][::std::mem::size_of::<RefCountLogger>() - 1usize];
                ["Alignment of RefCountLogger"][::std::mem::align_of::<RefCountLogger>() - 1usize];
            };
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum RefCountAtomicity {
                AtomicRefCount = 0,
                NonAtomicRefCount = 1,
            }
            pub type RefCounted_HasThreadSafeRefCnt = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct FreePolicy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasReceiverTypeHelper {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of HasReceiverTypeHelper"]
                    [::std::mem::size_of::<HasReceiverTypeHelper>() - 1usize];
                ["Alignment of HasReceiverTypeHelper"]
                    [::std::mem::align_of::<HasReceiverTypeHelper>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasReceiverType {
                pub _address: u8,
            }
            pub type ReceiverTypeImpl_Type = root::__BindgenOpaqueArray<u8, 0usize>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ReceiverType {
                pub _address: u8,
            }
            pub type ReceiverType_Type = u8;
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct UniquePtrGetterTransfers {
                pub mPtr: *mut root::mozilla::detail::UniquePtrGetterTransfers_Ptr,
                pub mReceiver: root::mozilla::detail::UniquePtrGetterTransfers_Receiver,
            }
            #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
            pub type UniquePtrGetterTransfers_Ptr = u8;
            pub type UniquePtrGetterTransfers_Receiver = root::mozilla::detail::ReceiverType;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConditionVariableImpl {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct MutexImpl {
                pub platformData_: [*mut ::std::os::raw::c_void; 5usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MutexImpl_PlatformData {
                _unused: [u8; 0],
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of MutexImpl"][::std::mem::size_of::<MutexImpl>() - 40usize];
                ["Alignment of MutexImpl"][::std::mem::align_of::<MutexImpl>() - 8usize];
                ["Offset of field: MutexImpl::platformData_"]
                    [::std::mem::offset_of!(MutexImpl, platformData_) - 0usize];
            };
            #[repr(C)]
            pub struct RWLockImpl {
                pub mRWLock: root::pthread_rwlock_t,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of RWLockImpl"][::std::mem::size_of::<RWLockImpl>() - 56usize];
                ["Alignment of RWLockImpl"][::std::mem::align_of::<RWLockImpl>() - 8usize];
                ["Offset of field: RWLockImpl::mRWLock"]
                    [::std::mem::offset_of!(RWLockImpl, mRWLock) - 0usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UnsupportedType {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of UnsupportedType"][::std::mem::size_of::<UnsupportedType>() - 1usize];
                ["Alignment of UnsupportedType"]
                    [::std::mem::align_of::<UnsupportedType>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsSupportedPass2 {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsSupported {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_signed_char_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_signed_char_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_unsigned_char_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_unsigned_char_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_short_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_short_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_unsigned_short_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_unsigned_short_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_int_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_int_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_unsigned_int_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_unsigned_int_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_long_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_long_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupported_open0_unsigned_long_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupported>() - 1usize];
                ["Align of template specialization: IsSupported_open0_unsigned_long_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupported>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_char_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_char_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_signed_char_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_signed_char_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_unsigned_char_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_unsigned_char_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_short_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_short_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_unsigned_short_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_unsigned_short_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: detail :: IsSupportedPass2 > () - 1usize] ;
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_int_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_int_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_unsigned_int_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_unsigned_int_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_long_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_long_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_unsigned_long_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_unsigned_long_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_long_long_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
                ["Align of template specialization: IsSupportedPass2_open0_long_long_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::IsSupportedPass2>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: IsSupportedPass2_open0_unsigned_long_long_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: detail :: IsSupportedPass2 > () - 1usize] ;
                ["Align of template specialization: IsSupportedPass2_open0_unsigned_long_long_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: detail :: IsSupportedPass2 > () - 1usize] ;
            };
            pub type TwiceBiggerType_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct CastToCheckedIntImpl {
                pub _address: u8,
            }
            #[doc = " @class CheckedInt\n @brief Integer wrapper class checking for integer overflow and other errors\n @param T the integer type to wrap. Can be any type among the following:\n            - any basic integer type such as |int|\n            - any stdint type such as |int8_t|\n\n This class implements guarded integer arithmetic. Do a computation, check\n that isValid() returns true, you then have a guarantee that no problem, such\n as integer overflow, happened during this computation, and you can call\n value() to get the plain integer value.\n\n The arithmetic operators in this class are guaranteed not to raise a signal\n (e.g. in case of a division by zero).\n\n For example, suppose that you want to implement a function that computes\n (aX+aY)/aZ, that doesn't crash if aZ==0, and that reports on error (divide by\n zero or integer overflow). You could code it as follows:\n@code\nbool computeXPlusYOverZ(int aX, int aY, int aZ, int* aResult)\n{\nCheckedInt<int> checkedResult = (CheckedInt<int>(aX) + aY) / aZ;\nif (checkedResult.isValid()) {\naResult = checkedResult.value();\nreturn true;\n} else {\nreturn false;\n}\n}\n@endcode\n\n Implicit conversion from plain integers to checked integers is allowed. The\n plain integer is checked to be in range before being casted to the\n destination type. This means that the following lines all compile, and the\n resulting CheckedInts are correctly detected as valid or invalid:\n @code\n// 1 is of type int, is found to be in range for uint8_t, x is valid\nCheckedInt<uint8_t> x(1);\n// -1 is of type int, is found not to be in range for uint8_t, x is invalid\nCheckedInt<uint8_t> x(-1);\n// -1 is of type int, is found to be in range for int8_t, x is valid\nCheckedInt<int8_t> x(-1);\n// 1000 is of type int16_t, is found not to be in range for int8_t,\n// x is invalid\nCheckedInt<int8_t> x(int16_t(1000));\n// 3123456789 is of type uint32_t, is found not to be in range for int32_t,\n// x is invalid\nCheckedInt<int32_t> x(uint32_t(3123456789));\n @endcode\n Implicit conversion from\n checked integers to plain integers is not allowed. As shown in the\n above example, to get the value of a checked integer as a normal integer,\n call value().\n\n Arithmetic operations between checked and plain integers is allowed; the\n result type is the type of the checked integer.\n\n Checked integers of different types cannot be used in the same arithmetic\n expression.\n\n There are convenience typedefs for all stdint types, of the following form\n (these are just 2 examples):\n@code\ntypedef CheckedInt<int32_t> CheckedInt32;\ntypedef CheckedInt<uint16_t> CheckedUint16;\n@endcode"]
            pub type CastToCheckedIntImpl_ReturnType<T> = root::mozilla::CheckedInt<T>;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: HasFreeLSB_open0_ptr_JSString_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
                ["Align of template specialization: HasFreeLSB_open0_ptr_JSString_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
            };
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: HasFreeLSB_open0_ptr_JSObject_close0"]
                    [::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
                ["Align of template specialization: HasFreeLSB_open0_ptr_JSObject_close0"]
                    [::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>() - 1usize];
            };
        }
        pub mod tl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static Min_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static Max_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static FloorLog2_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static CeilingLog2_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static RoundUpPow2_value: usize;
            }
            #[doc = " Compute the number of bits in the given unsigned type."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BitSize {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}checkPrecondition"]
                pub static NBitMask_checkPrecondition: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static NBitMask_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static MulOverflowMask_value: usize;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MallocAllocPolicy"][::std::mem::size_of::<MallocAllocPolicy>() - 1usize];
            ["Alignment of MallocAllocPolicy"]
                [::std::mem::align_of::<MallocAllocPolicy>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NeverAllocPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of NeverAllocPolicy"][::std::mem::size_of::<NeverAllocPolicy>() - 1usize];
            ["Alignment of NeverAllocPolicy"][::std::mem::align_of::<NeverAllocPolicy>() - 1usize];
        };
        #[doc = " CompactPair is the logical concatenation of an instance of A with an instance\n B. Space is conserved when possible.  Neither A nor B may be a final class.\n\n In general if space conservation is not critical is preferred to use\n std::pair.\n\n It's typically clearer to have individual A and B member fields.  Except if\n you want the space-conserving qualities of CompactPair, you're probably\n better off not using this!\n\n No guarantees are provided about the memory layout of A and B, the order of\n initialization or destruction of A and B, and so on.  (This is approximately\n required to optimize space usage.)  The first/second names are merely\n conceptual!"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompactPair {
            pub _address: u8,
        }
        pub type CompactPair_Base = u8;
        #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UniquePtr {
            pub _address: u8,
        }
        pub type UniquePtr_ElementType = u8;
        pub type UniquePtr_DeleterType = u8;
        pub type UniquePtr_Pointer = u8;
        #[doc = " A default deletion policy using plain old operator delete.\n\n Note that this type can be specialized, but authors should beware of the risk\n that the specialization may at some point cease to match (either because it\n gets moved to a different compilation unit or the signature changes). If the\n non-specialized (|delete|-based) version compiles for that type but does the\n wrong thing, bad things could happen.\n\n This is a non-issue for types which are always incomplete (i.e. opaque handle\n types), since |delete|-ing such a type will always trigger a compilation\n error."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DefaultDelete {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct PrintfTarget__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct PrintfTarget {
            pub vtable_: *const PrintfTarget__bindgen_vtable,
            pub mEmitted: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of PrintfTarget"][::std::mem::size_of::<PrintfTarget>() - 16usize];
            ["Alignment of PrintfTarget"][::std::mem::align_of::<PrintfTarget>() - 8usize];
            ["Offset of field: PrintfTarget::mEmitted"]
                [::std::mem::offset_of!(PrintfTarget, mEmitted) - 8usize];
        };
        pub type SmprintfPolicyPointer = u8;
        pub type SmprintfPointer = u8;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SprintfState<AllocPolicy> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AllocPolicy>>,
            pub _base: root::mozilla::PrintfTarget,
            pub _base_1: AllocPolicy,
            pub mMaxlen: usize,
            pub mBase: *mut ::std::os::raw::c_char,
            pub mCur: *mut ::std::os::raw::c_char,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct FloatingPoint {
            pub _address: u8,
        }
        pub type FloatingPoint_Base = root::mozilla::detail::FloatingPointTrait;
        #[doc = " An unsigned integral type suitable for accessing the bitwise representation\n of T."]
        pub type FloatingPoint_Bits = root::mozilla::FloatingPoint_Base;
        pub type InfinityBits_Traits = root::mozilla::FloatingPoint;
        pub type SpecificNaNBits_Traits = root::mozilla::FloatingPoint;
        #[repr(C)]
        pub struct AlignedStorage2 {
            pub u: root::mozilla::AlignedStorage2_U,
        }
        #[repr(C)]
        pub union AlignedStorage2_U {
            pub mBytes: *mut ::std::os::raw::c_char,
            pub mDummy: u64,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NotNullTag {
            KnownNotNull = 0,
        }
        #[doc = " A version of CorruptionCanary that is suitable as a member of objects that\n are statically allocated."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct CorruptionCanaryForStatics {
            pub mValue: usize,
        }
        pub const CorruptionCanaryForStatics_kCanarySet: usize = 252382987;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CorruptionCanaryForStatics"]
                [::std::mem::size_of::<CorruptionCanaryForStatics>() - 8usize];
            ["Alignment of CorruptionCanaryForStatics"]
                [::std::mem::align_of::<CorruptionCanaryForStatics>() - 8usize];
            ["Offset of field: CorruptionCanaryForStatics::mValue"]
                [::std::mem::offset_of!(CorruptionCanaryForStatics, mValue) - 0usize];
        };
        #[doc = " This class is designed to cause crashes when various kinds of memory\n corruption are observed. For instance, let's say we have a class C where we\n suspect out-of-bounds writes to some members.  We can insert a member of type\n Poison near the members we suspect are being corrupted by out-of-bounds\n writes.  Or perhaps we have a class K we suspect is subject to use-after-free\n violations, in which case it doesn't particularly matter where in the class\n we add the member of type Poison.\n\n In either case, we then insert calls to Check() throughout the code.  Doing\n so enables us to narrow down the location where the corruption is occurring.\n A pleasant side-effect of these additional Check() calls is that crash\n signatures may become more regular, as crashes will ideally occur\n consolidated at the point of a Check(), rather than scattered about at\n various uses of the corrupted memory."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct CorruptionCanary {
            pub _base: root::mozilla::CorruptionCanaryForStatics,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CorruptionCanary"][::std::mem::size_of::<CorruptionCanary>() - 8usize];
            ["Alignment of CorruptionCanary"][::std::mem::align_of::<CorruptionCanary>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Nothing {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Nothing"][::std::mem::size_of::<Nothing>() - 1usize];
            ["Alignment of Nothing"][::std::mem::align_of::<Nothing>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Maybe {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Maybe_SomeGuard {
            pub _address: u8,
        }
        pub type Maybe_ValueType = u8;
        pub type MallocSizeOf =
            ::std::option::Option<unsafe extern "C" fn(p: *const ::std::os::raw::c_void) -> usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RangedPtr<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mPtr: *mut T,
        }
        pub mod span_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_span_oracle {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_span {
                pub _base: root::mozilla::span_details::is_span_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_std_array_oracle {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_std_array {
                pub _base: root::mozilla::span_details::is_std_array_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_allowed_element_type_conversion {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SpanKnownBounds {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of SpanKnownBounds"][::std::mem::size_of::<SpanKnownBounds>() - 1usize];
                ["Alignment of SpanKnownBounds"]
                    [::std::mem::align_of::<SpanKnownBounds>() - 1usize];
            };
            pub type span_iterator_element_type_ = root::__BindgenOpaqueArray<u8, 0usize>;
            pub type span_iterator_iterator_category = root::std::random_access_iterator_tag;
            pub type span_iterator_value_type = u8;
            pub type span_iterator_difference_type = isize;
            pub type span_iterator_reference = *mut root::std::conditional_t;
            pub type span_iterator_pointer = u8;
            pub type extent_type_index_type = usize;
        }
        pub type Span_element_type<ElementType> = ElementType;
        pub type Span_value_type = u8;
        pub type Span_index_type = usize;
        pub type Span_pointer<ElementType> = *mut root::mozilla::Span_element_type<ElementType>;
        pub type Span_reference<ElementType> = *mut root::mozilla::Span_element_type<ElementType>;
        pub type Span_iterator = u8;
        pub type Span_const_iterator = u8;
        pub type Span_reverse_iterator = u8;
        pub type Span_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Span_storage_type<ElementType, ExtentType> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ElementType>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<ExtentType>>,
            pub _base: ExtentType,
            pub data_: root::mozilla::Span_pointer<ElementType>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OwningNonNull {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StaticLocalRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StaticRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RefPtrTraits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AlignmentFinder {
            pub _address: u8,
        }
        pub type TimeStampValue = u64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeStampTests {
            _unused: [u8; 0],
        }
        #[doc = " Platform-specific implementation details of BaseTimeDuration."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BaseTimeDurationPlatformUtils {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of BaseTimeDurationPlatformUtils"]
                [::std::mem::size_of::<BaseTimeDurationPlatformUtils>() - 1usize];
            ["Alignment of BaseTimeDurationPlatformUtils"]
                [::std::mem::align_of::<BaseTimeDurationPlatformUtils>() - 1usize];
        };
        #[doc = " Instances of this class represent the length of an interval of time.\n Negative durations are allowed, meaning the end is before the start.\n\n Internally the duration is stored as a int64_t in units of\n PR_TicksPerSecond() when building with NSPR interval timers, or a\n system-dependent unit when building with system clocks.  The\n system-dependent unit must be constant, otherwise the semantics of\n this class would be broken.\n\n The ValueCalculator template parameter determines how arithmetic\n operations are performed on the integer count of ticks (mValue)."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BaseTimeDuration {
            pub mValue: i64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration__SomethingVeryRandomHere {
            _unused: [u8; 0],
        }
        #[doc = " Perform arithmetic operations on the value of a BaseTimeDuration without\n doing strict checks on the range of values."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TimeDurationValueCalculator {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TimeDurationValueCalculator"]
                [::std::mem::size_of::<TimeDurationValueCalculator>() - 1usize];
            ["Alignment of TimeDurationValueCalculator"]
                [::std::mem::align_of::<TimeDurationValueCalculator>() - 1usize];
        };
        #[doc = " Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for\n arithmetic on the mValue member.\n\n Use this class for time durations that are *not* expected to hold values of\n Forever (or the negative equivalent) or when such time duration are *not*\n expected to be used in arithmetic operations."]
        pub type TimeDuration = root::mozilla::BaseTimeDuration;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TimeStamp {
            #[doc = " When built with PRIntervalTime, a value of 0 means this instance\n is \"null\". Otherwise, the low 32 bits represent a PRIntervalTime,\n and the high 32 bits represent a counter of the number of\n rollovers of PRIntervalTime that we've seen. This counter starts\n at 1 to avoid a real time colliding with the \"null\" value.\n\n PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum\n time to wrap around is about 2^64/100000 seconds, i.e. about\n 5,849,424 years.\n\n When using a system clock, a value is system dependent."]
            pub mValue: root::mozilla::TimeStampValue,
        }
        #[doc = " Instances of this class represent the length of an interval of time.\n Negative durations are allowed, meaning the end is before the start.\n\n Internally the duration is stored as a int64_t in units of\n PR_TicksPerSecond() when building with NSPR interval timers, or a\n system-dependent unit when building with system clocks.  The\n system-dependent unit must be constant, otherwise the semantics of\n this class would be broken.\n\n The ValueCalculator template parameter determines how arithmetic\n operations are performed on the integer count of ticks (mValue)."]
        pub type TimeStamp_DurationType = root::mozilla::TimeDuration;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TimeStamp"][::std::mem::size_of::<TimeStamp>() - 8usize];
            ["Alignment of TimeStamp"][::std::mem::align_of::<TimeStamp>() - 8usize];
            ["Offset of field: TimeStamp::mValue"]
                [::std::mem::offset_of!(TimeStamp, mValue) - 0usize];
        };
        #[doc = " A code unit within a UTF-8 encoded string.  (A code unit is the smallest\n unit within the Unicode encoding of a string.  For UTF-8 this is an 8-bit\n number; for UTF-16 it would be a 16-bit number.)\n\n This is *not* the same as a single code point: in UTF-8, non-ASCII code\n points are constituted by multiple code units."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union Utf8Unit {
            pub mValue: ::std::os::raw::c_char,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Utf8Unit"][::std::mem::size_of::<Utf8Unit>() - 1usize];
            ["Alignment of Utf8Unit"][::std::mem::align_of::<Utf8Unit>() - 1usize];
            ["Offset of field: Utf8Unit::mValue"]
                [::std::mem::offset_of!(Utf8Unit, mValue) - 0usize];
        };
        pub type HashNumber = u32;
        #[doc = " A pseudorandom function mapping 32-bit integers to 32-bit integers.\n\n This is for when you're feeding private data (like pointer values or credit\n card numbers) to a non-crypto hash function (like HashBytes) and then using\n the hash code for something that untrusted parties could observe (like a JS\n Map). Plug in a HashCodeScrambler before that last step to avoid leaking the\n private data.\n\n By itself, this does not prevent hash-flooding DoS attacks, because an\n attacker can still generate many values with exactly equal hash codes by\n attacking the non-crypto hash function alone. Equal hash codes will, of\n course, still be equal however much you scramble them.\n\n The algorithm is SipHash-1-3. See <https://131002.net/siphash/>."]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashCodeScrambler {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashCodeScrambler_SipHasher {
            pub _bindgen_opaque_blob: [u64; 4usize],
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of HashCodeScrambler_SipHasher"]
                [::std::mem::size_of::<HashCodeScrambler_SipHasher>() - 32usize];
            ["Alignment of HashCodeScrambler_SipHasher"]
                [::std::mem::align_of::<HashCodeScrambler_SipHasher>() - 8usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of HashCodeScrambler"][::std::mem::size_of::<HashCodeScrambler>() - 16usize];
            ["Alignment of HashCodeScrambler"]
                [::std::mem::align_of::<HashCodeScrambler>() - 8usize];
        };
        pub mod ipc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IPDLParamTraits {
                pub _address: u8,
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct VariantType {
            pub _address: u8,
        }
        pub type VariantType_Type<T> = T;
        extern "C" {
            #[link_name = "\u{1}index"]
            pub static VariantIndex_index: usize;
        }
        #[doc = " # mozilla::Variant\n\n A variant / tagged union / heterogenous disjoint union / sum-type template\n class. Similar in concept to (but not derived from) `boost::variant`.\n\n Sometimes, you may wish to use a C union with non-POD types. However, this is\n forbidden in C++ because it is not clear which type in the union should have\n its constructor and destructor run on creation and deletion\n respectively. This is the problem that `mozilla::Variant` solves.\n\n ## Usage\n\n A `mozilla::Variant` instance is constructed (via move or copy) from one of\n its variant types (ignoring const and references). It does *not* support\n construction from subclasses of variant types or types that coerce to one of\n the variant types.\n\n     Variant<char, uint32_t> v1('a');\n     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());\n     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed\n     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int\n\n Because specifying the full type of a Variant value is often verbose,\n there are two easier ways to construct values:\n\n A. AsVariant() can be used to construct a Variant value using type inference\n in contexts such as expressions or when returning values from functions.\n Because AsVariant() must copy or move the value into a temporary and this\n cannot necessarily be elided by the compiler, it's mostly appropriate only\n for use with primitive or very small types.\n\n     Variant<char, uint32_t> Foo() { return AsVariant('x'); }\n     // ...\n     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x').\n\n B. Brace-construction with VariantType or VariantIndex; this also allows\n in-place construction with any number of arguments.\n\n     struct AB { AB(int, int){...} };\n     static Variant<AB, bool> foo()\n     {\n       return {VariantIndex<0>{}, 1, 2};\n     }\n     // ...\n     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2).\n\n All access to the contained value goes through type-safe accessors.\n Either the stored type, or the type index may be provided.\n\n     void\n     Foo(Variant<A, B, C> v)\n     {\n       if (v.is<A>()) {\n         A& ref = v.as<A>();\n         ...\n       } else (v.is<1>()) { // Instead of v.is<B>.\n         ...\n       } else {\n         ...\n       }\n     }\n\n In some situation, a Variant may be constructed from templated types, in\n which case it is possible that the same type could be given multiple times by\n an external developer. Or seemingly-different types could be aliases.\n In this case, repeated types can only be accessed through their index, to\n prevent ambiguous access by type.\n\n    // Bad!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(int(0)) {} // Error '0' by default\n      ResultOrError(const T& r) : m(r) {}\n      bool IsResult() const { return m.is<T>(); }\n      bool IsError() const { return m.is<int>(); }\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // Fail!\n    // In Variant<int, int>, which 'int' are we refering to, from inside\n    // ResultOrError functions?\n\n    // Good!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default\n      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}\n      bool IsResult() const { return m.is<0>(); } // 0 -> T\n      bool IsError() const { return m.is<1>(); } // 1 -> int\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // It now works!\n\n Attempting to use the contained value as type `T1` when the `Variant`\n instance contains a value of type `T2` causes an assertion failure.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<B>(); // <--- Assertion failure!\n\n Trying to use a `Variant<Ts...>` instance as some type `U` that is not a\n member of the set of `Ts...` is a compiler error.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<SomeRandomType>(); // <--- Compiler error!\n\n Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it\n out of the containing `Variant` instance with the `extract<T>` method:\n\n     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());\n     auto ptr = v.extract<UniquePtr<A>>();\n\n Finally, you can exhaustively match on the contained variant and branch into\n different code paths depending on which type is contained. This is preferred\n to manually checking every variant type T with is<T>() because it provides\n compile-time checking that you handled every type, rather than runtime\n assertion failures.\n\n     // Bad!\n     char* foo(Variant<A, B, C, D>& v) {\n       if (v.is<A>()) {\n         return ...;\n       } else if (v.is<B>()) {\n         return ...;\n       } else {\n         return doSomething(v.as<C>()); // Forgot about case D!\n       }\n     }\n\n     // Instead, a single function object (that can deal with all possible\n     // options) may be provided:\n     struct FooMatcher\n     {\n       // The return type of all matchers must be identical.\n       char* operator()(A& a) { ... }\n       char* operator()(B& b) { ... }\n       char* operator()(C& c) { ... }\n       char* operator()(D& d) { ... } // Compile-time error to forget D!\n     }\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match(FooMatcher());\n     }\n\n     // In some situations, a single generic lambda may also be appropriate:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto&) {...});\n     }\n\n     // Alternatively, multiple function objects may be provided, each one\n     // corresponding to an option, in the same order:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](A&) { ... },\n                      [](B&) { ... },\n                      [](C&) { ... },\n                      [](D&) { ... });\n     }\n\n     // In rare cases, the index of the currently-active alternative is\n     // needed, it may be obtained by adding a first parameter in the matcner\n     // callback, which will receive the index in its most compact type (just\n     // use `size_t` if the exact type is not important), e.g.:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto aIndex, auto& aAlternative) {...});\n       // --OR--\n       return v.match([](size_t aIndex, auto& aAlternative) {...});\n     }\n\n ## Examples\n\n A tree is either an empty leaf, or a node with a value and two children:\n\n     struct Leaf { };\n\n     template<typename T>\n     struct Node\n     {\n       T value;\n       Tree<T>* left;\n       Tree<T>* right;\n     };\n\n     template<typename T>\n     using Tree = Variant<Leaf, Node<T>>;\n\n A copy-on-write string is either a non-owning reference to some existing\n string, or an owning reference to our copy:\n\n     class CopyOnWriteString\n     {\n       Variant<const char*, UniquePtr<char[]>> string;\n\n       ...\n     };\n\n Because Variant must be aligned suitable to hold any value stored within it,\n and because |alignas| requirements don't affect platform ABI with respect to\n how parameters are laid out in memory, Variant can't be used as the type of a\n function parameter.  Pass Variant to functions by pointer or reference\n instead."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Variant {
            pub _address: u8,
        }
        pub type Variant_Tag = root::mozilla::detail::VariantTag;
        pub type Variant_Impl = u8;
        #[doc = " Empty struct, indicating success for operations that have no return value.\n For example, if you declare another empty struct `struct OutOfMemory {};`,\n then `Result<Ok, OutOfMemory>` represents either success or OOM."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Ok {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Ok"][::std::mem::size_of::<Ok>() - 1usize];
            ["Alignment of Ok"][::std::mem::align_of::<Ok>() - 1usize];
        };
        #[doc = " A tag used to differentiate between GenericErrorResult created by the Err\n function (completely new error) and GenericErrorResult created by the\n Result::propagateErr function (propagated error). This can be used to track\n error propagation and eventually produce error stacks for logging/debugging\n purposes."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ErrorPropagationTag {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ErrorPropagationTag"][::std::mem::size_of::<ErrorPropagationTag>() - 1usize];
            ["Alignment of ErrorPropagationTag"]
                [::std::mem::align_of::<ErrorPropagationTag>() - 1usize];
        };
        #[doc = " Result<V, E> represents the outcome of an operation that can either succeed\n or fail. It contains either a success value of type V or an error value of\n type E.\n\n All Result methods are const, so results are basically immutable.\n This is just like Variant<V, E> but with a slightly different API, and the\n following cases are optimized so Result can be stored more efficiently:\n\n - If both the success and error types do not use their least significant bit,\n are trivially copyable and destructible, Result<V, E> is guaranteed to be as\n large as the larger type. This is determined via the HasFreeLSB trait. By\n default, empty classes (in particular Ok) and aligned pointer types are\n assumed to have a free LSB, but you can specialize this trait for other\n types. If the success type is empty, the representation is guaranteed to be\n all zero bits on success. Do not change this representation! There is JIT\n code that depends on it. (Implementation note: The lowest bit is used as a\n tag bit: 0 to indicate the Result's bits are a success value, 1 to indicate\n the Result's bits (with the 1 masked out) encode an error value)\n\n - Else, if the error type can't have a all-zero bits representation and is\n not larger than a pointer, a CompactPair is used to represent this rather\n than a Variant. This has shown to be better optimizable, and the template\n code is much simpler than that of Variant, so it should also compile faster.\n Whether an error type can't be all-zero bits, is determined via the\n UnusedZero trait. MFBT doesn't declare any public type UnusedZero, but\n nsresult is declared UnusedZero in XPCOM.\n\n The purpose of Result is to reduce the screwups caused by using `false` or\n `nullptr` to indicate errors.\n What screwups? See <https://bugzilla.mozilla.org/show_bug.cgi?id=912928> for\n a partial list.\n\n Result<const V, E> or Result<V, const E> are not meaningful. The success or\n error values in a Result instance are non-modifiable in-place anyway. This\n guarantee must also be maintained when evolving Result. They can be\n unwrap()ped, but this loses const qualification. However, Result<const V, E>\n or Result<V, const E> may be misleading and prevent movability. Just use\n Result<V, E>. (Result<const V*, E> may make sense though, just Result<const\n V* const, E> is not possible.)"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Result {
            pub mImpl: root::mozilla::Result_Impl,
        }
        pub type Result_Impl = root::mozilla::detail::SelectResultImpl;
        pub type Result_ok_type<V> = V;
        pub type Result_err_type<E> = E;
        #[doc = " A type that auto-converts to an error Result. This is like a Result without\n a success type. It's the best return type for functions that always return\n an error--functions designed to build and populate error objects. It's also\n useful in error-handling macros; see MOZ_TRY for an example."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GenericErrorResult<E> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            pub mErrorValue: E,
        }
        #[repr(u8)]
        #[doc = " An enum of memory ordering possibilities for atomics.\n\n Memory ordering is the observable state of distinct values in memory.\n (It's a separate concept from atomicity, which concerns whether an\n operation can ever be observed in an intermediate state.  Don't\n conflate the two!)  Given a sequence of operations in source code on\n memory, it is *not* always the case that, at all times and on all\n cores, those operations will appear to have occurred in that exact\n sequence.  First, the compiler might reorder that sequence, if it\n thinks another ordering will be more efficient.  Second, the CPU may\n not expose so consistent a view of memory.  CPUs will often perform\n their own instruction reordering, above and beyond that performed by\n the compiler.  And each core has its own memory caches, and accesses\n (reads and writes both) to \"memory\" may only resolve to out-of-date\n cache entries -- not to the \"most recently\" performed operation in\n some global sense.  Any access to a value that may be used by\n multiple threads, potentially across multiple cores, must therefore\n have a memory ordering imposed on it, for all code on all\n threads/cores to have a sufficiently coherent worldview.\n\n http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync and\n http://en.cppreference.com/w/cpp/atomic/memory_order go into more\n detail on all this, including examples of how each mode works.\n\n Note that for simplicity and practicality, not all of the modes in\n C++11 are supported.  The missing C++11 modes are either subsumed by\n the modes we provide below, or not relevant for the CPUs we support\n in Gecko.  These three modes are confusing enough as it is!"]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryOrdering {
            Relaxed = 0,
            ReleaseAcquire = 1,
            SequentiallyConsistent = 2,
        }
        #[doc = " DebugOnly contains a value of type T, but only in debug builds.  In release\n builds, it does not contain a value.  This helper is intended to be used with\n MOZ_ASSERT()-style macros, allowing one to write:\n\n   DebugOnly<bool> check = func();\n   MOZ_ASSERT(check);\n\n more concisely than declaring |check| conditional on #ifdef DEBUG.\n\n DebugOnly instances can only be coerced to T in debug builds.  In release\n builds they don't have a value, so type coercion is not well defined.\n\n NOTE: DebugOnly instances still take up one byte of space, plus padding, even\n in optimized, non-DEBUG builds (see bug 1253094 comment 37 for more info).\n For this reason the class is MOZ_STACK_CLASS to prevent consumers using\n DebugOnly for struct/class members and unwittingly inflating the size of\n their objects in release builds."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct DebugOnly {
            pub _address: u8,
        }
        pub type Array_ElementType<T> = T;
        pub type Array_iterator<T> = *mut T;
        pub type Array_const_iterator<T> = *const T;
        pub type Array_reverse_iterator = u8;
        pub type Array_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct EnumTypeFitsWithin {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MinContiguousEnumValue {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MaxContiguousEnumValue {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MaxEnumValue {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ContiguousEnumValues {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ContiguousEnumSize {
            pub _address: u8,
        }
        pub type EnumeratedArray_ArrayType = u8;
        pub type EnumeratedArray_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LinkedListElement {
            pub mNext: *mut root::mozilla::LinkedListElement,
            pub mPrev: *mut root::mozilla::LinkedListElement,
            pub mIsSentinel: bool,
        }
        #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
        pub type LinkedListElement_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedListElement_RawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstRawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ClientType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstClientType = root::mozilla::LinkedListElement_Traits;
        impl root::mozilla::LinkedListElement_NodeKind {
            pub const Sentinel: root::mozilla::LinkedListElement_NodeKind =
                LinkedListElement_NodeKind::Normal;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LinkedListElement_NodeKind {
            Normal = 0,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LinkedList {
            pub sentinel: root::mozilla::LinkedListElement,
        }
        #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
        pub type LinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedList_RawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstRawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ElementType = *mut root::mozilla::LinkedListElement;
        pub type LinkedList_ConstElementType = *const root::mozilla::LinkedListElement;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct LinkedList_Iterator<Type> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Type>>,
            pub mCurrent: Type,
        }
        pub type LinkedList_Iterator_iterator_category = root::std::forward_iterator_tag;
        pub type LinkedList_Iterator_value_type<T> = T;
        pub type LinkedList_Iterator_difference_type = isize;
        pub type LinkedList_Iterator_pointer<T> = *mut T;
        pub type LinkedList_Iterator_reference<T> = *mut T;
        pub type LinkedList_const_iterator =
            root::mozilla::LinkedList_Iterator<root::mozilla::LinkedList_ConstRawType>;
        pub type LinkedList_iterator =
            root::mozilla::LinkedList_Iterator<root::mozilla::LinkedList_RawType>;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoCleanLinkedList {
            pub _base: root::mozilla::LinkedList,
        }
        #[doc = " LinkedList supports refcounted elements using this adapter class. Clients\n using LinkedList<RefPtr<T>> will get a data structure that holds a strong\n reference to T as long as T is in the list."]
        pub type AutoCleanLinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type AutoCleanLinkedList_ClientType = root::mozilla::detail::LinkedListElementTraits;
        pub type BitSet_Word = root::mozilla::detail::UnwrapMaybeAtomic;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BitSet_Reference {
            pub mBitSet: *mut u8,
            pub mPos: usize,
        }
        #[doc = " Opaque<T> is a replacement for integral T in cases where only comparisons\n must be supported, and it's desirable to prevent accidental dependency on\n exact values."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Opaque<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mValue: T,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ReentrancyGuard {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ReentrancyGuard"][::std::mem::size_of::<ReentrancyGuard>() - 1usize];
            ["Alignment of ReentrancyGuard"][::std::mem::align_of::<ReentrancyGuard>() - 1usize];
        };
        #[doc = " Opaque<T> is a replacement for integral T in cases where only comparisons\n must be supported, and it's desirable to prevent accidental dependency on\n exact values."]
        pub type Generation = root::mozilla::Opaque<u64>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashMap {
            pub _address: u8,
        }
        pub type HashMap_TableEntry = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashMap_MapHashPolicy {
            pub _address: u8,
        }
        pub type HashMap_MapHashPolicy_Base = u8;
        pub type HashMap_MapHashPolicy_KeyType = u8;
        pub type HashMap_Impl = u8;
        pub type HashMap_Lookup = u8;
        pub type HashMap_Entry = u8;
        pub type HashMap_Ptr = u8;
        pub type HashMap_AddPtr = u8;
        pub type HashMap_Iterator = u8;
        pub type HashMap_ModIterator = u8;
        pub type HashMap_Range = u8;
        pub type HashMap_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashSet {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashSet_SetHashPolicy {
            pub _address: u8,
        }
        pub type HashSet_SetHashPolicy_Base = u8;
        pub type HashSet_SetHashPolicy_KeyType = u8;
        pub type HashSet_Impl = u8;
        pub type HashSet_Lookup = u8;
        pub type HashSet_Entry = u8;
        pub type HashSet_Ptr = u8;
        pub type HashSet_AddPtr = u8;
        pub type HashSet_Iterator = u8;
        pub type HashSet_ModIterator = u8;
        pub type HashSet_Range = u8;
        pub type HashSet_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PointerHasher {
            pub _address: u8,
        }
        pub type PointerHasher_Lookup<Key> = Key;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DefaultHasher {
            pub _address: u8,
        }
        pub type DefaultHasher_Lookup<Key> = Key;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: DefaultHasher_open0_double_void_close0"]
                [::std::mem::size_of::<root::mozilla::DefaultHasher>() - 1usize];
            ["Align of template specialization: DefaultHasher_open0_double_void_close0"]
                [::std::mem::align_of::<root::mozilla::DefaultHasher>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: DefaultHasher_open0_float_void_close0"]
                [::std::mem::size_of::<root::mozilla::DefaultHasher>() - 1usize];
            ["Align of template specialization: DefaultHasher_open0_float_void_close0"]
                [::std::mem::align_of::<root::mozilla::DefaultHasher>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CStringHasher {
            pub _address: u8,
        }
        pub type CStringHasher_Key = *const ::std::os::raw::c_char;
        pub type CStringHasher_Lookup = *const ::std::os::raw::c_char;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CStringHasher"][::std::mem::size_of::<CStringHasher>() - 1usize];
            ["Alignment of CStringHasher"][::std::mem::align_of::<CStringHasher>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct FallibleHashMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashMapEntry {
            pub _address: u8,
        }
        pub type HashMapEntry_KeyType = u8;
        pub type HashMapEntry_ValueType = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StackCaptureOptions {
            NoStack = 0,
            Full = 1,
            NonNative = 2,
        }
        #[repr(C)]
        pub struct FailureLatch__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct FailureLatch {
            pub vtable_: *const FailureLatch__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of FailureLatch"][::std::mem::size_of::<FailureLatch>() - 8usize];
            ["Alignment of FailureLatch"][::std::mem::align_of::<FailureLatch>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct FailureLatchInfallibleSource {
            pub _base: root::mozilla::FailureLatch,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of FailureLatchInfallibleSource"]
                [::std::mem::size_of::<FailureLatchInfallibleSource>() - 8usize];
            ["Alignment of FailureLatchInfallibleSource"]
                [::std::mem::align_of::<FailureLatchInfallibleSource>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct FailureLatchSource {
            pub _base: root::mozilla::FailureLatch,
            pub mFailed: bool,
            pub mReason: root::std::string,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of FailureLatchSource"][::std::mem::size_of::<FailureLatchSource>() - 48usize];
            ["Alignment of FailureLatchSource"]
                [::std::mem::align_of::<FailureLatchSource>() - 8usize];
            ["Offset of field: FailureLatchSource::mFailed"]
                [::std::mem::offset_of!(FailureLatchSource, mFailed) - 8usize];
            ["Offset of field: FailureLatchSource::mReason"]
                [::std::mem::offset_of!(FailureLatchSource, mReason) - 16usize];
        };
        pub type Vector_Impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Vector_CapacityAndReserved {
            pub mCapacity: usize,
        }
        pub type Vector_ElementType<T> = T;
        pub const Vector_InlineLength: root::mozilla::Vector__bindgen_ty_1 =
            Vector__bindgen_ty_1::InlineLength;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Vector__bindgen_ty_1 {
            InlineLength = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Vector_Range<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mCur: *mut T,
            pub mEnd: *mut T,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Vector_ConstRange<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mCur: *const T,
            pub mEnd: *const T,
        }
        #[repr(C)]
        pub struct JSONWriteFunc__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JSONWriteFunc {
            pub vtable_: *const JSONWriteFunc__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JSONWriteFunc"][::std::mem::size_of::<JSONWriteFunc>() - 8usize];
            ["Alignment of JSONWriteFunc"][::std::mem::align_of::<JSONWriteFunc>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JSONWriter {
            pub mMaybeOwnedWriter: u64,
            pub mWriter: *mut root::mozilla::JSONWriteFunc,
            pub mNeedComma: root::__BindgenOpaqueArray<u64, 4usize>,
            pub mNeedNewlines: root::__BindgenOpaqueArray<u64, 4usize>,
            pub mDepth: usize,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JSONWriter_EscapedString {
            pub mStringSpan: root::__BindgenOpaqueArray<u64, 2usize>,
            pub mOwnedStr: u64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JSONWriter_EscapedString"]
                [::std::mem::size_of::<JSONWriter_EscapedString>() - 24usize];
            ["Alignment of JSONWriter_EscapedString"]
                [::std::mem::align_of::<JSONWriter_EscapedString>() - 8usize];
            ["Offset of field: JSONWriter_EscapedString::mStringSpan"]
                [::std::mem::offset_of!(JSONWriter_EscapedString, mStringSpan) - 0usize];
            ["Offset of field: JSONWriter_EscapedString::mOwnedStr"]
                [::std::mem::offset_of!(JSONWriter_EscapedString, mOwnedStr) - 16usize];
        };
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum JSONWriter_CollectionStyle {
            MultiLineStyle = 0,
            SingleLineStyle = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter18scArrayBeginStringE"]
            pub static JSONWriter_scArrayBeginString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter16scArrayEndStringE"]
            pub static JSONWriter_scArrayEndString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter13scCommaStringE"]
            pub static JSONWriter_scCommaString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter13scEmptyStringE"]
            pub static JSONWriter_scEmptyString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter13scFalseStringE"]
            pub static JSONWriter_scFalseString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter15scNewLineStringE"]
            pub static JSONWriter_scNewLineString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter12scNullStringE"]
            pub static JSONWriter_scNullString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter19scObjectBeginStringE"]
            pub static JSONWriter_scObjectBeginString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter17scObjectEndStringE"]
            pub static JSONWriter_scObjectEndString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter21scPropertyBeginStringE"]
            pub static JSONWriter_scPropertyBeginString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter19scPropertyEndStringE"]
            pub static JSONWriter_scPropertyEndString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter13scQuoteStringE"]
            pub static JSONWriter_scQuoteString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter13scSpaceStringE"]
            pub static JSONWriter_scSpaceString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter22scTopObjectBeginStringE"]
            pub static JSONWriter_scTopObjectBeginString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter20scTopObjectEndStringE"]
            pub static JSONWriter_scTopObjectEndString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla10JSONWriter12scTrueStringE"]
            pub static JSONWriter_scTrueString: root::__BindgenOpaqueArray<u64, 2usize>;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JSONWriter"][::std::mem::size_of::<JSONWriter>() - 88usize];
            ["Alignment of JSONWriter"][::std::mem::align_of::<JSONWriter>() - 8usize];
            ["Offset of field: JSONWriter::mMaybeOwnedWriter"]
                [::std::mem::offset_of!(JSONWriter, mMaybeOwnedWriter) - 0usize];
            ["Offset of field: JSONWriter::mWriter"]
                [::std::mem::offset_of!(JSONWriter, mWriter) - 8usize];
            ["Offset of field: JSONWriter::mNeedComma"]
                [::std::mem::offset_of!(JSONWriter, mNeedComma) - 16usize];
            ["Offset of field: JSONWriter::mNeedNewlines"]
                [::std::mem::offset_of!(JSONWriter, mNeedNewlines) - 48usize];
            ["Offset of field: JSONWriter::mDepth"]
                [::std::mem::offset_of!(JSONWriter, mDepth) - 80usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotNull<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mBasePtr: root::mozilla::detail::CopyablePtr<T>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MovingNotNull<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mBasePtr: T,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProportionValue {
            pub mIntegralValue: root::mozilla::ProportionValue_UnderlyingType,
        }
        pub type ProportionValue_UnderlyingType = u32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProportionValue_Internal {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProportionValue_Internal"]
                [::std::mem::size_of::<ProportionValue_Internal>() - 1usize];
            ["Alignment of ProportionValue_Internal"]
                [::std::mem::align_of::<ProportionValue_Internal>() - 1usize];
        };
        pub const ProportionValue_scFractionalBits: ::std::os::raw::c_uint = 31;
        pub const ProportionValue_scMaxU: root::mozilla::ProportionValue_UnderlyingType =
            2147483648;
        pub const ProportionValue_scMaxD: f64 = 2147483648.0;
        pub const ProportionValue_scInvMaxD: f64 = 0.0000000004656612873077393;
        pub const ProportionValue_scInvalidU: root::mozilla::ProportionValue_UnderlyingType =
            4294967295;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProportionValue"][::std::mem::size_of::<ProportionValue>() - 4usize];
            ["Alignment of ProportionValue"][::std::mem::align_of::<ProportionValue>() - 4usize];
            ["Offset of field: ProportionValue::mIntegralValue"]
                [::std::mem::offset_of!(ProportionValue, mIntegralValue) - 0usize];
        };
        pub mod literals {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RefCounted {
            pub _address: u8,
        }
        pub mod external {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        pub struct ProgressLogger {
            pub mGlobalProgressOrNull: root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>,
            pub mLocalStartInGlobalSpace: root::mozilla::ProportionValue,
            pub mLocalToGlobalMultiplier: root::mozilla::ProportionValue,
            pub mLocationAtDestruction: *const ::std::os::raw::c_char,
        }
        #[repr(C)]
        pub struct ProgressLogger_SharedProgress {
            pub __bindgen_padding_0: [u32; 2usize],
            pub mProgress: u32,
            pub mLastLocation: u64,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla14ProgressLogger14SharedProgress18NO_LOCATION_UPDATEE"]
            pub static ProgressLogger_SharedProgress_NO_LOCATION_UPDATE:
                *const ::std::os::raw::c_char;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProgressLogger_SharedProgress"]
                [::std::mem::size_of::<ProgressLogger_SharedProgress>() - 24usize];
            ["Alignment of ProgressLogger_SharedProgress"]
                [::std::mem::align_of::<ProgressLogger_SharedProgress>() - 8usize];
            ["Offset of field: ProgressLogger_SharedProgress::mProgress"]
                [::std::mem::offset_of!(ProgressLogger_SharedProgress, mProgress) - 8usize];
            ["Offset of field: ProgressLogger_SharedProgress::mLastLocation"]
                [::std::mem::offset_of!(ProgressLogger_SharedProgress, mLastLocation) - 16usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN7mozilla14ProgressLogger18NO_LOCATION_UPDATEE"]
            pub static ProgressLogger_NO_LOCATION_UPDATE: *const ::std::os::raw::c_char;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProgressLogger"][::std::mem::size_of::<ProgressLogger>() - 24usize];
            ["Alignment of ProgressLogger"][::std::mem::align_of::<ProgressLogger>() - 8usize];
            ["Offset of field: ProgressLogger::mGlobalProgressOrNull"]
                [::std::mem::offset_of!(ProgressLogger, mGlobalProgressOrNull) - 0usize];
            ["Offset of field: ProgressLogger::mLocalStartInGlobalSpace"]
                [::std::mem::offset_of!(ProgressLogger, mLocalStartInGlobalSpace) - 8usize];
            ["Offset of field: ProgressLogger::mLocalToGlobalMultiplier"]
                [::std::mem::offset_of!(ProgressLogger, mLocalToGlobalMultiplier) - 12usize];
            ["Offset of field: ProgressLogger::mLocationAtDestruction"]
                [::std::mem::offset_of!(ProgressLogger, mLocationAtDestruction) - 16usize];
        };
        #[repr(C)]
        pub struct ProgressLogger_IndexAndProgressLoggerRange {
            pub mGlobalProgressOrNull: root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>,
            pub mLoopStartInGlobalSpace: root::mozilla::ProportionValue,
            pub mLoopIncrementInGlobalSpace: root::mozilla::ProportionValue,
            pub mLoopCount: u32,
            pub mLocationOrNullEmptyToIgnoreAtEdges: *const ::std::os::raw::c_char,
        }
        #[repr(C)]
        pub struct ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger {
            pub index: u32,
            pub progressLogger: root::mozilla::ProgressLogger,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger"]
                [::std::mem::size_of::<
                    ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger,
                >() - 32usize];
            ["Alignment of ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger"]
                [::std::mem::align_of::<
                    ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger,
                >() - 8usize];
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger::index"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger , index) - 0usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger::progressLogger"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLogger , progressLogger) - 8usize] ;
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerEndIterator {
            pub mIndex: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerEndIterator"] [:: std :: mem :: size_of :: < ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerEndIterator > () - 4usize] ;
            ["Alignment of ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerEndIterator"] [:: std :: mem :: align_of :: < ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerEndIterator > () - 4usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerEndIterator::mIndex"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerEndIterator , mIndex) - 0usize] ;
        };
        #[repr(C)]
        pub struct ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator {
            pub mGlobalProgressOrNull: root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>,
            pub mLoopStartInGlobalSpace: root::mozilla::ProportionValue,
            pub mLoopIncrementInGlobalSpace: root::mozilla::ProportionValue,
            pub mIndex: u32,
            pub mLocationOrNullEmptyToIgnoreAtEdges: *const ::std::os::raw::c_char,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator"]
                [::std::mem::size_of::<
                    ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator,
                >() - 32usize];
            ["Alignment of ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator"] [:: std :: mem :: align_of :: < ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator > () - 8usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator::mGlobalProgressOrNull"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator , mGlobalProgressOrNull) - 0usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator::mLoopStartInGlobalSpace"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator , mLoopStartInGlobalSpace) - 8usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator::mLoopIncrementInGlobalSpace"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator , mLoopIncrementInGlobalSpace) - 12usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator::mIndex"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator , mIndex) - 16usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator::mLocationOrNullEmptyToIgnoreAtEdges"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange_IndexAndProgressLoggerIterator , mLocationOrNullEmptyToIgnoreAtEdges) - 24usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProgressLogger_IndexAndProgressLoggerRange"]
                [::std::mem::size_of::<ProgressLogger_IndexAndProgressLoggerRange>() - 32usize];
            ["Alignment of ProgressLogger_IndexAndProgressLoggerRange"]
                [::std::mem::align_of::<ProgressLogger_IndexAndProgressLoggerRange>() - 8usize];
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange::mGlobalProgressOrNull"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange , mGlobalProgressOrNull) - 0usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange::mLoopStartInGlobalSpace"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange , mLoopStartInGlobalSpace) - 8usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange::mLoopIncrementInGlobalSpace"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange , mLoopIncrementInGlobalSpace) - 12usize] ;
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange::mLoopCount"][::std::mem::offset_of!(
                ProgressLogger_IndexAndProgressLoggerRange,
                mLoopCount
            )
                - 16usize];
            ["Offset of field: ProgressLogger_IndexAndProgressLoggerRange::mLocationOrNullEmptyToIgnoreAtEdges"] [:: std :: mem :: offset_of ! (ProgressLogger_IndexAndProgressLoggerRange , mLocationOrNullEmptyToIgnoreAtEdges) - 24usize] ;
        };
        pub type fallible_t = root::std::nothrow_t;
        pub type UniqueFreePtr = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ULEB128Reader<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mValue: T,
            pub mShift: ::std::os::raw::c_uint,
        }
        pub type ProfileBufferIndex = u64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileBufferBlockIndex {
            pub mBlockIndex: root::mozilla::ProfileBufferIndex,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferBlockIndex"]
                [::std::mem::size_of::<ProfileBufferBlockIndex>() - 8usize];
            ["Alignment of ProfileBufferBlockIndex"]
                [::std::mem::align_of::<ProfileBufferBlockIndex>() - 8usize];
            ["Offset of field: ProfileBufferBlockIndex::mBlockIndex"]
                [::std::mem::offset_of!(ProfileBufferBlockIndex, mBlockIndex) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct unused_t {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of unused_t"][::std::mem::size_of::<unused_t>() - 1usize];
            ["Alignment of unused_t"][::std::mem::align_of::<unused_t>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferEntryReader {
            pub mCurrentSpan: root::mozilla::ProfileBufferEntryReader_SpanOfConstBytes,
            pub mNextSpanOrEmpty: root::mozilla::ProfileBufferEntryReader_SpanOfConstBytes,
            pub mCurrentBlockIndex: root::mozilla::ProfileBufferBlockIndex,
            pub mNextBlockIndex: root::mozilla::ProfileBufferBlockIndex,
        }
        pub type ProfileBufferEntryReader_Byte = u8;
        pub type ProfileBufferEntryReader_Length = u32;
        #[doc = " Span - slices for C++\n\n Span implements Rust's slice concept for C++. It's called \"Span\" instead of\n \"Slice\" to follow the naming used in C++ Core Guidelines.\n\n A Span wraps a pointer and a length that identify a non-owning view to a\n contiguous block of memory of objects of the same type. Various types,\n including (pre-decay) C arrays, XPCOM strings, nsTArray, mozilla::Array,\n mozilla::Range and contiguous standard-library containers, auto-convert\n into Spans when attempting to pass them as arguments to methods that take\n Spans. (Span itself autoconverts into mozilla::Range.)\n\n Like Rust's slices, Span provides safety against out-of-bounds access by\n performing run-time bound checks. However, unlike Rust's slices, Span\n cannot provide safety against use-after-free.\n\n (Note: Span is like Rust's slice only conceptually. Due to the lack of\n ABI guarantees, you should still decompose spans/slices to raw pointer\n and length parts when crossing the FFI. The Elements() and data() methods\n are guaranteed to return a non-null pointer even for zero-length spans,\n so the pointer can be used as a raw part of a Rust slice without further\n checks.)\n\n In addition to having constructors (with the support of deduction guides)\n that take various well-known types, a Span for an arbitrary type can be\n constructed from a pointer and a length or a pointer and another pointer\n pointing just past the last element.\n\n A Span<const char> or Span<const char16_t> can be obtained for const char*\n or const char16_t pointing to a zero-terminated string using the\n MakeStringSpan() function (which treats a nullptr argument equivalently\n to the empty string). Corresponding implicit constructor does not exist\n in order to avoid accidental construction in cases where const char* or\n const char16_t* do not point to a zero-terminated string.\n\n Span has methods that follow the Mozilla naming style and methods that\n don't. The methods that follow the Mozilla naming style are meant to be\n used directly from Mozilla code. The methods that don't are meant for\n integration with C++11 range-based loops and with meta-programming that\n expects the same methods that are found on the standard-library\n containers. For example, to decompose a Span into its parts in Mozilla\n code, use Elements() and Length() (as with nsTArray) instead of data()\n and size() (as with std::vector).\n\n The pointer and length wrapped by a Span cannot be changed after a Span has\n been created. When new values are required, simply create a new Span. Span\n has a method called Subspan() that works analogously to the Substring()\n method of XPCOM strings taking a start index and an optional length. As a\n Mozilla extension (relative to Microsoft's gsl::span that mozilla::Span is\n based on), Span has methods From(start), To(end) and FromTo(start, end)\n that correspond to Rust's &slice[start..], &slice[..end] and\n &slice[start..end], respectively. (That is, the end index is the index of\n the first element not to be included in the new subspan.)\n\n When indicating a Span that's only read from, const goes inside the type\n parameter. Don't put const in front of Span. That is:\n size_t ReadsFromOneSpanAndWritesToAnother(Span<const uint8_t> aReadFrom,\n                                           Span<uint8_t> aWrittenTo);\n\n Any Span<const T> can be viewed as Span<const uint8_t> using the function\n AsBytes(). Any Span<T> can be viewed as Span<uint8_t> using the function\n AsWritableBytes().\n\n Note that iterators from different Span instances are uncomparable, even if\n they refer to the same memory. This also applies to any spans derived via\n Subspan etc."]
        pub type ProfileBufferEntryReader_SpanOfConstBytes =
            root::__BindgenOpaqueArray<u64, 2usize>;
        pub type ProfileBufferEntryReader_difference_type = u32;
        pub type ProfileBufferEntryReader_value_type = root::mozilla::ProfileBufferEntryReader_Byte;
        pub type ProfileBufferEntryReader_pointer =
            *const root::mozilla::ProfileBufferEntryReader_Byte;
        pub type ProfileBufferEntryReader_reference =
            *const root::mozilla::ProfileBufferEntryReader_Byte;
        pub type ProfileBufferEntryReader_iterator_category = root::std::input_iterator_tag;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferEntryReader_DoubleSpanOfConstBytes {
            pub mFirstOrOnly: root::mozilla::ProfileBufferEntryReader_SpanOfConstBytes,
            pub mSecondOrEmpty: root::mozilla::ProfileBufferEntryReader_SpanOfConstBytes,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferEntryReader_DoubleSpanOfConstBytes"][::std::mem::size_of::<
                ProfileBufferEntryReader_DoubleSpanOfConstBytes,
            >() - 32usize];
            ["Alignment of ProfileBufferEntryReader_DoubleSpanOfConstBytes"][::std::mem::align_of::<
                ProfileBufferEntryReader_DoubleSpanOfConstBytes,
            >() - 8usize];
            ["Offset of field: ProfileBufferEntryReader_DoubleSpanOfConstBytes::mFirstOrOnly"][::std::mem::offset_of!(
                ProfileBufferEntryReader_DoubleSpanOfConstBytes,
                mFirstOrOnly
            )
                - 0usize];
            ["Offset of field: ProfileBufferEntryReader_DoubleSpanOfConstBytes::mSecondOrEmpty"][::std::mem::offset_of!(
                ProfileBufferEntryReader_DoubleSpanOfConstBytes,
                mSecondOrEmpty
            )
                - 16usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferEntryReader"]
                [::std::mem::size_of::<ProfileBufferEntryReader>() - 48usize];
            ["Alignment of ProfileBufferEntryReader"]
                [::std::mem::align_of::<ProfileBufferEntryReader>() - 8usize];
            ["Offset of field: ProfileBufferEntryReader::mCurrentSpan"]
                [::std::mem::offset_of!(ProfileBufferEntryReader, mCurrentSpan) - 0usize];
            ["Offset of field: ProfileBufferEntryReader::mNextSpanOrEmpty"]
                [::std::mem::offset_of!(ProfileBufferEntryReader, mNextSpanOrEmpty) - 16usize];
            ["Offset of field: ProfileBufferEntryReader::mCurrentBlockIndex"]
                [::std::mem::offset_of!(ProfileBufferEntryReader, mCurrentBlockIndex) - 32usize];
            ["Offset of field: ProfileBufferEntryReader::mNextBlockIndex"]
                [::std::mem::offset_of!(ProfileBufferEntryReader, mNextBlockIndex) - 40usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferEntryWriter {
            pub mCurrentSpan: root::mozilla::ProfileBufferEntryWriter_SpanOfBytes,
            pub mNextSpanOrEmpty: root::mozilla::ProfileBufferEntryWriter_SpanOfBytes,
            pub mCurrentBlockIndex: root::mozilla::ProfileBufferBlockIndex,
            pub mNextBlockIndex: root::mozilla::ProfileBufferBlockIndex,
        }
        pub type ProfileBufferEntryWriter_Byte = u8;
        pub type ProfileBufferEntryWriter_Length = u32;
        #[doc = " Span - slices for C++\n\n Span implements Rust's slice concept for C++. It's called \"Span\" instead of\n \"Slice\" to follow the naming used in C++ Core Guidelines.\n\n A Span wraps a pointer and a length that identify a non-owning view to a\n contiguous block of memory of objects of the same type. Various types,\n including (pre-decay) C arrays, XPCOM strings, nsTArray, mozilla::Array,\n mozilla::Range and contiguous standard-library containers, auto-convert\n into Spans when attempting to pass them as arguments to methods that take\n Spans. (Span itself autoconverts into mozilla::Range.)\n\n Like Rust's slices, Span provides safety against out-of-bounds access by\n performing run-time bound checks. However, unlike Rust's slices, Span\n cannot provide safety against use-after-free.\n\n (Note: Span is like Rust's slice only conceptually. Due to the lack of\n ABI guarantees, you should still decompose spans/slices to raw pointer\n and length parts when crossing the FFI. The Elements() and data() methods\n are guaranteed to return a non-null pointer even for zero-length spans,\n so the pointer can be used as a raw part of a Rust slice without further\n checks.)\n\n In addition to having constructors (with the support of deduction guides)\n that take various well-known types, a Span for an arbitrary type can be\n constructed from a pointer and a length or a pointer and another pointer\n pointing just past the last element.\n\n A Span<const char> or Span<const char16_t> can be obtained for const char*\n or const char16_t pointing to a zero-terminated string using the\n MakeStringSpan() function (which treats a nullptr argument equivalently\n to the empty string). Corresponding implicit constructor does not exist\n in order to avoid accidental construction in cases where const char* or\n const char16_t* do not point to a zero-terminated string.\n\n Span has methods that follow the Mozilla naming style and methods that\n don't. The methods that follow the Mozilla naming style are meant to be\n used directly from Mozilla code. The methods that don't are meant for\n integration with C++11 range-based loops and with meta-programming that\n expects the same methods that are found on the standard-library\n containers. For example, to decompose a Span into its parts in Mozilla\n code, use Elements() and Length() (as with nsTArray) instead of data()\n and size() (as with std::vector).\n\n The pointer and length wrapped by a Span cannot be changed after a Span has\n been created. When new values are required, simply create a new Span. Span\n has a method called Subspan() that works analogously to the Substring()\n method of XPCOM strings taking a start index and an optional length. As a\n Mozilla extension (relative to Microsoft's gsl::span that mozilla::Span is\n based on), Span has methods From(start), To(end) and FromTo(start, end)\n that correspond to Rust's &slice[start..], &slice[..end] and\n &slice[start..end], respectively. (That is, the end index is the index of\n the first element not to be included in the new subspan.)\n\n When indicating a Span that's only read from, const goes inside the type\n parameter. Don't put const in front of Span. That is:\n size_t ReadsFromOneSpanAndWritesToAnother(Span<const uint8_t> aReadFrom,\n                                           Span<uint8_t> aWrittenTo);\n\n Any Span<const T> can be viewed as Span<const uint8_t> using the function\n AsBytes(). Any Span<T> can be viewed as Span<uint8_t> using the function\n AsWritableBytes().\n\n Note that iterators from different Span instances are uncomparable, even if\n they refer to the same memory. This also applies to any spans derived via\n Subspan etc."]
        pub type ProfileBufferEntryWriter_SpanOfBytes = root::__BindgenOpaqueArray<u64, 2usize>;
        pub type ProfileBufferEntryWriter_value_type = root::mozilla::ProfileBufferEntryWriter_Byte;
        pub type ProfileBufferEntryWriter_pointer =
            *mut root::mozilla::ProfileBufferEntryWriter_Byte;
        pub type ProfileBufferEntryWriter_reference =
            *mut root::mozilla::ProfileBufferEntryWriter_Byte;
        pub type ProfileBufferEntryWriter_iterator_category = root::std::output_iterator_tag;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferEntryWriter"]
                [::std::mem::size_of::<ProfileBufferEntryWriter>() - 48usize];
            ["Alignment of ProfileBufferEntryWriter"]
                [::std::mem::align_of::<ProfileBufferEntryWriter>() - 8usize];
            ["Offset of field: ProfileBufferEntryWriter::mCurrentSpan"]
                [::std::mem::offset_of!(ProfileBufferEntryWriter, mCurrentSpan) - 0usize];
            ["Offset of field: ProfileBufferEntryWriter::mNextSpanOrEmpty"]
                [::std::mem::offset_of!(ProfileBufferEntryWriter, mNextSpanOrEmpty) - 16usize];
            ["Offset of field: ProfileBufferEntryWriter::mCurrentBlockIndex"]
                [::std::mem::offset_of!(ProfileBufferEntryWriter, mCurrentBlockIndex) - 32usize];
            ["Offset of field: ProfileBufferEntryWriter::mNextBlockIndex"]
                [::std::mem::offset_of!(ProfileBufferEntryWriter, mNextBlockIndex) - 40usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileBufferEntryWriter_Serializer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileBufferEntryReader_Deserializer {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryWriter_Serializer_open0_ProfileBufferBlockIndex_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryWriter_Serializer_open0_ProfileBufferBlockIndex_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryReader_Deserializer_open0_ProfileBufferBlockIndex_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryReader_Deserializer_open0_ProfileBufferBlockIndex_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileBufferUnownedCString {
            pub mCString: *const ::std::os::raw::c_char,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferUnownedCString"]
                [::std::mem::size_of::<ProfileBufferUnownedCString>() - 8usize];
            ["Alignment of ProfileBufferUnownedCString"]
                [::std::mem::align_of::<ProfileBufferUnownedCString>() - 8usize];
            ["Offset of field: ProfileBufferUnownedCString::mCString"]
                [::std::mem::offset_of!(ProfileBufferUnownedCString, mCString) - 0usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryWriter_Serializer_open0_ProfileBufferUnownedCString_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryWriter_Serializer_open0_ProfileBufferUnownedCString_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileBufferRawPointer<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mRawPointer: *mut T,
        }
        pub mod baseprofiler {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct ChunkedJSONWriteFunc {
                pub _base: root::mozilla::JSONWriteFunc,
                pub _base_1: root::mozilla::FailureLatch,
                pub mChunkPtr: *mut ::std::os::raw::c_char,
                pub mChunkEnd: *mut ::std::os::raw::c_char,
                pub mChunkList: root::__BindgenOpaqueArray<u64, 3usize>,
                pub mChunkLengths: root::__BindgenOpaqueArray<u64, 3usize>,
                pub mFailureLatch: u64,
            }
            pub const ChunkedJSONWriteFunc_kChunkSize: usize = 2097152;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ChunkedJSONWriteFunc"]
                    [::std::mem::size_of::<ChunkedJSONWriteFunc>() - 88usize];
                ["Alignment of ChunkedJSONWriteFunc"]
                    [::std::mem::align_of::<ChunkedJSONWriteFunc>() - 8usize];
                ["Offset of field: ChunkedJSONWriteFunc::mChunkPtr"]
                    [::std::mem::offset_of!(ChunkedJSONWriteFunc, mChunkPtr) - 16usize];
                ["Offset of field: ChunkedJSONWriteFunc::mChunkEnd"]
                    [::std::mem::offset_of!(ChunkedJSONWriteFunc, mChunkEnd) - 24usize];
                ["Offset of field: ChunkedJSONWriteFunc::mChunkList"]
                    [::std::mem::offset_of!(ChunkedJSONWriteFunc, mChunkList) - 32usize];
                ["Offset of field: ChunkedJSONWriteFunc::mChunkLengths"]
                    [::std::mem::offset_of!(ChunkedJSONWriteFunc, mChunkLengths) - 56usize];
                ["Offset of field: ChunkedJSONWriteFunc::mFailureLatch"]
                    [::std::mem::offset_of!(ChunkedJSONWriteFunc, mFailureLatch) - 80usize];
            };
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct OStreamJSONWriteFunc {
                pub _base: root::mozilla::JSONWriteFunc,
                pub mStream: *mut root::std::ostream,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of OStreamJSONWriteFunc"]
                    [::std::mem::size_of::<OStreamJSONWriteFunc>() - 16usize];
                ["Alignment of OStreamJSONWriteFunc"]
                    [::std::mem::align_of::<OStreamJSONWriteFunc>() - 8usize];
                ["Offset of field: OStreamJSONWriteFunc::mStream"]
                    [::std::mem::offset_of!(OStreamJSONWriteFunc, mStream) - 8usize];
            };
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct SpliceableJSONWriter {
                pub _base: root::mozilla::JSONWriter,
                pub _base_1: root::mozilla::FailureLatch,
                pub mFailureLatch: u64,
                pub mUniqueStrings: *mut root::mozilla::baseprofiler::UniqueJSONStrings,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of SpliceableJSONWriter"]
                    [::std::mem::size_of::<SpliceableJSONWriter>() - 112usize];
                ["Alignment of SpliceableJSONWriter"]
                    [::std::mem::align_of::<SpliceableJSONWriter>() - 8usize];
                ["Offset of field: SpliceableJSONWriter::mFailureLatch"]
                    [::std::mem::offset_of!(SpliceableJSONWriter, mFailureLatch) - 96usize];
                ["Offset of field: SpliceableJSONWriter::mUniqueStrings"]
                    [::std::mem::offset_of!(SpliceableJSONWriter, mUniqueStrings) - 104usize];
            };
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct SpliceableChunkedJSONWriter {
                pub _base: root::mozilla::baseprofiler::SpliceableJSONWriter,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of SpliceableChunkedJSONWriter"]
                    [::std::mem::size_of::<SpliceableChunkedJSONWriter>() - 112usize];
                ["Alignment of SpliceableChunkedJSONWriter"]
                    [::std::mem::align_of::<SpliceableChunkedJSONWriter>() - 8usize];
            };
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct JSONSchemaWriter {
                pub mWriter: *mut root::mozilla::JSONWriter,
                pub mIndex: u32,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of JSONSchemaWriter"][::std::mem::size_of::<JSONSchemaWriter>() - 16usize];
                ["Alignment of JSONSchemaWriter"]
                    [::std::mem::align_of::<JSONSchemaWriter>() - 8usize];
                ["Offset of field: JSONSchemaWriter::mWriter"]
                    [::std::mem::offset_of!(JSONSchemaWriter, mWriter) - 0usize];
                ["Offset of field: JSONSchemaWriter::mIndex"]
                    [::std::mem::offset_of!(JSONSchemaWriter, mIndex) - 8usize];
            };
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct UniqueJSONStrings {
                pub _base: root::mozilla::FailureLatch,
                pub mStringTableWriter: root::mozilla::baseprofiler::SpliceableChunkedJSONWriter,
                pub mStringHashToIndexMap: root::__BindgenOpaqueArray<u64, 3usize>,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of UniqueJSONStrings"]
                    [::std::mem::size_of::<UniqueJSONStrings>() - 144usize];
                ["Alignment of UniqueJSONStrings"]
                    [::std::mem::align_of::<UniqueJSONStrings>() - 8usize];
                ["Offset of field: UniqueJSONStrings::mStringTableWriter"]
                    [::std::mem::offset_of!(UniqueJSONStrings, mStringTableWriter) - 8usize];
                ["Offset of field: UniqueJSONStrings::mStringHashToIndexMap"]
                    [::std::mem::offset_of!(UniqueJSONStrings, mStringHashToIndexMap) - 120usize];
            };
            impl root::mozilla::baseprofiler::ProfilingCategoryPair {
                pub const LAST: root::mozilla::baseprofiler::ProfilingCategoryPair =
                    ProfilingCategoryPair::TELEMETRY;
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ProfilingCategoryPair {
                IDLE = 0,
                OTHER = 1,
                OTHER_PreferenceRead = 2,
                OTHER_Profiling = 3,
                TEST = 4,
                LAYOUT = 5,
                LAYOUT_FrameConstruction = 6,
                LAYOUT_Reflow = 7,
                LAYOUT_CSSParsing = 8,
                LAYOUT_SelectorQuery = 9,
                LAYOUT_StyleComputation = 10,
                LAYOUT_Destroy = 11,
                LAYOUT_Printing = 12,
                JS = 13,
                JS_Parsing = 14,
                JS_BaselineCompilation = 15,
                JS_IonCompilation = 16,
                JS_Interpreter = 17,
                JS_BaselineInterpret = 18,
                JS_Baseline = 19,
                JS_IonMonkey = 20,
                JS_Builtin = 21,
                JS_WasmIon = 22,
                JS_WasmBaseline = 23,
                JS_WasmOther = 24,
                GCCC = 25,
                GCCC_MinorGC = 26,
                GCCC_MajorGC = 27,
                GCCC_MajorGC_Mark = 28,
                GCCC_MajorGC_Sweep = 29,
                GCCC_MajorGC_Compact = 30,
                GCCC_UnmarkGray = 31,
                GCCC_Barrier = 32,
                GCCC_FreeSnowWhite = 33,
                GCCC_BuildGraph = 34,
                GCCC_ScanRoots = 35,
                GCCC_CollectWhite = 36,
                GCCC_Finalize = 37,
                NETWORK = 38,
                GRAPHICS = 39,
                GRAPHICS_DisplayListBuilding = 40,
                GRAPHICS_DisplayListMerging = 41,
                GRAPHICS_LayerBuilding = 42,
                GRAPHICS_TileAllocation = 43,
                GRAPHICS_WRDisplayList = 44,
                GRAPHICS_Rasterization = 45,
                GRAPHICS_FlushingAsyncPaints = 46,
                GRAPHICS_ImageDecoding = 47,
                DOM = 48,
                JAVA_ANDROID = 49,
                JAVA_ANDROIDX = 50,
                JAVA_LANGUAGE = 51,
                JAVA_MOZILLA = 52,
                JAVA_KOTLIN = 53,
                JAVA_BLOCKED = 54,
                MAILNEWS = 55,
                IPC = 56,
                MEDIA = 57,
                MEDIA_CUBEB = 58,
                MEDIA_PLAYBACK = 59,
                MEDIA_RT = 60,
                A11Y = 61,
                PROFILER = 62,
                TIMER = 63,
                REMOTE_PROTOCOL = 64,
                SANDBOX = 65,
                TELEMETRY = 66,
                COUNT = 67,
            }
            impl root::mozilla::baseprofiler::ProfilingCategory {
                pub const LAST: root::mozilla::baseprofiler::ProfilingCategory =
                    ProfilingCategory::TELEMETRY;
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ProfilingCategory {
                IDLE = 0,
                OTHER = 1,
                TEST = 2,
                LAYOUT = 3,
                JS = 4,
                GCCC = 5,
                NETWORK = 6,
                GRAPHICS = 7,
                DOM = 8,
                JAVA_ANDROID = 9,
                JAVA_ANDROIDX = 10,
                JAVA_LANGUAGE = 11,
                JAVA_MOZILLA = 12,
                JAVA_KOTLIN = 13,
                JAVA_BLOCKED = 14,
                MAILNEWS = 15,
                IPC = 16,
                MEDIA = 17,
                A11Y = 18,
                PROFILER = 19,
                TIMER = 20,
                REMOTE_PROTOCOL = 21,
                SANDBOX = 22,
                TELEMETRY = 23,
                COUNT = 24,
            }
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct ProfilingCategoryInfo {
                pub mName: *const ::std::os::raw::c_char,
                pub mColor: *const ::std::os::raw::c_char,
                pub mSubcategoryNames: root::__BindgenOpaqueArray<u64, 2usize>,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ProfilingCategoryInfo"]
                    [::std::mem::size_of::<ProfilingCategoryInfo>() - 32usize];
                ["Alignment of ProfilingCategoryInfo"]
                    [::std::mem::align_of::<ProfilingCategoryInfo>() - 8usize];
                ["Offset of field: ProfilingCategoryInfo::mName"]
                    [::std::mem::offset_of!(ProfilingCategoryInfo, mName) - 0usize];
                ["Offset of field: ProfilingCategoryInfo::mColor"]
                    [::std::mem::offset_of!(ProfilingCategoryInfo, mColor) - 8usize];
                ["Offset of field: ProfilingCategoryInfo::mSubcategoryNames"]
                    [::std::mem::offset_of!(ProfilingCategoryInfo, mSubcategoryNames) - 16usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProfilingCategoryPairInfo {
                pub mCategory: root::mozilla::baseprofiler::ProfilingCategory,
                pub mSubcategoryIndex: u32,
                pub mLabel: *const ::std::os::raw::c_char,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ProfilingCategoryPairInfo"]
                    [::std::mem::size_of::<ProfilingCategoryPairInfo>() - 16usize];
                ["Alignment of ProfilingCategoryPairInfo"]
                    [::std::mem::align_of::<ProfilingCategoryPairInfo>() - 8usize];
                ["Offset of field: ProfilingCategoryPairInfo::mCategory"]
                    [::std::mem::offset_of!(ProfilingCategoryPairInfo, mCategory) - 0usize];
                ["Offset of field: ProfilingCategoryPairInfo::mSubcategoryIndex"]
                    [::std::mem::offset_of!(ProfilingCategoryPairInfo, mSubcategoryIndex) - 4usize];
                ["Offset of field: ProfilingCategoryPairInfo::mLabel"]
                    [::std::mem::offset_of!(ProfilingCategoryPairInfo, mLabel) - 8usize];
            };
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub type ProcessIdType = ::std::os::raw::c_int;
                pub type ThreadIdType = ::std::os::raw::c_long;
                #[repr(C)]
                #[derive(Debug, PartialEq)]
                pub struct BaseProfilerMutex {
                    pub _base: root::mozilla::detail::MutexImpl,
                    pub mOwningThreadId: u64,
                    pub mName: *const ::std::os::raw::c_char,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of BaseProfilerMutex"]
                        [::std::mem::size_of::<BaseProfilerMutex>() - 56usize];
                    ["Alignment of BaseProfilerMutex"]
                        [::std::mem::align_of::<BaseProfilerMutex>() - 8usize];
                    ["Offset of field: BaseProfilerMutex::mOwningThreadId"]
                        [::std::mem::offset_of!(BaseProfilerMutex, mOwningThreadId) - 40usize];
                    ["Offset of field: BaseProfilerMutex::mName"]
                        [::std::mem::offset_of!(BaseProfilerMutex, mName) - 48usize];
                };
                #[repr(C)]
                #[derive(Debug, PartialEq)]
                pub struct BaseProfilerAutoLock {
                    pub mMutex: *mut root::mozilla::baseprofiler::detail::BaseProfilerMutex,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of BaseProfilerAutoLock"]
                        [::std::mem::size_of::<BaseProfilerAutoLock>() - 8usize];
                    ["Alignment of BaseProfilerAutoLock"]
                        [::std::mem::align_of::<BaseProfilerAutoLock>() - 8usize];
                    ["Offset of field: BaseProfilerAutoLock::mMutex"]
                        [::std::mem::offset_of!(BaseProfilerAutoLock, mMutex) - 0usize];
                };
                #[repr(C)]
                #[derive(Debug, PartialEq)]
                pub struct BaseProfilerMaybeMutex {
                    pub _base: root::mozilla::detail::MutexImpl,
                    pub mMaybeMutex: root::__BindgenOpaqueArray<u64, 8usize>,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of BaseProfilerMaybeMutex"]
                        [::std::mem::size_of::<BaseProfilerMaybeMutex>() - 104usize];
                    ["Alignment of BaseProfilerMaybeMutex"]
                        [::std::mem::align_of::<BaseProfilerMaybeMutex>() - 8usize];
                    ["Offset of field: BaseProfilerMaybeMutex::mMaybeMutex"]
                        [::std::mem::offset_of!(BaseProfilerMaybeMutex, mMaybeMutex) - 40usize];
                };
                #[repr(C)]
                #[derive(Debug, PartialEq)]
                pub struct BaseProfilerMaybeAutoLock {
                    pub mMaybeMutex:
                        *mut root::mozilla::baseprofiler::detail::BaseProfilerMaybeMutex,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of BaseProfilerMaybeAutoLock"]
                        [::std::mem::size_of::<BaseProfilerMaybeAutoLock>() - 8usize];
                    ["Alignment of BaseProfilerMaybeAutoLock"]
                        [::std::mem::align_of::<BaseProfilerMaybeAutoLock>() - 8usize];
                    ["Offset of field: BaseProfilerMaybeAutoLock::mMaybeMutex"]
                        [::std::mem::offset_of!(BaseProfilerMaybeAutoLock, mMaybeMutex) - 0usize];
                };
                #[repr(C)]
                pub struct BaseProfilerSharedMutex {
                    pub _base: root::mozilla::detail::RWLockImpl,
                    pub mOwningThreadId: u64,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of BaseProfilerSharedMutex"]
                        [::std::mem::size_of::<BaseProfilerSharedMutex>() - 64usize];
                    ["Alignment of BaseProfilerSharedMutex"]
                        [::std::mem::align_of::<BaseProfilerSharedMutex>() - 8usize];
                    ["Offset of field: BaseProfilerSharedMutex::mOwningThreadId"][::std::mem::offset_of!(
                        BaseProfilerSharedMutex,
                        mOwningThreadId
                    ) - 56usize];
                };
                #[repr(C)]
                #[derive(Debug, PartialEq)]
                pub struct BaseProfilerAutoLockExclusive {
                    pub mSharedMutex:
                        *mut root::mozilla::baseprofiler::detail::BaseProfilerSharedMutex,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of BaseProfilerAutoLockExclusive"]
                        [::std::mem::size_of::<BaseProfilerAutoLockExclusive>() - 8usize];
                    ["Alignment of BaseProfilerAutoLockExclusive"]
                        [::std::mem::align_of::<BaseProfilerAutoLockExclusive>() - 8usize];
                    ["Offset of field: BaseProfilerAutoLockExclusive::mSharedMutex"][::std::mem::offset_of!(
                        BaseProfilerAutoLockExclusive,
                        mSharedMutex
                    ) - 0usize];
                };
                #[repr(C)]
                #[derive(Debug, PartialEq)]
                pub struct BaseProfilerAutoLockShared {
                    pub mSharedMutex:
                        *mut root::mozilla::baseprofiler::detail::BaseProfilerSharedMutex,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of BaseProfilerAutoLockShared"]
                        [::std::mem::size_of::<BaseProfilerAutoLockShared>() - 8usize];
                    ["Alignment of BaseProfilerAutoLockShared"]
                        [::std::mem::align_of::<BaseProfilerAutoLockShared>() - 8usize];
                    ["Offset of field: BaseProfilerAutoLockShared::mSharedMutex"]
                        [::std::mem::offset_of!(BaseProfilerAutoLockShared, mSharedMutex) - 0usize];
                };
            }
            #[repr(C)]
            #[repr(align(4))]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BaseProfilerProcessId {
                pub _bindgen_opaque_blob: u32,
            }
            pub type BaseProfilerProcessId_NativeType =
                root::mozilla::baseprofiler::detail::ProcessIdType;
            pub type BaseProfilerProcessId_NumberType = root::std::conditional_t;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of BaseProfilerProcessId"]
                    [::std::mem::size_of::<BaseProfilerProcessId>() - 4usize];
                ["Alignment of BaseProfilerProcessId"]
                    [::std::mem::align_of::<BaseProfilerProcessId>() - 4usize];
            };
            extern "C" {
                #[link_name = "\u{1}_ZN7mozilla12baseprofiler21BaseProfilerProcessId13scUnspecifiedE"]
                pub static BaseProfilerProcessId_scUnspecified:
                    root::mozilla::baseprofiler::BaseProfilerProcessId_NumberType;
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BaseProfilerThreadId {
                pub _bindgen_opaque_blob: u64,
            }
            pub type BaseProfilerThreadId_NativeType =
                root::mozilla::baseprofiler::detail::ThreadIdType;
            pub type BaseProfilerThreadId_NumberType = root::std::conditional_t;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of BaseProfilerThreadId"]
                    [::std::mem::size_of::<BaseProfilerThreadId>() - 8usize];
                ["Alignment of BaseProfilerThreadId"]
                    [::std::mem::align_of::<BaseProfilerThreadId>() - 8usize];
            };
            extern "C" {
                #[link_name = "\u{1}_ZN7mozilla12baseprofiler20BaseProfilerThreadId13scUnspecifiedE"]
                pub static BaseProfilerThreadId_scUnspecified:
                    root::mozilla::baseprofiler::BaseProfilerThreadId_NumberType;
            }
            pub mod category {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub type MarkerCategory = root::mozilla::MarkerCategory;
            }
            pub mod markers {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone, PartialEq)]
                pub struct NoPayload {
                    pub _address: u8,
                }
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of NoPayload"][::std::mem::size_of::<NoPayload>() - 1usize];
                    ["Alignment of NoPayload"][::std::mem::align_of::<NoPayload>() - 1usize];
                };
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferChunk {
            pub mInternalHeader: root::mozilla::ProfileBufferChunk_InternalHeader,
            pub mBuffer: root::mozilla::ProfileBufferChunk_Byte,
        }
        pub type ProfileBufferChunk_Byte = u8;
        pub type ProfileBufferChunk_Length = u32;
        #[doc = " Span - slices for C++\n\n Span implements Rust's slice concept for C++. It's called \"Span\" instead of\n \"Slice\" to follow the naming used in C++ Core Guidelines.\n\n A Span wraps a pointer and a length that identify a non-owning view to a\n contiguous block of memory of objects of the same type. Various types,\n including (pre-decay) C arrays, XPCOM strings, nsTArray, mozilla::Array,\n mozilla::Range and contiguous standard-library containers, auto-convert\n into Spans when attempting to pass them as arguments to methods that take\n Spans. (Span itself autoconverts into mozilla::Range.)\n\n Like Rust's slices, Span provides safety against out-of-bounds access by\n performing run-time bound checks. However, unlike Rust's slices, Span\n cannot provide safety against use-after-free.\n\n (Note: Span is like Rust's slice only conceptually. Due to the lack of\n ABI guarantees, you should still decompose spans/slices to raw pointer\n and length parts when crossing the FFI. The Elements() and data() methods\n are guaranteed to return a non-null pointer even for zero-length spans,\n so the pointer can be used as a raw part of a Rust slice without further\n checks.)\n\n In addition to having constructors (with the support of deduction guides)\n that take various well-known types, a Span for an arbitrary type can be\n constructed from a pointer and a length or a pointer and another pointer\n pointing just past the last element.\n\n A Span<const char> or Span<const char16_t> can be obtained for const char*\n or const char16_t pointing to a zero-terminated string using the\n MakeStringSpan() function (which treats a nullptr argument equivalently\n to the empty string). Corresponding implicit constructor does not exist\n in order to avoid accidental construction in cases where const char* or\n const char16_t* do not point to a zero-terminated string.\n\n Span has methods that follow the Mozilla naming style and methods that\n don't. The methods that follow the Mozilla naming style are meant to be\n used directly from Mozilla code. The methods that don't are meant for\n integration with C++11 range-based loops and with meta-programming that\n expects the same methods that are found on the standard-library\n containers. For example, to decompose a Span into its parts in Mozilla\n code, use Elements() and Length() (as with nsTArray) instead of data()\n and size() (as with std::vector).\n\n The pointer and length wrapped by a Span cannot be changed after a Span has\n been created. When new values are required, simply create a new Span. Span\n has a method called Subspan() that works analogously to the Substring()\n method of XPCOM strings taking a start index and an optional length. As a\n Mozilla extension (relative to Microsoft's gsl::span that mozilla::Span is\n based on), Span has methods From(start), To(end) and FromTo(start, end)\n that correspond to Rust's &slice[start..], &slice[..end] and\n &slice[start..end], respectively. (That is, the end index is the index of\n the first element not to be included in the new subspan.)\n\n When indicating a Span that's only read from, const goes inside the type\n parameter. Don't put const in front of Span. That is:\n size_t ReadsFromOneSpanAndWritesToAnother(Span<const uint8_t> aReadFrom,\n                                           Span<uint8_t> aWrittenTo);\n\n Any Span<const T> can be viewed as Span<const uint8_t> using the function\n AsBytes(). Any Span<T> can be viewed as Span<uint8_t> using the function\n AsWritableBytes().\n\n Note that iterators from different Span instances are uncomparable, even if\n they refer to the same memory. This also applies to any spans derived via\n Subspan etc."]
        pub type ProfileBufferChunk_SpanOfBytes = root::__BindgenOpaqueArray<u64, 2usize>;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferChunk_ReserveReturn {
            pub mSpan: root::mozilla::ProfileBufferChunk_SpanOfBytes,
            pub mBlockRangeIndex: root::mozilla::ProfileBufferBlockIndex,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferChunk_ReserveReturn"]
                [::std::mem::size_of::<ProfileBufferChunk_ReserveReturn>() - 24usize];
            ["Alignment of ProfileBufferChunk_ReserveReturn"]
                [::std::mem::align_of::<ProfileBufferChunk_ReserveReturn>() - 8usize];
            ["Offset of field: ProfileBufferChunk_ReserveReturn::mSpan"]
                [::std::mem::offset_of!(ProfileBufferChunk_ReserveReturn, mSpan) - 0usize];
            ["Offset of field: ProfileBufferChunk_ReserveReturn::mBlockRangeIndex"][::std::mem::offset_of!(
                ProfileBufferChunk_ReserveReturn,
                mBlockRangeIndex
            ) - 16usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileBufferChunk_Header {
            pub mOffsetFirstBlock: root::mozilla::ProfileBufferChunk_Length,
            pub mOffsetPastLastBlock: root::mozilla::ProfileBufferChunk_Length,
            pub mStartTimeStamp: root::mozilla::TimeStamp,
            pub mDoneTimeStamp: root::mozilla::TimeStamp,
            pub mBufferBytes: root::mozilla::ProfileBufferChunk_Length,
            pub mBlockCount: root::mozilla::ProfileBufferChunk_Length,
            pub mRangeStart: root::mozilla::ProfileBufferIndex,
            pub mProcessId: ::std::os::raw::c_int,
            pub mPADDING: ::std::os::raw::c_int,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferChunk_Header"]
                [::std::mem::size_of::<ProfileBufferChunk_Header>() - 48usize];
            ["Alignment of ProfileBufferChunk_Header"]
                [::std::mem::align_of::<ProfileBufferChunk_Header>() - 8usize];
            ["Offset of field: ProfileBufferChunk_Header::mOffsetFirstBlock"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mOffsetFirstBlock) - 0usize];
            ["Offset of field: ProfileBufferChunk_Header::mOffsetPastLastBlock"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mOffsetPastLastBlock) - 4usize];
            ["Offset of field: ProfileBufferChunk_Header::mStartTimeStamp"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mStartTimeStamp) - 8usize];
            ["Offset of field: ProfileBufferChunk_Header::mDoneTimeStamp"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mDoneTimeStamp) - 16usize];
            ["Offset of field: ProfileBufferChunk_Header::mBufferBytes"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mBufferBytes) - 24usize];
            ["Offset of field: ProfileBufferChunk_Header::mBlockCount"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mBlockCount) - 28usize];
            ["Offset of field: ProfileBufferChunk_Header::mRangeStart"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mRangeStart) - 32usize];
            ["Offset of field: ProfileBufferChunk_Header::mProcessId"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mProcessId) - 40usize];
            ["Offset of field: ProfileBufferChunk_Header::mPADDING"]
                [::std::mem::offset_of!(ProfileBufferChunk_Header, mPADDING) - 44usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferChunk_InternalHeader {
            pub mHeader: root::mozilla::ProfileBufferChunk_Header,
            pub mNext: u64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferChunk_InternalHeader"]
                [::std::mem::size_of::<ProfileBufferChunk_InternalHeader>() - 56usize];
            ["Alignment of ProfileBufferChunk_InternalHeader"]
                [::std::mem::align_of::<ProfileBufferChunk_InternalHeader>() - 8usize];
            ["Offset of field: ProfileBufferChunk_InternalHeader::mHeader"]
                [::std::mem::offset_of!(ProfileBufferChunk_InternalHeader, mHeader) - 0usize];
            ["Offset of field: ProfileBufferChunk_InternalHeader::mNext"]
                [::std::mem::offset_of!(ProfileBufferChunk_InternalHeader, mNext) - 48usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferChunk"][::std::mem::size_of::<ProfileBufferChunk>() - 64usize];
            ["Alignment of ProfileBufferChunk"]
                [::std::mem::align_of::<ProfileBufferChunk>() - 8usize];
            ["Offset of field: ProfileBufferChunk::mInternalHeader"]
                [::std::mem::offset_of!(ProfileBufferChunk, mInternalHeader) - 0usize];
            ["Offset of field: ProfileBufferChunk::mBuffer"]
                [::std::mem::offset_of!(ProfileBufferChunk, mBuffer) - 56usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ScopeExit<ExitFunction> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ExitFunction>>,
            pub mExitFunction: ExitFunction,
            pub mExecuteOnDestruction: bool,
        }
        #[repr(C)]
        pub struct ProfileBufferChunkManager__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferChunkManager {
            pub vtable_: *const ProfileBufferChunkManager__bindgen_vtable,
        }
        pub const ProfileBufferChunkManager_scExpectedMaximumStackSize:
            root::mozilla::ProfileBufferChunk_Length = 131072;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferChunkManager"]
                [::std::mem::size_of::<ProfileBufferChunkManager>() - 8usize];
            ["Alignment of ProfileBufferChunkManager"]
                [::std::mem::align_of::<ProfileBufferChunkManager>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileBufferChunkManagerSingle {
            pub _base: root::mozilla::ProfileBufferChunkManager,
            pub mInitialChunk: u64,
            pub mReleasedChunk: u64,
            pub mBufferBytes: root::mozilla::ProfileBufferChunkManagerSingle_Length,
            pub mChunkDestroyedCallback: root::__BindgenOpaqueArray<u64, 4usize>,
        }
        pub type ProfileBufferChunkManagerSingle_Length = root::mozilla::ProfileBufferChunk_Length;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileBufferChunkManagerSingle"]
                [::std::mem::size_of::<ProfileBufferChunkManagerSingle>() - 64usize];
            ["Alignment of ProfileBufferChunkManagerSingle"]
                [::std::mem::align_of::<ProfileBufferChunkManagerSingle>() - 8usize];
            ["Offset of field: ProfileBufferChunkManagerSingle::mInitialChunk"]
                [::std::mem::offset_of!(ProfileBufferChunkManagerSingle, mInitialChunk) - 8usize];
            ["Offset of field: ProfileBufferChunkManagerSingle::mReleasedChunk"]
                [::std::mem::offset_of!(ProfileBufferChunkManagerSingle, mReleasedChunk) - 16usize];
            ["Offset of field: ProfileBufferChunkManagerSingle::mBufferBytes"]
                [::std::mem::offset_of!(ProfileBufferChunkManagerSingle, mBufferBytes) - 24usize];
            ["Offset of field: ProfileBufferChunkManagerSingle::mChunkDestroyedCallback"][::std::mem::offset_of!(
                ProfileBufferChunkManagerSingle,
                mChunkDestroyedCallback
            )
                - 32usize];
        };
        pub mod profiler {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone, PartialEq)]
                pub struct InChunkPointer {
                    pub mChunk: *const root::mozilla::ProfileBufferChunk,
                    pub mNextChunkGroup: *const root::mozilla::ProfileBufferChunk,
                    pub mOffsetInChunk: root::mozilla::profiler::detail::InChunkPointer_Length,
                }
                pub type InChunkPointer_Byte = root::mozilla::ProfileBufferChunk_Byte;
                pub type InChunkPointer_Length = root::mozilla::ProfileBufferChunk_Length;
                #[allow(clippy::unnecessary_operation, clippy::identity_op)]
                const _: () = {
                    ["Size of InChunkPointer"][::std::mem::size_of::<InChunkPointer>() - 24usize];
                    ["Alignment of InChunkPointer"]
                        [::std::mem::align_of::<InChunkPointer>() - 8usize];
                    ["Offset of field: InChunkPointer::mChunk"]
                        [::std::mem::offset_of!(InChunkPointer, mChunk) - 0usize];
                    ["Offset of field: InChunkPointer::mNextChunkGroup"]
                        [::std::mem::offset_of!(InChunkPointer, mNextChunkGroup) - 8usize];
                    ["Offset of field: InChunkPointer::mOffsetInChunk"]
                        [::std::mem::offset_of!(InChunkPointer, mOffsetInChunk) - 16usize];
                };
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileChunkedBuffer {
            pub mMutex: root::mozilla::baseprofiler::detail::BaseProfilerMaybeMutex,
            pub mChunkManager: *mut root::mozilla::ProfileBufferChunkManager,
            pub mOwnedChunkManager: u64,
            pub mCurrentChunk: u64,
            pub mNextChunks: u64,
            pub mRequestedChunkHolder:
                root::RefPtr<root::mozilla::ProfileChunkedBuffer_RequestedChunkRefCountedHolder>,
            pub mNextChunkRangeStart: root::mozilla::ProfileBufferIndex,
            pub mRangeStart: u64,
            pub mRangeEnd: root::mozilla::ProfileBufferIndex,
            pub mPushedBlockCount: u64,
            pub mClearedBlockCount: u64,
            pub mFailedPutBytes: u64,
        }
        pub type ProfileChunkedBuffer_Byte = root::mozilla::ProfileBufferChunk_Byte;
        pub type ProfileChunkedBuffer_Length = root::mozilla::ProfileBufferChunk_Length;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfileChunkedBuffer_ThreadSafety {
            WithoutMutex = 0,
            WithMutex = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileChunkedBuffer_State {
            pub mRangeStart: root::mozilla::ProfileBufferIndex,
            pub mRangeEnd: root::mozilla::ProfileBufferIndex,
            pub mPushedBlockCount: u64,
            pub mClearedBlockCount: u64,
            pub mFailedPutBytes: u64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileChunkedBuffer_State"]
                [::std::mem::size_of::<ProfileChunkedBuffer_State>() - 40usize];
            ["Alignment of ProfileChunkedBuffer_State"]
                [::std::mem::align_of::<ProfileChunkedBuffer_State>() - 8usize];
            ["Offset of field: ProfileChunkedBuffer_State::mRangeStart"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_State, mRangeStart) - 0usize];
            ["Offset of field: ProfileChunkedBuffer_State::mRangeEnd"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_State, mRangeEnd) - 8usize];
            ["Offset of field: ProfileChunkedBuffer_State::mPushedBlockCount"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_State, mPushedBlockCount) - 16usize];
            ["Offset of field: ProfileChunkedBuffer_State::mClearedBlockCount"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_State, mClearedBlockCount) - 24usize];
            ["Offset of field: ProfileChunkedBuffer_State::mFailedPutBytes"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_State, mFailedPutBytes) - 32usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileChunkedBuffer_BlockIterator {
            pub mNextBlockPointer: root::mozilla::profiler::detail::InChunkPointer,
            pub mCurrentBlockIndex: root::mozilla::ProfileBufferBlockIndex,
            pub mCurrentEntry: root::mozilla::ProfileBufferEntryReader,
            pub mBuffer: u64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileChunkedBuffer_BlockIterator"]
                [::std::mem::size_of::<ProfileChunkedBuffer_BlockIterator>() - 88usize];
            ["Alignment of ProfileChunkedBuffer_BlockIterator"]
                [::std::mem::align_of::<ProfileChunkedBuffer_BlockIterator>() - 8usize];
            ["Offset of field: ProfileChunkedBuffer_BlockIterator::mNextBlockPointer"][::std::mem::offset_of!(
                ProfileChunkedBuffer_BlockIterator,
                mNextBlockPointer
            ) - 0usize];
            ["Offset of field: ProfileChunkedBuffer_BlockIterator::mCurrentBlockIndex"][::std::mem::offset_of!(
                ProfileChunkedBuffer_BlockIterator,
                mCurrentBlockIndex
            )
                - 24usize];
            ["Offset of field: ProfileChunkedBuffer_BlockIterator::mCurrentEntry"][::std::mem::offset_of!(
                ProfileChunkedBuffer_BlockIterator,
                mCurrentEntry
            ) - 32usize];
            ["Offset of field: ProfileChunkedBuffer_BlockIterator::mBuffer"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_BlockIterator, mBuffer) - 80usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfileChunkedBuffer_Reader {
            pub mBuffer: *const root::mozilla::ProfileChunkedBuffer,
            pub mChunks0: *const root::mozilla::ProfileBufferChunk,
            pub mChunks1: *const root::mozilla::ProfileBufferChunk,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileChunkedBuffer_Reader"]
                [::std::mem::size_of::<ProfileChunkedBuffer_Reader>() - 24usize];
            ["Alignment of ProfileChunkedBuffer_Reader"]
                [::std::mem::align_of::<ProfileChunkedBuffer_Reader>() - 8usize];
            ["Offset of field: ProfileChunkedBuffer_Reader::mBuffer"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_Reader, mBuffer) - 0usize];
            ["Offset of field: ProfileChunkedBuffer_Reader::mChunks0"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_Reader, mChunks0) - 8usize];
            ["Offset of field: ProfileChunkedBuffer_Reader::mChunks1"]
                [::std::mem::offset_of!(ProfileChunkedBuffer_Reader, mChunks1) - 16usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ProfileChunkedBuffer_RequestedChunkRefCountedHolder {
            pub mRequestMutex: root::mozilla::baseprofiler::detail::BaseProfilerMutex,
            pub mRefCount: ::std::os::raw::c_int,
            pub mState: root::mozilla::ProfileChunkedBuffer_RequestedChunkRefCountedHolder_State,
            pub mRequestedChunk: u64,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfileChunkedBuffer_RequestedChunkRefCountedHolder_State {
            Unused = 0,
            Requested = 1,
            Fulfilled = 2,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileChunkedBuffer_RequestedChunkRefCountedHolder"][::std::mem::size_of::<
                ProfileChunkedBuffer_RequestedChunkRefCountedHolder,
            >() - 72usize];
            ["Alignment of ProfileChunkedBuffer_RequestedChunkRefCountedHolder"]
                [::std::mem::align_of::<ProfileChunkedBuffer_RequestedChunkRefCountedHolder>()
                    - 8usize];
            ["Offset of field: ProfileChunkedBuffer_RequestedChunkRefCountedHolder::mRequestMutex"] [:: std :: mem :: offset_of ! (ProfileChunkedBuffer_RequestedChunkRefCountedHolder , mRequestMutex) - 0usize] ;
            ["Offset of field: ProfileChunkedBuffer_RequestedChunkRefCountedHolder::mRefCount"][::std::mem::offset_of!(
                ProfileChunkedBuffer_RequestedChunkRefCountedHolder,
                mRefCount
            )
                - 56usize];
            ["Offset of field: ProfileChunkedBuffer_RequestedChunkRefCountedHolder::mState"][::std::mem::offset_of!(
                ProfileChunkedBuffer_RequestedChunkRefCountedHolder,
                mState
            )
                - 60usize];
            ["Offset of field: ProfileChunkedBuffer_RequestedChunkRefCountedHolder::mRequestedChunk"] [:: std :: mem :: offset_of ! (ProfileChunkedBuffer_RequestedChunkRefCountedHolder , mRequestedChunk) - 64usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfileChunkedBuffer"]
                [::std::mem::size_of::<ProfileChunkedBuffer>() - 192usize];
            ["Alignment of ProfileChunkedBuffer"]
                [::std::mem::align_of::<ProfileChunkedBuffer>() - 8usize];
            ["Offset of field: ProfileChunkedBuffer::mMutex"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mMutex) - 0usize];
            ["Offset of field: ProfileChunkedBuffer::mChunkManager"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mChunkManager) - 104usize];
            ["Offset of field: ProfileChunkedBuffer::mOwnedChunkManager"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mOwnedChunkManager) - 112usize];
            ["Offset of field: ProfileChunkedBuffer::mCurrentChunk"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mCurrentChunk) - 120usize];
            ["Offset of field: ProfileChunkedBuffer::mNextChunks"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mNextChunks) - 128usize];
            ["Offset of field: ProfileChunkedBuffer::mRequestedChunkHolder"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mRequestedChunkHolder) - 136usize];
            ["Offset of field: ProfileChunkedBuffer::mNextChunkRangeStart"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mNextChunkRangeStart) - 144usize];
            ["Offset of field: ProfileChunkedBuffer::mRangeStart"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mRangeStart) - 152usize];
            ["Offset of field: ProfileChunkedBuffer::mRangeEnd"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mRangeEnd) - 160usize];
            ["Offset of field: ProfileChunkedBuffer::mPushedBlockCount"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mPushedBlockCount) - 168usize];
            ["Offset of field: ProfileChunkedBuffer::mClearedBlockCount"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mClearedBlockCount) - 176usize];
            ["Offset of field: ProfileChunkedBuffer::mFailedPutBytes"]
                [::std::mem::offset_of!(ProfileChunkedBuffer, mFailedPutBytes) - 184usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryWriter_Serializer_open0_ProfileChunkedBuffer_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryWriter_Serializer_open0_ProfileChunkedBuffer_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryReader_Deserializer_open0_ProfileChunkedBuffer_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryReader_Deserializer_open0_ProfileChunkedBuffer_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryWriter_Serializer_open0_UniquePtr_open1_ProfileChunkedBuffer_DefaultDelete_open2_ProfileChunkedBuffer_close2_close1_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryWriter_Serializer_open0_UniquePtr_open1_ProfileChunkedBuffer_DefaultDelete_open2_ProfileChunkedBuffer_close2_close1_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryWriter_Serializer_open0_ptr_ProfileChunkedBuffer_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryWriter_Serializer_open0_ptr_ProfileChunkedBuffer_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: ProfileBufferEntryReader_Deserializer_open0_UniquePtr_open1_ProfileChunkedBuffer_DefaultDelete_open2_ProfileChunkedBuffer_close2_close1_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
            ["Align of template specialization: ProfileBufferEntryReader_Deserializer_open0_UniquePtr_open1_ProfileChunkedBuffer_DefaultDelete_open2_ProfileChunkedBuffer_close2_close1_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
        };
        impl root::mozilla::ProfilerStringView_Ownership {
            pub const Reference: root::mozilla::ProfilerStringView_Ownership =
                ProfilerStringView_Ownership::Literal;
        }
        impl root::mozilla::ProfilerStringView_Ownership {
            pub const OwnedThroughStringView: root::mozilla::ProfilerStringView_Ownership =
                ProfilerStringView_Ownership::Literal;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilerStringView_Ownership {
            Literal = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerCategory {
            pub mCategoryPair: root::mozilla::baseprofiler::ProfilingCategoryPair,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerCategory"][::std::mem::size_of::<MarkerCategory>() - 4usize];
            ["Alignment of MarkerCategory"][::std::mem::align_of::<MarkerCategory>() - 4usize];
            ["Offset of field: MarkerCategory::mCategoryPair"]
                [::std::mem::offset_of!(MarkerCategory, mCategoryPair) - 0usize];
        };
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerThreadId {
            pub _bindgen_opaque_blob: u64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerThreadId"][::std::mem::size_of::<MarkerThreadId>() - 8usize];
            ["Alignment of MarkerThreadId"][::std::mem::align_of::<MarkerThreadId>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerTiming {
            pub mStartTime: root::mozilla::TimeStamp,
            pub mEndTime: root::mozilla::TimeStamp,
            pub mPhase: root::mozilla::MarkerTiming_Phase,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerTiming_Phase {
            Instant = 0,
            Interval = 1,
            IntervalStart = 2,
            IntervalEnd = 3,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerTiming"][::std::mem::size_of::<MarkerTiming>() - 24usize];
            ["Alignment of MarkerTiming"][::std::mem::align_of::<MarkerTiming>() - 8usize];
            ["Offset of field: MarkerTiming::mStartTime"]
                [::std::mem::offset_of!(MarkerTiming, mStartTime) - 0usize];
            ["Offset of field: MarkerTiming::mEndTime"]
                [::std::mem::offset_of!(MarkerTiming, mEndTime) - 8usize];
            ["Offset of field: MarkerTiming::mPhase"]
                [::std::mem::offset_of!(MarkerTiming, mPhase) - 16usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct MarkerStack {
            pub mCaptureOptions: root::mozilla::StackCaptureOptions,
            pub mOptionalChunkedBufferStorage: u64,
            pub mChunkedBuffer: *mut root::mozilla::ProfileChunkedBuffer,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerStack"][::std::mem::size_of::<MarkerStack>() - 24usize];
            ["Alignment of MarkerStack"][::std::mem::align_of::<MarkerStack>() - 8usize];
            ["Offset of field: MarkerStack::mCaptureOptions"]
                [::std::mem::offset_of!(MarkerStack, mCaptureOptions) - 0usize];
            ["Offset of field: MarkerStack::mOptionalChunkedBufferStorage"]
                [::std::mem::offset_of!(MarkerStack, mOptionalChunkedBufferStorage) - 8usize];
            ["Offset of field: MarkerStack::mChunkedBuffer"]
                [::std::mem::offset_of!(MarkerStack, mChunkedBuffer) - 16usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerInnerWindowId {
            pub mInnerWindowId: u64,
        }
        pub const MarkerInnerWindowId_scNoId: u64 = 0;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerInnerWindowId"][::std::mem::size_of::<MarkerInnerWindowId>() - 8usize];
            ["Alignment of MarkerInnerWindowId"]
                [::std::mem::align_of::<MarkerInnerWindowId>() - 8usize];
            ["Offset of field: MarkerInnerWindowId::mInnerWindowId"]
                [::std::mem::offset_of!(MarkerInnerWindowId, mInnerWindowId) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct MarkerOptions {
            pub mThreadId: root::mozilla::MarkerThreadId,
            pub mTiming: root::mozilla::MarkerTiming,
            pub mStack: root::mozilla::MarkerStack,
            pub mInnerWindowId: root::mozilla::MarkerInnerWindowId,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerOptions"][::std::mem::size_of::<MarkerOptions>() - 64usize];
            ["Alignment of MarkerOptions"][::std::mem::align_of::<MarkerOptions>() - 8usize];
            ["Offset of field: MarkerOptions::mThreadId"]
                [::std::mem::offset_of!(MarkerOptions, mThreadId) - 0usize];
            ["Offset of field: MarkerOptions::mTiming"]
                [::std::mem::offset_of!(MarkerOptions, mTiming) - 8usize];
            ["Offset of field: MarkerOptions::mStack"]
                [::std::mem::offset_of!(MarkerOptions, mStack) - 32usize];
            ["Offset of field: MarkerOptions::mInnerWindowId"]
                [::std::mem::offset_of!(MarkerOptions, mInnerWindowId) - 56usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct MarkerSchema {
            pub mLocations: root::__BindgenOpaqueArray<u64, 3usize>,
            pub mChartLabel: root::std::string,
            pub mTooltipLabel: root::std::string,
            pub mTableLabel: root::std::string,
            pub mIsStackBased: bool,
            pub mData: root::mozilla::MarkerSchema_DataRowVector,
            pub mGraphs: root::__BindgenOpaqueArray<u64, 3usize>,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_InputType {
            Uint64 = 0,
            Uint32 = 1,
            Uint8 = 2,
            Boolean = 3,
            CString = 4,
            String = 5,
            TimeStamp = 6,
            TimeDuration = 7,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_Location {
            MarkerChart = 0,
            MarkerTable = 1,
            TimelineOverview = 2,
            TimelineMemory = 3,
            TimelineIPC = 4,
            TimelineFileIO = 5,
            StackChart = 6,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerSchema_SpecialFrontendLocation {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerSchema_SpecialFrontendLocation"]
                [::std::mem::size_of::<MarkerSchema_SpecialFrontendLocation>() - 1usize];
            ["Alignment of MarkerSchema_SpecialFrontendLocation"]
                [::std::mem::align_of::<MarkerSchema_SpecialFrontendLocation>() - 1usize];
        };
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_Format {
            Url = 0,
            FilePath = 1,
            SanitizedString = 2,
            String = 3,
            UniqueString = 4,
            Duration = 5,
            Time = 6,
            Seconds = 7,
            Milliseconds = 8,
            Microseconds = 9,
            Nanoseconds = 10,
            Bytes = 11,
            Percentage = 12,
            Integer = 13,
            Decimal = 14,
            Flow = 15,
            TerminatingFlow = 16,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_ETWMarkerGroup {
            Generic = 1,
            UserMarkers = 2,
            Memory = 4,
            Scheduling = 8,
            Text = 16,
            Tracing = 32,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_PayloadFlags {
            None = 0,
            Searchable = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerSchema_PayloadField {
            pub Key: *const ::std::os::raw::c_char,
            pub InputTy: root::mozilla::MarkerSchema_InputType,
            pub Label: *const ::std::os::raw::c_char,
            pub Fmt: root::mozilla::MarkerSchema_Format,
            pub Flags: root::mozilla::MarkerSchema_PayloadFlags,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerSchema_PayloadField"]
                [::std::mem::size_of::<MarkerSchema_PayloadField>() - 32usize];
            ["Alignment of MarkerSchema_PayloadField"]
                [::std::mem::align_of::<MarkerSchema_PayloadField>() - 8usize];
            ["Offset of field: MarkerSchema_PayloadField::Key"]
                [::std::mem::offset_of!(MarkerSchema_PayloadField, Key) - 0usize];
            ["Offset of field: MarkerSchema_PayloadField::InputTy"]
                [::std::mem::offset_of!(MarkerSchema_PayloadField, InputTy) - 8usize];
            ["Offset of field: MarkerSchema_PayloadField::Label"]
                [::std::mem::offset_of!(MarkerSchema_PayloadField, Label) - 16usize];
            ["Offset of field: MarkerSchema_PayloadField::Fmt"]
                [::std::mem::offset_of!(MarkerSchema_PayloadField, Fmt) - 24usize];
            ["Offset of field: MarkerSchema_PayloadField::Flags"]
                [::std::mem::offset_of!(MarkerSchema_PayloadField, Flags) - 28usize];
        };
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_Searchable {
            NotSearchable = 0,
            Searchable = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_GraphType {
            Line = 0,
            Bar = 1,
            FilledLine = 2,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MarkerSchema_GraphColor {
            Blue = 0,
            Green = 1,
            Grey = 2,
            Ink = 3,
            Magenta = 4,
            Orange = 5,
            Purple = 6,
            Red = 7,
            Teal = 8,
            Yellow = 9,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerSchema_DynamicData {
            pub mKey: root::std::string,
            pub mLabel: root::__BindgenOpaqueArray<u64, 5usize>,
            pub mFormat: root::mozilla::MarkerSchema_Format,
            pub mSearchable: root::__BindgenOpaqueArray<u32, 2usize>,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerSchema_DynamicData"]
                [::std::mem::size_of::<MarkerSchema_DynamicData>() - 88usize];
            ["Alignment of MarkerSchema_DynamicData"]
                [::std::mem::align_of::<MarkerSchema_DynamicData>() - 8usize];
            ["Offset of field: MarkerSchema_DynamicData::mKey"]
                [::std::mem::offset_of!(MarkerSchema_DynamicData, mKey) - 0usize];
            ["Offset of field: MarkerSchema_DynamicData::mLabel"]
                [::std::mem::offset_of!(MarkerSchema_DynamicData, mLabel) - 32usize];
            ["Offset of field: MarkerSchema_DynamicData::mFormat"]
                [::std::mem::offset_of!(MarkerSchema_DynamicData, mFormat) - 72usize];
            ["Offset of field: MarkerSchema_DynamicData::mSearchable"]
                [::std::mem::offset_of!(MarkerSchema_DynamicData, mSearchable) - 76usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerSchema_StaticData {
            pub mLabel: root::std::string,
            pub mValue: root::std::string,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerSchema_StaticData"]
                [::std::mem::size_of::<MarkerSchema_StaticData>() - 64usize];
            ["Alignment of MarkerSchema_StaticData"]
                [::std::mem::align_of::<MarkerSchema_StaticData>() - 8usize];
            ["Offset of field: MarkerSchema_StaticData::mLabel"]
                [::std::mem::offset_of!(MarkerSchema_StaticData, mLabel) - 0usize];
            ["Offset of field: MarkerSchema_StaticData::mValue"]
                [::std::mem::offset_of!(MarkerSchema_StaticData, mValue) - 32usize];
        };
        #[doc = " # mozilla::Variant\n\n A variant / tagged union / heterogenous disjoint union / sum-type template\n class. Similar in concept to (but not derived from) `boost::variant`.\n\n Sometimes, you may wish to use a C union with non-POD types. However, this is\n forbidden in C++ because it is not clear which type in the union should have\n its constructor and destructor run on creation and deletion\n respectively. This is the problem that `mozilla::Variant` solves.\n\n ## Usage\n\n A `mozilla::Variant` instance is constructed (via move or copy) from one of\n its variant types (ignoring const and references). It does *not* support\n construction from subclasses of variant types or types that coerce to one of\n the variant types.\n\n     Variant<char, uint32_t> v1('a');\n     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());\n     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed\n     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int\n\n Because specifying the full type of a Variant value is often verbose,\n there are two easier ways to construct values:\n\n A. AsVariant() can be used to construct a Variant value using type inference\n in contexts such as expressions or when returning values from functions.\n Because AsVariant() must copy or move the value into a temporary and this\n cannot necessarily be elided by the compiler, it's mostly appropriate only\n for use with primitive or very small types.\n\n     Variant<char, uint32_t> Foo() { return AsVariant('x'); }\n     // ...\n     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x').\n\n B. Brace-construction with VariantType or VariantIndex; this also allows\n in-place construction with any number of arguments.\n\n     struct AB { AB(int, int){...} };\n     static Variant<AB, bool> foo()\n     {\n       return {VariantIndex<0>{}, 1, 2};\n     }\n     // ...\n     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2).\n\n All access to the contained value goes through type-safe accessors.\n Either the stored type, or the type index may be provided.\n\n     void\n     Foo(Variant<A, B, C> v)\n     {\n       if (v.is<A>()) {\n         A& ref = v.as<A>();\n         ...\n       } else (v.is<1>()) { // Instead of v.is<B>.\n         ...\n       } else {\n         ...\n       }\n     }\n\n In some situation, a Variant may be constructed from templated types, in\n which case it is possible that the same type could be given multiple times by\n an external developer. Or seemingly-different types could be aliases.\n In this case, repeated types can only be accessed through their index, to\n prevent ambiguous access by type.\n\n    // Bad!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(int(0)) {} // Error '0' by default\n      ResultOrError(const T& r) : m(r) {}\n      bool IsResult() const { return m.is<T>(); }\n      bool IsError() const { return m.is<int>(); }\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // Fail!\n    // In Variant<int, int>, which 'int' are we refering to, from inside\n    // ResultOrError functions?\n\n    // Good!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default\n      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}\n      bool IsResult() const { return m.is<0>(); } // 0 -> T\n      bool IsError() const { return m.is<1>(); } // 1 -> int\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // It now works!\n\n Attempting to use the contained value as type `T1` when the `Variant`\n instance contains a value of type `T2` causes an assertion failure.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<B>(); // <--- Assertion failure!\n\n Trying to use a `Variant<Ts...>` instance as some type `U` that is not a\n member of the set of `Ts...` is a compiler error.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<SomeRandomType>(); // <--- Compiler error!\n\n Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it\n out of the containing `Variant` instance with the `extract<T>` method:\n\n     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());\n     auto ptr = v.extract<UniquePtr<A>>();\n\n Finally, you can exhaustively match on the contained variant and branch into\n different code paths depending on which type is contained. This is preferred\n to manually checking every variant type T with is<T>() because it provides\n compile-time checking that you handled every type, rather than runtime\n assertion failures.\n\n     // Bad!\n     char* foo(Variant<A, B, C, D>& v) {\n       if (v.is<A>()) {\n         return ...;\n       } else if (v.is<B>()) {\n         return ...;\n       } else {\n         return doSomething(v.as<C>()); // Forgot about case D!\n       }\n     }\n\n     // Instead, a single function object (that can deal with all possible\n     // options) may be provided:\n     struct FooMatcher\n     {\n       // The return type of all matchers must be identical.\n       char* operator()(A& a) { ... }\n       char* operator()(B& b) { ... }\n       char* operator()(C& c) { ... }\n       char* operator()(D& d) { ... } // Compile-time error to forget D!\n     }\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match(FooMatcher());\n     }\n\n     // In some situations, a single generic lambda may also be appropriate:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto&) {...});\n     }\n\n     // Alternatively, multiple function objects may be provided, each one\n     // corresponding to an option, in the same order:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](A&) { ... },\n                      [](B&) { ... },\n                      [](C&) { ... },\n                      [](D&) { ... });\n     }\n\n     // In rare cases, the index of the currently-active alternative is\n     // needed, it may be obtained by adding a first parameter in the matcner\n     // callback, which will receive the index in its most compact type (just\n     // use `size_t` if the exact type is not important), e.g.:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto aIndex, auto& aAlternative) {...});\n       // --OR--\n       return v.match([](size_t aIndex, auto& aAlternative) {...});\n     }\n\n ## Examples\n\n A tree is either an empty leaf, or a node with a value and two children:\n\n     struct Leaf { };\n\n     template<typename T>\n     struct Node\n     {\n       T value;\n       Tree<T>* left;\n       Tree<T>* right;\n     };\n\n     template<typename T>\n     using Tree = Variant<Leaf, Node<T>>;\n\n A copy-on-write string is either a non-owning reference to some existing\n string, or an owning reference to our copy:\n\n     class CopyOnWriteString\n     {\n       Variant<const char*, UniquePtr<char[]>> string;\n\n       ...\n     };\n\n Because Variant must be aligned suitable to hold any value stored within it,\n and because |alignas| requirements don't affect platform ABI with respect to\n how parameters are laid out in memory, Variant can't be used as the type of a\n function parameter.  Pass Variant to functions by pointer or reference\n instead."]
        pub type MarkerSchema_DataRow = root::__BindgenOpaqueArray<u64, 12usize>;
        pub type MarkerSchema_DataRowVector = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MarkerSchema_GraphData {
            pub mKey: root::std::string,
            pub mType: root::mozilla::MarkerSchema_GraphType,
            pub mColor: root::__BindgenOpaqueArray<u32, 2usize>,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerSchema_GraphData"]
                [::std::mem::size_of::<MarkerSchema_GraphData>() - 48usize];
            ["Alignment of MarkerSchema_GraphData"]
                [::std::mem::align_of::<MarkerSchema_GraphData>() - 8usize];
            ["Offset of field: MarkerSchema_GraphData::mKey"]
                [::std::mem::offset_of!(MarkerSchema_GraphData, mKey) - 0usize];
            ["Offset of field: MarkerSchema_GraphData::mType"]
                [::std::mem::offset_of!(MarkerSchema_GraphData, mType) - 32usize];
            ["Offset of field: MarkerSchema_GraphData::mColor"]
                [::std::mem::offset_of!(MarkerSchema_GraphData, mColor) - 36usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MarkerSchema"][::std::mem::size_of::<MarkerSchema>() - 176usize];
            ["Alignment of MarkerSchema"][::std::mem::align_of::<MarkerSchema>() - 8usize];
            ["Offset of field: MarkerSchema::mLocations"]
                [::std::mem::offset_of!(MarkerSchema, mLocations) - 0usize];
            ["Offset of field: MarkerSchema::mChartLabel"]
                [::std::mem::offset_of!(MarkerSchema, mChartLabel) - 24usize];
            ["Offset of field: MarkerSchema::mTooltipLabel"]
                [::std::mem::offset_of!(MarkerSchema, mTooltipLabel) - 56usize];
            ["Offset of field: MarkerSchema::mTableLabel"]
                [::std::mem::offset_of!(MarkerSchema, mTableLabel) - 88usize];
            ["Offset of field: MarkerSchema::mIsStackBased"]
                [::std::mem::offset_of!(MarkerSchema, mIsStackBased) - 120usize];
            ["Offset of field: MarkerSchema::mData"]
                [::std::mem::offset_of!(MarkerSchema, mData) - 128usize];
            ["Offset of field: MarkerSchema::mGraphs"]
                [::std::mem::offset_of!(MarkerSchema, mGraphs) - 152usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BaseMarkerType {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Range<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mStart: root::mozilla::RangedPtr<T>,
            pub mEnd: root::mozilla::RangedPtr<T>,
        }
        #[doc = " EnumSet<T, U> is a set of values defined by an enumeration. It is implemented\n using a bit mask with the size of U for each value. It works both for enum\n and enum class types. EnumSet also works with U being a BitSet."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct EnumSet<Serialized> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Serialized>>,
            pub mBitField: Serialized,
        }
        pub type EnumSet_valueType<T> = T;
        pub type EnumSet_serializedType<Serialized> = Serialized;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct EnumSet_ConstIterator<Serialized> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Serialized>>,
            pub mSet: *const root::mozilla::EnumSet<Serialized>,
            pub mPos: usize,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PositionOfSignBit {
            pub _address: u8,
        }
        #[doc = " @class CheckedInt\n @brief Integer wrapper class checking for integer overflow and other errors\n @param T the integer type to wrap. Can be any type among the following:\n            - any basic integer type such as |int|\n            - any stdint type such as |int8_t|\n\n This class implements guarded integer arithmetic. Do a computation, check\n that isValid() returns true, you then have a guarantee that no problem, such\n as integer overflow, happened during this computation, and you can call\n value() to get the plain integer value.\n\n The arithmetic operators in this class are guaranteed not to raise a signal\n (e.g. in case of a division by zero).\n\n For example, suppose that you want to implement a function that computes\n (aX+aY)/aZ, that doesn't crash if aZ==0, and that reports on error (divide by\n zero or integer overflow). You could code it as follows:\n@code\nbool computeXPlusYOverZ(int aX, int aY, int aZ, int* aResult)\n{\nCheckedInt<int> checkedResult = (CheckedInt<int>(aX) + aY) / aZ;\nif (checkedResult.isValid()) {\naResult = checkedResult.value();\nreturn true;\n} else {\nreturn false;\n}\n}\n@endcode\n\n Implicit conversion from plain integers to checked integers is allowed. The\n plain integer is checked to be in range before being casted to the\n destination type. This means that the following lines all compile, and the\n resulting CheckedInts are correctly detected as valid or invalid:\n @code\n// 1 is of type int, is found to be in range for uint8_t, x is valid\nCheckedInt<uint8_t> x(1);\n// -1 is of type int, is found not to be in range for uint8_t, x is invalid\nCheckedInt<uint8_t> x(-1);\n// -1 is of type int, is found to be in range for int8_t, x is valid\nCheckedInt<int8_t> x(-1);\n// 1000 is of type int16_t, is found not to be in range for int8_t,\n// x is invalid\nCheckedInt<int8_t> x(int16_t(1000));\n// 3123456789 is of type uint32_t, is found not to be in range for int32_t,\n// x is invalid\nCheckedInt<int32_t> x(uint32_t(3123456789));\n @endcode\n Implicit conversion from\n checked integers to plain integers is not allowed. As shown in the\n above example, to get the value of a checked integer as a normal integer,\n call value().\n\n Arithmetic operations between checked and plain integers is allowed; the\n result type is the type of the checked integer.\n\n Checked integers of different types cannot be used in the same arithmetic\n expression.\n\n There are convenience typedefs for all stdint types, of the following form\n (these are just 2 examples):\n@code\ntypedef CheckedInt<int32_t> CheckedInt32;\ntypedef CheckedInt<uint16_t> CheckedUint16;\n@endcode"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CheckedInt<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub mValue: T,
            pub mIsValid: bool,
        }
        pub type CheckedInt8 = root::mozilla::CheckedInt<i8>;
        pub type CheckedUint8 = root::mozilla::CheckedInt<u8>;
        pub type CheckedInt16 = root::mozilla::CheckedInt<i16>;
        pub type CheckedUint16 = root::mozilla::CheckedInt<u16>;
        pub type CheckedInt32 = root::mozilla::CheckedInt<i32>;
        #[doc = " @class CheckedInt\n @brief Integer wrapper class checking for integer overflow and other errors\n @param T the integer type to wrap. Can be any type among the following:\n            - any basic integer type such as |int|\n            - any stdint type such as |int8_t|\n\n This class implements guarded integer arithmetic. Do a computation, check\n that isValid() returns true, you then have a guarantee that no problem, such\n as integer overflow, happened during this computation, and you can call\n value() to get the plain integer value.\n\n The arithmetic operators in this class are guaranteed not to raise a signal\n (e.g. in case of a division by zero).\n\n For example, suppose that you want to implement a function that computes\n (aX+aY)/aZ, that doesn't crash if aZ==0, and that reports on error (divide by\n zero or integer overflow). You could code it as follows:\n@code\nbool computeXPlusYOverZ(int aX, int aY, int aZ, int* aResult)\n{\nCheckedInt<int> checkedResult = (CheckedInt<int>(aX) + aY) / aZ;\nif (checkedResult.isValid()) {\naResult = checkedResult.value();\nreturn true;\n} else {\nreturn false;\n}\n}\n@endcode\n\n Implicit conversion from plain integers to checked integers is allowed. The\n plain integer is checked to be in range before being casted to the\n destination type. This means that the following lines all compile, and the\n resulting CheckedInts are correctly detected as valid or invalid:\n @code\n// 1 is of type int, is found to be in range for uint8_t, x is valid\nCheckedInt<uint8_t> x(1);\n// -1 is of type int, is found not to be in range for uint8_t, x is invalid\nCheckedInt<uint8_t> x(-1);\n// -1 is of type int, is found to be in range for int8_t, x is valid\nCheckedInt<int8_t> x(-1);\n// 1000 is of type int16_t, is found not to be in range for int8_t,\n// x is invalid\nCheckedInt<int8_t> x(int16_t(1000));\n// 3123456789 is of type uint32_t, is found not to be in range for int32_t,\n// x is invalid\nCheckedInt<int32_t> x(uint32_t(3123456789));\n @endcode\n Implicit conversion from\n checked integers to plain integers is not allowed. As shown in the\n above example, to get the value of a checked integer as a normal integer,\n call value().\n\n Arithmetic operations between checked and plain integers is allowed; the\n result type is the type of the checked integer.\n\n Checked integers of different types cannot be used in the same arithmetic\n expression.\n\n There are convenience typedefs for all stdint types, of the following form\n (these are just 2 examples):\n@code\ntypedef CheckedInt<int32_t> CheckedInt32;\ntypedef CheckedInt<uint16_t> CheckedUint16;\n@endcode"]
        pub type CheckedUint32 = root::mozilla::CheckedInt<u32>;
        pub type CheckedInt64 = root::mozilla::CheckedInt<i64>;
        pub type CheckedUint64 = root::mozilla::CheckedInt<u64>;
        #[doc = " This structure precedes the string buffers \"we\" allocate.  It may be the\n case that nsTAString::mData does not point to one of these special\n buffers.  The mDataFlags member variable distinguishes the buffer type.\n\n When this header is in use, it enables reference counting, and capacity\n tracking.  NOTE: A string buffer can be modified only if its reference\n count is 1."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct StringBuffer {
            pub mRefCount: u32,
            pub mStorageSize: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of StringBuffer"][::std::mem::size_of::<StringBuffer>() - 8usize];
            ["Alignment of StringBuffer"][::std::mem::align_of::<StringBuffer>() - 4usize];
            ["Offset of field: StringBuffer::mRefCount"]
                [::std::mem::offset_of!(StringBuffer, mRefCount) - 0usize];
            ["Offset of field: StringBuffer::mStorageSize"]
                [::std::mem::offset_of!(StringBuffer, mStorageSize) - 4usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferList {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferList_Segment {
            pub mData: *mut ::std::os::raw::c_char,
            pub mSize: usize,
            pub mCapacity: usize,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferList_IterImpl {
            pub mSegment: usize,
            pub mData: *mut ::std::os::raw::c_char,
            pub mDataEnd: *mut ::std::os::raw::c_char,
            pub mAbsoluteOffset: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: RefPtrTraits_open0_InitialStencilAndDelazifications_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: RefPtrTraits > () - 1usize] ;
            ["Align of template specialization: RefPtrTraits_open0_InitialStencilAndDelazifications_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: RefPtrTraits > () - 1usize] ;
        };
    }
    #[doc = " already_AddRefed cooperates with reference counting smart pointers to enable\n you to assign in a pointer _without_ |AddRef|ing it.  You might want to use\n this as a return type from a function that returns an already |AddRef|ed\n pointer.  Or, you might want to use this as a parameter type in a function\n that wants to force a transfer-of-ownership from a RefPtr in the caller (for\n example, if the function expects callers to pass in a newly-created object,\n which the function then takes ownership of).\n\n TODO Move already_AddRefed to namespace mozilla.  This has not yet been done\n because of the sheer number of usages of already_AddRefed.\n\n When should you use already_AddRefed<>?\n * Ensure a consumer takes ownership of a reference\n * Pass ownership without calling AddRef/Release (sometimes required in\n   off-main-thread code)\n * The ref pointer type you're using doesn't support move construction\n\n Otherwise, use std::move(RefPtr/nsCOMPtr/etc)."]
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct already_AddRefed<T> {
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        pub mRawPtr: *mut T,
    }
    pub mod __pstl {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod execution {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod fmt {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct RefPtr<T> {
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        pub mRawPtr: *mut T,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct RefPtr_Proxy {
        pub _address: u8,
    }
    pub type RefPtr_Proxy_member_function = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct RefPtr_ConstRemovingRefPtrTraits {
        pub _address: u8,
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseScript {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseShape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GetterSetter {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropMap {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpShared {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Shape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Scope {
            _unused: [u8; 0],
        }
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SmallBuffer {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Cell {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Arena {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ArenaChunk {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct StoreBuffer {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TenuredCell {
                _unused: [u8; 0],
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ChunkKind {
                Invalid = 0,
                TenuredArenas = 1,
                MediumBuffers = 2,
                NurseryToSpace = 3,
                NurseryFromSpace = 4,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ChunkBase {
                pub storeBuffer: *mut root::js::gc::StoreBuffer,
                pub runtime: *mut root::JSRuntime,
                pub kind: root::js::gc::ChunkKind,
                pub nurseryChunkIndex: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ChunkBase"][::std::mem::size_of::<ChunkBase>() - 24usize];
                ["Alignment of ChunkBase"][::std::mem::align_of::<ChunkBase>() - 8usize];
                ["Offset of field: ChunkBase::storeBuffer"]
                    [::std::mem::offset_of!(ChunkBase, storeBuffer) - 0usize];
                ["Offset of field: ChunkBase::runtime"]
                    [::std::mem::offset_of!(ChunkBase, runtime) - 8usize];
                ["Offset of field: ChunkBase::kind"]
                    [::std::mem::offset_of!(ChunkBase, kind) - 16usize];
                ["Offset of field: ChunkBase::nurseryChunkIndex"]
                    [::std::mem::offset_of!(ChunkBase, nurseryChunkIndex) - 17usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ArenaChunkInfo {
                pub next: *mut root::js::gc::ArenaChunk,
                pub prev: *mut root::js::gc::ArenaChunk,
                pub numArenasFree: u32,
                pub numArenasFreeCommitted: u32,
                pub isCurrentChunk: bool,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ArenaChunkInfo"][::std::mem::size_of::<ArenaChunkInfo>() - 32usize];
                ["Alignment of ArenaChunkInfo"][::std::mem::align_of::<ArenaChunkInfo>() - 8usize];
                ["Offset of field: ArenaChunkInfo::next"]
                    [::std::mem::offset_of!(ArenaChunkInfo, next) - 0usize];
                ["Offset of field: ArenaChunkInfo::prev"]
                    [::std::mem::offset_of!(ArenaChunkInfo, prev) - 8usize];
                ["Offset of field: ArenaChunkInfo::numArenasFree"]
                    [::std::mem::offset_of!(ArenaChunkInfo, numArenasFree) - 16usize];
                ["Offset of field: ArenaChunkInfo::numArenasFreeCommitted"]
                    [::std::mem::offset_of!(ArenaChunkInfo, numArenasFreeCommitted) - 20usize];
                ["Offset of field: ArenaChunkInfo::isCurrentChunk"]
                    [::std::mem::offset_of!(ArenaChunkInfo, isCurrentChunk) - 24usize];
            };
            #[doc = " Atomic<T> implementation for integral types.\n\n In addition to atomic store and load operations, compound assignment and\n increment/decrement operators are implemented which perform the\n corresponding read-modify-write operation atomically.  Finally, an atomic\n swap method is provided."]
            pub type MarkBitmapWord = u64;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ColorBit {
                BlackBit = 0,
                GrayOrBlackBit = 1,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum MarkColor {
                Gray = 1,
                Black = 2,
            }
            extern "C" {
                #[link_name = "\u{1}ByteCount"]
                pub static MarkBitmap_ByteCount: usize;
            }
            extern "C" {
                #[link_name = "\u{1}WordCount"]
                pub static MarkBitmap_WordCount: usize;
            }
            extern "C" {
                #[link_name = "\u{1}FirstThingAdjustmentBits"]
                pub static MarkBitmap_FirstThingAdjustmentBits: usize;
            }
            extern "C" {
                #[link_name = "\u{1}FirstThingAdjustmentWords"]
                pub static MarkBitmap_FirstThingAdjustmentWords: usize;
            }
            pub type ChunkMarkBitmap = root::__BindgenOpaqueArray<u8, 16128usize>;
            #[doc = " An object like std::bitset but which provides access to the underlying\n storage.\n\n The type |StorageType| must be an unsigned integer or a mozilla::Atomic\n wrapping an unsigned integer. Use of atomic types makes word access atomic,\n but does not make operations that operate on the whole bitset atomic.\n\n The limited API is due to expedience only; feel free to flesh out any\n std::bitset-like members."]
            pub type ChunkPageBitmap = root::__BindgenOpaqueArray<u32, 8usize>;
            #[doc = " An object like std::bitset but which provides access to the underlying\n storage.\n\n The type |StorageType| must be an unsigned integer or a mozilla::Atomic\n wrapping an unsigned integer. Use of atomic types makes word access atomic,\n but does not make operations that operate on the whole bitset atomic.\n\n The limited API is due to expedience only; feel free to flesh out any\n std::bitset-like members."]
            pub type ChunkArenaBitmap = root::__BindgenOpaqueArray<u32, 8usize>;
            #[repr(C)]
            #[repr(align(64))]
            pub struct ArenaChunkBase {
                pub _base: root::js::gc::ChunkBase,
                pub info: root::js::gc::ArenaChunkInfo,
                pub __bindgen_padding_0: u64,
                pub markBits: root::js::gc::ChunkMarkBitmap,
                pub freeCommittedArenas: root::js::gc::ChunkArenaBitmap,
                pub decommittedPages: root::js::gc::ChunkPageBitmap,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ArenaChunkBase"][::std::mem::size_of::<ArenaChunkBase>() - 16256usize];
                ["Alignment of ArenaChunkBase"][::std::mem::align_of::<ArenaChunkBase>() - 64usize];
                ["Offset of field: ArenaChunkBase::info"]
                    [::std::mem::offset_of!(ArenaChunkBase, info) - 24usize];
                ["Offset of field: ArenaChunkBase::markBits"]
                    [::std::mem::offset_of!(ArenaChunkBase, markBits) - 64usize];
                ["Offset of field: ArenaChunkBase::freeCommittedArenas"]
                    [::std::mem::offset_of!(ArenaChunkBase, freeCommittedArenas) - 16192usize];
                ["Offset of field: ArenaChunkBase::decommittedPages"]
                    [::std::mem::offset_of!(ArenaChunkBase, decommittedPages) - 16224usize];
            };
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}_ZN2js2gc6detail16CanCheckGrayBitsEPKNS0_11TenuredCellE"]
                    pub fn CanCheckGrayBits(cell: *const root::js::gc::TenuredCell) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN2js2gc6detail23CellIsMarkedGrayIfKnownEPKNS0_11TenuredCellE"]
                    pub fn CellIsMarkedGrayIfKnown(cell: *const root::js::gc::TenuredCell) -> bool;
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc29PerformIncrementalReadBarrierEN2JS9GCCellPtrE"]
                pub fn PerformIncrementalReadBarrier(thing: root::JS::GCCellPtr);
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProfilerMemoryCounts {
                pub bytes: usize,
                pub operations: u64,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ProfilerMemoryCounts"]
                    [::std::mem::size_of::<ProfilerMemoryCounts>() - 16usize];
                ["Alignment of ProfilerMemoryCounts"]
                    [::std::mem::align_of::<ProfilerMemoryCounts>() - 8usize];
                ["Offset of field: ProfilerMemoryCounts::bytes"]
                    [::std::mem::offset_of!(ProfilerMemoryCounts, bytes) - 0usize];
                ["Offset of field: ProfilerMemoryCounts::operations"]
                    [::std::mem::offset_of!(ProfilerMemoryCounts, operations) - 8usize];
            };
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc23GetProfilerMemoryCountsEv"]
                pub fn GetProfilerMemoryCounts() -> root::js::gc::ProfilerMemoryCounts;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPPN2JS6BigIntEPKc"]
                pub fn TraceExternalEdge(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JS::BigInt,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPPN2JS6SymbolEPKc"]
                pub fn TraceExternalEdge1(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JS::Symbol,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP6JSAtomPKc"]
                pub fn TraceExternalEdge2(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSAtom,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP10JSFunctionPKc"]
                pub fn TraceExternalEdge3(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSFunction,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP14JSLinearStringPKc"]
                pub fn TraceExternalEdge4(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSLinearString,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSObjectPKc"]
                pub fn TraceExternalEdge5(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSObject,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSScriptPKc"]
                pub fn TraceExternalEdge6(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSScript,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSStringPKc"]
                pub fn TraceExternalEdge7(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSString,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPN2JS5ValueEPKc"]
                pub fn TraceExternalEdge8(
                    trc: *mut root::JSTracer,
                    thingp: *mut root::JS::Value,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPN2JS11PropertyKeyEPKc"]
                pub fn TraceExternalEdge9(
                    trc: *mut root::JSTracer,
                    thingp: *mut root::JS::PropertyKey,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc10TraceRealmEP8JSTracerPN2JS5RealmEPKc"]
                pub fn TraceRealm(
                    trc: *mut root::JSTracer,
                    realm: *mut root::JS::Realm,
                    name: *const ::std::os::raw::c_char,
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GCRuntime {
                _unused: [u8; 0],
            }
            extern "C" {
                #[doc = " Create an object providing access to the garbage collector's internal notion\n of the current state of memory (both GC heap memory and GCthing-controlled\n malloc memory."]
                #[link_name = "\u{1}_ZN2js2gc19NewMemoryInfoObjectEP9JSContext"]
                pub fn NewMemoryInfoObject(cx: *mut root::JSContext) -> *mut root::JSObject;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc12GetGCContextEP9JSContext"]
                pub fn GetGCContext(cx: *mut root::JSContext) -> *mut root::JS::GCContext;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SharedMemoryUse {
                pub count: usize,
                pub nbytes: usize,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of SharedMemoryUse"][::std::mem::size_of::<SharedMemoryUse>() - 16usize];
                ["Alignment of SharedMemoryUse"]
                    [::std::mem::align_of::<SharedMemoryUse>() - 8usize];
                ["Offset of field: SharedMemoryUse::count"]
                    [::std::mem::offset_of!(SharedMemoryUse, count) - 0usize];
                ["Offset of field: SharedMemoryUse::nbytes"]
                    [::std::mem::offset_of!(SharedMemoryUse, nbytes) - 8usize];
            };
            pub type SharedMemoryMap = u8;
        }
        pub mod jit {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct JitCode {
                _unused: [u8; 0],
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum InlinableNative {
                __bindgen_cannot_repr_c_on_empty_enum = 0,
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum TrampolineNative {
                __bindgen_cannot_repr_c_on_empty_enum = 0,
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js29CurrentThreadCanAccessRuntimeEPK9JSRuntime"]
            pub fn CurrentThreadCanAccessRuntime(rt: *const root::JSRuntime) -> bool;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ThreadType {
            THREAD_TYPE_NONE = 0,
            THREAD_TYPE_MAIN = 1,
            THREAD_TYPE_WASM_COMPILE_TIER1 = 2,
            THREAD_TYPE_WASM_COMPILE_TIER2 = 3,
            THREAD_TYPE_BASELINE = 4,
            THREAD_TYPE_ION = 5,
            THREAD_TYPE_COMPRESS = 6,
            THREAD_TYPE_GCPARALLEL = 7,
            THREAD_TYPE_PROMISE_TASK = 8,
            THREAD_TYPE_ION_FREE = 9,
            THREAD_TYPE_WASM_GENERATOR_COMPLETE_TIER2 = 10,
            THREAD_TYPE_WASM_COMPILE_PARTIAL_TIER2 = 11,
            THREAD_TYPE_WORKER = 12,
            THREAD_TYPE_DELAZIFY = 13,
            THREAD_TYPE_DELAZIFY_FREE = 14,
            THREAD_TYPE_MAX = 15,
        }
        pub mod oom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AutoEnterOOMUnsafeRegion {
            pub _address: u8,
        }
        pub type AutoEnterOOMUnsafeRegion_AnnotateOOMAllocationSizeCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: usize)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2js24AutoEnterOOMUnsafeRegion23annotateOOMSizeCallbackE"]
            pub static mut AutoEnterOOMUnsafeRegion_annotateOOMSizeCallback: u64;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoEnterOOMUnsafeRegion"]
                [::std::mem::size_of::<AutoEnterOOMUnsafeRegion>() - 1usize];
            ["Alignment of AutoEnterOOMUnsafeRegion"]
                [::std::mem::align_of::<AutoEnterOOMUnsafeRegion>() - 1usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js19InitMallocAllocatorEv"]
            pub fn InitMallocAllocator();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23ShutDownMallocAllocatorEv"]
            pub fn ShutDownMallocAllocator();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34AssertJSStringBufferInCorrectArenaEPKv"]
            pub fn AssertJSStringBufferInCorrectArena(ptr: *const ::std::os::raw::c_void);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FrontendContext {
            _unused: [u8; 0],
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AllocFunction {
            Malloc = 0,
            Calloc = 1,
            Realloc = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ArenaAllocPolicyBase {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ArenaAllocPolicyBase"]
                [::std::mem::size_of::<ArenaAllocPolicyBase>() - 1usize];
            ["Alignment of ArenaAllocPolicyBase"]
                [::std::mem::align_of::<ArenaAllocPolicyBase>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllocPolicyBase {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AllocPolicyBase"][::std::mem::size_of::<AllocPolicyBase>() - 1usize];
            ["Alignment of AllocPolicyBase"][::std::mem::align_of::<AllocPolicyBase>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BackgroundAllocPolicyBase {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of BackgroundAllocPolicyBase"]
                [::std::mem::size_of::<BackgroundAllocPolicyBase>() - 1usize];
            ["Alignment of BackgroundAllocPolicyBase"]
                [::std::mem::align_of::<BackgroundAllocPolicyBase>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SystemAllocPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of SystemAllocPolicy"][::std::mem::size_of::<SystemAllocPolicy>() - 1usize];
            ["Alignment of SystemAllocPolicy"]
                [::std::mem::align_of::<SystemAllocPolicy>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BackgroundSystemAllocPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of BackgroundSystemAllocPolicy"]
                [::std::mem::size_of::<BackgroundSystemAllocPolicy>() - 1usize];
            ["Alignment of BackgroundSystemAllocPolicy"]
                [::std::mem::align_of::<BackgroundSystemAllocPolicy>() - 1usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js17ReportOutOfMemoryEP9JSContext"]
            pub fn ReportOutOfMemory(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17ReportOutOfMemoryEPNS_15FrontendContextE"]
            pub fn ReportOutOfMemory1(fc: *mut root::js::FrontendContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js22ReportLargeOutOfMemoryEP9JSContext"]
            pub fn ReportLargeOutOfMemory(cx: *mut root::JSContext);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TempAllocPolicy {
            pub context_bits_: usize,
        }
        pub const TempAllocPolicy_JsContextTag: usize = 1;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TempAllocPolicy"][::std::mem::size_of::<TempAllocPolicy>() - 8usize];
            ["Alignment of TempAllocPolicy"][::std::mem::align_of::<TempAllocPolicy>() - 8usize];
            ["Offset of field: TempAllocPolicy::context_bits_"]
                [::std::mem::offset_of!(TempAllocPolicy, context_bits_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MallocAllocPolicy"][::std::mem::size_of::<MallocAllocPolicy>() - 1usize];
            ["Alignment of MallocAllocPolicy"]
                [::std::mem::align_of::<MallocAllocPolicy>() - 1usize];
        };
        pub type HashNumber = root::mozilla::HashNumber;
        pub type DefaultHasher = root::mozilla::DefaultHasher;
        pub type PointerHasher = root::mozilla::PointerHasher;
        pub type HashSet = u8;
        pub type HashMap = u8;
        extern "C" {
            #[link_name = "\u{1}_ZN2js26CurrentThreadCanAccessZoneEPN2JS4ZoneE"]
            pub fn CurrentThreadCanAccessZone(zone: *mut root::JS::Zone) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GenericTracerImpl {
            pub _base: root::JSTracer,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AbstractGeneratorObject {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SavedFrame {
            _unused: [u8; 0],
        }
        pub mod wasm {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AnyRef {
                _unused: [u8; 0],
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js32UnsafeTraceManuallyBarrieredEdgeEP8JSTracerPP8JSObjectPKc"]
            pub fn UnsafeTraceManuallyBarrieredEdge(
                trc: *mut root::JSTracer,
                thingp: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
        }
        pub const ProfilingStackFrame_NullPCOffset: i32 = -1;
        extern "C" {
            #[link_name = "\u{1}_ZN2js24SetContextProfilingStackEP9JSContextP14ProfilingStack"]
            pub fn SetContextProfilingStack(
                cx: *mut root::JSContext,
                profilingStack: *mut root::ProfilingStack,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27EnableContextProfilingStackEP9JSContextb"]
            pub fn EnableContextProfilingStack(cx: *mut root::JSContext, enabled: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js35RegisterContextProfilingEventMarkerEP9JSContextPFvN7mozilla14MarkerCategoryEPKcS5_EPFvS3_S5_NS2_9TimeStampES5_E"]
            pub fn RegisterContextProfilingEventMarker(
                cx: *mut root::JSContext,
                mark: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: root::mozilla::MarkerCategory,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *const ::std::os::raw::c_char,
                    ),
                >,
                interval: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: root::mozilla::MarkerCategory,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: root::mozilla::TimeStamp,
                        arg4: *const ::std::os::raw::c_char,
                    ),
                >,
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoGeckoProfilerEntry {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerEntryMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerBaselineOSRMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GeckoProfilerThread {
            pub profilingStack_: *mut root::ProfilingStack,
            pub profilingStackIfEnabled_: *mut root::ProfilingStack,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of GeckoProfilerThread"][::std::mem::size_of::<GeckoProfilerThread>() - 16usize];
            ["Alignment of GeckoProfilerThread"]
                [::std::mem::align_of::<GeckoProfilerThread>() - 8usize];
            ["Offset of field: GeckoProfilerThread::profilingStack_"]
                [::std::mem::offset_of!(GeckoProfilerThread, profilingStack_) - 0usize];
            ["Offset of field: GeckoProfilerThread::profilingStackIfEnabled_"]
                [::std::mem::offset_of!(GeckoProfilerThread, profilingStackIfEnabled_) - 8usize];
        };
        pub type UniquePtr = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
            pub type UniqueSelector_SingleObject = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct PtrBarrierMethodsBase {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct TypeIsGCThing {
                pub _base: root::std::false_type,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: TypeIsGCThing_open0_Value_close0"]
                    [::std::mem::size_of::<root::js::detail::TypeIsGCThing>() - 1usize];
                ["Align of template specialization: TypeIsGCThing_open0_Value_close0"]
                    [::std::mem::align_of::<root::js::detail::TypeIsGCThing>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProxyReservedSlots {
                pub slots: [root::JS::Value; 1usize],
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ProxyReservedSlots"]
                    [::std::mem::size_of::<ProxyReservedSlots>() - 8usize];
                ["Alignment of ProxyReservedSlots"]
                    [::std::mem::align_of::<ProxyReservedSlots>() - 8usize];
                ["Offset of field: ProxyReservedSlots::slots"]
                    [::std::mem::offset_of!(ProxyReservedSlots, slots) - 0usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProxyValueArray {
                pub expandoSlot: root::JS::Value,
                pub privateSlot: root::JS::Value,
                pub reservedSlots: root::js::detail::ProxyReservedSlots,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ProxyValueArray"][::std::mem::size_of::<ProxyValueArray>() - 24usize];
                ["Alignment of ProxyValueArray"]
                    [::std::mem::align_of::<ProxyValueArray>() - 8usize];
                ["Offset of field: ProxyValueArray::expandoSlot"]
                    [::std::mem::offset_of!(ProxyValueArray, expandoSlot) - 0usize];
                ["Offset of field: ProxyValueArray::privateSlot"]
                    [::std::mem::offset_of!(ProxyValueArray, privateSlot) - 8usize];
                ["Offset of field: ProxyValueArray::reservedSlots"]
                    [::std::mem::offset_of!(ProxyValueArray, reservedSlots) - 16usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProxyDataLayout {
                pub reservedSlots: *mut root::js::detail::ProxyReservedSlots,
                pub handler: *const root::js::BaseProxyHandler,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of ProxyDataLayout"][::std::mem::size_of::<ProxyDataLayout>() - 16usize];
                ["Alignment of ProxyDataLayout"]
                    [::std::mem::align_of::<ProxyDataLayout>() - 8usize];
                ["Offset of field: ProxyDataLayout::reservedSlots"]
                    [::std::mem::offset_of!(ProxyDataLayout, reservedSlots) - 0usize];
                ["Offset of field: ProxyDataLayout::handler"]
                    [::std::mem::offset_of!(ProxyDataLayout, handler) - 8usize];
            };
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail15SetValueInProxyEPN2JS5ValueERKS2_"]
                pub fn SetValueInProxy(slot: *mut root::JS::Value, value: *const root::JS::Value);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail12IsWindowSlowEP8JSObject"]
                pub fn IsWindowSlow(obj: *mut root::JSObject) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail25ToWindowProxyIfWindowSlowEP8JSObject"]
                pub fn ToWindowProxyIfWindowSlow(obj: *mut root::JSObject) -> *mut root::JSObject;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Nursery {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BarrierMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableWrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootedOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HandleOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandleOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HeapOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct IsHeapConstructibleType {
            pub _base: root::std::false_type,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_BigInt_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_BigInt_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_Symbol_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_Symbol_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_JSAtom_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_JSAtom_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_JSFunction_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_JSFunction_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_JSLinearString_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_JSLinearString_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_JSObject_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_JSObject_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_JSScript_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_JSScript_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_ptr_JSString_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_ptr_JSString_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_Value_void_close0"]
                [::std::mem::size_of::<root::js::IsHeapConstructibleType>() - 1usize];
            ["Align of template specialization: IsHeapConstructibleType_open0_Value_void_close0"]
                [::std::mem::align_of::<root::js::IsHeapConstructibleType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsHeapConstructibleType_open0_PropertyKey_void_close0"] [:: std :: mem :: size_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
            ["Align of template specialization: IsHeapConstructibleType_open0_PropertyKey_void_close0"] [:: std :: mem :: align_of :: < root :: js :: IsHeapConstructibleType > () - 1usize] ;
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: BarrierMethods_open0_ptr_JSObject_void_close0"]
                [::std::mem::size_of::<root::js::BarrierMethods>() - 1usize];
            ["Align of template specialization: BarrierMethods_open0_ptr_JSObject_void_close0"]
                [::std::mem::align_of::<root::js::BarrierMethods>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: BarrierMethods_open0_ptr_JSFunction_void_close0"]
                [::std::mem::size_of::<root::js::BarrierMethods>() - 1usize];
            ["Align of template specialization: BarrierMethods_open0_ptr_JSFunction_void_close0"]
                [::std::mem::align_of::<root::js::BarrierMethods>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: BarrierMethods_open0_ptr_JSString_void_close0"]
                [::std::mem::size_of::<root::js::BarrierMethods>() - 1usize];
            ["Align of template specialization: BarrierMethods_open0_ptr_JSString_void_close0"]
                [::std::mem::align_of::<root::js::BarrierMethods>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: BarrierMethods_open0_ptr_JSScript_void_close0"]
                [::std::mem::size_of::<root::js::BarrierMethods>() - 1usize];
            ["Align of template specialization: BarrierMethods_open0_ptr_JSScript_void_close0"]
                [::std::mem::align_of::<root::js::BarrierMethods>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: BarrierMethods_open0_ptr_BigInt_void_close0"]
                [::std::mem::size_of::<root::js::BarrierMethods>() - 1usize];
            ["Align of template specialization: BarrierMethods_open0_ptr_BigInt_void_close0"]
                [::std::mem::align_of::<root::js::BarrierMethods>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StableCellHasher {
            pub _address: u8,
        }
        pub type StableCellHasher_Key<T> = T;
        pub type StableCellHasher_Lookup<T> = T;
        #[repr(C)]
        pub struct VirtualTraceable__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct VirtualTraceable {
            pub vtable_: *const VirtualTraceable__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of VirtualTraceable"][::std::mem::size_of::<VirtualTraceable>() - 8usize];
            ["Alignment of VirtualTraceable"][::std::mem::align_of::<VirtualTraceable>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StackRootedBase {
            pub stack: *mut *mut root::js::StackRootedBase,
            pub prev: *mut root::js::StackRootedBase,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of StackRootedBase"][::std::mem::size_of::<StackRootedBase>() - 16usize];
            ["Alignment of StackRootedBase"][::std::mem::align_of::<StackRootedBase>() - 8usize];
            ["Offset of field: StackRootedBase::stack"]
                [::std::mem::offset_of!(StackRootedBase, stack) - 0usize];
            ["Offset of field: StackRootedBase::prev"]
                [::std::mem::offset_of!(StackRootedBase, prev) - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct PersistentRootedBase {
            pub _base: root::mozilla::LinkedListElement,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of PersistentRootedBase"]
                [::std::mem::size_of::<PersistentRootedBase>() - 24usize];
            ["Alignment of PersistentRootedBase"]
                [::std::mem::align_of::<PersistentRootedBase>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct StackRootedTraceableBase {
            pub _base: root::js::StackRootedBase,
            pub _base_1: root::js::VirtualTraceable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of StackRootedTraceableBase"]
                [::std::mem::size_of::<StackRootedTraceableBase>() - 24usize];
            ["Alignment of StackRootedTraceableBase"]
                [::std::mem::align_of::<StackRootedTraceableBase>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct PersistentRootedTraceableBase {
            pub _base: root::js::PersistentRootedBase,
            pub _base_1: root::js::VirtualTraceable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of PersistentRootedTraceableBase"]
                [::std::mem::size_of::<PersistentRootedTraceableBase>() - 32usize];
            ["Alignment of PersistentRootedTraceableBase"]
                [::std::mem::align_of::<PersistentRootedTraceableBase>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TypedRootedGCThingBase<Base> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
            pub _base: Base,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TypedRootedTraceableBase<Base> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
            pub _base: Base,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootedTraceableTraits {
            pub _address: u8,
        }
        pub type RootedTraceableTraits_StackBase =
            root::js::TypedRootedTraceableBase<root::js::StackRootedTraceableBase>;
        pub type RootedTraceableTraits_PersistentBase =
            root::js::TypedRootedTraceableBase<root::js::PersistentRootedTraceableBase>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootedGCThingTraits {
            pub _address: u8,
        }
        pub type RootedGCThingTraits_StackBase =
            root::js::TypedRootedGCThingBase<root::js::StackRootedBase>;
        pub type RootedGCThingTraits_PersistentBase =
            root::js::TypedRootedGCThingBase<root::js::PersistentRootedBase>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GenericPrinter {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct JSONPrinter {
            _unused: [u8; 0],
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: BarrierMethods_open0_Value_void_close0"]
                [::std::mem::size_of::<root::js::BarrierMethods>() - 1usize];
            ["Align of template specialization: BarrierMethods_open0_Value_void_close0"]
                [::std::mem::align_of::<root::js::BarrierMethods>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableValueOperations {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26ReportBadValueTypeAndCrashERKN2JS5ValueE"]
            pub fn ReportBadValueTypeAndCrash(val: *const root::JS::Value) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15TraceValueArrayEP8JSTracermPN2JS5ValueE"]
            pub fn TraceValueArray(
                trc: *mut root::JSTracer,
                length: usize,
                elements: *mut root::JS::Value,
            );
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: BarrierMethods_open0_PropertyKey_void_close0"]
                [::std::mem::size_of::<root::js::BarrierMethods>() - 1usize];
            ["Align of template specialization: BarrierMethods_open0_PropertyKey_void_close0"]
                [::std::mem::align_of::<root::js::BarrierMethods>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyResult {
            _unused: [u8; 0],
        }
        pub type LookupPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                objp: root::JS::MutableHandleObject,
                propp: *mut root::js::PropertyResult,
            ) -> bool,
        >;
        pub type DefinePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type HasPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                foundp: *mut bool,
            ) -> bool,
        >;
        pub type GetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >;
        pub type SetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type GetOwnPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: u64,
            ) -> bool,
        >;
        pub type DeletePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        #[repr(C)]
        pub struct ElementAdder {
            pub resObj_: root::JS::RootedObject,
            pub vp_: *mut root::JS::Value,
            pub index_: u32,
            pub getBehavior_: root::js::ElementAdder_GetBehavior,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ElementAdder_GetBehavior {
            CheckHasElemPreserveHoles = 0,
            GetElement = 1,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ElementAdder"][::std::mem::size_of::<ElementAdder>() - 40usize];
            ["Alignment of ElementAdder"][::std::mem::align_of::<ElementAdder>() - 8usize];
            ["Offset of field: ElementAdder::resObj_"]
                [::std::mem::offset_of!(ElementAdder, resObj_) - 0usize];
            ["Offset of field: ElementAdder::vp_"]
                [::std::mem::offset_of!(ElementAdder, vp_) - 24usize];
            ["Offset of field: ElementAdder::index_"]
                [::std::mem::offset_of!(ElementAdder, index_) - 32usize];
            ["Offset of field: ElementAdder::getBehavior_"]
                [::std::mem::offset_of!(ElementAdder, getBehavior_) - 36usize];
        };
        pub type GetElementsOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool,
        >;
        #[doc = " Callback for the creation of constructor and prototype objects."]
        pub type ClassObjectCreationOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
            ) -> *mut root::JSObject,
        >;
        #[doc = " Callback for custom post-processing after class initialization via\n ClassSpec."]
        pub type FinishClassInitOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                ctor: root::JS::HandleObject,
                proto: root::JS::HandleObject,
            ) -> bool,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClassSpec {
            pub createConstructor: root::js::ClassObjectCreationOp,
            pub createPrototype: root::js::ClassObjectCreationOp,
            pub constructorFunctions: *const root::JSFunctionSpec,
            pub constructorProperties: *const root::JSPropertySpec,
            pub prototypeFunctions: *const root::JSFunctionSpec,
            pub prototypeProperties: *const root::JSPropertySpec,
            pub finishInit: root::js::FinishClassInitOp,
            pub flags: usize,
        }
        pub const ClassSpec_ProtoKeyWidth: usize = 7;
        pub const ClassSpec_ProtoKeyMask: usize = 127;
        pub const ClassSpec_DontDefineConstructor: usize = 128;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ClassSpec"][::std::mem::size_of::<ClassSpec>() - 64usize];
            ["Alignment of ClassSpec"][::std::mem::align_of::<ClassSpec>() - 8usize];
            ["Offset of field: ClassSpec::createConstructor"]
                [::std::mem::offset_of!(ClassSpec, createConstructor) - 0usize];
            ["Offset of field: ClassSpec::createPrototype"]
                [::std::mem::offset_of!(ClassSpec, createPrototype) - 8usize];
            ["Offset of field: ClassSpec::constructorFunctions"]
                [::std::mem::offset_of!(ClassSpec, constructorFunctions) - 16usize];
            ["Offset of field: ClassSpec::constructorProperties"]
                [::std::mem::offset_of!(ClassSpec, constructorProperties) - 24usize];
            ["Offset of field: ClassSpec::prototypeFunctions"]
                [::std::mem::offset_of!(ClassSpec, prototypeFunctions) - 32usize];
            ["Offset of field: ClassSpec::prototypeProperties"]
                [::std::mem::offset_of!(ClassSpec, prototypeProperties) - 40usize];
            ["Offset of field: ClassSpec::finishInit"]
                [::std::mem::offset_of!(ClassSpec, finishInit) - 48usize];
            ["Offset of field: ClassSpec::flags"]
                [::std::mem::offset_of!(ClassSpec, flags) - 56usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClassExtension {
            #[doc = " Optional hook called when an object is moved by generational or\n compacting GC.\n\n There may exist weak pointers to an object that are not traced through\n when the normal trace APIs are used, for example objects in the wrapper\n cache. This hook allows these pointers to be updated.\n\n Note that this hook can be called before JS_NewObject() returns if a GC\n is triggered during construction of the object. This can happen for\n global objects for example.\n\n The function should return the difference between nursery bytes used and\n tenured bytes used, which may be nonzero e.g. if some nursery-allocated\n data beyond the actual GC thing is moved into malloced memory.\n\n This is used to compute the nursery promotion rate."]
            pub objectMovedOp: root::JSObjectMovedOp,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ClassExtension"][::std::mem::size_of::<ClassExtension>() - 8usize];
            ["Alignment of ClassExtension"][::std::mem::align_of::<ClassExtension>() - 8usize];
            ["Offset of field: ClassExtension::objectMovedOp"]
                [::std::mem::offset_of!(ClassExtension, objectMovedOp) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ObjectOps {
            pub lookupProperty: root::js::LookupPropertyOp,
            pub defineProperty: root::js::DefinePropertyOp,
            pub hasProperty: root::js::HasPropertyOp,
            pub getProperty: root::js::GetPropertyOp,
            pub setProperty: root::js::SetPropertyOp,
            pub getOwnPropertyDescriptor: root::js::GetOwnPropertyOp,
            pub deleteProperty: root::js::DeletePropertyOp,
            pub getElements: root::js::GetElementsOp,
            pub funToString: root::JSFunToStringOp,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ObjectOps"][::std::mem::size_of::<ObjectOps>() - 72usize];
            ["Alignment of ObjectOps"][::std::mem::align_of::<ObjectOps>() - 8usize];
            ["Offset of field: ObjectOps::lookupProperty"]
                [::std::mem::offset_of!(ObjectOps, lookupProperty) - 0usize];
            ["Offset of field: ObjectOps::defineProperty"]
                [::std::mem::offset_of!(ObjectOps, defineProperty) - 8usize];
            ["Offset of field: ObjectOps::hasProperty"]
                [::std::mem::offset_of!(ObjectOps, hasProperty) - 16usize];
            ["Offset of field: ObjectOps::getProperty"]
                [::std::mem::offset_of!(ObjectOps, getProperty) - 24usize];
            ["Offset of field: ObjectOps::setProperty"]
                [::std::mem::offset_of!(ObjectOps, setProperty) - 32usize];
            ["Offset of field: ObjectOps::getOwnPropertyDescriptor"]
                [::std::mem::offset_of!(ObjectOps, getOwnPropertyDescriptor) - 40usize];
            ["Offset of field: ObjectOps::deleteProperty"]
                [::std::mem::offset_of!(ObjectOps, deleteProperty) - 48usize];
            ["Offset of field: ObjectOps::getElements"]
                [::std::mem::offset_of!(ObjectOps, getElements) - 56usize];
            ["Offset of field: ObjectOps::funToString"]
                [::std::mem::offset_of!(ObjectOps, funToString) - 64usize];
        };
        #[repr(i32)]
        #[doc = " Enumeration describing possible values of the [[Class]] internal property\n value of objects."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ESClass {
            Object = 0,
            Array = 1,
            Number = 2,
            String = 3,
            Boolean = 4,
            RegExp = 5,
            ArrayBuffer = 6,
            SharedArrayBuffer = 7,
            Date = 8,
            Set = 9,
            Map = 10,
            Promise = 11,
            MapIterator = 12,
            SetIterator = 13,
            Arguments = 14,
            Error = 15,
            BigInt = 16,
            Function = 17,
            #[doc = " None of the above."]
            Other = 18,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js5UnboxEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleINS2_5ValueEEE"]
            pub fn Unbox(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16AssertHeapIsIdleEv"]
            pub fn AssertHeapIsIdle();
        }
        pub mod gcstats {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Statistics {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Debugger {
            _unused: [u8; 0],
        }
        pub type Vector = u8;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ErrorArgumentsType {
            ArgumentsAreUnicode = 0,
            ArgumentsAreASCII = 1,
            ArgumentsAreLatin1 = 2,
            ArgumentsAreUTF8 = 3,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RefCounted {
            pub mRefCnt: root::MozRefCountType,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AtomicRefCounted {
            pub mRefCnt: u64,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StackFormat {
            SpiderMonkey = 0,
            V8 = 1,
            Default = 2,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14SetStackFormatEP9JSContextNS_11StackFormatE"]
            pub fn SetStackFormat(cx: *mut root::JSContext, format: root::js::StackFormat);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetStackFormatEP9JSContext"]
            pub fn GetStackFormat(cx: *mut root::JSContext) -> root::js::StackFormat;
        }
        pub mod frontend {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct InitialStencilAndDelazifications {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationStencil {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationGCOutput {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationInput {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PreallocatedCompilationGCOutput {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptSource {
            _unused: [u8; 0],
        }
        extern "C" {
            #[doc = " Hint that we expect a crash. Currently, the only thing that cares is the\n breakpad injector, which (if loaded) will suppress minidump generation."]
            #[link_name = "\u{1}_ZN2js20NoteIntentionalCrashEv"]
            pub fn NoteIntentionalCrash();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13ToBooleanSlowEN2JS6HandleINS0_5ValueEEE"]
            pub fn ToBooleanSlow(v: root::JS::HandleValue) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToNumberSlowEP9JSContextN2JS6HandleINS2_5ValueEEEPd"]
            pub fn ToNumberSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                dp: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10ToInt8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPa"]
            pub fn ToInt8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i8,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToUint8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPh"]
            pub fn ToUint8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u8,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPs"]
            pub fn ToInt16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPi"]
            pub fn ToInt32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPj"]
            pub fn ToUint32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPt"]
            pub fn ToUint16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPl"]
            pub fn ToInt64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPm"]
            pub fn ToUint64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToStringSlowEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ToStringSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToObjectSlowEP9JSContextN2JS6HandleINS2_5ValueEEEb"]
            pub fn ToObjectSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                reportScanStack: bool,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " In memory reporting, we have concept of \"sundries\", line items which are too\n small to be worth reporting individually.  Under some circumstances, a memory\n reporter gets tossed into the sundries bucket if it's smaller than\n MemoryReportingSundriesThreshold() bytes.\n\n We need to define this value here, rather than in the code which actually\n generates the memory reports, because NotableStringInfo uses this value."]
            #[link_name = "\u{1}_ZN2js32MemoryReportingSundriesThresholdEv"]
            pub fn MemoryReportingSundriesThreshold() -> usize;
        }
        #[doc = " This hash policy avoids flattening ropes (which perturbs the site being\n measured and requires a JSContext) at the expense of doing a FULL ROPE COPY\n on every hash and match! Beware."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct InefficientNonFlatteningStringHashPolicy {
            pub _address: u8,
        }
        pub type InefficientNonFlatteningStringHashPolicy_Lookup = *mut root::JSString;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of InefficientNonFlatteningStringHashPolicy"]
                [::std::mem::size_of::<InefficientNonFlatteningStringHashPolicy>() - 1usize];
            ["Alignment of InefficientNonFlatteningStringHashPolicy"]
                [::std::mem::align_of::<InefficientNonFlatteningStringHashPolicy>() - 1usize];
        };
        #[repr(C)]
        pub struct BaseProxyHandler__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BaseProxyHandler {
            pub vtable_: *const BaseProxyHandler__bindgen_vtable,
            pub mFamily: *const ::std::os::raw::c_void,
            pub mHasPrototype: bool,
            pub mHasSecurityPolicy: bool,
        }
        pub type BaseProxyHandler_Action = u32;
        pub const BaseProxyHandler_NONE: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::NONE;
        pub const BaseProxyHandler_GET: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::GET;
        pub const BaseProxyHandler_SET: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::SET;
        pub const BaseProxyHandler_CALL: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::CALL;
        pub const BaseProxyHandler_ENUMERATE: root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::ENUMERATE;
        pub const BaseProxyHandler_GET_PROPERTY_DESCRIPTOR:
            root::js::BaseProxyHandler__bindgen_ty_1 =
            BaseProxyHandler__bindgen_ty_1::GET_PROPERTY_DESCRIPTOR;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BaseProxyHandler__bindgen_ty_1 {
            NONE = 0,
            GET = 1,
            SET = 2,
            CALL = 4,
            ENUMERATE = 8,
            GET_PROPERTY_DESCRIPTOR = 16,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of BaseProxyHandler"][::std::mem::size_of::<BaseProxyHandler>() - 18usize];
            ["Alignment of BaseProxyHandler"][::std::mem::align_of::<BaseProxyHandler>() - 1usize];
            ["Offset of field: BaseProxyHandler::mFamily"]
                [::std::mem::offset_of!(BaseProxyHandler, mFamily) - 8usize];
            ["Offset of field: BaseProxyHandler::mHasPrototype"]
                [::std::mem::offset_of!(BaseProxyHandler, mHasPrototype) - 16usize];
            ["Offset of field: BaseProxyHandler::mHasSecurityPolicy"]
                [::std::mem::offset_of!(BaseProxyHandler, mHasSecurityPolicy) - 17usize];
        };
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NurseryAllocableProxyHandler {
            pub _base: root::js::BaseProxyHandler,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of NurseryAllocableProxyHandler"]
                [::std::mem::size_of::<NurseryAllocableProxyHandler>() - 18usize];
            ["Alignment of NurseryAllocableProxyHandler"]
                [::std::mem::align_of::<NurseryAllocableProxyHandler>() - 1usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js10ProxyClassE"]
            pub static ProxyClass: root::JSClass;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProxyOptions {
            pub lazyProto_: bool,
            pub clasp_: *const root::JSClass,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProxyOptions"][::std::mem::size_of::<ProxyOptions>() - 16usize];
            ["Alignment of ProxyOptions"][::std::mem::align_of::<ProxyOptions>() - 8usize];
            ["Offset of field: ProxyOptions::lazyProto_"]
                [::std::mem::offset_of!(ProxyOptions, lazyProto_) - 0usize];
            ["Offset of field: ProxyOptions::clasp_"]
                [::std::mem::offset_of!(ProxyOptions, clasp_) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js14NewProxyObjectEP9JSContextPKNS_16BaseProxyHandlerEN2JS6HandleINS5_5ValueEEEP8JSObjectRKNS_12ProxyOptionsE"]
            pub fn NewProxyObject(
                cx: *mut root::JSContext,
                handler: *const root::js::BaseProxyHandler,
                priv_: root::JS::HandleValue,
                proto: *mut root::JSObject,
                options: *const root::js::ProxyOptions,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16RenewProxyObjectEP9JSContextP8JSObjectPNS_16BaseProxyHandlerERKN2JS5ValueE"]
            pub fn RenewProxyObject(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                handler: *mut root::js::BaseProxyHandler,
                priv_: *const root::JS::Value,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        pub struct AutoEnterPolicy__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoEnterPolicy {
            pub vtable_: *const AutoEnterPolicy__bindgen_vtable,
            pub allow: bool,
            pub rv: bool,
        }
        pub type AutoEnterPolicy_Action = root::js::BaseProxyHandler_Action;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoEnterPolicy"][::std::mem::size_of::<AutoEnterPolicy>() - 16usize];
            ["Alignment of AutoEnterPolicy"][::std::mem::align_of::<AutoEnterPolicy>() - 8usize];
            ["Offset of field: AutoEnterPolicy::allow"]
                [::std::mem::offset_of!(AutoEnterPolicy, allow) - 8usize];
            ["Offset of field: AutoEnterPolicy::rv"]
                [::std::mem::offset_of!(AutoEnterPolicy, rv) - 9usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AutoWaivePolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoWaivePolicy"][::std::mem::size_of::<AutoWaivePolicy>() - 1usize];
            ["Alignment of AutoWaivePolicy"][::std::mem::align_of::<AutoWaivePolicy>() - 1usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js13ProxyClassOpsE"]
            pub static ProxyClassOps: root::JSClassOps;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19ProxyClassExtensionE"]
            pub static ProxyClassExtension: root::js::ClassExtension;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14ProxyObjectOpsE"]
            pub static ProxyObjectOps: root::js::ObjectOps;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15NukeNonCCWProxyEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn NukeNonCCWProxy(cx: *mut root::JSContext, proxy: root::JS::HandleObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34NukeRemovedCrossCompartmentWrapperEP9JSContextP8JSObject"]
            pub fn NukeRemovedCrossCompartmentWrapper(
                cx: *mut root::JSContext,
                wrapper: *mut root::JSObject,
            );
        }
        extern "C" {
            #[doc = " Get the first SavedFrame object in this SavedFrame stack whose principals are\n subsumed by the given |principals|. If there is no such frame, return\n nullptr.\n\n Do NOT pass a non-SavedFrame object here."]
            #[link_name = "\u{1}_ZN2js26GetFirstSubsumedSavedFrameEP9JSContextP12JSPrincipalsN2JS6HandleIP8JSObjectEENS4_20SavedFrameSelfHostedE"]
            pub fn GetFirstSubsumedSavedFrame(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SharedArrayRawBuffer {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SharedArrayRawBufferRefs {
            pub refs_: root::__BindgenOpaqueArray<u64, 3usize>,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of SharedArrayRawBufferRefs"]
                [::std::mem::size_of::<SharedArrayRawBufferRefs>() - 24usize];
            ["Alignment of SharedArrayRawBufferRefs"]
                [::std::mem::align_of::<SharedArrayRawBufferRefs>() - 8usize];
            ["Offset of field: SharedArrayRawBufferRefs::refs_"]
                [::std::mem::offset_of!(SharedArrayRawBufferRefs, refs_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferIterator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WrapperOptions {
            pub _base: root::js::ProxyOptions,
            pub proto_: root::__BindgenOpaqueArray<u64, 4usize>,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of WrapperOptions"][::std::mem::size_of::<WrapperOptions>() - 48usize];
            ["Alignment of WrapperOptions"][::std::mem::align_of::<WrapperOptions>() - 8usize];
            ["Offset of field: WrapperOptions::proto_"]
                [::std::mem::offset_of!(WrapperOptions, proto_) - 16usize];
        };
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ForwardingProxyHandler {
            pub _base: root::js::BaseProxyHandler,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ForwardingProxyHandler"]
                [::std::mem::size_of::<ForwardingProxyHandler>() - 18usize];
            ["Alignment of ForwardingProxyHandler"]
                [::std::mem::align_of::<ForwardingProxyHandler>() - 1usize];
        };
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Wrapper {
            pub _base: root::js::ForwardingProxyHandler,
            pub mFlags: ::std::os::raw::c_uint,
        }
        impl root::js::Wrapper_Flags {
            pub const LAST_USED_FLAG: root::js::Wrapper_Flags = Wrapper_Flags::CROSS_COMPARTMENT;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Wrapper_Flags {
            CROSS_COMPARTMENT = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper6familyE"]
            pub static Wrapper_family: ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper9singletonE"]
            pub static Wrapper_singleton: root::js::Wrapper;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper22singletonWithPrototypeE"]
            pub static Wrapper_singletonWithPrototype: root::js::Wrapper;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7Wrapper12defaultProtoE"]
            pub static Wrapper_defaultProto: *mut root::JSObject;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Wrapper"][::std::mem::size_of::<Wrapper>() - 22usize];
            ["Alignment of Wrapper"][::std::mem::align_of::<Wrapper>() - 1usize];
            ["Offset of field: Wrapper::mFlags"][::std::mem::offset_of!(Wrapper, mFlags) - 18usize];
        };
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CrossCompartmentWrapper {
            pub _base: root::js::Wrapper,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23CrossCompartmentWrapper9singletonE"]
            pub static CrossCompartmentWrapper_singleton: root::js::CrossCompartmentWrapper;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23CrossCompartmentWrapper22singletonWithPrototypeE"]
            pub static CrossCompartmentWrapper_singletonWithPrototype:
                root::js::CrossCompartmentWrapper;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CrossCompartmentWrapper"]
                [::std::mem::size_of::<CrossCompartmentWrapper>() - 22usize];
            ["Alignment of CrossCompartmentWrapper"]
                [::std::mem::align_of::<CrossCompartmentWrapper>() - 1usize];
        };
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OpaqueCrossCompartmentWrapper {
            pub _base: root::js::CrossCompartmentWrapper,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js29OpaqueCrossCompartmentWrapper9singletonE"]
            pub static OpaqueCrossCompartmentWrapper_singleton:
                root::js::OpaqueCrossCompartmentWrapper;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of OpaqueCrossCompartmentWrapper"]
                [::std::mem::size_of::<OpaqueCrossCompartmentWrapper>() - 22usize];
            ["Alignment of OpaqueCrossCompartmentWrapper"]
                [::std::mem::align_of::<OpaqueCrossCompartmentWrapper>() - 1usize];
        };
        #[repr(C)]
        pub struct SecurityWrapper__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SecurityWrapper<Base> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
            pub vtable_: *const SecurityWrapper__bindgen_vtable,
            pub _base: Base,
        }
        pub type SecurityWrapper_Permissive<Base> = Base;
        pub type SecurityWrapper_Restrictive<Base> = root::js::SecurityWrapper<Base>;
        pub type CrossCompartmentSecurityWrapper =
            root::js::SecurityWrapper<root::js::CrossCompartmentWrapper>;
        extern "C" {
            #[link_name = "\u{1}_ZN2js24TransparentObjectWrapperEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn TransparentObjectWrapper(
                cx: *mut root::JSContext,
                existing: root::JS::HandleObject,
                obj: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15UncheckedUnwrapEP8JSObjectbPj"]
            pub fn UncheckedUnwrap(
                obj: *mut root::JSObject,
                stopAtWindowProxy: bool,
                flagsp: *mut ::std::os::raw::c_uint,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19CheckedUnwrapStaticEP8JSObject"]
            pub fn CheckedUnwrapStatic(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js22UnwrapOneCheckedStaticEP8JSObject"]
            pub fn UnwrapOneCheckedStatic(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20CheckedUnwrapDynamicEP8JSObjectP9JSContextb"]
            pub fn CheckedUnwrapDynamic(
                obj: *mut root::JSObject,
                cx: *mut root::JSContext,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23UnwrapOneCheckedDynamicEN2JS6HandleIP8JSObjectEEP9JSContextb"]
            pub fn UnwrapOneCheckedDynamic(
                obj: root::JS::HandleObject,
                cx: *mut root::JSContext,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28UncheckedUnwrapWithoutExposeEP8JSObject"]
            pub fn UncheckedUnwrapWithoutExpose(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18ReportAccessDeniedEP9JSContext"]
            pub fn ReportAccessDenied(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27NukeCrossCompartmentWrapperEP9JSContextP8JSObject"]
            pub fn NukeCrossCompartmentWrapper(
                cx: *mut root::JSContext,
                wrapper: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js35NukeCrossCompartmentWrapperIfExistsEP9JSContextPN2JS11CompartmentEP8JSObject"]
            pub fn NukeCrossCompartmentWrapperIfExists(
                cx: *mut root::JSContext,
                source: *mut root::JS::Compartment,
                target: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12RemapWrapperEP9JSContextP8JSObjectS3_"]
            pub fn RemapWrapper(
                cx: *mut root::JSContext,
                wobj: *mut root::JSObject,
                newTarget: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16RemapDeadWrapperEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn RemapDeadWrapper(
                cx: *mut root::JSContext,
                wobj: root::JS::HandleObject,
                newTarget: root::JS::HandleObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25RemapAllWrappersForObjectEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn RemapAllWrappersForObject(
                cx: *mut root::JSContext,
                oldTarget: root::JS::HandleObject,
                newTarget: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17RecomputeWrappersEP9JSContextRKNS_17CompartmentFilterES4_"]
            pub fn RecomputeWrappers(
                cx: *mut root::JSContext,
                sourceFilter: *const root::js::CompartmentFilter,
                targetFilter: *const root::js::CompartmentFilter,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21UnwrapArrayBufferViewEP8JSObject"]
            pub fn UnwrapArrayBufferView(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31GetArrayBufferViewLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferViewLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15UnwrapInt8ArrayEP8JSObject"]
            pub fn UnwrapInt8Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapUint8ArrayEP8JSObject"]
            pub fn UnwrapUint8Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapInt16ArrayEP8JSObject"]
            pub fn UnwrapInt16Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17UnwrapUint16ArrayEP8JSObject"]
            pub fn UnwrapUint16Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapInt32ArrayEP8JSObject"]
            pub fn UnwrapInt32Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17UnwrapUint32ArrayEP8JSObject"]
            pub fn UnwrapUint32Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18UnwrapFloat32ArrayEP8JSObject"]
            pub fn UnwrapFloat32Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18UnwrapFloat64ArrayEP8JSObject"]
            pub fn UnwrapFloat64Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23UnwrapUint8ClampedArrayEP8JSObject"]
            pub fn UnwrapUint8ClampedArray(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19UnwrapBigInt64ArrayEP8JSObject"]
            pub fn UnwrapBigInt64Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20UnwrapBigUint64ArrayEP8JSObject"]
            pub fn UnwrapBigUint64Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18UnwrapFloat16ArrayEP8JSObject"]
            pub fn UnwrapFloat16Array(maybeWrapped: *mut root::JSObject) -> *mut root::JSObject;
        }
        pub type EnableIfABOVType = root::std::enable_if_t;
        extern "C" {
            #[doc = " A JSErrorCallback suitable for passing to |JS_ReportErrorNumberASCII| and\n similar functions in concert with one of the |JSErrNum| error numbers.\n\n This function is a function only of |errorNumber|: |userRef| and ambient\n state have no effect on its behavior."]
            #[link_name = "\u{1}_ZN2js15GetErrorMessageEPvj"]
            pub fn GetErrorMessage(
                userRef: *mut ::std::os::raw::c_void,
                errorNumber: ::std::os::raw::c_uint,
            ) -> *const root::JSErrorFormatString;
        }
        extern "C" {
            #[doc = " Tell the JS engine which Class is used for WindowProxy objects. Used by the\n functions below."]
            #[link_name = "\u{1}_ZN2js19SetWindowProxyClassEP9JSContextPK7JSClass"]
            pub fn SetWindowProxyClass(cx: *mut root::JSContext, clasp: *const root::JSClass);
        }
        extern "C" {
            #[doc = " Associates a WindowProxy with a Window (global object). `windowProxy` must\n have the Class set by SetWindowProxyClass."]
            #[link_name = "\u{1}_ZN2js14SetWindowProxyEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn SetWindowProxy(
                cx: *mut root::JSContext,
                global: root::JS::Handle<*mut root::JSObject>,
                windowProxy: root::JS::Handle<*mut root::JSObject>,
            );
        }
        extern "C" {
            #[doc = " Returns true iff `obj` has the WindowProxy Class (see SetWindowProxyClass)."]
            #[link_name = "\u{1}_ZN2js13IsWindowProxyEP8JSObject"]
            pub fn IsWindowProxy(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " If `obj` is a WindowProxy, get its associated Window (the compartment's\n global), else return `obj`. This function is infallible and never returns\n nullptr."]
            #[link_name = "\u{1}_ZN2js21ToWindowIfWindowProxyEP8JSObject"]
            pub fn ToWindowIfWindowProxy(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the script private value associated with an object, if any.\n\n The private value is set with SetScriptPrivate() or SetModulePrivate() and is\n internally stored on the relevant ScriptSourceObject.\n\n This is used by the cycle collector to trace through\n ScriptSourceObjects. This allows private values to contain an nsISupports\n pointer and hence support references to cycle collected C++ objects."]
            #[link_name = "\u{1}_ZN2js21MaybeGetScriptPrivateEP8JSObject"]
            pub fn MaybeGetScriptPrivate(object: *mut root::JSObject) -> root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17IsArgumentsObjectEN2JS6HandleIP8JSObjectEE"]
            pub fn IsArgumentsObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15AddRawValueRootEP9JSContextPN2JS5ValueEPKc"]
            pub fn AddRawValueRoot(
                cx: *mut root::JSContext,
                vp: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18RemoveRawValueRootEP9JSContextPN2JS5ValueE"]
            pub fn RemoveRawValueRoot(cx: *mut root::JSContext, vp: *mut root::JS::Value);
        }
        extern "C" {
            #[doc = " Use the runtime's internal handling of job queues for Promise jobs.\n\n Most embeddings, notably web browsers, will have their own task scheduling\n systems and need to integrate handling of Promise jobs into that, so they\n will want to manage job queues themselves. For basic embeddings such as the\n JS shell that don't have an event loop of their own, it's easier to have\n SpiderMonkey handle job queues internally.\n\n Note that the embedding still has to trigger processing of job queues at\n right time(s), such as after evaluation of a script has run to completion."]
            #[link_name = "\u{1}_ZN2js20UseInternalJobQueuesEP9JSContext"]
            pub fn UseInternalJobQueues(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Enqueue |job| on the internal job queue.\n\n This is useful in tests for creating situations where a call occurs with no\n other JavaScript on the stack."]
            #[link_name = "\u{1}_ZN2js10EnqueueJobEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn EnqueueJob(cx: *mut root::JSContext, job: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[doc = " Instruct the runtime to stop draining the internal job queue.\n\n Useful if the embedding is in the process of quitting in reaction to a\n builtin being called, or if it wants to resume executing jobs later on."]
            #[link_name = "\u{1}_ZN2js20StopDrainingJobQueueEP9JSContext"]
            pub fn StopDrainingJobQueue(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Instruct the runtime to restart draining the internal job queue after\n stopping it with StopDrainingJobQueue."]
            #[link_name = "\u{1}_ZN2js23RestartDrainingJobQueueEP9JSContext"]
            pub fn RestartDrainingJobQueue(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7RunJobsEP9JSContext"]
            pub fn RunJobs(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12GetRealmZoneEPN2JS5RealmE"]
            pub fn GetRealmZone(realm: *mut root::JS::Realm) -> *mut root::JS::Zone;
        }
        pub type PreserveWrapperCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::JSContext, arg2: root::JS::HandleObject) -> bool,
        >;
        pub type HasReleasedWrapperCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: root::JS::HandleObject) -> bool>;
        extern "C" {
            #[link_name = "\u{1}_ZN2js13IsSystemRealmEPN2JS5RealmE"]
            pub fn IsSystemRealm(realm: *mut root::JS::Realm) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19IsSystemCompartmentEPN2JS11CompartmentE"]
            pub fn IsSystemCompartment(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12IsSystemZoneEPN2JS4ZoneE"]
            pub fn IsSystemZone(zone: *mut root::JS::Zone) -> bool;
        }
        #[repr(C)]
        pub struct WeakMapTracer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WeakMapTracer {
            pub vtable_: *const WeakMapTracer__bindgen_vtable,
            pub runtime: *mut root::JSRuntime,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of WeakMapTracer"][::std::mem::size_of::<WeakMapTracer>() - 16usize];
            ["Alignment of WeakMapTracer"][::std::mem::align_of::<WeakMapTracer>() - 8usize];
            ["Offset of field: WeakMapTracer::runtime"]
                [::std::mem::offset_of!(WeakMapTracer, runtime) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js13TraceWeakMapsEPNS_13WeakMapTracerE"]
            pub fn TraceWeakMaps(trc: *mut root::js::WeakMapTracer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18AreGCGrayBitsValidEP9JSRuntime"]
            pub fn AreGCGrayBitsValid(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21ZoneGlobalsAreAllGrayEPN2JS4ZoneE"]
            pub fn ZoneGlobalsAreAllGray(zone: *mut root::JS::Zone) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js37IsCompartmentZoneSweepingOrCompactingEPN2JS11CompartmentE"]
            pub fn IsCompartmentZoneSweepingOrCompacting(comp: *mut root::JS::Compartment) -> bool;
        }
        pub type IterateGCThingCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: root::JS::GCCellPtr,
                arg3: *const root::JS::AutoRequireNoGC,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2js23TraceGrayWrapperTargetsEP8JSTracerPN2JS4ZoneE"]
            pub fn TraceGrayWrapperTargets(trc: *mut root::JSTracer, zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Invoke cellCallback on every gray JSObject in the given zone."]
            #[link_name = "\u{1}_ZN2js18IterateGrayObjectsEPN2JS4ZoneEPFvPvNS0_9GCCellPtrERKNS0_15AutoRequireNoGCEES3_"]
            pub fn IterateGrayObjects(
                zone: *mut root::JS::Zone,
                cellCallback: root::js::IterateGCThingCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17GetAnyRealmInZoneEPN2JS4ZoneE"]
            pub fn GetAnyRealmInZone(zone: *mut root::JS::Zone) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27GetFirstGlobalInCompartmentEPN2JS11CompartmentE"]
            pub fn GetFirstGlobalInCompartment(
                comp: *mut root::JS::Compartment,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24CompartmentHasLiveGlobalEPN2JS11CompartmentE"]
            pub fn CompartmentHasLiveGlobal(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21IsSharableCompartmentEPN2JS11CompartmentE"]
            pub fn IsSharableCompartment(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15ProtoKeyToClassE10JSProtoKey"]
            pub fn ProtoKeyToClass(key: root::JSProtoKey) -> *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js30ShouldIgnorePropertyDefinitionEP9JSContext10JSProtoKeyN2JS11PropertyKeyE"]
            pub fn ShouldIgnorePropertyDefinition(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                id: root::jsid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16IsFunctionObjectEP8JSObject"]
            pub fn IsFunctionObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34UninlinedIsCrossCompartmentWrapperEPK8JSObject"]
            pub fn UninlinedIsCrossCompartmentWrapper(obj: *const root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextP8JSObject"]
            pub fn AssertSameCompartment(cx: *mut root::JSContext, obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn AssertSameCompartment1(cx: *mut root::JSContext, v: root::JS::HandleValue);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23NotifyAnimationActivityEP8JSObject"]
            pub fn NotifyAnimationActivity(obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26DefineFunctionWithReservedEP9JSContextP8JSObjectPKcPFbS1_jPN2JS5ValueEEjj"]
            pub fn DefineFunctionWithReserved(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                attrs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23NewFunctionWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjPKc"]
            pub fn NewFunctionWithReserved(
                cx: *mut root::JSContext,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                name: *const ::std::os::raw::c_char,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27NewFunctionByIdWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjNS2_11PropertyKeyE"]
            pub fn NewFunctionByIdWithReserved(
                cx: *mut root::JSContext,
                native: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                id: root::jsid,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js35NewFunctionByIdWithReservedAndProtoEP9JSContextPFbS1_jPN2JS5ValueEENS2_6HandleIP8JSObjectEEjjNS2_11PropertyKeyE"]
            pub fn NewFunctionByIdWithReservedAndProto(
                cx: *mut root::JSContext,
                native: root::JSNative,
                proto: root::JS::Handle<*mut root::JSObject>,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                id: root::jsid,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Get or set function's reserved slot value.\n `fun` should be a function created with `*WithReserved` API above.\n Such functions have 2 reserved slots, and `which` can be either 0 or 1."]
            #[link_name = "\u{1}_ZN2js25GetFunctionNativeReservedEP8JSObjectm"]
            pub fn GetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
            ) -> *const root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25SetFunctionNativeReservedEP8JSObjectmRKN2JS5ValueE"]
            pub fn SetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
                val: *const root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25FunctionHasNativeReservedEP8JSObject"]
            pub fn FunctionHasNativeReserved(fun: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetObjectProtoEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleIS5_EE"]
            pub fn GetObjectProto(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                proto: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18GetStaticPrototypeEP8JSObject"]
            pub fn GetStaticPrototype(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20GetRealmOriginalEvalEP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
            pub fn GetRealmOriginalEval(
                cx: *mut root::JSContext,
                eval: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Add some or all property keys of obj to the id vector *props.\n\n The flags parameter controls which property keys are added. Pass a\n combination of the following bits:\n\n     JSITER_OWNONLY - Don't also search the prototype chain; only consider\n       obj's own properties.\n\n     JSITER_HIDDEN - Include nonenumerable properties.\n\n     JSITER_SYMBOLS - Include property keys that are symbols. The default\n       behavior is to filter out symbols.\n\n     JSITER_SYMBOLSONLY - Exclude non-symbol property keys.\n\n This is the closest C++ API we have to `Reflect.ownKeys(obj)`, or\n equivalently, the ES6 [[OwnPropertyKeys]] internal method. Pass\n `JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS` as flags to get\n results that match the output of Reflect.ownKeys."]
            #[link_name = "\u{1}_ZN2js15GetPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEEjNS2_13MutableHandleINS2_13StackGCVectorINS2_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn GetPropertyKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                flags: ::std::os::raw::c_uint,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Determine whether the given string is an array index in the sense of\n <https://tc39.github.io/ecma262/#array-index>.\n\n If it isn't, returns false.\n\n If it is, returns true and outputs the index in *indexp."]
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEPK14JSLinearStringPj"]
            pub fn StringIsArrayIndex(str_: *const root::JSLinearString, indexp: *mut u32) -> bool;
        }
        extern "C" {
            #[doc = " Overload of StringIsArrayIndex taking a (char16_t*,length) pair. Behaves\n the same as the JSLinearString version."]
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEPKDsjPj"]
            pub fn StringIsArrayIndex1(str_: *const u16, length: u32, indexp: *mut u32) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27SetPreserveWrapperCallbacksEP9JSContextPFbS1_N2JS6HandleIP8JSObjectEEEPFbS6_E"]
            pub fn SetPreserveWrapperCallbacks(
                cx: *mut root::JSContext,
                preserveWrapper: root::js::PreserveWrapperCallback,
                hasReleasedWrapper: root::js::HasReleasedWrapperCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28IsObjectInContextCompartmentEP8JSObjectPK9JSContext"]
            pub fn IsObjectInContextCompartment(
                obj: *mut root::JSObject,
                cx: *const root::JSContext,
            ) -> bool;
        }
        pub type DOMInstanceClassHasProtoAtDepth = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::JSClass, arg2: u32, arg3: u32) -> bool,
        >;
        pub type DOMInstanceClassIsError =
            ::std::option::Option<unsafe extern "C" fn(arg1: *const root::JSClass) -> bool>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct JSDOMCallbacks {
            pub instanceClassMatchesProto: root::js::DOMInstanceClassHasProtoAtDepth,
            pub instanceClassIsError: root::js::DOMInstanceClassIsError,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JSDOMCallbacks"][::std::mem::size_of::<JSDOMCallbacks>() - 16usize];
            ["Alignment of JSDOMCallbacks"][::std::mem::align_of::<JSDOMCallbacks>() - 8usize];
            ["Offset of field: JSDOMCallbacks::instanceClassMatchesProto"]
                [::std::mem::offset_of!(JSDOMCallbacks, instanceClassMatchesProto) - 0usize];
            ["Offset of field: JSDOMCallbacks::instanceClassIsError"]
                [::std::mem::offset_of!(JSDOMCallbacks, instanceClassIsError) - 8usize];
        };
        pub type DOMCallbacks = root::js::JSDOMCallbacks;
        extern "C" {
            #[link_name = "\u{1}_ZN2js15SetDOMCallbacksEP9JSContextPKNS_14JSDOMCallbacksE"]
            pub fn SetDOMCallbacks(
                cx: *mut root::JSContext,
                callbacks: *const root::js::DOMCallbacks,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15GetDOMCallbacksEP9JSContext"]
            pub fn GetDOMCallbacks(cx: *mut root::JSContext) -> *const root::js::DOMCallbacks;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19GetTestingFunctionsEP9JSContext"]
            pub fn GetTestingFunctions(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get an error type name from a JSExnType constant.\n Returns nullptr for invalid arguments and JSEXN_INTERNALERR"]
            #[link_name = "\u{1}_ZN2js16GetErrorTypeNameEP9JSContexts"]
            pub fn GetErrorTypeName(
                cx: *mut root::JSContext,
                exnType: i16,
            ) -> *mut root::JSLinearString;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NukeReferencesToWindow {
            NukeWindowReferences = 0,
            DontNukeWindowReferences = 1,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NukeReferencesFromTarget {
            NukeAllReferences = 0,
            NukeIncomingReferences = 1,
        }
        #[repr(C)]
        pub struct CompartmentFilter__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompartmentFilter {
            pub vtable_: *const CompartmentFilter__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CompartmentFilter"][::std::mem::size_of::<CompartmentFilter>() - 8usize];
            ["Alignment of CompartmentFilter"]
                [::std::mem::align_of::<CompartmentFilter>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllCompartments {
            pub _base: root::js::CompartmentFilter,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AllCompartments"][::std::mem::size_of::<AllCompartments>() - 8usize];
            ["Alignment of AllCompartments"][::std::mem::align_of::<AllCompartments>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SingleCompartment {
            pub _base: root::js::CompartmentFilter,
            pub ours: *mut root::JS::Compartment,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of SingleCompartment"][::std::mem::size_of::<SingleCompartment>() - 16usize];
            ["Alignment of SingleCompartment"]
                [::std::mem::align_of::<SingleCompartment>() - 8usize];
            ["Offset of field: SingleCompartment::ours"]
                [::std::mem::offset_of!(SingleCompartment, ours) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js28NukeCrossCompartmentWrappersEP9JSContextRKNS_17CompartmentFilterEPN2JS5RealmENS_22NukeReferencesToWindowENS_24NukeReferencesFromTargetE"]
            pub fn NukeCrossCompartmentWrappers(
                cx: *mut root::JSContext,
                sourceFilter: *const root::js::CompartmentFilter,
                target: *mut root::JS::Realm,
                nukeReferencesToWindow: root::js::NukeReferencesToWindow,
                nukeReferencesFromTarget: root::js::NukeReferencesFromTarget,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15AllowNewWrapperEPN2JS11CompartmentEP8JSObject"]
            pub fn AllowNewWrapper(
                target: *mut root::JS::Compartment,
                obj: *mut root::JSObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16NukedObjectRealmEP8JSObject"]
            pub fn NukedObjectRealm(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Detect whether the internal date value is NaN."]
            #[link_name = "\u{1}_ZN2js11DateIsValidEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn DateIsValid(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isValid: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21DateGetMsecSinceEpochEP9JSContextN2JS6HandleIP8JSObjectEEPd"]
            pub fn DateGetMsecSinceEpoch(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                msecSinceEpoch: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11GetSCOffsetEP23JSStructuredCloneWriter"]
            pub fn GetSCOffset(writer: *mut root::JSStructuredCloneWriter) -> u64;
        }
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " PrepareScriptEnvironmentAndInvoke asserts the embedder has registered a\n ScriptEnvironmentPreparer and then it calls the preparer's 'invoke' method\n with the given |closure|, with the assumption that the preparer will set up\n any state necessary to run script in |global|, invoke |closure| with a valid\n JSContext*, report any exceptions thrown from the closure, and return.\n\n PrepareScriptEnvironmentAndInvoke will report any exceptions that are thrown\n by the closure.  Consumers who want to propagate back whether the closure\n succeeded should do so via members of the closure itself."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ScriptEnvironmentPreparer {
            pub vtable_: *const ScriptEnvironmentPreparer__bindgen_vtable,
        }
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer_Closure__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ScriptEnvironmentPreparer_Closure {
            pub vtable_: *const ScriptEnvironmentPreparer_Closure__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ScriptEnvironmentPreparer_Closure"]
                [::std::mem::size_of::<ScriptEnvironmentPreparer_Closure>() - 8usize];
            ["Alignment of ScriptEnvironmentPreparer_Closure"]
                [::std::mem::align_of::<ScriptEnvironmentPreparer_Closure>() - 8usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ScriptEnvironmentPreparer"]
                [::std::mem::size_of::<ScriptEnvironmentPreparer>() - 8usize];
            ["Alignment of ScriptEnvironmentPreparer"]
                [::std::mem::align_of::<ScriptEnvironmentPreparer>() - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js33PrepareScriptEnvironmentAndInvokeEP9JSContextN2JS6HandleIP8JSObjectEERNS_25ScriptEnvironmentPreparer7ClosureE"]
            pub fn PrepareScriptEnvironmentAndInvoke(
                cx: *mut root::JSContext,
                global: root::JS::HandleObject,
                closure: *mut root::js::ScriptEnvironmentPreparer_Closure,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28SetScriptEnvironmentPreparerEP9JSContextPNS_25ScriptEnvironmentPreparerE"]
            pub fn SetScriptEnvironmentPreparer(
                cx: *mut root::JSContext,
                preparer: *mut root::js::ScriptEnvironmentPreparer,
            );
        }
        #[repr(C)]
        pub struct AllocationMetadataBuilder__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllocationMetadataBuilder {
            pub vtable_: *const AllocationMetadataBuilder__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AllocationMetadataBuilder"]
                [::std::mem::size_of::<AllocationMetadataBuilder>() - 8usize];
            ["Alignment of AllocationMetadataBuilder"]
                [::std::mem::align_of::<AllocationMetadataBuilder>() - 8usize];
        };
        extern "C" {
            #[doc = " Specify a callback to invoke when creating each JS object in the current\n compartment, which may return a metadata object to associate with the\n object."]
            #[link_name = "\u{1}_ZN2js28SetAllocationMetadataBuilderEP9JSContextPKNS_25AllocationMetadataBuilderE"]
            pub fn SetAllocationMetadataBuilder(
                cx: *mut root::JSContext,
                callback: *const root::js::AllocationMetadataBuilder,
            );
        }
        extern "C" {
            #[doc = " Get the metadata associated with an object."]
            #[link_name = "\u{1}_ZN2js21GetAllocationMetadataEP8JSObject"]
            pub fn GetAllocationMetadata(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20GetElementsWithAdderEP9JSContextN2JS6HandleIP8JSObjectEES6_jjPNS_12ElementAdderE"]
            pub fn GetElementsWithAdder(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15ForwardToNativeEP9JSContextPFbS1_jPN2JS5ValueEERKNS2_8CallArgsE"]
            pub fn ForwardToNative(
                cx: *mut root::JSContext,
                native: root::JSNative,
                args: *const root::JS::CallArgs,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31ExecuteInFrameScriptEnvironmentEP9JSContextN2JS6HandleIP8JSObjectEENS3_IP8JSScriptEENS2_13MutableHandleIS5_EE"]
            pub fn ExecuteInFrameScriptEnvironment(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                script: root::JS::HandleScript,
                scope: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12IsSavedFrameEP8JSObject"]
            pub fn IsSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19ReportIsNotFunctionEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ReportIsNotFunction(cx: *mut root::JSContext, v: root::JS::HandleValue) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoAssertNoContentJS {
            pub context_: *mut root::JSContext,
            pub prevAllowContentJS_: bool,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoAssertNoContentJS"]
                [::std::mem::size_of::<AutoAssertNoContentJS>() - 16usize];
            ["Alignment of AutoAssertNoContentJS"]
                [::std::mem::align_of::<AutoAssertNoContentJS>() - 8usize];
            ["Offset of field: AutoAssertNoContentJS::context_"]
                [::std::mem::offset_of!(AutoAssertNoContentJS, context_) - 0usize];
            ["Offset of field: AutoAssertNoContentJS::prevAllowContentJS_"]
                [::std::mem::offset_of!(AutoAssertNoContentJS, prevAllowContentJS_) - 8usize];
        };
        extern "C" {
            #[doc = " This function reports memory used by a zone in bytes, this includes:\n  * The size of this JS GC zone.\n  * Malloc memory referred to from this zone.\n  * JIT memory for this zone.\n\n Note that malloc memory referred to from this zone can include\n SharedArrayBuffers which may also be referred to from other zones. Adding the\n memory usage of multiple zones may lead to an over-estimate."]
            #[link_name = "\u{1}_ZN2js21GetMemoryUsageForZoneEPN2JS4ZoneE"]
            pub fn GetMemoryUsageForZone(zone: *mut root::JS::Zone) -> u64;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryUse {
            __bindgen_cannot_repr_c_on_empty_enum = 0,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27GetSharedMemoryUsageForZoneEPN2JS4ZoneE"]
            pub fn GetSharedMemoryUsageForZone(
                zone: *mut root::JS::Zone,
            ) -> *const root::js::gc::SharedMemoryMap;
        }
        extern "C" {
            #[doc = " This function only reports GC heap memory,\n and not malloc allocated memory associated with GC things.\n It reports the total of all memory for the whole Runtime."]
            #[link_name = "\u{1}_ZN2js14GetGCHeapUsageEP9JSContext"]
            pub fn GetGCHeapUsage(cx: *mut root::JSContext) -> u64;
        }
        #[repr(C)]
        pub struct CompartmentTransplantCallback__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompartmentTransplantCallback {
            pub vtable_: *const CompartmentTransplantCallback__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CompartmentTransplantCallback"]
                [::std::mem::size_of::<CompartmentTransplantCallback>() - 8usize];
            ["Alignment of CompartmentTransplantCallback"]
                [::std::mem::align_of::<CompartmentTransplantCallback>() - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2js24RemapRemoteWindowProxiesEP9JSContextPNS_29CompartmentTransplantCallbackEN2JS13MutableHandleIP8JSObjectEE"]
            pub fn RemapRemoteWindowProxies(
                cx: *mut root::JSContext,
                callback: *mut root::js::CompartmentTransplantCallback,
                newTarget: root::JS::MutableHandleObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26GetObjectZoneFromAnyThreadEPK8JSObject"]
            pub fn GetObjectZoneFromAnyThread(obj: *const root::JSObject) -> *mut root::JS::Zone;
        }
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type Heap<T> = crate::jsgc::Heap<T>;
        pub type Rooted<T> = crate::jsgc::Rooted<T>;
        pub type StackGCVector<T, AllocPolicy> = crate::jsgc::StackGCVector<T, AllocPolicy>;
        #[doc = " Type representing a JS error or exception. At the moment this only\n \"represents\" an error in a rather abstract way."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Error {
            pub kind: root::JS::Error_ErrorKind,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Error_ErrorKind {
            Unspecified = 2,
            OOM = 4,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Error"][::std::mem::size_of::<Error>() - 8usize];
            ["Alignment of Error"][::std::mem::align_of::<Error>() - 8usize];
            ["Offset of field: Error::kind"][::std::mem::offset_of!(Error, kind) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OOM {
            pub _base: root::JS::Error,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of OOM"][::std::mem::size_of::<OOM>() - 8usize];
            ["Alignment of OOM"][::std::mem::align_of::<OOM>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UnusedZero {
            pub _address: u8,
        }
        pub type UnusedZero_StorageType = root::std::underlying_type_t;
        #[doc = " `Result` is intended to be the return type of JSAPI calls and internal\n functions that can run JS code or allocate memory from the JS GC heap. Such\n functions can:\n\n -   succeed, possibly returning a value;\n\n -   fail with a JS exception (out-of-memory falls in this category); or\n\n -   fail because JS execution was terminated, which occurs when e.g. a\n     user kills a script from the \"slow script\" UI. This is also how we\n     unwind the stack when the debugger forces the current function to\n     return. JS `catch` blocks can't catch this kind of failure,\n     and JS `finally` blocks don't execute."]
        pub type Result = root::mozilla::Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCContext {
            _unused: [u8; 0],
        }
        pub type Latin1Char = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Symbol {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BigInt {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Compartment {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Realm {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Runtime {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Zone {
            _unused: [u8; 0],
        }
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleFunction = root::JS::Handle<*mut root::JSFunction>;
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleId = root::JS::Handle<root::JS::PropertyKey>;
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleObject = root::JS::Handle<*mut root::JSObject>;
        pub type HandleScript = root::JS::Handle<*mut root::JSScript>;
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleString = root::JS::Handle<*mut root::JSString>;
        pub type HandleSymbol = root::JS::Handle<*mut root::JS::Symbol>;
        pub type HandleBigInt = root::JS::Handle<*mut root::JS::BigInt>;
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        pub type HandleValue = root::JS::Handle<root::JS::Value>;
        pub type HandleValueVector =
            root::JS::Handle<root::JS::StackGCVector<root::JS::Value, root::js::TempAllocPolicy>>;
        pub type HandleIdVector = root::JS::Handle<
            root::JS::StackGCVector<root::JS::PropertyKey, root::js::TempAllocPolicy>,
        >;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleFunction = root::JS::MutableHandle<*mut root::JSFunction>;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleId = root::JS::MutableHandle<root::JS::PropertyKey>;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleObject = root::JS::MutableHandle<*mut root::JSObject>;
        pub type MutableHandleScript = root::JS::MutableHandle<*mut root::JSScript>;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleString = root::JS::MutableHandle<*mut root::JSString>;
        pub type MutableHandleSymbol = root::JS::MutableHandle<*mut root::JS::Symbol>;
        pub type MutableHandleBigInt = root::JS::MutableHandle<*mut root::JS::BigInt>;
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        pub type MutableHandleValue = root::JS::MutableHandle<root::JS::Value>;
        pub type MutableHandleValueVector = root::JS::MutableHandle<
            root::JS::StackGCVector<root::JS::Value, root::js::TempAllocPolicy>,
        >;
        #[doc = " Local variable of type T whose value is always rooted. This is typically\n used for local variables, or for non-rooted values being passed to a\n function that requires a handle, e.g. Foo(Root<T>(cx, x)).\n\n If you want to add additional methods to Rooted for a specific\n specialization, define a RootedOperations<T> specialization containing them."]
        pub type RootedObject = root::JS::Rooted<*mut root::JSObject>;
        pub type RootedFunction = root::JS::Rooted<*mut root::JSFunction>;
        pub type RootedScript = root::JS::Rooted<*mut root::JSScript>;
        pub type RootedString = root::JS::Rooted<*mut root::JSString>;
        pub type RootedSymbol = root::JS::Rooted<*mut root::JS::Symbol>;
        pub type RootedBigInt = root::JS::Rooted<*mut root::JS::BigInt>;
        pub type RootedId = root::JS::Rooted<root::JS::PropertyKey>;
        #[doc = " Local variable of type T whose value is always rooted. This is typically\n used for local variables, or for non-rooted values being passed to a\n function that requires a handle, e.g. Foo(Root<T>(cx, x)).\n\n If you want to add additional methods to Rooted for a specific\n specialization, define a RootedOperations<T> specialization containing them."]
        pub type RootedValue = root::JS::Rooted<root::JS::Value>;
        pub type PersistentRootedFunction = u8;
        pub type PersistentRootedId = u8;
        #[doc = " A copyable, assignable global GC root type with arbitrary lifetime, an\n infallible constructor, and automatic unrooting on destruction.\n\n These roots can be used in heap-allocated data structures, so they are not\n associated with any particular JSContext or stack. They are registered with\n the JSRuntime itself, without locking. Initialization may take place on\n construction, or in two phases if the no-argument constructor is called\n followed by init().\n\n Note that you must not use an PersistentRooted in an object owned by a JS\n object:\n\n Whenever one object whose lifetime is decided by the GC refers to another\n such object, that edge must be traced only if the owning JS object is traced.\n This applies not only to JS objects (which obviously are managed by the GC)\n but also to C++ objects owned by JS objects.\n\n If you put a PersistentRooted in such a C++ object, that is almost certainly\n a leak. When a GC begins, the referent of the PersistentRooted is treated as\n live, unconditionally (because a PersistentRooted is a *root*), even if the\n JS object that owns it is unreachable. If there is any path from that\n referent back to the JS object, then the C++ object containing the\n PersistentRooted will not be destructed, and the whole blob of objects will\n not be freed, even if there are no references to them from the outside.\n\n In the context of Firefox, this is a severe restriction: almost everything in\n Firefox is owned by some JS object or another, so using PersistentRooted in\n such objects would introduce leaks. For these kinds of edges, Heap<T> or\n TenuredHeap<T> would be better types. It's up to the implementor of the type\n containing Heap<T> or TenuredHeap<T> members to make sure their referents get\n marked when the object itself is marked."]
        pub type PersistentRootedObject = root::__BindgenOpaqueArray<u64, 4usize>;
        pub type PersistentRootedScript = u8;
        pub type PersistentRootedString = u8;
        pub type PersistentRootedSymbol = u8;
        pub type PersistentRootedBigInt = u8;
        pub type PersistentRootedValue = u8;
        pub type PersistentRootedIdVector = u8;
        pub type PersistentRootedObjectVector = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TraceKind {
            Object = 0,
            BigInt = 1,
            String = 2,
            Symbol = 3,
            Shape = 4,
            BaseShape = 5,
            Null = 6,
            JitCode = 7,
            Script = 8,
            Scope = 9,
            RegExpShared = 10,
            GetterSetter = 11,
            PropMap = 12,
            SmallBuffer = 13,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MapTypeToTraceKind {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct IsBaseTraceType {
            pub _base: root::std::false_type,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_BaseShape_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_BaseShape_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_JitCode_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_JitCode_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_Scope_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_Scope_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_JSObject_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_JSObject_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_BaseScript_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_BaseScript_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_Shape_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_Shape_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_JSString_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_JSString_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_Symbol_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_Symbol_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_BigInt_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_BigInt_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_RegExpShared_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_RegExpShared_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_GetterSetter_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_GetterSetter_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_PropMap_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_PropMap_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: IsBaseTraceType_open0_SmallBuffer_close0"]
                [::std::mem::size_of::<root::JS::IsBaseTraceType>() - 1usize];
            ["Align of template specialization: IsBaseTraceType_open0_SmallBuffer_close0"]
                [::std::mem::align_of::<root::JS::IsBaseTraceType>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_BaseShape_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_BaseShape_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_JitCode_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_JitCode_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_Scope_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_Scope_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_JSObject_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_JSObject_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_BaseScript_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_BaseScript_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_Shape_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_Shape_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_JSString_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_JSString_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_Symbol_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_Symbol_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_BigInt_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_BigInt_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_RegExpShared_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_RegExpShared_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_GetterSetter_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_GetterSetter_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_PropMap_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_PropMap_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_SmallBuffer_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_SmallBuffer_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_JSLinearString_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_JSLinearString_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_JSFunction_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_JSFunction_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToTraceKind_open0_JSScript_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToTraceKind>() - 1usize];
            ["Align of template specialization: MapTypeToTraceKind_open0_JSScript_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToTraceKind>() - 1usize];
        };
        #[repr(i8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RootKind {
            BaseShape = 0,
            JitCode = 1,
            Scope = 2,
            Object = 3,
            Script = 4,
            Shape = 5,
            String = 6,
            Symbol = 7,
            BigInt = 8,
            RegExpShared = 9,
            GetterSetter = 10,
            PropMap = 11,
            SmallBuffer = 12,
            Id = 13,
            Value = 14,
            Traceable = 15,
            Limit = 16,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MapTypeToRootKind {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToRootKind_open0_ptr_Realm_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToRootKind>() - 1usize];
            ["Align of template specialization: MapTypeToRootKind_open0_ptr_Realm_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToRootKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToRootKind_open0_Value_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToRootKind>() - 1usize];
            ["Align of template specialization: MapTypeToRootKind_open0_Value_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToRootKind>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: MapTypeToRootKind_open0_PropertyKey_close0"]
                [::std::mem::size_of::<root::JS::MapTypeToRootKind>() - 1usize];
            ["Align of template specialization: MapTypeToRootKind_open0_PropertyKey_close0"]
                [::std::mem::align_of::<root::JS::MapTypeToRootKind>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoEnterCycleCollection {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoEnterCycleCollection"]
                [::std::mem::size_of::<AutoEnterCycleCollection>() - 1usize];
            ["Alignment of AutoEnterCycleCollection"]
                [::std::mem::align_of::<AutoEnterCycleCollection>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DeletePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of FreePolicy"][::std::mem::size_of::<FreePolicy>() - 1usize];
            ["Alignment of FreePolicy"][::std::mem::align_of::<FreePolicy>() - 1usize];
        };
        pub type UniqueChars = u64;
        pub type UniqueTwoByteChars = u8;
        pub type UniqueLatin1Chars = u64;
        pub type UniqueWideChars = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct DefineComparisonOps {
                pub _base: root::std::false_type,
            }
            pub type RootedTraits = root::std::conditional_t;
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail11ComputeThisEP9JSContextPNS_5ValueENS_13MutableHandleIP8JSObjectEE"]
                pub fn ComputeThis(
                    cx: *mut root::JSContext,
                    vp: *mut root::JS::Value,
                    thisObject: root::JS::MutableHandleObject,
                ) -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IncludeUsedRval {
                pub usedRval_: bool,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of IncludeUsedRval"][::std::mem::size_of::<IncludeUsedRval>() - 1usize];
                ["Alignment of IncludeUsedRval"]
                    [::std::mem::align_of::<IncludeUsedRval>() - 1usize];
                ["Offset of field: IncludeUsedRval::usedRval_"]
                    [::std::mem::offset_of!(IncludeUsedRval, usedRval_) - 0usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct NoUsedRval {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of NoUsedRval"][::std::mem::size_of::<NoUsedRval>() - 1usize];
                ["Alignment of NoUsedRval"][::std::mem::align_of::<NoUsedRval>() - 1usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct CallArgsBase {
                pub _address: u8,
            }
            pub const MaybeLimitedColumnNumber_OriginValue: u32 = 1;
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail24StringToLinearStringSlowEP9JSContextP8JSString"]
                pub fn StringToLinearStringSlow(
                    cx: *mut root::JSContext,
                    str_: *mut root::JSString,
                ) -> *mut root::JSLinearString;
            }
            pub type Int64Limits = u8;
            pub type Uint64Limits = u8;
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail15BigIntFromInt64EP9JSContextl"]
                pub fn BigIntFromInt64(cx: *mut root::JSContext, num: i64)
                    -> *mut root::JS::BigInt;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail16BigIntFromUint64EP9JSContextm"]
                pub fn BigIntFromUint64(
                    cx: *mut root::JSContext,
                    num: u64,
                ) -> *mut root::JS::BigInt;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail14BigIntFromBoolEP9JSContextb"]
                pub fn BigIntFromBool(cx: *mut root::JSContext, b: bool) -> *mut root::JS::BigInt;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct NumberToBigIntConverter {
                pub _address: u8,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of template specialization: NumberToBigIntConverter_open0_bool__void_close0"] [:: std :: mem :: size_of :: < root :: JS :: detail :: NumberToBigIntConverter > () - 1usize] ;
                ["Align of template specialization: NumberToBigIntConverter_open0_bool__void_close0"] [:: std :: mem :: align_of :: < root :: JS :: detail :: NumberToBigIntConverter > () - 1usize] ;
            };
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail13BigIntIsInt64EPKNS_6BigIntEPl"]
                pub fn BigIntIsInt64(bi: *const root::JS::BigInt, result: *mut i64) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail14BigIntIsUint64EPKNS_6BigIntEPm"]
                pub fn BigIntIsUint64(bi: *const root::JS::BigInt, result: *mut u64) -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BigIntToNumberChecker {
                pub _address: u8,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum InitState {
                Uninitialized = 0,
                Initializing = 1,
                Running = 2,
                ShutDown = 3,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum FrontendOnly {
                No = 0,
                Yes = 1,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail25InitWithFailureDiagnosticEbNS0_12FrontendOnlyE"]
                pub fn InitWithFailureDiagnostic(
                    isDebugBuild: bool,
                    frontendOnly: root::JS::detail::FrontendOnly,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail26SetReservedSlotWithBarrierEP8JSObjectmRKNS_5ValueE"]
                pub fn SetReservedSlotWithBarrier(
                    obj: *mut root::JSObject,
                    slot: usize,
                    value: *const root::JS::Value,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail19CallMethodIfWrappedEP9JSContextPFbNS_6HandleINS_5ValueEEEEPFbS2_RKNS_8CallArgsEESA_"]
                pub fn CallMethodIfWrapped(
                    cx: *mut root::JSContext,
                    test: root::JS::IsAcceptableThis,
                    impl_: root::JS::NativeImpl,
                    args: *const root::JS::CallArgs,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail19ReportSourceTooLongEP9JSContext"]
                pub fn ReportSourceTooLong(cx: *mut root::JSContext);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail19ReportSourceTooLongEPN2js15FrontendContextE"]
                pub fn ReportSourceTooLong1(fc: *mut root::JS::FrontendContext);
            }
            pub type ExternalTypeOf_t = u8;
        }
        pub mod shadow {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct String {
                pub flags_: usize,
                pub __bindgen_anon_1: root::JS::shadow::String__bindgen_ty_1,
                pub externalCallbacks: *const root::JSExternalStringCallbacks,
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub union String__bindgen_ty_1 {
                pub nonInlineCharsLatin1: *const root::JS::Latin1Char,
                pub nonInlineCharsTwoByte: *const u16,
                pub inlineStorageLatin1: [root::JS::Latin1Char; 1usize],
                pub inlineStorageTwoByte: [u16; 1usize],
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of String__bindgen_ty_1"]
                    [::std::mem::size_of::<String__bindgen_ty_1>() - 8usize];
                ["Alignment of String__bindgen_ty_1"]
                    [::std::mem::align_of::<String__bindgen_ty_1>() - 8usize];
                ["Offset of field: String__bindgen_ty_1::nonInlineCharsLatin1"]
                    [::std::mem::offset_of!(String__bindgen_ty_1, nonInlineCharsLatin1) - 0usize];
                ["Offset of field: String__bindgen_ty_1::nonInlineCharsTwoByte"]
                    [::std::mem::offset_of!(String__bindgen_ty_1, nonInlineCharsTwoByte) - 0usize];
                ["Offset of field: String__bindgen_ty_1::inlineStorageLatin1"]
                    [::std::mem::offset_of!(String__bindgen_ty_1, inlineStorageLatin1) - 0usize];
                ["Offset of field: String__bindgen_ty_1::inlineStorageTwoByte"]
                    [::std::mem::offset_of!(String__bindgen_ty_1, inlineStorageTwoByte) - 0usize];
            };
            pub const String_ATOM_BIT: u32 = 8;
            pub const String_LINEAR_BIT: u32 = 16;
            pub const String_INLINE_CHARS_BIT: u32 = 64;
            pub const String_LATIN1_CHARS_BIT: u32 = 1024;
            pub const String_HAS_STRING_BUFFER_BIT: u32 = 4096;
            pub const String_EXTERNAL_FLAGS: u32 = 272;
            pub const String_TYPE_FLAGS_MASK: u32 = 1016;
            pub const String_PERMANENT_ATOM_MASK: u32 = 264;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of String"][::std::mem::size_of::<String>() - 24usize];
                ["Alignment of String"][::std::mem::align_of::<String>() - 8usize];
                ["Offset of field: String::flags_"]
                    [::std::mem::offset_of!(String, flags_) - 0usize];
                ["Offset of field: String::externalCallbacks"]
                    [::std::mem::offset_of!(String, externalCallbacks) - 16usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Symbol {
                pub _1: *mut ::std::os::raw::c_void,
                pub code_: u32,
            }
            pub const Symbol_WellKnownAPILimit: u32 = 2147483648;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of Symbol"][::std::mem::size_of::<Symbol>() - 16usize];
                ["Alignment of Symbol"][::std::mem::align_of::<Symbol>() - 8usize];
                ["Offset of field: Symbol::_1"][::std::mem::offset_of!(Symbol, _1) - 0usize];
                ["Offset of field: Symbol::code_"][::std::mem::offset_of!(Symbol, code_) - 8usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Zone {
                pub runtime_: *mut root::JSRuntime,
                pub barrierTracer_: *mut root::JSTracer,
                pub needsIncrementalBarrier_: root::JS::shadow::Zone_BarrierState,
                pub gcState_: root::JS::shadow::Zone_GCState,
                pub kind_: root::JS::shadow::Zone_Kind,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Zone_GCState {
                NoGC = 0,
                Prepare = 1,
                MarkBlackOnly = 2,
                MarkBlackAndGray = 3,
                Sweep = 4,
                Finished = 5,
                Compact = 6,
                VerifyPreBarriers = 7,
                Limit = 8,
            }
            #[doc = " Atomic<T> implementation for integral types.\n\n In addition to atomic store and load operations, compound assignment and\n increment/decrement operators are implemented which perform the\n corresponding read-modify-write operation atomically.  Finally, an atomic\n swap method is provided."]
            pub type Zone_BarrierState = u32;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Zone_Kind {
                NormalZone = 0,
                AtomsZone = 1,
                SystemZone = 2,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of Zone"][::std::mem::size_of::<Zone>() - 32usize];
                ["Alignment of Zone"][::std::mem::align_of::<Zone>() - 8usize];
                ["Offset of field: Zone::runtime_"]
                    [::std::mem::offset_of!(Zone, runtime_) - 0usize];
                ["Offset of field: Zone::barrierTracer_"]
                    [::std::mem::offset_of!(Zone, barrierTracer_) - 8usize];
                ["Offset of field: Zone::needsIncrementalBarrier_"]
                    [::std::mem::offset_of!(Zone, needsIncrementalBarrier_) - 16usize];
                ["Offset of field: Zone::gcState_"]
                    [::std::mem::offset_of!(Zone, gcState_) - 20usize];
                ["Offset of field: Zone::kind_"][::std::mem::offset_of!(Zone, kind_) - 24usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Realm {
                pub compartment_: *mut root::JS::Compartment,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of Realm"][::std::mem::size_of::<Realm>() - 8usize];
                ["Alignment of Realm"][::std::mem::align_of::<Realm>() - 8usize];
                ["Offset of field: Realm::compartment_"]
                    [::std::mem::offset_of!(Realm, compartment_) - 0usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BaseShape {
                pub clasp: *const root::JSClass,
                pub realm: *mut root::JS::Realm,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of BaseShape"][::std::mem::size_of::<BaseShape>() - 16usize];
                ["Alignment of BaseShape"][::std::mem::align_of::<BaseShape>() - 8usize];
                ["Offset of field: BaseShape::clasp"]
                    [::std::mem::offset_of!(BaseShape, clasp) - 0usize];
                ["Offset of field: BaseShape::realm"]
                    [::std::mem::offset_of!(BaseShape, realm) - 8usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Shape {
                pub base: *mut root::JS::shadow::BaseShape,
                pub immutableFlags: u32,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Shape_Kind {
                Shared = 1,
                Dictionary = 3,
                Proxy = 0,
                WasmGC = 2,
            }
            pub const Shape_KIND_SHIFT: u32 = 4;
            pub const Shape_KIND_MASK: u32 = 3;
            pub const Shape_FIXED_SLOTS_SHIFT: u32 = 6;
            pub const Shape_FIXED_SLOTS_MASK: u32 = 1984;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of Shape"][::std::mem::size_of::<Shape>() - 16usize];
                ["Alignment of Shape"][::std::mem::align_of::<Shape>() - 8usize];
                ["Offset of field: Shape::base"][::std::mem::offset_of!(Shape, base) - 0usize];
                ["Offset of field: Shape::immutableFlags"]
                    [::std::mem::offset_of!(Shape, immutableFlags) - 8usize];
            };
            #[doc = " This layout is shared by all native objects. For non-native objects, the\n shape may always be accessed safely, and other members may be as well,\n depending on the object's specific layout."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Object {
                pub shape: *mut root::JS::shadow::Shape,
                pub slots: *mut root::JS::Value,
                pub _1: *mut ::std::os::raw::c_void,
            }
            pub const Object_MAX_FIXED_SLOTS: usize = 16;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of Object"][::std::mem::size_of::<Object>() - 24usize];
                ["Alignment of Object"][::std::mem::align_of::<Object>() - 8usize];
                ["Offset of field: Object::shape"][::std::mem::offset_of!(Object, shape) - 0usize];
                ["Offset of field: Object::slots"][::std::mem::offset_of!(Object, slots) - 8usize];
                ["Offset of field: Object::_1"][::std::mem::offset_of!(Object, _1) - 16usize];
            };
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Function {
                pub _base: root::JS::shadow::Object,
            }
            pub const Function_FlagsAndArgCountSlot: root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::FlagsAndArgCountSlot;
            pub const Function_NativeFuncOrInterpretedEnvSlot:
                root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::NativeFuncOrInterpretedEnvSlot;
            pub const Function_NativeJitInfoOrInterpretedScriptSlot:
                root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::NativeJitInfoOrInterpretedScriptSlot;
            pub const Function_AtomSlot: root::JS::shadow::Function__bindgen_ty_1 =
                Function__bindgen_ty_1::AtomSlot;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Function__bindgen_ty_1 {
                FlagsAndArgCountSlot = 0,
                NativeFuncOrInterpretedEnvSlot = 1,
                NativeJitInfoOrInterpretedScriptSlot = 2,
                AtomSlot = 3,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of Function"][::std::mem::size_of::<Function>() - 24usize];
                ["Alignment of Function"][::std::mem::align_of::<Function>() - 8usize];
            };
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum HeapState {
            Idle = 0,
            Tracing = 1,
            MajorCollecting = 2,
            MinorCollecting = 3,
            CycleCollecting = 4,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16RuntimeHeapStateEv"]
            pub fn RuntimeHeapState() -> root::JS::HeapState;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StackKind {
            StackForSystemCode = 0,
            StackForTrustedScript = 1,
            StackForUntrustedScript = 2,
            StackKindCount = 3,
        }
        #[doc = " A GC pointer, tagged with the trace kind.\n\n In general, a GC pointer should be stored with an exact type. This class\n is for use when that is not possible because a single pointer must point\n to several kinds of GC thing."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCCellPtr {
            pub ptr: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of GCCellPtr"][::std::mem::size_of::<GCCellPtr>() - 8usize];
            ["Alignment of GCCellPtr"][::std::mem::align_of::<GCCellPtr>() - 8usize];
            ["Offset of field: GCCellPtr::ptr"][::std::mem::offset_of!(GCCellPtr, ptr) - 0usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetTenuredGCThingZoneENS_9GCCellPtrE"]
            pub fn GetTenuredGCThingZone(thing: root::JS::GCCellPtr) -> *mut root::JS::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetNurseryCellZoneEPN2js2gc4CellE"]
            pub fn GetNurseryCellZone(cell: *mut root::js::gc::Cell) -> *mut root::JS::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13GetObjectZoneEP8JSObject"]
            pub fn GetObjectZone(obj: *mut root::JSObject) -> *mut root::JS::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16GCThingTraceKindEPv"]
            pub fn GCThingTraceKind(thing: *mut ::std::os::raw::c_void) -> root::JS::TraceKind;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IsIncrementalBarrierNeededEP9JSContext"]
            pub fn IsIncrementalBarrierNeeded(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierEP8JSObject"]
            pub fn IncrementalPreWriteBarrier(obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierENS_9GCCellPtrE"]
            pub fn IncrementalPreWriteBarrier1(thing: root::JS::GCCellPtr);
        }
        extern "C" {
            #[doc = " Unsets the gray bit for anything reachable from |thing|. |kind| should not be\n JS::TraceKind::Shape. |thing| should be non-null. The return value indicates\n if anything was unmarked."]
            #[link_name = "\u{1}_ZN2JS28UnmarkGrayGCThingRecursivelyENS_9GCCellPtrE"]
            pub fn UnmarkGrayGCThingRecursively(thing: root::JS::GCCellPtr) -> bool;
        }
        extern "C" {
            #[doc = " Returns a static string equivalent of |kind|."]
            #[link_name = "\u{1}_ZN2JS18GCTraceKindToAsciiENS_9TraceKindE"]
            pub fn GCTraceKindToAscii(kind: root::JS::TraceKind) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Returns the base size in bytes of the GC thing of kind |kind|."]
            #[link_name = "\u{1}_ZN2JS15GCTraceKindSizeENS_9TraceKindE"]
            pub fn GCTraceKindSize(kind: root::JS::TraceKind) -> usize;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TracerKind {
            Marking = 0,
            Tenuring = 1,
            Moving = 2,
            ClearEdges = 3,
            Sweeping = 4,
            MinorSweeping = 5,
            Barrier = 6,
            Callback = 7,
            UnmarkGray = 8,
            VerifyTraceProtoAndIface = 9,
            CompartmentCheck = 10,
            HeapCheck = 11,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WeakMapTraceAction {
            #[doc = " Do not trace into weak map keys or values during traversal. Users must\n handle weak maps manually."]
            Skip = 0,
            #[doc = " Do true ephemeron marking with a weak key lookup marking phase. This is\n the default for GCMarker."]
            Expand = 1,
            #[doc = " Trace through to all values, irrespective of whether the keys are live\n or not. Used for non-marking tracers."]
            TraceValues = 2,
            #[doc = " Trace through to all keys and values, irrespective of whether the keys\n are live or not. Used for non-marking tracers."]
            TraceKeysAndValues = 3,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WeakEdgeTraceAction {
            Skip = 0,
            Trace = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TraceOptions {
            pub weakMapAction: root::JS::WeakMapTraceAction,
            pub weakEdgeAction: root::JS::WeakEdgeTraceAction,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TraceOptions"][::std::mem::size_of::<TraceOptions>() - 8usize];
            ["Alignment of TraceOptions"][::std::mem::align_of::<TraceOptions>() - 4usize];
            ["Offset of field: TraceOptions::weakMapAction"]
                [::std::mem::offset_of!(TraceOptions, weakMapAction) - 0usize];
            ["Offset of field: TraceOptions::weakEdgeAction"]
                [::std::mem::offset_of!(TraceOptions, weakEdgeAction) - 4usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TracingContext {
            pub index_: usize,
            pub functor_: *mut root::JS::TracingContext_Functor,
        }
        #[repr(C)]
        pub struct TracingContext_Functor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TracingContext_Functor {
            pub vtable_: *const TracingContext_Functor__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TracingContext_Functor"]
                [::std::mem::size_of::<TracingContext_Functor>() - 8usize];
            ["Alignment of TracingContext_Functor"]
                [::std::mem::align_of::<TracingContext_Functor>() - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14TracingContext12InvalidIndexE"]
            pub static TracingContext_InvalidIndex: usize;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TracingContext"][::std::mem::size_of::<TracingContext>() - 16usize];
            ["Alignment of TracingContext"][::std::mem::align_of::<TracingContext>() - 8usize];
            ["Offset of field: TracingContext::index_"]
                [::std::mem::offset_of!(TracingContext, index_) - 0usize];
            ["Offset of field: TracingContext::functor_"]
                [::std::mem::offset_of!(TracingContext, functor_) - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CallbackTracer {
            pub _base: root::js::GenericTracerImpl,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CallbackTracer"][::std::mem::size_of::<CallbackTracer>() - 48usize];
            ["Alignment of CallbackTracer"][::std::mem::align_of::<CallbackTracer>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoTracingIndex {
            pub trc_: *mut root::JSTracer,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoTracingIndex"][::std::mem::size_of::<AutoTracingIndex>() - 8usize];
            ["Alignment of AutoTracingIndex"][::std::mem::align_of::<AutoTracingIndex>() - 8usize];
            ["Offset of field: AutoTracingIndex::trc_"]
                [::std::mem::offset_of!(AutoTracingIndex, trc_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoTracingDetails {
            pub trc_: *mut root::JSTracer,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoTracingDetails"][::std::mem::size_of::<AutoTracingDetails>() - 8usize];
            ["Alignment of AutoTracingDetails"]
                [::std::mem::align_of::<AutoTracingDetails>() - 8usize];
            ["Offset of field: AutoTracingDetails::trc_"]
                [::std::mem::offset_of!(AutoTracingDetails, trc_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoClearTracingContext {
            pub trc_: *mut root::JSTracer,
            pub prev_: root::JS::TracingContext,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoClearTracingContext"]
                [::std::mem::size_of::<AutoClearTracingContext>() - 24usize];
            ["Alignment of AutoClearTracingContext"]
                [::std::mem::align_of::<AutoClearTracingContext>() - 8usize];
            ["Offset of field: AutoClearTracingContext::trc_"]
                [::std::mem::offset_of!(AutoClearTracingContext, trc_) - 0usize];
            ["Offset of field: AutoClearTracingContext::prev_"]
                [::std::mem::offset_of!(AutoClearTracingContext, prev_) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPNS_6BigIntEPKc"]
            pub fn TraceRoot(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JS::BigInt,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPNS_6SymbolEPKc"]
            pub fn TraceRoot1(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JS::Symbol,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP6JSAtomPKc"]
            pub fn TraceRoot2(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSAtom,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP10JSFunctionPKc"]
            pub fn TraceRoot3(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSFunction,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP14JSLinearStringPKc"]
            pub fn TraceRoot4(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSLinearString,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSObjectPKc"]
            pub fn TraceRoot5(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSScriptPKc"]
            pub fn TraceRoot6(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSScript,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSStringPKc"]
            pub fn TraceRoot7(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSString,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPNS_5ValueEPKc"]
            pub fn TraceRoot8(
                trc: *mut root::JSTracer,
                edgep: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPNS_11PropertyKeyEPKc"]
            pub fn TraceRoot9(
                trc: *mut root::JSTracer,
                edgep: *mut root::JS::PropertyKey,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPN2js23AbstractGeneratorObjectEPKc"]
            pub fn TraceRoot10(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::js::AbstractGeneratorObject,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPN2js10SavedFrameEPKc"]
            pub fn TraceRoot11(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::js::SavedFrame,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPN2js4wasm6AnyRefEPKc"]
            pub fn TraceRoot12(
                trc: *mut root::JSTracer,
                edgep: *mut root::js::wasm::AnyRef,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13TraceChildrenEP8JSTracerNS_9GCCellPtrE"]
            pub fn TraceChildren(trc: *mut root::JSTracer, thing: root::JS::GCCellPtr);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StructGCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct IgnoreGCPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_unsigned_int_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_unsigned_int_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_unsigned_long_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_unsigned_long_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_bool__close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_bool__close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCPointerPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_BigInt_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_BigInt_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_BigInt_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_BigInt_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_Symbol_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_Symbol_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_Symbol_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_Symbol_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSAtom_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSAtom_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSAtom_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSAtom_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSFunction_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSFunction_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSFunction_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSFunction_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSLinearString_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSLinearString_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSLinearString_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSLinearString_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSObject_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSObject_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSObject_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSObject_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSScript_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSScript_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSScript_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSScript_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSString_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSString_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_JSString_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_JSString_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NonGCPointerPolicy {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_Nothing_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_Nothing_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_Ok_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_Ok_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        pub type NativeStackSize = usize;
        pub type NativeStackBase = usize;
        pub type NativeStackLimit = usize;
        impl root::JS::ProfilingCategoryPair {
            pub const LAST: root::JS::ProfilingCategoryPair = ProfilingCategoryPair::TELEMETRY;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingCategoryPair {
            IDLE = 0,
            OTHER = 1,
            OTHER_PreferenceRead = 2,
            OTHER_Profiling = 3,
            TEST = 4,
            LAYOUT = 5,
            LAYOUT_FrameConstruction = 6,
            LAYOUT_Reflow = 7,
            LAYOUT_CSSParsing = 8,
            LAYOUT_SelectorQuery = 9,
            LAYOUT_StyleComputation = 10,
            LAYOUT_Destroy = 11,
            LAYOUT_Printing = 12,
            JS = 13,
            JS_Parsing = 14,
            JS_BaselineCompilation = 15,
            JS_IonCompilation = 16,
            JS_Interpreter = 17,
            JS_BaselineInterpret = 18,
            JS_Baseline = 19,
            JS_IonMonkey = 20,
            JS_Builtin = 21,
            JS_WasmIon = 22,
            JS_WasmBaseline = 23,
            JS_WasmOther = 24,
            GCCC = 25,
            GCCC_MinorGC = 26,
            GCCC_MajorGC = 27,
            GCCC_MajorGC_Mark = 28,
            GCCC_MajorGC_Sweep = 29,
            GCCC_MajorGC_Compact = 30,
            GCCC_UnmarkGray = 31,
            GCCC_Barrier = 32,
            GCCC_FreeSnowWhite = 33,
            GCCC_BuildGraph = 34,
            GCCC_ScanRoots = 35,
            GCCC_CollectWhite = 36,
            GCCC_Finalize = 37,
            NETWORK = 38,
            GRAPHICS = 39,
            GRAPHICS_DisplayListBuilding = 40,
            GRAPHICS_DisplayListMerging = 41,
            GRAPHICS_LayerBuilding = 42,
            GRAPHICS_TileAllocation = 43,
            GRAPHICS_WRDisplayList = 44,
            GRAPHICS_Rasterization = 45,
            GRAPHICS_FlushingAsyncPaints = 46,
            GRAPHICS_ImageDecoding = 47,
            DOM = 48,
            JAVA_ANDROID = 49,
            JAVA_ANDROIDX = 50,
            JAVA_LANGUAGE = 51,
            JAVA_MOZILLA = 52,
            JAVA_KOTLIN = 53,
            JAVA_BLOCKED = 54,
            MAILNEWS = 55,
            IPC = 56,
            MEDIA = 57,
            MEDIA_CUBEB = 58,
            MEDIA_PLAYBACK = 59,
            MEDIA_RT = 60,
            A11Y = 61,
            PROFILER = 62,
            TIMER = 63,
            REMOTE_PROTOCOL = 64,
            SANDBOX = 65,
            TELEMETRY = 66,
            COUNT = 67,
        }
        impl root::JS::ProfilingCategory {
            pub const LAST: root::JS::ProfilingCategory = ProfilingCategory::TELEMETRY;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingCategory {
            IDLE = 0,
            OTHER = 1,
            TEST = 2,
            LAYOUT = 3,
            JS = 4,
            GCCC = 5,
            NETWORK = 6,
            GRAPHICS = 7,
            DOM = 8,
            JAVA_ANDROID = 9,
            JAVA_ANDROIDX = 10,
            JAVA_LANGUAGE = 11,
            JAVA_MOZILLA = 12,
            JAVA_KOTLIN = 13,
            JAVA_BLOCKED = 14,
            MAILNEWS = 15,
            IPC = 16,
            MEDIA = 17,
            A11Y = 18,
            PROFILER = 19,
            TIMER = 20,
            REMOTE_PROTOCOL = 21,
            SANDBOX = 22,
            TELEMETRY = 23,
            COUNT = 24,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfilingCategoryPairInfo {
            pub mCategory: root::JS::ProfilingCategory,
            pub mSubcategoryIndex: u32,
            pub mLabel: *const ::std::os::raw::c_char,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ProfilingCategoryPairInfo"]
                [::std::mem::size_of::<ProfilingCategoryPairInfo>() - 16usize];
            ["Alignment of ProfilingCategoryPairInfo"]
                [::std::mem::align_of::<ProfilingCategoryPairInfo>() - 8usize];
            ["Offset of field: ProfilingCategoryPairInfo::mCategory"]
                [::std::mem::offset_of!(ProfilingCategoryPairInfo, mCategory) - 0usize];
            ["Offset of field: ProfilingCategoryPairInfo::mSubcategoryIndex"]
                [::std::mem::offset_of!(ProfilingCategoryPairInfo, mSubcategoryIndex) - 4usize];
            ["Offset of field: ProfilingCategoryPairInfo::mLabel"]
                [::std::mem::offset_of!(ProfilingCategoryPairInfo, mLabel) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28GetProfilingCategoryPairInfoENS_21ProfilingCategoryPairE"]
            pub fn GetProfilingCategoryPairInfo(
                aCategoryPair: root::JS::ProfilingCategoryPair,
            ) -> *const root::JS::ProfilingCategoryPairInfo;
        }
        pub type RegisterThreadCallback = ::std::option::Option<
            unsafe extern "C" fn(
                threadName: *const ::std::os::raw::c_char,
                stackBase: *mut ::std::os::raw::c_void,
            ) -> *mut root::ProfilingStack,
        >;
        pub type UnregisterThreadCallback = ::std::option::Option<unsafe extern "C" fn()>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27SetProfilingThreadCallbacksEPFP14ProfilingStackPKcPvEPFvvE"]
            pub fn SetProfilingThreadCallbacks(
                registerThread: root::JS::RegisterThreadCallback,
                unregisterThread: root::JS::UnregisterThreadCallback,
            );
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_Realm_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_Realm_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetCurrentRealmOrNullEP9JSContext"]
            pub fn GetCurrentRealmOrNull(cx: *mut root::JSContext) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetObjectRealmOrNullEP8JSObject"]
            pub fn GetObjectRealmOrNull(obj: *mut root::JSObject) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetRealmPrivateEPNS_5RealmE"]
            pub fn GetRealmPrivate(realm: *mut root::JS::Realm) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetRealmPrivateEPNS_5RealmEPv"]
            pub fn SetRealmPrivate(realm: *mut root::JS::Realm, data: *mut ::std::os::raw::c_void);
        }
        pub type DestroyRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(gcx: *mut root::JS::GCContext, realm: *mut root::JS::Realm),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23SetDestroyRealmCallbackEP9JSContextPFvPNS_9GCContextEPNS_5RealmEE"]
            pub fn SetDestroyRealmCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DestroyRealmCallback,
            );
        }
        pub type RealmNameCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                realm: *mut root::JS::Realm,
                buf: *mut ::std::os::raw::c_char,
                bufsize: usize,
                nogc: *const root::JS::AutoRequireNoGC,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20SetRealmNameCallbackEP9JSContextPFvS1_PNS_5RealmEPcmRKNS_15AutoRequireNoGCEE"]
            pub fn SetRealmNameCallback(
                cx: *mut root::JSContext,
                callback: root::JS::RealmNameCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetRealmGlobalOrNullEPNS_5RealmE"]
            pub fn GetRealmGlobalOrNull(realm: *mut root::JS::Realm) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InitRealmStandardClassesEP9JSContext"]
            pub fn InitRealmStandardClasses(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27MaybeFreezeCtorAndPrototypeEP9JSContextNS_6HandleIP8JSObjectEES5_"]
            pub fn MaybeFreezeCtorAndPrototype(
                cx: *mut root::JSContext,
                ctor: root::JS::HandleObject,
                maybeProto: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetRealmObjectPrototypeEP9JSContext"]
            pub fn GetRealmObjectPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS29GetRealmObjectPrototypeHandleEP9JSContext"]
            pub fn GetRealmObjectPrototypeHandle(
                cx: *mut root::JSContext,
            ) -> root::JS::Handle<*mut root::JSObject>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetRealmFunctionPrototypeEP9JSContext"]
            pub fn GetRealmFunctionPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31GetRealmFunctionPrototypeHandleEP9JSContext"]
            pub fn GetRealmFunctionPrototypeHandle(
                cx: *mut root::JSContext,
            ) -> root::JS::Handle<*mut root::JSObject>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22GetRealmArrayPrototypeEP9JSContext"]
            pub fn GetRealmArrayPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22GetRealmErrorPrototypeEP9JSContext"]
            pub fn GetRealmErrorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetRealmIteratorPrototypeEP9JSContext"]
            pub fn GetRealmIteratorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30GetRealmAsyncIteratorPrototypeEP9JSContext"]
            pub fn GetRealmAsyncIteratorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17GetRealmKeyObjectEP9JSContext"]
            pub fn GetRealmKeyObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16GetFunctionRealmEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetFunctionRealm(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
            ) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[doc = " NB: This API is infallible; a nullptr return value does not indicate error.\n\n |target| must not be a cross-compartment wrapper because CCWs are not\n associated with a single realm.\n\n Entering a realm roots the realm and its global object until the matching\n JS::LeaveRealm() call."]
            #[link_name = "\u{1}_ZN2JS10EnterRealmEP9JSContextP8JSObject"]
            pub fn EnterRealm(
                cx: *mut root::JSContext,
                target: *mut root::JSObject,
            ) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10LeaveRealmEP9JSContextPNS_5RealmE"]
            pub fn LeaveRealm(cx: *mut root::JSContext, oldRealm: *mut root::JS::Realm);
        }
        extern "C" {
            #[doc = " Reset the seed for Math.random() within the current realm.\n\n Enables embedders to reset the seed at controlled points, e.g. after\n resuming execution from an instance snapshot of SpiderMonkey's VM."]
            #[link_name = "\u{1}_ZN2JS24ResetRealmMathRandomSeedEP9JSContext"]
            pub fn ResetRealmMathRandomSeed(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26HeapObjectPostWriteBarrierEPP8JSObjectS1_S1_"]
            pub fn HeapObjectPostWriteBarrier(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapObjectWriteBarriersEPP8JSObjectS1_S1_"]
            pub fn HeapObjectWriteBarriers(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapStringWriteBarriersEPP8JSStringS1_S1_"]
            pub fn HeapStringWriteBarriers(
                objp: *mut *mut root::JSString,
                prev: *mut root::JSString,
                next: *mut root::JSString,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapBigIntWriteBarriersEPPNS_6BigIntES1_S1_"]
            pub fn HeapBigIntWriteBarriers(
                bip: *mut *mut root::JS::BigInt,
                prev: *mut root::JS::BigInt,
                next: *mut root::JS::BigInt,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapScriptWriteBarriersEPP8JSScriptS1_S1_"]
            pub fn HeapScriptWriteBarriers(
                objp: *mut *mut root::JSScript,
                prev: *mut root::JSScript,
                next: *mut root::JSScript,
            );
        }
        #[doc = " SafelyInitialized<T>::create() creates a safely-initialized |T|, suitable for\n use as a default value in situations requiring a safe but arbitrary |T|\n value. Implemented as a static method of a struct to allow partial\n specialization for subclasses via the Enable template parameter."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SafelyInitialized {
            pub _address: u8,
        }
        pub type Heap_ElementType<T> = T;
        #[doc = " The TenuredHeap<T> class is similar to the Heap<T> class above in that it\n encapsulates the GC concerns of an on-heap reference to a JS object. However,\n it has two important differences:\n\n  1) Pointers which are statically known to only reference \"tenured\" objects\n     can avoid the extra overhead of SpiderMonkey's post write barriers.\n\n  2) Objects in the \"tenured\" heap have stronger alignment restrictions than\n     those in the \"nursery\", so it is possible to store flags in the lower\n     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged\n     pointer with a nice API for accessing the flag bits and adds various\n     assertions to ensure that it is not mis-used.\n\n GC things are said to be \"tenured\" when they are located in the long-lived\n heap: e.g. they have gained tenure as an object by surviving past at least\n one GC. For performance, SpiderMonkey allocates some things which are known\n to normally be long lived directly into the tenured generation; for example,\n global objects. Additionally, SpiderMonkey does not visit individual objects\n when deleting non-tenured objects, so object with finalizers are also always\n tenured; for instance, this includes most DOM objects.\n\n The considerations to keep in mind when using a TenuredHeap<T> vs a normal\n Heap<T> are:\n\n  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.\n  - It is however valid for a Heap<T> to refer to a tenured thing.\n  - It is not possible to store flag bits in a Heap<T>."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct TenuredHeap {
            pub bits: usize,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TenuredHeap__bindgen_ty_1 {
            maskBits = 0,
        }
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful\n as a parameter type, which guarantees that the T lvalue is properly\n rooted. See \"Move GC Stack Rooting\" above.\n\n If you want to add additional methods to Handle for a specific\n specialization, define a HandleOperations<T> specialization containing them."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Handle<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub ptr: *const T,
        }
        pub type Handle_ElementType<T> = T;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Handle_Disambiguator {
            DeliberatelyChoosingThisOverload = 0,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Handle_CallerIdentity {
            ImUsingThisOnlyInFromFromMarkedLocation = 0,
        }
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is\n useful for outparams.\n\n If you want to add additional methods to MutableHandle for a specific\n specialization, define a MutableHandleOperations<T> specialization containing\n them."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandle<T> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub ptr: *mut T,
        }
        pub type MutableHandle_ElementType<T> = T;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AutoGCRooterKind {
            WrapperVector = 0,
            Wrapper = 1,
            Custom = 2,
            Limit = 3,
        }
        #[doc = " EnumeratedArray is a fixed-size array container for use when an\n array is indexed by a specific enum class.\n\n This provides type safety by guarding at compile time against accidentally\n indexing such arrays with unrelated values. This also removes the need\n for manual casting when using a typed enum value to index arrays.\n\n Aside from the typing of indices, EnumeratedArray is similar to Array.\n\n Example:\n\n   enum class AnimalSpecies {\n     Cow,\n     Sheep,\n     Count\n   };\n\n   EnumeratedArray<AnimalSpecies, int, AnimalSpecies::Count> headCount;\n\n   headCount[AnimalSpecies::Cow] = 17;\n   headCount[AnimalSpecies::Sheep] = 30;\n\n If the enum class has contiguous values and provides a specialization of\n mozilla::MaxContiguousEnumValue then the size will be calculated as the max\n value + 1."]
        pub type RootedListHeads = root::__BindgenOpaqueArray<u64, 16usize>;
        #[doc = " EnumeratedArray is a fixed-size array container for use when an\n array is indexed by a specific enum class.\n\n This provides type safety by guarding at compile time against accidentally\n indexing such arrays with unrelated values. This also removes the need\n for manual casting when using a typed enum value to index arrays.\n\n Aside from the typing of indices, EnumeratedArray is similar to Array.\n\n Example:\n\n   enum class AnimalSpecies {\n     Cow,\n     Sheep,\n     Count\n   };\n\n   EnumeratedArray<AnimalSpecies, int, AnimalSpecies::Count> headCount;\n\n   headCount[AnimalSpecies::Cow] = 17;\n   headCount[AnimalSpecies::Sheep] = 30;\n\n If the enum class has contiguous values and provides a specialization of\n mozilla::MaxContiguousEnumValue then the size will be calculated as the max\n value + 1."]
        pub type AutoRooterListHeads = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootingContext {
            pub stackRoots_: root::JS::RootedListHeads,
            pub autoGCRooters_: root::JS::AutoRooterListHeads,
            pub geckoProfiler_: root::js::GeckoProfilerThread,
            pub nursery_: *mut root::js::Nursery,
            pub zone_: *mut root::JS::Zone,
            pub realm_: *mut root::JS::Realm,
            pub nativeStackLimit: [root::JS::NativeStackLimit; 3usize],
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RootingContext"][::std::mem::size_of::<RootingContext>() - 216usize];
            ["Alignment of RootingContext"][::std::mem::align_of::<RootingContext>() - 8usize];
            ["Offset of field: RootingContext::stackRoots_"]
                [::std::mem::offset_of!(RootingContext, stackRoots_) - 0usize];
            ["Offset of field: RootingContext::autoGCRooters_"]
                [::std::mem::offset_of!(RootingContext, autoGCRooters_) - 128usize];
            ["Offset of field: RootingContext::geckoProfiler_"]
                [::std::mem::offset_of!(RootingContext, geckoProfiler_) - 152usize];
            ["Offset of field: RootingContext::nursery_"]
                [::std::mem::offset_of!(RootingContext, nursery_) - 168usize];
            ["Offset of field: RootingContext::zone_"]
                [::std::mem::offset_of!(RootingContext, zone_) - 176usize];
            ["Offset of field: RootingContext::realm_"]
                [::std::mem::offset_of!(RootingContext, realm_) - 184usize];
            ["Offset of field: RootingContext::nativeStackLimit"]
                [::std::mem::offset_of!(RootingContext, nativeStackLimit) - 192usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoGCRooter {
            pub down: *mut root::JS::AutoGCRooter,
            pub stackTop: *mut *mut root::JS::AutoGCRooter,
            pub kind_: root::JS::AutoGCRooter_Kind,
        }
        pub use self::super::super::root::JS::AutoGCRooterKind as AutoGCRooter_Kind;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoGCRooter"][::std::mem::size_of::<AutoGCRooter>() - 24usize];
            ["Alignment of AutoGCRooter"][::std::mem::align_of::<AutoGCRooter>() - 8usize];
            ["Offset of field: AutoGCRooter::down"]
                [::std::mem::offset_of!(AutoGCRooter, down) - 0usize];
            ["Offset of field: AutoGCRooter::stackTop"]
                [::std::mem::offset_of!(AutoGCRooter, stackTop) - 8usize];
            ["Offset of field: AutoGCRooter::kind_"]
                [::std::mem::offset_of!(AutoGCRooter, kind_) - 16usize];
        };
        #[repr(C)]
        pub struct CustomAutoRooter__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Custom rooting behavior for internal and external clients.\n\n Deprecated. Where possible, use Rooted<> instead."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct CustomAutoRooter {
            pub vtable_: *const CustomAutoRooter__bindgen_vtable,
            pub _base: root::JS::AutoGCRooter,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CustomAutoRooter"][::std::mem::size_of::<CustomAutoRooter>() - 32usize];
            ["Alignment of CustomAutoRooter"][::std::mem::align_of::<CustomAutoRooter>() - 8usize];
        };
        pub type Rooted_ElementType<T> = T;
        pub type RootedField_ElementType<T> = T;
        pub type RootedField_WrapperT = u8;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEPNS_14RootingContextENS_8RootKindEPN2js20PersistentRootedBaseE"]
            pub fn AddPersistentRoot(
                cx: *mut root::JS::RootingContext,
                kind: root::JS::RootKind,
                root: *mut root::js::PersistentRootedBase,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEP9JSRuntimeNS_8RootKindEPN2js20PersistentRootedBaseE"]
            pub fn AddPersistentRoot1(
                rt: *mut root::JSRuntime,
                kind: root::JS::RootKind,
                root: *mut root::js::PersistentRootedBase,
            );
        }
        #[doc = " A copyable, assignable global GC root type with arbitrary lifetime, an\n infallible constructor, and automatic unrooting on destruction.\n\n These roots can be used in heap-allocated data structures, so they are not\n associated with any particular JSContext or stack. They are registered with\n the JSRuntime itself, without locking. Initialization may take place on\n construction, or in two phases if the no-argument constructor is called\n followed by init().\n\n Note that you must not use an PersistentRooted in an object owned by a JS\n object:\n\n Whenever one object whose lifetime is decided by the GC refers to another\n such object, that edge must be traced only if the owning JS object is traced.\n This applies not only to JS objects (which obviously are managed by the GC)\n but also to C++ objects owned by JS objects.\n\n If you put a PersistentRooted in such a C++ object, that is almost certainly\n a leak. When a GC begins, the referent of the PersistentRooted is treated as\n live, unconditionally (because a PersistentRooted is a *root*), even if the\n JS object that owns it is unreachable. If there is any path from that\n referent back to the JS object, then the C++ object containing the\n PersistentRooted will not be destructed, and the whole blob of objects will\n not be freed, even if there are no references to them from the outside.\n\n In the context of Firefox, this is a severe restriction: almost everything in\n Firefox is owned by some JS object or another, so using PersistentRooted in\n such objects would introduce leaks. For these kinds of edges, Heap<T> or\n TenuredHeap<T> would be better types. It's up to the implementor of the type\n containing Heap<T> or TenuredHeap<T> members to make sure their referents get\n marked when the object itself is marked."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PersistentRooted {
            pub _address: u8,
        }
        pub type PersistentRooted_ElementType = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ValueType {
            Double = 0,
            Int32 = 1,
            Boolean = 2,
            Undefined = 3,
            Null = 4,
            Magic = 5,
            String = 6,
            Symbol = 7,
            PrivateGCThing = 8,
            BigInt = 9,
            Object = 12,
        }
        #[doc = " [SMDOC] JS::Value type\n\n JS::Value is the interface for a single JavaScript Engine value.  A few\n general notes on JS::Value:\n\n - JS::Value has setX() and isX() members for X in\n\n     { Int32, Double, String, Symbol, BigInt, Boolean, Undefined, Null,\n       Object, Magic }\n\n   JS::Value also contains toX() for each of the non-singleton types.\n\n - Magic is a singleton type whose payload contains either a JSWhyMagic\n   \"reason\" for the magic value or a uint32_t value. By providing JSWhyMagic\n   values when creating and checking for magic values, it is possible to\n   assert, at runtime, that only magic values with the expected reason flow\n   through a particular value. For example, if cx->exception has a magic\n   value, the reason must be JS_GENERATOR_CLOSING.\n\n - The JS::Value operations are preferred.  The JSVAL_* operations remain for\n   compatibility; they may be removed at some point.  These operations mostly\n   provide similar functionality.  But there are a few key differences.  One\n   is that JS::Value gives null a separate type.\n   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,\n   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a\n   JSObject&.)  A convenience member Value::setObjectOrNull is provided.\n\n - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on\n   32-bit user code should avoid copying jsval/JS::Value as much as possible,\n   preferring to pass by const Value&.\n\n Spectre mitigations\n ===================\n To mitigate Spectre attacks, we do the following:\n\n - On 64-bit platforms, when unboxing a Value, we XOR the bits with the\n   expected type tag (instead of masking the payload bits). This guarantees\n   that toString, toObject, toSymbol will return an invalid pointer (because\n   some high bits will be set) when called on a Value with a different type\n   tag.\n\n - On 32-bit platforms,when unboxing an object/string/symbol Value, we use a\n   conditional move (not speculated) to zero the payload register if the type\n   doesn't match."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Value {
            pub asBits_: u64,
        }
        pub type Value_PayloadType = u64;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Value"][::std::mem::size_of::<Value>() - 8usize];
            ["Alignment of Value"][::std::mem::align_of::<Value>() - 8usize];
            ["Offset of field: Value::asBits_"][::std::mem::offset_of!(Value, asBits_) - 0usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25HeapValuePostWriteBarrierEPNS_5ValueERKS0_S3_"]
            pub fn HeapValuePostWriteBarrier(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22HeapValueWriteBarriersEPNS_5ValueERKS0_S3_"]
            pub fn HeapValueWriteBarriers(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_Value_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_Value_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15NullHandleValueE"]
            pub static NullHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UndefinedHandleValueE"]
            pub static UndefinedHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15TrueHandleValueE"]
            pub static TrueHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16FalseHandleValueE"]
            pub static FalseHandleValue: root::JS::HandleValue;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: Handle_open0_Maybe_open1_Value_close1_close0"]
                [::std::mem::size_of::<u64>() - 8usize];
            ["Align of template specialization: Handle_open0_Maybe_open1_Value_close1_close0"]
                [::std::mem::align_of::<u64>() - 8usize];
        };
        pub type GCVector_ElementType<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PersistentRootedVector {
            pub _address: u8,
        }
        pub type PersistentRootedVector_Vec = u8;
        #[doc = " A copyable, assignable global GC root type with arbitrary lifetime, an\n infallible constructor, and automatic unrooting on destruction.\n\n These roots can be used in heap-allocated data structures, so they are not\n associated with any particular JSContext or stack. They are registered with\n the JSRuntime itself, without locking. Initialization may take place on\n construction, or in two phases if the no-argument constructor is called\n followed by init().\n\n Note that you must not use an PersistentRooted in an object owned by a JS\n object:\n\n Whenever one object whose lifetime is decided by the GC refers to another\n such object, that edge must be traced only if the owning JS object is traced.\n This applies not only to JS objects (which obviously are managed by the GC)\n but also to C++ objects owned by JS objects.\n\n If you put a PersistentRooted in such a C++ object, that is almost certainly\n a leak. When a GC begins, the referent of the PersistentRooted is treated as\n live, unconditionally (because a PersistentRooted is a *root*), even if the\n JS object that owns it is unreachable. If there is any path from that\n referent back to the JS object, then the C++ object containing the\n PersistentRooted will not be destructed, and the whole blob of objects will\n not be freed, even if there are no references to them from the outside.\n\n In the context of Firefox, this is a severe restriction: almost everything in\n Firefox is owned by some JS object or another, so using PersistentRooted in\n such objects would introduce leaks. For these kinds of edges, Heap<T> or\n TenuredHeap<T> would be better types. It's up to the implementor of the type\n containing Heap<T> or TenuredHeap<T> members to make sure their referents get\n marked when the object itself is marked."]
        pub type PersistentRootedVector_Base = u8;
        #[doc = " A generic handle to an array of rooted values.\n\n The rooted array refernced can take several forms, therfore this is not the\n same as Handle<js::ValueArray>."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HandleValueArray {
            pub length_: usize,
            pub elements_: *const root::JS::Value,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of HandleValueArray"][::std::mem::size_of::<HandleValueArray>() - 16usize];
            ["Alignment of HandleValueArray"][::std::mem::align_of::<HandleValueArray>() - 8usize];
            ["Offset of field: HandleValueArray::length_"]
                [::std::mem::offset_of!(HandleValueArray, length_) - 0usize];
            ["Offset of field: HandleValueArray::elements_"]
                [::std::mem::offset_of!(HandleValueArray, elements_) - 8usize];
        };
        extern "C" {
            #[doc = " Return true if the given object is callable. In ES6 terms, an object is\n callable if it has a [[Call]] internal method.\n\n Implements: ES6 7.2.3 IsCallable(argument).\n\n Functions are callable. A scripted proxy or wrapper is callable if its\n target is callable. Most other objects aren't callable."]
            #[link_name = "\u{1}_ZN2JS10IsCallableEP8JSObject"]
            pub fn IsCallable(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true if the given object is a constructor. In ES6 terms, an object is\n a constructor if it has a [[Construct]] internal method. The expression\n `new obj()` throws a TypeError if obj is not a constructor.\n\n Implements: ES6 7.2.4 IsConstructor(argument).\n\n JS functions and classes are constructors. Arrow functions and most builtin\n functions are not. A scripted proxy or wrapper is a constructor if its\n target is a constructor."]
            #[link_name = "\u{1}_ZN2JS13IsConstructorEP8JSObject"]
            pub fn IsConstructor(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS4CallEP9JSContextNS_6HandleINS_5ValueEEES4_RKNS_16HandleValueArrayENS_13MutableHandleIS3_EE"]
            pub fn Call(
                cx: *mut root::JSContext,
                thisv: root::JS::Handle<root::JS::Value>,
                fun: root::JS::Handle<root::JS::Value>,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Invoke a constructor. This is the C++ equivalent of\n `rval = Reflect.construct(fun, args, newTarget)`.\n\n Construct() takes a `newTarget` argument that most callers don't need.\n Consider using the four-argument Construct signature instead. (But if you're\n implementing a subclass or a proxy handler's construct() method, this is the\n right function to call.)\n\n Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]).\n Use this function to invoke the [[Construct]] internal method."]
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEERKNS_16HandleValueArrayENS_13MutableHandleIS6_EE"]
            pub fn Construct(
                cx: *mut root::JSContext,
                fun: root::JS::Handle<root::JS::Value>,
                newTarget: root::JS::Handle<*mut root::JSObject>,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Invoke a constructor. This is the C++ equivalent of\n `rval = new fun(...args)`.\n\n Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when\n newTarget is omitted."]
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEERKNS_16HandleValueArrayENS_13MutableHandleIP8JSObjectEE"]
            pub fn Construct1(
                cx: *mut root::JSContext,
                fun: root::JS::Handle<root::JS::Value>,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandle<*mut root::JSObject>,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Latin1Chars {
            pub _base: root::mozilla::Range<root::JS::Latin1Char>,
        }
        pub type Latin1Chars_Base = root::mozilla::Range<root::JS::Latin1Char>;
        pub type Latin1Chars_CharT = root::JS::Latin1Char;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Latin1Chars"][::std::mem::size_of::<Latin1Chars>() - 16usize];
            ["Alignment of Latin1Chars"][::std::mem::align_of::<Latin1Chars>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ConstLatin1Chars {
            pub _base: root::mozilla::Range<root::JS::Latin1Char>,
        }
        pub type ConstLatin1Chars_Base = root::mozilla::Range<root::JS::Latin1Char>;
        pub type ConstLatin1Chars_CharT = root::JS::Latin1Char;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ConstLatin1Chars"][::std::mem::size_of::<ConstLatin1Chars>() - 16usize];
            ["Alignment of ConstLatin1Chars"][::std::mem::align_of::<ConstLatin1Chars>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Latin1CharsZ {
            pub _base: root::mozilla::RangedPtr<root::JS::Latin1Char>,
        }
        pub type Latin1CharsZ_Base = root::mozilla::RangedPtr<root::JS::Latin1Char>;
        pub type Latin1CharsZ_CharT = root::JS::Latin1Char;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Latin1CharsZ"][::std::mem::size_of::<Latin1CharsZ>() - 8usize];
            ["Alignment of Latin1CharsZ"][::std::mem::align_of::<Latin1CharsZ>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UTF8Chars {
            pub _base: root::mozilla::Range<::std::os::raw::c_uchar>,
        }
        pub type UTF8Chars_Base = root::mozilla::Range<::std::os::raw::c_uchar>;
        pub type UTF8Chars_CharT = ::std::os::raw::c_uchar;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of UTF8Chars"][::std::mem::size_of::<UTF8Chars>() - 16usize];
            ["Alignment of UTF8Chars"][::std::mem::align_of::<UTF8Chars>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UTF8CharsZ {
            pub _base: root::mozilla::RangedPtr<::std::os::raw::c_uchar>,
        }
        pub type UTF8CharsZ_Base = root::mozilla::RangedPtr<::std::os::raw::c_uchar>;
        pub type UTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of UTF8CharsZ"][::std::mem::size_of::<UTF8CharsZ>() - 8usize];
            ["Alignment of UTF8CharsZ"][::std::mem::align_of::<UTF8CharsZ>() - 8usize];
        };
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ConstUTF8CharsZ {
            pub data_: *const ::std::os::raw::c_char,
        }
        pub type ConstUTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ConstUTF8CharsZ"][::std::mem::size_of::<ConstUTF8CharsZ>() - 8usize];
            ["Alignment of ConstUTF8CharsZ"][::std::mem::align_of::<ConstUTF8CharsZ>() - 1usize];
            ["Offset of field: ConstUTF8CharsZ::data_"]
                [::std::mem::offset_of!(ConstUTF8CharsZ, data_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type TwoByteChars_Base = root::mozilla::Range<u16>;
        pub type TwoByteChars_CharT = u16;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TwoByteChars"][::std::mem::size_of::<TwoByteChars>() - 16usize];
            ["Alignment of TwoByteChars"][::std::mem::align_of::<TwoByteChars>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TwoByteCharsZ {
            pub _base: root::mozilla::RangedPtr<u16>,
        }
        pub type TwoByteCharsZ_Base = root::mozilla::RangedPtr<u16>;
        pub type TwoByteCharsZ_CharT = u16;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TwoByteCharsZ"][::std::mem::size_of::<TwoByteCharsZ>() - 8usize];
            ["Alignment of TwoByteCharsZ"][::std::mem::align_of::<TwoByteCharsZ>() - 8usize];
        };
        pub type ConstCharPtr = root::mozilla::RangedPtr<u16>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ConstTwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type ConstTwoByteChars_Base = root::mozilla::Range<u16>;
        pub type ConstTwoByteChars_CharT = u16;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ConstTwoByteChars"][::std::mem::size_of::<ConstTwoByteChars>() - 16usize];
            ["Alignment of ConstTwoByteChars"]
                [::std::mem::align_of::<ConstTwoByteChars>() - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34LossyTwoByteCharsToNewLatin1CharsZEP9JSContextRKN7mozilla5RangeIKDsEE"]
            pub fn LossyTwoByteCharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                tbchars: *const root::mozilla::Range<u16>,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17Utf8ToOneUcs4CharEPKhi"]
            pub fn Utf8ToOneUcs4Char(
                utf8Buffer: *const u8,
                utf8Length: ::std::os::raw::c_int,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27UTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: *const root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS32LossyUTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_9UTF8CharsEPmm"]
            pub fn LossyUTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: *const root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetDeflatedUTF8StringLengthEP14JSLinearString"]
            pub fn GetDeflatedUTF8StringLength(s: *mut root::JSLinearString) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25DeflateStringToUTF8BufferEP14JSLinearStringN7mozilla4SpanIcLm18446744073709551615EEE"]
            pub fn DeflateStringToUTF8Buffer(
                src: *mut root::JSLinearString,
                dst: root::__BindgenOpaqueArray<u64, 2usize>,
            ) -> usize;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SmallestEncoding {
            ASCII = 0,
            Latin1 = 1,
            UTF16 = 2,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20FindSmallestEncodingERKNS_9UTF8CharsE"]
            pub fn FindSmallestEncoding(
                utf8: *const root::JS::UTF8Chars,
            ) -> root::JS::SmallestEncoding;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26UTF8CharsToNewLatin1CharsZEP9JSContextRKNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                utf8: *const root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEPKc"]
            pub fn StringIsASCII(s: *const ::std::os::raw::c_char) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEN7mozilla4SpanIKcLm18446744073709551615EEE"]
            pub fn StringIsASCII1(s: root::__BindgenOpaqueArray<u64, 2usize>) -> bool;
        }
        extern "C" {
            #[doc = " Encode a narrow multibyte character string to a UTF-8 string.\n\n NOTE: Should only be used when interacting with POSIX/OS functions and not\n       for encoding ASCII/Latin-1/etc. strings to UTF-8."]
            #[link_name = "\u{1}_ZN2JS18EncodeNarrowToUtf8EP9JSContextPKc"]
            pub fn EncodeNarrowToUtf8(
                cx: *mut root::JSContext,
                chars: *const ::std::os::raw::c_char,
            ) -> root::JS::UniqueChars;
        }
        extern "C" {
            #[doc = " Encode a wide string to a UTF-8 string.\n\n NOTE: Should only be used when interacting with Windows API functions."]
            #[link_name = "\u{1}_ZN2JS16EncodeWideToUtf8EP9JSContextPKw"]
            pub fn EncodeWideToUtf8(
                cx: *mut root::JSContext,
                chars: *const u32,
            ) -> root::JS::UniqueChars;
        }
        extern "C" {
            #[doc = " Encode a UTF-8 string to a narrow multibyte character string.\n\n NOTE: Should only be used when interacting with POSIX/OS functions and not\n       for encoding UTF-8 to ASCII/Latin-1/etc. strings."]
            #[link_name = "\u{1}_ZN2JS18EncodeUtf8ToNarrowEP9JSContextPKc"]
            pub fn EncodeUtf8ToNarrow(
                cx: *mut root::JSContext,
                chars: *const ::std::os::raw::c_char,
            ) -> root::JS::UniqueChars;
        }
        extern "C" {
            #[doc = " Encode a UTF-8 string to a wide string.\n\n NOTE: Should only be used when interacting with Windows API functions."]
            #[link_name = "\u{1}_ZN2JS16EncodeUtf8ToWideEP9JSContextPKc"]
            pub fn EncodeUtf8ToWide(
                cx: *mut root::JSContext,
                chars: *const ::std::os::raw::c_char,
            ) -> root::JS::UniqueWideChars;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PropertyKey {
            pub asBits_: usize,
        }
        pub const PropertyKey_IntTagBit: usize = 1;
        pub const PropertyKey_StringTypeTag: usize = 0;
        pub const PropertyKey_VoidTypeTag: usize = 2;
        pub const PropertyKey_SymbolTypeTag: usize = 4;
        pub const PropertyKey_TypeMask: usize = 7;
        pub const PropertyKey_IntMin: u32 = 0;
        pub const PropertyKey_IntMax: u32 = 2147483647;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of PropertyKey"][::std::mem::size_of::<PropertyKey>() - 8usize];
            ["Alignment of PropertyKey"][::std::mem::align_of::<PropertyKey>() - 8usize];
            ["Offset of field: PropertyKey::asBits_"]
                [::std::mem::offset_of!(PropertyKey, asBits_) - 0usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_PropertyKey_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_PropertyKey_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
        extern "C" {
            #[doc = " Get one of the well-known symbols defined by ES6 as PropertyKey. This is\n equivalent to calling JS::GetWellKnownSymbol and then creating a PropertyKey.\n\n `which` must be in the range [0, WellKnownSymbolLimit)."]
            #[link_name = "\u{1}_ZN2JS21GetWellKnownSymbolKeyEP9JSContextNS_10SymbolCodeE"]
            pub fn GetWellKnownSymbolKey(
                cx: *mut root::JSContext,
                which: root::JS::SymbolCode,
            ) -> root::JS::PropertyKey;
        }
        extern "C" {
            #[doc = " Generate getter/setter id for given id, by adding \"get \" or \"set \" prefix."]
            #[link_name = "\u{1}_ZN2JS10ToGetterIdEP9JSContextNS_6HandleINS_11PropertyKeyEEENS_13MutableHandleIS3_EE"]
            pub fn ToGetterId(
                cx: *mut root::JSContext,
                id: root::JS::Handle<root::JS::PropertyKey>,
                getterId: root::JS::MutableHandle<root::JS::PropertyKey>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10ToSetterIdEP9JSContextNS_6HandleINS_11PropertyKeyEEENS_13MutableHandleIS3_EE"]
            pub fn ToSetterId(
                cx: *mut root::JSContext,
                id: root::JS::Handle<root::JS::PropertyKey>,
                setterId: root::JS::MutableHandle<root::JS::PropertyKey>,
            ) -> bool;
        }
        #[doc = " Per ES6, the [[DefineOwnProperty]] internal method has three different\n possible outcomes:\n\n -   It can throw an exception (which we indicate by returning false).\n\n -   It can return true, indicating unvarnished success.\n\n -   It can return false, indicating \"strict failure\". The property could\n     not be defined. It's an error, but no exception was thrown.\n\n It's not just [[DefineOwnProperty]]: all the mutating internal methods have\n the same three outcomes. (The other affected internal methods are [[Set]],\n [[Delete]], [[SetPrototypeOf]], and [[PreventExtensions]].)\n\n If you think this design is awful, you're not alone.  But as it's the\n standard, we must represent these boolean \"success\" values somehow.\n ObjectOpSuccess is the class for this. It's like a bool, but when it's false\n it also stores an error code.\n\n Typical usage:\n\n     ObjectOpResult result;\n     if (!DefineProperty(cx, obj, id, ..., result)) {\n         return false;\n     }\n     if (!result) {\n         return result.reportError(cx, obj, id);\n     }\n\n Users don't have to call `result.report()`; another possible ending is:\n\n     argv.rval().setBoolean(result.ok());\n     return true;"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ObjectOpResult {
            #[doc = " code_ is either one of the special codes OkCode or Uninitialized, or an\n error code. For now the error codes are JS friend API and are defined in\n js/public/friend/ErrorNumbers.msg.\n\n code_ is uintptr_t (rather than uint32_t) for the convenience of the\n JITs, which would otherwise have to deal with either padding or stack\n alignment on 64-bit platforms."]
            pub code_: usize,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ObjectOpResult_SpecialCodes {
            OkCode = 0,
            Uninitialized = 18446744073709551615,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ObjectOpResult"][::std::mem::size_of::<ObjectOpResult>() - 8usize];
            ["Alignment of ObjectOpResult"][::std::mem::align_of::<ObjectOpResult>() - 8usize];
            ["Offset of field: ObjectOpResult::code_"]
                [::std::mem::offset_of!(ObjectOpResult, code_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WasmFunctionIndex {
            pub value_: u32,
        }
        pub const WasmFunctionIndex_Limit: u32 = 1073741823;
        pub const WasmFunctionIndex_DefaultBinarySourceColumnNumberOneOrigin: u32 = 1;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of WasmFunctionIndex"][::std::mem::size_of::<WasmFunctionIndex>() - 4usize];
            ["Alignment of WasmFunctionIndex"]
                [::std::mem::align_of::<WasmFunctionIndex>() - 4usize];
            ["Offset of field: WasmFunctionIndex::value_"]
                [::std::mem::offset_of!(WasmFunctionIndex, value_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ColumnNumberOffset {
            pub value_: i32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ColumnNumberOffset"][::std::mem::size_of::<ColumnNumberOffset>() - 4usize];
            ["Alignment of ColumnNumberOffset"]
                [::std::mem::align_of::<ColumnNumberOffset>() - 4usize];
            ["Offset of field: ColumnNumberOffset::value_"]
                [::std::mem::offset_of!(ColumnNumberOffset, value_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ColumnNumberUnsignedOffset {
            pub value_: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ColumnNumberUnsignedOffset"]
                [::std::mem::size_of::<ColumnNumberUnsignedOffset>() - 4usize];
            ["Alignment of ColumnNumberUnsignedOffset"]
                [::std::mem::align_of::<ColumnNumberUnsignedOffset>() - 4usize];
            ["Offset of field: ColumnNumberUnsignedOffset::value_"]
                [::std::mem::offset_of!(ColumnNumberUnsignedOffset, value_) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct LimitedColumnNumberOneOrigin {
            pub _base: u32,
        }
        pub type LimitedColumnNumberOneOrigin_Base = u32;
        pub const LimitedColumnNumberOneOrigin_Limit: u32 = 1073741823;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of LimitedColumnNumberOneOrigin"]
                [::std::mem::size_of::<LimitedColumnNumberOneOrigin>() - 4usize];
            ["Alignment of LimitedColumnNumberOneOrigin"]
                [::std::mem::align_of::<LimitedColumnNumberOneOrigin>() - 4usize];
        };
        #[repr(C, packed(4))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ColumnNumberOneOrigin {
            pub _base: u32,
        }
        pub type ColumnNumberOneOrigin_Base = u32;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ColumnNumberOneOrigin"]
                [::std::mem::size_of::<ColumnNumberOneOrigin>() - 4usize];
            ["Alignment of ColumnNumberOneOrigin"]
                [::std::mem::align_of::<ColumnNumberOneOrigin>() - 4usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TaggedColumnNumberOneOrigin {
            pub value_: u32,
        }
        pub const TaggedColumnNumberOneOrigin_WasmFunctionTag: u32 = 2147483648;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TaggedColumnNumberOneOrigin"]
                [::std::mem::size_of::<TaggedColumnNumberOneOrigin>() - 4usize];
            ["Alignment of TaggedColumnNumberOneOrigin"]
                [::std::mem::align_of::<TaggedColumnNumberOneOrigin>() - 4usize];
            ["Offset of field: TaggedColumnNumberOneOrigin::value_"]
                [::std::mem::offset_of!(TaggedColumnNumberOneOrigin, value_) - 0usize];
        };
        pub type FrontendContext = root::js::FrontendContext;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AsmJSOption {
            Enabled = 0,
            DisabledByAsmJSPref = 1,
            DisabledByLinker = 2,
            DisabledByNoWasmCompiler = 3,
            DisabledByDebugger = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DelazificationOption {
            OnDemandOnly = 0,
            CheckConcurrentWithOnDemand = 1,
            ConcurrentDepthFirst = 2,
            ConcurrentLargeFirst = 3,
            ParseEverythingEagerly = 4,
        }
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PrefableCompileOptions {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
            pub asmJSOption_: root::JS::AsmJSOption,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of PrefableCompileOptions"]
                [::std::mem::size_of::<PrefableCompileOptions>() - 2usize];
            ["Alignment of PrefableCompileOptions"]
                [::std::mem::align_of::<PrefableCompileOptions>() - 1usize];
            ["Offset of field: PrefableCompileOptions::asmJSOption_"]
                [::std::mem::offset_of!(PrefableCompileOptions, asmJSOption_) - 1usize];
        };
        impl PrefableCompileOptions {
            #[inline]
            pub fn importAttributes_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_importAttributes_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn importAttributes__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        0usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_importAttributes__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        0usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn sourcePragmas_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_sourcePragmas_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn sourcePragmas__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        1usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_sourcePragmas__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        1usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn throwOnAsmJSValidationFailure_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_throwOnAsmJSValidationFailure_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn throwOnAsmJSValidationFailure__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        2usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_throwOnAsmJSValidationFailure__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        2usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                importAttributes_: bool,
                sourcePragmas_: bool,
                throwOnAsmJSValidationFailure_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let importAttributes_: u8 = unsafe { ::std::mem::transmute(importAttributes_) };
                    importAttributes_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let sourcePragmas_: u8 = unsafe { ::std::mem::transmute(sourcePragmas_) };
                    sourcePragmas_ as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let throwOnAsmJSValidationFailure_: u8 =
                        unsafe { ::std::mem::transmute(throwOnAsmJSValidationFailure_) };
                    throwOnAsmJSValidationFailure_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " The common base class for the CompileOptions hierarchy.\n\n Use this in code that needs to propagate compile options from one\n compilation unit to another."]
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TransitiveCompileOptions {
            pub filename_: root::JS::ConstUTF8CharsZ,
            pub introducerFilename_: root::JS::ConstUTF8CharsZ,
            pub sourceMapURL_: *const u16,
            #[doc = " The Web Platform allows scripts to be loaded from arbitrary cross-origin\n sources. This allows an attack by which a malicious website loads a\n sensitive file (say, a bank statement) cross-origin (using the user's\n cookies), and sniffs the generated syntax errors (via a window.onerror\n handler) for juicy morsels of its contents.\n\n To counter this attack, HTML5 specifies that script errors should be\n sanitized (\"muted\") when the script is not same-origin with the global\n for which it is loaded. Callers should set this flag for cross-origin\n scripts, and it will be propagated appropriately to child scripts and\n passed back in JSErrorReports."]
            pub mutedErrors_: bool,
            pub forceStrictMode_: bool,
            pub alwaysUseFdlibm_: bool,
            pub skipFilenameValidation_: bool,
            pub hideScriptFromDebugger_: bool,
            pub deferDebugMetadata_: bool,
            pub eagerDelazificationStrategy_: root::JS::DelazificationOption,
            pub selfHostingMode: bool,
            pub discardSource: bool,
            pub sourceIsLazy: bool,
            pub allowHTMLComments: bool,
            pub nonSyntacticScope: bool,
            pub topLevelAwait: bool,
            pub borrowBuffer: bool,
            pub usePinnedBytecode: bool,
            pub prefableOptions_: root::JS::PrefableCompileOptions,
            #[doc = " |introductionType| is a statically allocated C string. See JSScript.h\n for more information."]
            pub introductionType: *const ::std::os::raw::c_char,
            pub introductionLineno: ::std::os::raw::c_uint,
            pub introductionOffset: u32,
            pub hasIntroductionInfo: bool,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TransitiveCompileOptions"]
                [::std::mem::size_of::<TransitiveCompileOptions>() - 58usize];
            ["Alignment of TransitiveCompileOptions"]
                [::std::mem::align_of::<TransitiveCompileOptions>() - 1usize];
            ["Offset of field: TransitiveCompileOptions::filename_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, filename_) - 0usize];
            ["Offset of field: TransitiveCompileOptions::introducerFilename_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, introducerFilename_) - 8usize];
            ["Offset of field: TransitiveCompileOptions::sourceMapURL_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, sourceMapURL_) - 16usize];
            ["Offset of field: TransitiveCompileOptions::mutedErrors_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, mutedErrors_) - 24usize];
            ["Offset of field: TransitiveCompileOptions::forceStrictMode_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, forceStrictMode_) - 25usize];
            ["Offset of field: TransitiveCompileOptions::alwaysUseFdlibm_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, alwaysUseFdlibm_) - 26usize];
            ["Offset of field: TransitiveCompileOptions::skipFilenameValidation_"][::std::mem::offset_of!(
                TransitiveCompileOptions,
                skipFilenameValidation_
            ) - 27usize];
            ["Offset of field: TransitiveCompileOptions::hideScriptFromDebugger_"][::std::mem::offset_of!(
                TransitiveCompileOptions,
                hideScriptFromDebugger_
            ) - 28usize];
            ["Offset of field: TransitiveCompileOptions::deferDebugMetadata_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, deferDebugMetadata_) - 29usize];
            ["Offset of field: TransitiveCompileOptions::eagerDelazificationStrategy_"][::std::mem::offset_of!(
                TransitiveCompileOptions,
                eagerDelazificationStrategy_
            )
                - 30usize];
            ["Offset of field: TransitiveCompileOptions::selfHostingMode"]
                [::std::mem::offset_of!(TransitiveCompileOptions, selfHostingMode) - 31usize];
            ["Offset of field: TransitiveCompileOptions::discardSource"]
                [::std::mem::offset_of!(TransitiveCompileOptions, discardSource) - 32usize];
            ["Offset of field: TransitiveCompileOptions::sourceIsLazy"]
                [::std::mem::offset_of!(TransitiveCompileOptions, sourceIsLazy) - 33usize];
            ["Offset of field: TransitiveCompileOptions::allowHTMLComments"]
                [::std::mem::offset_of!(TransitiveCompileOptions, allowHTMLComments) - 34usize];
            ["Offset of field: TransitiveCompileOptions::nonSyntacticScope"]
                [::std::mem::offset_of!(TransitiveCompileOptions, nonSyntacticScope) - 35usize];
            ["Offset of field: TransitiveCompileOptions::topLevelAwait"]
                [::std::mem::offset_of!(TransitiveCompileOptions, topLevelAwait) - 36usize];
            ["Offset of field: TransitiveCompileOptions::borrowBuffer"]
                [::std::mem::offset_of!(TransitiveCompileOptions, borrowBuffer) - 37usize];
            ["Offset of field: TransitiveCompileOptions::usePinnedBytecode"]
                [::std::mem::offset_of!(TransitiveCompileOptions, usePinnedBytecode) - 38usize];
            ["Offset of field: TransitiveCompileOptions::prefableOptions_"]
                [::std::mem::offset_of!(TransitiveCompileOptions, prefableOptions_) - 39usize];
            ["Offset of field: TransitiveCompileOptions::introductionType"]
                [::std::mem::offset_of!(TransitiveCompileOptions, introductionType) - 41usize];
            ["Offset of field: TransitiveCompileOptions::introductionLineno"]
                [::std::mem::offset_of!(TransitiveCompileOptions, introductionLineno) - 49usize];
            ["Offset of field: TransitiveCompileOptions::introductionOffset"]
                [::std::mem::offset_of!(TransitiveCompileOptions, introductionOffset) - 53usize];
            ["Offset of field: TransitiveCompileOptions::hasIntroductionInfo"]
                [::std::mem::offset_of!(TransitiveCompileOptions, hasIntroductionInfo) - 57usize];
        };
        #[doc = " The class representing a full set of compile options.\n\n Use this in code that only needs to access compilation options created\n elsewhere, like the compiler.  Don't instantiate this class (the constructor\n is protected anyway); instead, create instances only of the derived classes:\n CompileOptions and OwningCompileOptions."]
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ReadOnlyCompileOptions {
            pub _base: root::JS::TransitiveCompileOptions,
            pub lineno: u32,
            pub column: root::JS::ColumnNumberOneOrigin,
            pub scriptSourceOffset: ::std::os::raw::c_uint,
            pub isRunOnce: bool,
            pub noScriptRval: bool,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ReadOnlyCompileOptions"]
                [::std::mem::size_of::<ReadOnlyCompileOptions>() - 72usize];
            ["Alignment of ReadOnlyCompileOptions"]
                [::std::mem::align_of::<ReadOnlyCompileOptions>() - 1usize];
            ["Offset of field: ReadOnlyCompileOptions::lineno"]
                [::std::mem::offset_of!(ReadOnlyCompileOptions, lineno) - 58usize];
            ["Offset of field: ReadOnlyCompileOptions::column"]
                [::std::mem::offset_of!(ReadOnlyCompileOptions, column) - 62usize];
            ["Offset of field: ReadOnlyCompileOptions::scriptSourceOffset"]
                [::std::mem::offset_of!(ReadOnlyCompileOptions, scriptSourceOffset) - 66usize];
            ["Offset of field: ReadOnlyCompileOptions::isRunOnce"]
                [::std::mem::offset_of!(ReadOnlyCompileOptions, isRunOnce) - 70usize];
            ["Offset of field: ReadOnlyCompileOptions::noScriptRval"]
                [::std::mem::offset_of!(ReadOnlyCompileOptions, noScriptRval) - 71usize];
        };
        #[doc = " Compilation options, with dynamic lifetime. An instance of this type\n makes a copy of / holds / roots all dynamically allocated resources\n (principals; elements; strings) that it refers to. Its destructor frees\n / drops / unroots them. This is heavier than CompileOptions, below, but\n unlike CompileOptions, it can outlive any given stack frame.\n\n Note that this *roots* any JS values it refers to - they're live\n unconditionally. Thus, instances of this type can't be owned, directly\n or indirectly, by a JavaScript object: if any value that this roots ever\n comes to refer to the object that owns this, then the whole cycle, and\n anything else it entrains, will never be freed."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct OwningCompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OwningCompileOptions_ForFrontendContext {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of OwningCompileOptions_ForFrontendContext"]
                [::std::mem::size_of::<OwningCompileOptions_ForFrontendContext>() - 1usize];
            ["Alignment of OwningCompileOptions_ForFrontendContext"]
                [::std::mem::align_of::<OwningCompileOptions_ForFrontendContext>() - 1usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of OwningCompileOptions"]
                [::std::mem::size_of::<OwningCompileOptions>() - 72usize];
            ["Alignment of OwningCompileOptions"]
                [::std::mem::align_of::<OwningCompileOptions>() - 1usize];
        };
        #[doc = " Compilation options stored on the stack. An instance of this type\n simply holds references to dynamically allocated resources (element;\n filename; source map URL) that are owned by something else. If you\n create an instance of this type, it's up to you to guarantee that\n everything you store in it will outlive it."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CompileOptions"][::std::mem::size_of::<CompileOptions>() - 72usize];
            ["Alignment of CompileOptions"][::std::mem::align_of::<CompileOptions>() - 1usize];
        };
        #[doc = " Subset of CompileOptions fields used while instantiating Stencils."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct InstantiateOptions {
            pub skipFilenameValidation: bool,
            pub hideScriptFromDebugger: bool,
            pub deferDebugMetadata: bool,
            pub eagerDelazificationStrategy_: root::JS::DelazificationOption,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of InstantiateOptions"][::std::mem::size_of::<InstantiateOptions>() - 4usize];
            ["Alignment of InstantiateOptions"]
                [::std::mem::align_of::<InstantiateOptions>() - 1usize];
            ["Offset of field: InstantiateOptions::skipFilenameValidation"]
                [::std::mem::offset_of!(InstantiateOptions, skipFilenameValidation) - 0usize];
            ["Offset of field: InstantiateOptions::hideScriptFromDebugger"]
                [::std::mem::offset_of!(InstantiateOptions, hideScriptFromDebugger) - 1usize];
            ["Offset of field: InstantiateOptions::deferDebugMetadata"]
                [::std::mem::offset_of!(InstantiateOptions, deferDebugMetadata) - 2usize];
            ["Offset of field: InstantiateOptions::eagerDelazificationStrategy_"]
                [::std::mem::offset_of!(InstantiateOptions, eagerDelazificationStrategy_) - 3usize];
        };
        #[doc = " Subset of CompileOptions fields used while decoding Stencils."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ReadOnlyDecodeOptions {
            pub borrowBuffer: bool,
            pub usePinnedBytecode: bool,
            pub introducerFilename_: root::JS::ConstUTF8CharsZ,
            pub introductionType: *const ::std::os::raw::c_char,
            pub introductionLineno: u32,
            pub introductionOffset: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ReadOnlyDecodeOptions"]
                [::std::mem::size_of::<ReadOnlyDecodeOptions>() - 32usize];
            ["Alignment of ReadOnlyDecodeOptions"]
                [::std::mem::align_of::<ReadOnlyDecodeOptions>() - 8usize];
            ["Offset of field: ReadOnlyDecodeOptions::borrowBuffer"]
                [::std::mem::offset_of!(ReadOnlyDecodeOptions, borrowBuffer) - 0usize];
            ["Offset of field: ReadOnlyDecodeOptions::usePinnedBytecode"]
                [::std::mem::offset_of!(ReadOnlyDecodeOptions, usePinnedBytecode) - 1usize];
            ["Offset of field: ReadOnlyDecodeOptions::introducerFilename_"]
                [::std::mem::offset_of!(ReadOnlyDecodeOptions, introducerFilename_) - 2usize];
            ["Offset of field: ReadOnlyDecodeOptions::introductionType"]
                [::std::mem::offset_of!(ReadOnlyDecodeOptions, introductionType) - 16usize];
            ["Offset of field: ReadOnlyDecodeOptions::introductionLineno"]
                [::std::mem::offset_of!(ReadOnlyDecodeOptions, introductionLineno) - 24usize];
            ["Offset of field: ReadOnlyDecodeOptions::introductionOffset"]
                [::std::mem::offset_of!(ReadOnlyDecodeOptions, introductionOffset) - 28usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DecodeOptions {
            pub _base: root::JS::ReadOnlyDecodeOptions,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of DecodeOptions"][::std::mem::size_of::<DecodeOptions>() - 32usize];
            ["Alignment of DecodeOptions"][::std::mem::align_of::<DecodeOptions>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct OwningDecodeOptions {
            pub _base: root::JS::ReadOnlyDecodeOptions,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of OwningDecodeOptions"][::std::mem::size_of::<OwningDecodeOptions>() - 32usize];
            ["Alignment of OwningDecodeOptions"]
                [::std::mem::align_of::<OwningDecodeOptions>() - 8usize];
        };
        extern "C" {
            #[doc = " Asserts (in debug and release builds) that `obj` belongs to the current\n thread's context."]
            #[link_name = "\u{1}_ZN2JS34AssertObjectBelongsToCurrentThreadEP8JSObject"]
            pub fn AssertObjectBelongsToCurrentThread(obj: *mut root::JSObject);
        }
        #[doc = " Install a process-wide callback to validate script filenames. The JS engine\n will invoke this callback for each JS script it parses or XDR decodes.\n\n If the callback returns |false|, an exception is thrown and parsing/decoding\n will be aborted.\n\n See also CompileOptions::setSkipFilenameValidation to opt-out of the callback\n for specific parse jobs."]
        pub type FilenameValidationCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                filename: *const ::std::os::raw::c_char,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS29SetFilenameValidationCallbackEPFbP9JSContextPKcE"]
            pub fn SetFilenameValidationCallback(cb: root::JS::FilenameValidationCallback);
        }
        #[doc = " Install an context wide callback that implements the ECMA262 specification\n host hook `HostEnsureCanAddPrivateElement`.\n\n This hook, which should only be overriden for Web Browsers, examines the\n provided object to determine if the addition of a private field is allowed,\n throwing an exception and returning false if not.\n\n The default implementation of this hook, which will be used unless overriden,\n examines only proxy objects, and throws if the proxy handler returns true\n from the handler method `throwOnPrivateField()`."]
        pub type EnsureCanAddPrivateElementOp = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, val: root::JS::HandleValue) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS37SetHostEnsureCanAddPrivateElementHookEP9JSContextPFbS1_NS_6HandleINS_5ValueEEEE"]
            pub fn SetHostEnsureCanAddPrivateElementHook(
                cx: *mut root::JSContext,
                op: root::JS::EnsureCanAddPrivateElementOp,
            );
        }
        extern "C" {
            #[doc = " Transition the cx to a mode where failures that would normally cause a false\n return value will instead crash with a diagnostic assertion.\n\n Return value: the former brittle mode setting."]
            #[link_name = "\u{1}_ZN2JS14SetBrittleModeEP9JSContextb"]
            pub fn SetBrittleMode(cx: *mut root::JSContext, setting: bool) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoBrittleMode {
            pub wasBrittle: bool,
            pub cx: *mut root::JSContext,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoBrittleMode"][::std::mem::size_of::<AutoBrittleMode>() - 16usize];
            ["Alignment of AutoBrittleMode"][::std::mem::align_of::<AutoBrittleMode>() - 8usize];
            ["Offset of field: AutoBrittleMode::wasBrittle"]
                [::std::mem::offset_of!(AutoBrittleMode, wasBrittle) - 0usize];
            ["Offset of field: AutoBrittleMode::cx"]
                [::std::mem::offset_of!(AutoBrittleMode, cx) - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TimeBudget {
            pub budget: root::mozilla::TimeDuration,
            pub deadline: root::mozilla::TimeStamp,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TimeBudget"][::std::mem::size_of::<TimeBudget>() - 16usize];
            ["Alignment of TimeBudget"][::std::mem::align_of::<TimeBudget>() - 8usize];
            ["Offset of field: TimeBudget::budget"]
                [::std::mem::offset_of!(TimeBudget, budget) - 0usize];
            ["Offset of field: TimeBudget::deadline"]
                [::std::mem::offset_of!(TimeBudget, deadline) - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WorkBudget {
            pub budget: i64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of WorkBudget"][::std::mem::size_of::<WorkBudget>() - 8usize];
            ["Alignment of WorkBudget"][::std::mem::align_of::<WorkBudget>() - 8usize];
            ["Offset of field: WorkBudget::budget"]
                [::std::mem::offset_of!(WorkBudget, budget) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UnlimitedBudget {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of UnlimitedBudget"][::std::mem::size_of::<UnlimitedBudget>() - 1usize];
            ["Alignment of UnlimitedBudget"][::std::mem::align_of::<UnlimitedBudget>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SliceBudget {
            pub counter: i64,
            pub interruptRequested: *mut root::JS::SliceBudget_InterruptRequestFlag,
            pub budget: root::__BindgenOpaqueArray<u64, 3usize>,
            pub interrupted: bool,
            pub idle: bool,
            pub extended: bool,
        }
        pub type SliceBudget_InterruptRequestFlag = u8;
        pub const SliceBudget_UnlimitedCounter: i64 = 9223372036854775807;
        pub const SliceBudget_StepsPerExpensiveCheck: i64 = 1000;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of SliceBudget"][::std::mem::size_of::<SliceBudget>() - 48usize];
            ["Alignment of SliceBudget"][::std::mem::align_of::<SliceBudget>() - 8usize];
            ["Offset of field: SliceBudget::counter"]
                [::std::mem::offset_of!(SliceBudget, counter) - 0usize];
            ["Offset of field: SliceBudget::interruptRequested"]
                [::std::mem::offset_of!(SliceBudget, interruptRequested) - 8usize];
            ["Offset of field: SliceBudget::budget"]
                [::std::mem::offset_of!(SliceBudget, budget) - 16usize];
            ["Offset of field: SliceBudget::interrupted"]
                [::std::mem::offset_of!(SliceBudget, interrupted) - 40usize];
            ["Offset of field: SliceBudget::idle"]
                [::std::mem::offset_of!(SliceBudget, idle) - 41usize];
            ["Offset of field: SliceBudget::extended"]
                [::std::mem::offset_of!(SliceBudget, extended) - 42usize];
        };
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCOptions {
            Normal = 0,
            Shrink = 1,
            Shutdown = 2,
        }
        impl root::JS::GCReason {
            pub const DOM_WINDOW_UTILS: root::JS::GCReason = GCReason::FIRST_FIREFOX_REASON;
        }
        impl root::JS::GCReason {
            pub const PREPARE_FOR_PAGELOAD: root::JS::GCReason = GCReason::LAST_FIREFOX_REASON;
        }
        impl root::JS::GCReason {
            pub const RESERVED1: root::JS::GCReason = GCReason::FIRST_RESERVED_REASON;
        }
        impl root::JS::GCReason {
            pub const NUM_TELEMETRY_REASONS: root::JS::GCReason = GCReason::NUM_REASONS;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCReason {
            FIRST_FIREFOX_REASON = 33,
            LAST_FIREFOX_REASON = 57,
            FIRST_RESERVED_REASON = 90,
            API = 0,
            EAGER_ALLOC_TRIGGER = 1,
            DESTROY_RUNTIME = 2,
            ROOTS_REMOVED = 3,
            LAST_DITCH = 4,
            TOO_MUCH_MALLOC = 5,
            ALLOC_TRIGGER = 6,
            DEBUG_GC = 7,
            COMPARTMENT_REVIVED = 8,
            RESET = 9,
            OUT_OF_NURSERY = 10,
            EVICT_NURSERY = 11,
            SHARED_MEMORY_LIMIT = 13,
            EAGER_NURSERY_COLLECTION = 14,
            BG_TASK_FINISHED = 15,
            ABORT_GC = 16,
            FULL_WHOLE_CELL_BUFFER = 17,
            FULL_GENERIC_BUFFER = 18,
            FULL_VALUE_BUFFER = 19,
            FULL_CELL_PTR_OBJ_BUFFER = 20,
            FULL_SLOT_BUFFER = 21,
            FULL_SHAPE_BUFFER = 22,
            TOO_MUCH_WASM_MEMORY = 23,
            DISABLE_GENERATIONAL_GC = 24,
            FINISH_GC = 25,
            PREPARE_FOR_TRACING = 26,
            FULL_WASM_ANYREF_BUFFER = 27,
            FULL_CELL_PTR_STR_BUFFER = 28,
            TOO_MUCH_JIT_CODE = 29,
            FULL_CELL_PTR_BIGINT_BUFFER = 30,
            NURSERY_TRAILERS = 31,
            NURSERY_MALLOC_BUFFERS = 32,
            COMPONENT_UTILS = 34,
            MEM_PRESSURE = 35,
            CC_FINISHED = 36,
            CC_FORCED = 37,
            LOAD_END = 38,
            UNUSED3 = 39,
            PAGE_HIDE = 40,
            NSJSCONTEXT_DESTROY = 41,
            WORKER_SHUTDOWN = 42,
            SET_DOC_SHELL = 43,
            DOM_UTILS = 44,
            DOM_IPC = 45,
            DOM_WORKER = 46,
            INTER_SLICE_GC = 47,
            UNUSED1 = 48,
            FULL_GC_TIMER = 49,
            SHUTDOWN_CC = 50,
            UNUSED2 = 51,
            USER_INACTIVE = 52,
            XPCONNECT_SHUTDOWN = 53,
            DOCSHELL = 54,
            HTML_PARSER = 55,
            DOM_TESTUTILS = 56,
            RESERVED2 = 91,
            RESERVED3 = 92,
            RESERVED4 = 93,
            RESERVED5 = 94,
            RESERVED6 = 95,
            RESERVED7 = 96,
            RESERVED8 = 97,
            RESERVED9 = 98,
            NO_REASON = 99,
            NUM_REASONS = 100,
        }
        extern "C" {
            #[doc = " Get a statically allocated C string explaining the given GC reason."]
            #[link_name = "\u{1}_ZN2JS15ExplainGCReasonENS_8GCReasonE"]
            pub fn ExplainGCReason(reason: root::JS::GCReason) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Return true if the GC reason is internal to the JS engine."]
            #[link_name = "\u{1}_ZN2JS16InternalGCReasonENS_8GCReasonE"]
            pub fn InternalGCReason(reason: root::JS::GCReason) -> bool;
        }
        extern "C" {
            #[doc = " Get a statically allocated C string explaining the given Abort reason.\n Input is the integral value of the enum."]
            #[link_name = "\u{1}_ZN2JS20ExplainGCAbortReasonEj"]
            pub fn ExplainGCAbortReason(reason: u32) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Get a statically allocated C string describing the Phase.\n Input is the integral value of the enum."]
            #[link_name = "\u{1}_ZN2JS14GetGCPhaseNameEj"]
            pub fn GetGCPhaseName(phase: u32) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Schedule the given zone to be collected as part of the next GC."]
            #[link_name = "\u{1}_ZN2JS16PrepareZoneForGCEP9JSContextPNS_4ZoneE"]
            pub fn PrepareZoneForGC(cx: *mut root::JSContext, zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Schedule all zones to be collected in the next GC."]
            #[link_name = "\u{1}_ZN2JS16PrepareForFullGCEP9JSContext"]
            pub fn PrepareForFullGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " When performing an incremental GC, the zones that were selected for the\n previous incremental slice must be selected in subsequent slices as well.\n This function selects those slices automatically."]
            #[link_name = "\u{1}_ZN2JS23PrepareForIncrementalGCEP9JSContext"]
            pub fn PrepareForIncrementalGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns true if any zone in the system has been scheduled for GC with one of\n the functions above or by the JS engine."]
            #[link_name = "\u{1}_ZN2JS13IsGCScheduledEP9JSContext"]
            pub fn IsGCScheduled(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Undoes the effect of the Prepare methods above. The given zone will not be\n collected in the next GC."]
            #[link_name = "\u{1}_ZN2JS13SkipZoneForGCEP9JSContextPNS_4ZoneE"]
            pub fn SkipZoneForGC(cx: *mut root::JSContext, zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Performs a non-incremental collection of all selected zones."]
            #[link_name = "\u{1}_ZN2JS16NonIncrementalGCEP9JSContextNS_9GCOptionsENS_8GCReasonE"]
            pub fn NonIncrementalGC(
                cx: *mut root::JSContext,
                options: root::JS::GCOptions,
                reason: root::JS::GCReason,
            );
        }
        extern "C" {
            #[doc = " Begin an incremental collection and perform one slice worth of work. When\n this function returns, the collection may not be complete.\n IncrementalGCSlice() must be called repeatedly until\n !IsIncrementalGCInProgress(cx).\n\n Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or\n       shorter than the requested interval."]
            #[link_name = "\u{1}_ZN2JS18StartIncrementalGCEP9JSContextNS_9GCOptionsENS_8GCReasonERKNS_11SliceBudgetE"]
            pub fn StartIncrementalGC(
                cx: *mut root::JSContext,
                options: root::JS::GCOptions,
                reason: root::JS::GCReason,
                budget: *const root::JS::SliceBudget,
            );
        }
        extern "C" {
            #[doc = " Perform a slice of an ongoing incremental collection. When this function\n returns, the collection may not be complete. It must be called repeatedly\n until !IsIncrementalGCInProgress(cx).\n\n Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or\n       shorter than the requested interval."]
            #[link_name = "\u{1}_ZN2JS18IncrementalGCSliceEP9JSContextNS_8GCReasonERKNS_11SliceBudgetE"]
            pub fn IncrementalGCSlice(
                cx: *mut root::JSContext,
                reason: root::JS::GCReason,
                budget: *const root::JS::SliceBudget,
            );
        }
        extern "C" {
            #[doc = " Return whether an incremental GC has work to do on the foreground thread and\n would make progress if a slice was run now. If this returns false then the GC\n is waiting for background threads to finish their work and a slice started\n now would return immediately."]
            #[link_name = "\u{1}_ZN2JS30IncrementalGCHasForegroundWorkEP9JSContext"]
            pub fn IncrementalGCHasForegroundWork(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " If IsIncrementalGCInProgress(cx), this call finishes the ongoing collection\n by performing an arbitrarily long slice. If !IsIncrementalGCInProgress(cx),\n this is equivalent to NonIncrementalGC. When this function returns,\n IsIncrementalGCInProgress(cx) will always be false."]
            #[link_name = "\u{1}_ZN2JS19FinishIncrementalGCEP9JSContextNS_8GCReasonE"]
            pub fn FinishIncrementalGC(cx: *mut root::JSContext, reason: root::JS::GCReason);
        }
        extern "C" {
            #[doc = " If IsIncrementalGCInProgress(cx), this call aborts the ongoing collection and\n performs whatever work needs to be done to return the collector to its idle\n state. This may take an arbitrarily long time. When this function returns,\n IsIncrementalGCInProgress(cx) will always be false."]
            #[link_name = "\u{1}_ZN2JS18AbortIncrementalGCEP9JSContext"]
            pub fn AbortIncrementalGC(cx: *mut root::JSContext);
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: root::__BindgenOpaqueArray<u64, 3usize>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of GarbageCollectionEvent_Collection"]
                    [::std::mem::size_of::<GarbageCollectionEvent_Collection>() - 16usize];
                ["Alignment of GarbageCollectionEvent_Collection"]
                    [::std::mem::align_of::<GarbageCollectionEvent_Collection>() - 8usize];
                ["Offset of field: GarbageCollectionEvent_Collection::startTimestamp"][::std::mem::offset_of!(
                    GarbageCollectionEvent_Collection,
                    startTimestamp
                ) - 0usize];
                ["Offset of field: GarbageCollectionEvent_Collection::endTimestamp"][::std::mem::offset_of!(
                    GarbageCollectionEvent_Collection,
                    endTimestamp
                ) - 8usize];
            };
            pub type GarbageCollectionEvent_Ptr = u8;
            #[allow(clippy::unnecessary_operation, clippy::identity_op)]
            const _: () = {
                ["Size of GarbageCollectionEvent"]
                    [::std::mem::size_of::<GarbageCollectionEvent>() - 48usize];
                ["Alignment of GarbageCollectionEvent"]
                    [::std::mem::align_of::<GarbageCollectionEvent>() - 8usize];
                ["Offset of field: GarbageCollectionEvent::majorGCNumber_"]
                    [::std::mem::offset_of!(GarbageCollectionEvent, majorGCNumber_) - 0usize];
                ["Offset of field: GarbageCollectionEvent::reason"]
                    [::std::mem::offset_of!(GarbageCollectionEvent, reason) - 8usize];
                ["Offset of field: GarbageCollectionEvent::nonincrementalReason"][::std::mem::offset_of!(
                    GarbageCollectionEvent,
                    nonincrementalReason
                ) - 16usize];
                ["Offset of field: GarbageCollectionEvent::collections"]
                    [::std::mem::offset_of!(GarbageCollectionEvent, collections) - 24usize];
            };
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg23SetDebuggerMallocSizeOfEP9JSContextPFmPKvE"]
                pub fn SetDebuggerMallocSizeOf(
                    cx: *mut root::JSContext,
                    mallocSizeOf: root::mozilla::MallocSizeOf,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg23GetDebuggerMallocSizeOfEP9JSContext"]
                pub fn GetDebuggerMallocSizeOf(
                    cx: *mut root::JSContext,
                ) -> root::mozilla::MallocSizeOf;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg35FireOnGarbageCollectionHookRequiredEP9JSContext"]
                pub fn FireOnGarbageCollectionHookRequired(cx: *mut root::JSContext) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg10IsDebuggerER8JSObject"]
                pub fn IsDebugger(obj: *mut root::JSObject) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg18GetDebuggeeGlobalsEP9JSContextR8JSObjectNS_13MutableHandleINS_13StackGCVectorIPS3_N2js15TempAllocPolicyEEEEE"]
                pub fn GetDebuggeeGlobals(
                    cx: *mut root::JSContext,
                    dbgObj: *mut root::JSObject,
                    vector: root::JS::MutableHandleObjectVector,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg22ShouldAvoidSideEffectsEP9JSContext"]
                pub fn ShouldAvoidSideEffects(cx: *mut root::JSContext) -> bool;
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCProgress {
            GC_CYCLE_BEGIN = 0,
            GC_SLICE_BEGIN = 1,
            GC_SLICE_END = 2,
            GC_CYCLE_END = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCDescription {
            pub isZone_: bool,
            pub isComplete_: bool,
            pub options_: root::JS::GCOptions,
            pub reason_: root::JS::GCReason,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of GCDescription"][::std::mem::size_of::<GCDescription>() - 12usize];
            ["Alignment of GCDescription"][::std::mem::align_of::<GCDescription>() - 4usize];
            ["Offset of field: GCDescription::isZone_"]
                [::std::mem::offset_of!(GCDescription, isZone_) - 0usize];
            ["Offset of field: GCDescription::isComplete_"]
                [::std::mem::offset_of!(GCDescription, isComplete_) - 1usize];
            ["Offset of field: GCDescription::options_"]
                [::std::mem::offset_of!(GCDescription, options_) - 4usize];
            ["Offset of field: GCDescription::reason_"]
                [::std::mem::offset_of!(GCDescription, reason_) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13MinorGcToJSONEP9JSContext"]
            pub fn MinorGcToJSON(cx: *mut root::JSContext) -> root::JS::UniqueChars;
        }
        pub type GCSliceCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCProgress,
                desc: *const root::JS::GCDescription,
            ),
        >;
        extern "C" {
            #[doc = " The GC slice callback is called at the beginning and end of each slice. This\n callback may be used for GC notifications as well as to perform additional\n marking."]
            #[link_name = "\u{1}_ZN2JS18SetGCSliceCallbackEP9JSContextPFvS1_NS_10GCProgressERKNS_13GCDescriptionEE"]
            pub fn SetGCSliceCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCSliceCallback,
            ) -> root::JS::GCSliceCallback;
        }
        #[repr(i32)]
        #[doc = " Describes the progress of an observed nursery collection."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCNurseryProgress {
            #[doc = " The nursery collection is starting."]
            GC_NURSERY_COLLECTION_START = 0,
            #[doc = " The nursery collection is ending."]
            GC_NURSERY_COLLECTION_END = 1,
        }
        #[doc = " A nursery collection callback receives the progress of the nursery collection\n and the reason for the collection."]
        pub type GCNurseryCollectionCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCNurseryProgress,
                reason: root::JS::GCReason,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[doc = " Add and remove nursery collection callbacks for the given runtime. These will\n be called at the start and end of every nursery collection."]
            #[link_name = "\u{1}_ZN2JS30AddGCNurseryCollectionCallbackEP9JSContextPFvS1_NS_17GCNurseryProgressENS_8GCReasonEPvES4_"]
            pub fn AddGCNurseryCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCNurseryCollectionCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS33RemoveGCNurseryCollectionCallbackEP9JSContextPFvS1_NS_17GCNurseryProgressENS_8GCReasonEPvES4_"]
            pub fn RemoveGCNurseryCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCNurseryCollectionCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        pub type DoCycleCollectionCallback =
            ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext)>;
        extern "C" {
            #[doc = " The purge gray callback is called after any COMPARTMENT_REVIVED GC in which\n the majority of compartments have been marked gray."]
            #[link_name = "\u{1}_ZN2JS28SetDoCycleCollectionCallbackEP9JSContextPFvS1_E"]
            pub fn SetDoCycleCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DoCycleCollectionCallback,
            ) -> root::JS::DoCycleCollectionCallback;
        }
        pub type CreateSliceBudgetCallback = ::std::option::Option<
            unsafe extern "C" fn(reason: root::JS::GCReason, millis: i64) -> root::JS::SliceBudget,
        >;
        extern "C" {
            #[doc = " Called when generating a GC slice budget. It allows the embedding to control\n the duration of slices and potentially check an interrupt flag as well. For\n internally triggered GCs, the given millis parameter is the JS engine's\n internal scheduling decision, which the embedding can choose to ignore.\n (Otherwise, it will be the value that was passed to eg\n JS::IncrementalGCSlice())."]
            #[link_name = "\u{1}_ZN2JS30SetCreateGCSliceBudgetCallbackEP9JSContextPFNS_11SliceBudgetENS_8GCReasonElE"]
            pub fn SetCreateGCSliceBudgetCallback(
                cx: *mut root::JSContext,
                cb: root::JS::CreateSliceBudgetCallback,
            );
        }
        extern "C" {
            #[doc = " Returns true if incremental GC is enabled. Simply having incremental GC\n enabled is not sufficient to ensure incremental collections are happening.\n See the comment \"Incremental GC\" above for reasons why incremental GC may be\n suppressed. Inspection of the \"nonincremental reason\" field of the\n GCDescription returned by GCSliceCallback may help narrow down the cause if\n collections are not happening incrementally when expected."]
            #[link_name = "\u{1}_ZN2JS22IsIncrementalGCEnabledEP9JSContext"]
            pub fn IsIncrementalGCEnabled(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Returns true while an incremental GC is ongoing, both when actively\n collecting and between slices."]
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSContext"]
            pub fn IsIncrementalGCInProgress(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Returns true while an incremental GC is ongoing, both when actively\n collecting and between slices."]
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSRuntime"]
            pub fn IsIncrementalGCInProgress1(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the most recent GC ran incrementally."]
            #[link_name = "\u{1}_ZN2JS16WasIncrementalGCEP9JSRuntime"]
            pub fn WasIncrementalGC(rt: *mut root::JSRuntime) -> bool;
        }
        #[doc = " Ensure that generational GC is disabled within some scope.\n\n This evicts the nursery and discards JIT code so it is not a lightweight\n operation."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoDisableGenerationalGC {
            pub cx: *mut root::JSContext,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoDisableGenerationalGC"]
                [::std::mem::size_of::<AutoDisableGenerationalGC>() - 8usize];
            ["Alignment of AutoDisableGenerationalGC"]
                [::std::mem::align_of::<AutoDisableGenerationalGC>() - 8usize];
            ["Offset of field: AutoDisableGenerationalGC::cx"]
                [::std::mem::offset_of!(AutoDisableGenerationalGC, cx) - 0usize];
        };
        extern "C" {
            #[doc = " Returns true if generational allocation and collection is currently enabled\n on the given runtime."]
            #[link_name = "\u{1}_ZN2JS23IsGenerationalGCEnabledEP9JSRuntime"]
            pub fn IsGenerationalGCEnabled(rt: *mut root::JSRuntime) -> bool;
        }
        #[doc = " Pass a subclass of this \"abstract\" class to callees to require that they\n never GC. Subclasses can use assertions or the hazard analysis to ensure no\n GC happens."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoRequireNoGC {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoRequireNoGC"][::std::mem::size_of::<AutoRequireNoGC>() - 1usize];
            ["Alignment of AutoRequireNoGC"][::std::mem::align_of::<AutoRequireNoGC>() - 1usize];
        };
        #[doc = " Diagnostic assert (see MOZ_DIAGNOSTIC_ASSERT) that GC cannot occur while this\n class is live. This class does not disable the static rooting hazard\n analysis.\n\n This works by entering a GC unsafe region, which is checked on allocation and\n on GC."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoAssertNoGC {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoAssertNoGC"][::std::mem::size_of::<AutoAssertNoGC>() - 1usize];
            ["Alignment of AutoAssertNoGC"][::std::mem::align_of::<AutoAssertNoGC>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoSuppressGCAnalysis {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoSuppressGCAnalysis"]
                [::std::mem::size_of::<AutoSuppressGCAnalysis>() - 1usize];
            ["Alignment of AutoSuppressGCAnalysis"]
                [::std::mem::align_of::<AutoSuppressGCAnalysis>() - 1usize];
        };
        #[doc = " Assert that code is only ever called from a GC callback, disable the static\n rooting hazard analysis and assert if any allocation that could potentially\n trigger a GC occurs while this guard object is live.\n\n This is useful to make the static analysis ignore code that runs in GC\n callbacks."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoAssertGCCallback {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoAssertGCCallback"]
                [::std::mem::size_of::<AutoAssertGCCallback>() - 1usize];
            ["Alignment of AutoAssertGCCallback"]
                [::std::mem::align_of::<AutoAssertGCCallback>() - 1usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoCheckCannotGC {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoCheckCannotGC"][::std::mem::size_of::<AutoCheckCannotGC>() - 1usize];
            ["Alignment of AutoCheckCannotGC"]
                [::std::mem::align_of::<AutoCheckCannotGC>() - 1usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17SetLowMemoryStateEP9JSContextb"]
            pub fn SetLowMemoryState(cx: *mut root::JSContext, newState: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20NotifyGCRootsRemovedEP9JSContext"]
            pub fn NotifyGCRootsRemoved(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Check whether the nursery should be eagerly collected, this is before it is\n full.\n\n The idea is that this can be called when the host environment has some idle\n time which it can use to for GC activity.\n\n Returns GCReason::NO_REASON to indicate no collection is desired."]
            #[link_name = "\u{1}_ZN2JS16WantEagerMinorGCEP9JSRuntime"]
            pub fn WantEagerMinorGC(rt: *mut root::JSRuntime) -> root::JS::GCReason;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16WantEagerMajorGCEP9JSRuntime"]
            pub fn WantEagerMajorGC(rt: *mut root::JSRuntime) -> root::JS::GCReason;
        }
        extern "C" {
            #[doc = " Check whether the nursery should be eagerly collected as per WantEagerMajorGC\n above, and if so run a collection.\n\n The idea is that this can be called when the host environment has some idle\n time which it can use to for GC activity."]
            #[link_name = "\u{1}_ZN2JS25MaybeRunNurseryCollectionEP9JSRuntimeNS_8GCReasonE"]
            pub fn MaybeRunNurseryCollection(rt: *mut root::JSRuntime, reason: root::JS::GCReason);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20RunNurseryCollectionEP9JSRuntimeNS_8GCReasonEN7mozilla16BaseTimeDurationINS3_27TimeDurationValueCalculatorEEE"]
            pub fn RunNurseryCollection(
                rt: *mut root::JSRuntime,
                reason: root::JS::GCReason,
                aSinceLastMinorGC: root::mozilla::TimeDuration,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS42SetHostCleanupFinalizationRegistryCallbackEP9JSContextPFvP10JSFunctionP8JSObjectPvES6_"]
            pub fn SetHostCleanupFinalizationRegistryCallback(
                cx: *mut root::JSContext,
                cb: root::JSHostCleanupFinalizationRegistryCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Clear kept alive objects in JS WeakRef.\n https://tc39.es/proposal-weakrefs/#sec-clear-kept-objects"]
            #[link_name = "\u{1}_ZN2JS16ClearKeptObjectsEP9JSContext"]
            pub fn ClearKeptObjects(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21AtomsZoneIsCollectingEP9JSRuntime"]
            pub fn AtomsZoneIsCollecting(runtime: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11IsAtomsZoneEPNS_4ZoneE"]
            pub fn IsAtomsZone(zone: *mut root::JS::Zone) -> bool;
        }
        #[repr(C)]
        pub struct ErrorReportBuilder {
            pub reportp: *mut root::JSErrorReport,
            pub ownedReport: root::JSErrorReport,
            pub exnObject: root::JS::RootedObject,
            pub filename: root::JS::UniqueChars,
            pub toStringResult_: root::JS::ConstUTF8CharsZ,
            pub toStringResultBytesStorage: root::JS::UniqueChars,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ErrorReportBuilder_SniffingBehavior {
            WithSideEffects = 0,
            NoSideEffects = 1,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ErrorReportBuilder"][::std::mem::size_of::<ErrorReportBuilder>() - 144usize];
            ["Alignment of ErrorReportBuilder"]
                [::std::mem::align_of::<ErrorReportBuilder>() - 8usize];
            ["Offset of field: ErrorReportBuilder::reportp"]
                [::std::mem::offset_of!(ErrorReportBuilder, reportp) - 0usize];
            ["Offset of field: ErrorReportBuilder::ownedReport"]
                [::std::mem::offset_of!(ErrorReportBuilder, ownedReport) - 8usize];
            ["Offset of field: ErrorReportBuilder::exnObject"]
                [::std::mem::offset_of!(ErrorReportBuilder, exnObject) - 96usize];
            ["Offset of field: ErrorReportBuilder::filename"]
                [::std::mem::offset_of!(ErrorReportBuilder, filename) - 120usize];
            ["Offset of field: ErrorReportBuilder::toStringResult_"]
                [::std::mem::offset_of!(ErrorReportBuilder, toStringResult_) - 128usize];
            ["Offset of field: ErrorReportBuilder::toStringResultBytesStorage"]
                [::std::mem::offset_of!(ErrorReportBuilder, toStringResultBytesStorage) - 136usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10PrintErrorEP8_IO_FILEP13JSErrorReportb"]
            pub fn PrintError(
                file: *mut root::FILE,
                report: *mut root::JSErrorReport,
                reportWarnings: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10PrintErrorEP8_IO_FILERKNS_18ErrorReportBuilderEb"]
            pub fn PrintError1(
                file: *mut root::FILE,
                builder: *const root::JS::ErrorReportBuilder,
                reportWarnings: bool,
            );
        }
        extern "C" {
            #[doc = " An uncatchable exception is used to terminate execution by returning false\n or nullptr without reporting a pending exception on the context. These\n exceptions are called \"uncatchable\" because try-catch can't be used to catch\n them.\n\n This is mainly used to terminate JS execution from the interrupt handler.\n\n If the context has a pending exception, this function will clear it. Also, in\n debug builds, it sets a flag on the context to improve exception handling\n assertions in the engine."]
            #[link_name = "\u{1}_ZN2JS26ReportUncatchableExceptionEP9JSContext"]
            pub fn ReportUncatchableException(cx: *mut root::JSContext);
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ExceptionStackBehavior {
            DoNotCapture = 0,
            Capture = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ExceptionStatus {
            None = 0,
            ForcedReturn = 1,
            Throwing = 2,
            OutOfMemory = 3,
            OverRecursed = 4,
        }
        #[repr(C)]
        pub struct ExceptionStack {
            pub exception_: root::JS::Rooted<root::JS::Value>,
            pub stack_: root::JS::Rooted<*mut root::JSObject>,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ExceptionStack"][::std::mem::size_of::<ExceptionStack>() - 48usize];
            ["Alignment of ExceptionStack"][::std::mem::align_of::<ExceptionStack>() - 8usize];
            ["Offset of field: ExceptionStack::exception_"]
                [::std::mem::offset_of!(ExceptionStack, exception_) - 0usize];
            ["Offset of field: ExceptionStack::stack_"]
                [::std::mem::offset_of!(ExceptionStack, stack_) - 24usize];
        };
        #[doc = " Save and later restore the current exception state of a given JSContext.\n This is useful for implementing behavior in C++ that's like try/catch\n or try/finally in JS.\n\n Typical usage:\n\n     bool ok = JS::Evaluate(cx, ...);\n     AutoSaveExceptionState savedExc(cx);\n     ... cleanup that might re-enter JS ...\n     return ok;"]
        #[repr(C)]
        pub struct AutoSaveExceptionState {
            pub context: *mut root::JSContext,
            pub status: root::JS::ExceptionStatus,
            pub exceptionValue: root::JS::RootedValue,
            pub exceptionStack: root::JS::RootedObject,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoSaveExceptionState"]
                [::std::mem::size_of::<AutoSaveExceptionState>() - 64usize];
            ["Alignment of AutoSaveExceptionState"]
                [::std::mem::align_of::<AutoSaveExceptionState>() - 8usize];
            ["Offset of field: AutoSaveExceptionState::context"]
                [::std::mem::offset_of!(AutoSaveExceptionState, context) - 0usize];
            ["Offset of field: AutoSaveExceptionState::status"]
                [::std::mem::offset_of!(AutoSaveExceptionState, status) - 8usize];
            ["Offset of field: AutoSaveExceptionState::exceptionValue"]
                [::std::mem::offset_of!(AutoSaveExceptionState, exceptionValue) - 16usize];
            ["Offset of field: AutoSaveExceptionState::exceptionStack"]
                [::std::mem::offset_of!(AutoSaveExceptionState, exceptionStack) - 40usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetPendingExceptionStackEP9JSContextPNS_14ExceptionStackE"]
            pub fn GetPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *mut root::JS::ExceptionStack,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26StealPendingExceptionStackEP9JSContextPNS_14ExceptionStackE"]
            pub fn StealPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *mut root::JS::ExceptionStack,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24SetPendingExceptionStackEP9JSContextRKNS_14ExceptionStackE"]
            pub fn SetPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *const root::JS::ExceptionStack,
            );
        }
        extern "C" {
            #[doc = " If the given object is an exception object (or an unwrappable\n cross-compartment wrapper for one), return the stack for that exception, if\n any.  Will return null if the given object is not an exception object\n (including if it's null or a security wrapper that can't be unwrapped) or if\n the exception has no stack."]
            #[link_name = "\u{1}_ZN2JS20ExceptionStackOrNullENS_6HandleIP8JSObjectEE"]
            pub fn ExceptionStackOrNull(obj: root::JS::HandleObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the current realm's global. Returns nullptr if no realm has been\n entered."]
            #[link_name = "\u{1}_ZN2JS19CurrentGlobalOrNullEP9JSContext"]
            pub fn CurrentGlobalOrNull(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the current realm's global. Returns nullptr if no realm has been\n entered."]
            #[link_name = "\u{1}_ZN2JS13CurrentGlobalEP9JSContext"]
            pub fn CurrentGlobal(cx: *mut root::JSContext) -> *const *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the global object associated with an object's realm. The object must not\n be a cross-compartment wrapper (because CCWs are shared by all realms in the\n compartment)."]
            #[link_name = "\u{1}_ZN2JS21GetNonCCWObjectGlobalEP8JSObject"]
            pub fn GetNonCCWObjectGlobal(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        #[repr(u32)]
        #[doc = " During global creation, we fire notifications to callbacks registered\n via the Debugger API. These callbacks are arbitrary script, and can touch\n the global in arbitrary ways. When that happens, the global should not be\n in a half-baked state. But this creates a problem for consumers that need\n to set slots on the global to put it in a consistent state.\n\n This API provides a way for consumers to set slots atomically (immediately\n after the global is created), before any debugger hooks are fired. It's\n unfortunately on the clunky side, but that's the way the cookie crumbles.\n\n If callers have no additional state on the global to set up, they may pass\n |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to\n fire the hook as its final act before returning. Otherwise, callers should\n pass |DontFireOnNewGlobalHook|, which means that they are responsible for\n invoking JS_FireOnNewGlobalObject upon successfully creating the global. If\n an error occurs and the operation aborts, callers should skip firing the\n hook. But otherwise, callers must take care to fire the hook exactly once\n before compiling any script in the global's scope (we have assertions in\n place to enforce this). This lets us be sure that debugger clients never miss\n breakpoints."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum OnNewGlobalHookOption {
            FireOnNewGlobalHook = 0,
            DontFireOnNewGlobalHook = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12NewMapObjectEP9JSContext"]
            pub fn NewMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7MapSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapGetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleIS6_EE"]
            pub fn MapGet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapSetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapSet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9MapDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MapClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapClear(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7MapKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9MapValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10MapEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10MapForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12NewSetObjectEP9JSContext"]
            pub fn NewSetObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7SetSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6SetHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9SetDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6SetAddEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn SetAdd(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8SetClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetClear(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7SetKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9SetValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10SetEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10SetForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn SetForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
        }
        #[doc = " If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS\n engine may call the large-allocation-failure callback, if set, to allow the\n embedding to flush caches, possibly perform shrinking GCs, etc. to make some\n room. The allocation will then be retried (and may still fail.) This callback\n can be called on any thread and must be set at most once in a process."]
        pub type LargeAllocationFailureCallback = ::std::option::Option<unsafe extern "C" fn()>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS40SetProcessLargeAllocationFailureCallbackEPFvvE"]
            pub fn SetProcessLargeAllocationFailureCallback(
                afc: root::JS::LargeAllocationFailureCallback,
            );
        }
        #[doc = " Unlike the error reporter, which is only called if the exception for an OOM\n bubbles up and is not caught, the OutOfMemoryCallback is called immediately\n at the OOM site to allow the embedding to capture the current state of heap\n allocation before anything is freed. If the large-allocation-failure callback\n is called at all (not all allocation sites call the large-allocation-failure\n callback on failure), it is called before the out-of-memory callback; the\n out-of-memory callback is only called if the allocation still fails after the\n large-allocation-failure callback has returned."]
        pub type OutOfMemoryCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::JSContext, arg2: *mut ::std::os::raw::c_void),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SetOutOfMemoryCallbackEP9JSContextPFvS1_PvES2_"]
            pub fn SetOutOfMemoryCallback(
                cx: *mut root::JSContext,
                cb: root::JS::OutOfMemoryCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryUse {
            XPCWrappedNative = 0,
            DOMBinding = 1,
            CTypeFFIType = 2,
            CTypeFFITypeElements = 3,
            CTypeFunctionInfo = 4,
            CTypeFieldInfo = 5,
            CDataBufferPtr = 6,
            CDataBuffer = 7,
            CClosureInfo = 8,
            CTypesInt64 = 9,
            Embedding1 = 10,
            Embedding2 = 11,
            Embedding3 = 12,
            Embedding4 = 13,
            Embedding5 = 14,
        }
        extern "C" {
            #[doc = " Advise the GC of external memory owned by a JSObject. This is used to\n determine when to collect zones. Calls must be matched by calls to\n RemoveAssociatedMemory() when the memory is deallocated or no longer owned by\n the object."]
            #[link_name = "\u{1}_ZN2JS19AddAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn AddAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
        }
        extern "C" {
            #[doc = " Advise the GC that external memory reported by JS::AddAssociatedMemory() is\n no longer owned by a JSObject. Calls must match those to\n AddAssociatedMemory()."]
            #[link_name = "\u{1}_ZN2JS22RemoveAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn RemoveAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RuntimeCode {
            JS = 0,
            WASM = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CompilationType {
            DirectEval = 0,
            IndirectEval = 1,
            Function = 2,
            Undefined = 3,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoHoldPrincipals {
            pub cx_: *mut root::JSContext,
            pub principals_: *mut root::JSPrincipals,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoHoldPrincipals"][::std::mem::size_of::<AutoHoldPrincipals>() - 16usize];
            ["Alignment of AutoHoldPrincipals"]
                [::std::mem::align_of::<AutoHoldPrincipals>() - 8usize];
            ["Offset of field: AutoHoldPrincipals::cx_"]
                [::std::mem::offset_of!(AutoHoldPrincipals, cx_) - 0usize];
            ["Offset of field: AutoHoldPrincipals::principals_"]
                [::std::mem::offset_of!(AutoHoldPrincipals, principals_) - 8usize];
        };
        pub type IdVector = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PropertyAttribute {
            Configurable = 0,
            Enumerable = 1,
            Writable = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PropertyAttributes {
            pub _base: root::mozilla::EnumSet<::std::os::raw::c_uchar>,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of PropertyAttributes"][::std::mem::size_of::<PropertyAttributes>() - 1usize];
            ["Alignment of PropertyAttributes"]
                [::std::mem::align_of::<PropertyAttributes>() - 1usize];
        };
        #[doc = " A structure that represents a property on an object, or the absence of a\n property.  Use {,Mutable}Handle<PropertyDescriptor> to interact with\n instances of this structure rather than interacting directly with member\n fields."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PropertyDescriptor {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize]>,
            pub getter_: *mut root::JSObject,
            pub setter_: *mut root::JSObject,
            pub value_: root::JS::Value,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of PropertyDescriptor"][::std::mem::size_of::<PropertyDescriptor>() - 32usize];
            ["Alignment of PropertyDescriptor"]
                [::std::mem::align_of::<PropertyDescriptor>() - 8usize];
            ["Offset of field: PropertyDescriptor::getter_"]
                [::std::mem::offset_of!(PropertyDescriptor, getter_) - 8usize];
            ["Offset of field: PropertyDescriptor::setter_"]
                [::std::mem::offset_of!(PropertyDescriptor, setter_) - 16usize];
            ["Offset of field: PropertyDescriptor::value_"]
                [::std::mem::offset_of!(PropertyDescriptor, value_) - 24usize];
        };
        impl PropertyDescriptor {
            #[inline]
            pub fn hasConfigurable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasConfigurable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn hasConfigurable__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        0usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_hasConfigurable__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        0usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn configurable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_configurable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn configurable__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        1usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_configurable__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        1usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn hasEnumerable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasEnumerable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn hasEnumerable__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        2usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_hasEnumerable__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        2usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn enumerable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_enumerable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn enumerable__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        3usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_enumerable__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        3usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn hasWritable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasWritable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn hasWritable__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        4usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_hasWritable__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        4usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn writable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_writable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn writable__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        5usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_writable__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        5usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn hasValue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasValue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn hasValue__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        6usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_hasValue__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        6usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn hasGetter_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasGetter_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn hasGetter__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        7usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_hasGetter__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        7usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn hasSetter_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasSetter_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn hasSetter__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        8usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_hasSetter__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        8usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn resolving_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_resolving_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn resolving__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        9usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_resolving__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        9usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                hasConfigurable_: bool,
                configurable_: bool,
                hasEnumerable_: bool,
                enumerable_: bool,
                hasWritable_: bool,
                writable_: bool,
                hasValue_: bool,
                hasGetter_: bool,
                hasSetter_: bool,
                resolving_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 2usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let hasConfigurable_: u8 = unsafe { ::std::mem::transmute(hasConfigurable_) };
                    hasConfigurable_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let configurable_: u8 = unsafe { ::std::mem::transmute(configurable_) };
                    configurable_ as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let hasEnumerable_: u8 = unsafe { ::std::mem::transmute(hasEnumerable_) };
                    hasEnumerable_ as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let enumerable_: u8 = unsafe { ::std::mem::transmute(enumerable_) };
                    enumerable_ as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let hasWritable_: u8 = unsafe { ::std::mem::transmute(hasWritable_) };
                    hasWritable_ as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let writable_: u8 = unsafe { ::std::mem::transmute(writable_) };
                    writable_ as u64
                });
                __bindgen_bitfield_unit.set(6usize, 1u8, {
                    let hasValue_: u8 = unsafe { ::std::mem::transmute(hasValue_) };
                    hasValue_ as u64
                });
                __bindgen_bitfield_unit.set(7usize, 1u8, {
                    let hasGetter_: u8 = unsafe { ::std::mem::transmute(hasGetter_) };
                    hasGetter_ as u64
                });
                __bindgen_bitfield_unit.set(8usize, 1u8, {
                    let hasSetter_: u8 = unsafe { ::std::mem::transmute(hasSetter_) };
                    hasSetter_ as u64
                });
                __bindgen_bitfield_unit.set(9usize, 1u8, {
                    let resolving_: u8 = unsafe { ::std::mem::transmute(resolving_) };
                    resolving_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28ToCompletePropertyDescriptorEP9JSContextNS_6HandleINS_5ValueEEENS_13MutableHandleINS_18PropertyDescriptorEEE"]
            pub fn ToCompletePropertyDescriptor(
                cx: *mut root::JSContext,
                descriptor: root::JS::Handle<root::JS::Value>,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a new Symbol with the given description. This function never returns\n a Symbol that is in the Runtime-wide symbol registry.\n\n If description is null, the new Symbol's [[Description]] attribute is\n undefined."]
            #[link_name = "\u{1}_ZN2JS9NewSymbolEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn NewSymbol(
                cx: *mut root::JSContext,
                description: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
        }
        extern "C" {
            #[doc = " Symbol.for as specified in ES6.\n\n Get a Symbol with the description 'key' from the Runtime-wide symbol\n registry. If there is not already a Symbol with that description in the\n registry, a new Symbol is created and registered. 'key' must not be null."]
            #[link_name = "\u{1}_ZN2JS12GetSymbolForEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn GetSymbolFor(
                cx: *mut root::JSContext,
                key: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
        }
        extern "C" {
            #[doc = " Get the [[Description]] attribute of the given symbol.\n\n This function is infallible. If it returns null, that means the symbol's\n [[Description]] is undefined."]
            #[link_name = "\u{1}_ZN2JS20GetSymbolDescriptionENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolDescription(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> *mut root::JSString;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SymbolCode {
            isConcatSpreadable = 0,
            iterator = 1,
            match_ = 2,
            replace = 3,
            search = 4,
            species = 5,
            hasInstance = 6,
            split = 7,
            toPrimitive = 8,
            toStringTag = 9,
            unscopables = 10,
            asyncIterator = 11,
            matchAll = 12,
            Limit = 13,
            WellKnownAPILimit = 2147483648,
            PrivateNameSymbol = 4294967293,
            InSymbolRegistry = 4294967294,
            UniqueSymbol = 4294967295,
        }
        extern "C" {
            #[doc = " Return the SymbolCode telling what sort of symbol `symbol` is.\n\n A symbol's SymbolCode never changes once it is created."]
            #[link_name = "\u{1}_ZN2JS13GetSymbolCodeENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolCode(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> root::JS::SymbolCode;
        }
        extern "C" {
            #[doc = " Get one of the well-known symbols defined by ES6. A single set of well-known\n symbols is shared by all compartments in a JSRuntime.\n\n `which` must be in the range [0, WellKnownSymbolLimit)."]
            #[link_name = "\u{1}_ZN2JS18GetWellKnownSymbolEP9JSContextNS_10SymbolCodeE"]
            pub fn GetWellKnownSymbol(
                cx: *mut root::JSContext,
                which: root::JS::SymbolCode,
            ) -> *mut root::JS::Symbol;
        }
        pub type IterateRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realm: *mut root::JS::Realm,
                nogc: *const root::JS::AutoRequireNoGC,
            ),
        >;
        extern "C" {
            #[doc = " This function calls |realmCallback| on every realm. Beware that there is no\n guarantee that the realm will survive after the callback returns. Also,\n barriers are disabled via the TraceSession."]
            #[link_name = "\u{1}_ZN2JS13IterateRealmsEP9JSContextPvPFvS1_S2_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealms(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        extern "C" {
            #[doc = " Like IterateRealms, but only call the callback for realms using |principals|."]
            #[link_name = "\u{1}_ZN2JS27IterateRealmsWithPrincipalsEP9JSContextP12JSPrincipalsPvPFvS1_S4_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealmsWithPrincipals(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        extern "C" {
            #[doc = " Like IterateRealms, but only iterates realms in |compartment|."]
            #[link_name = "\u{1}_ZN2JS26IterateRealmsInCompartmentEP9JSContextPNS_11CompartmentEPvPFvS1_S4_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealmsInCompartment(
                cx: *mut root::JSContext,
                compartment: *mut root::JS::Compartment,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        #[repr(i32)]
        #[doc = " An enum that JSIterateCompartmentCallback can return to indicate\n whether to keep iterating."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CompartmentIterResult {
            KeepGoing = 0,
            Stop = 1,
        }
        #[repr(i32)]
        #[doc = " Specification for which compartment/zone a newly created realm should use."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CompartmentSpecifier {
            NewCompartmentInSystemZone = 0,
            NewCompartmentInExistingZone = 1,
            NewCompartmentAndZone = 2,
            ExistingCompartment = 3,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LocaleString {
            pub _base: root::js::RefCounted,
            pub chars_: *const ::std::os::raw::c_char,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of LocaleString"][::std::mem::size_of::<LocaleString>() - 16usize];
            ["Alignment of LocaleString"][::std::mem::align_of::<LocaleString>() - 8usize];
            ["Offset of field: LocaleString::chars_"]
                [::std::mem::offset_of!(LocaleString, chars_) - 8usize];
        };
        #[doc = " RealmCreationOptions specifies options relevant to creating a new realm, that\n are either immutable characteristics of that realm or that are discarded\n after the realm has been created.\n\n Access to these options on an existing realm is read-only: if you need\n particular selections, you must make them before you create the realm."]
        #[repr(C)]
        pub struct RealmCreationOptions {
            pub traceGlobal_: root::JSTraceOp,
            pub compSpec_: root::JS::CompartmentSpecifier,
            pub __bindgen_anon_1: root::JS::RealmCreationOptions__bindgen_ty_1,
            pub profilerRealmID_: u64,
            pub locale_: root::RefPtr<root::JS::LocaleString>,
            pub invisibleToDebugger_: bool,
            pub preserveJitCode_: bool,
            pub sharedMemoryAndAtomics_: bool,
            pub defineSharedArrayBufferConstructor_: bool,
            pub coopAndCoep_: bool,
            pub toSource_: bool,
            pub secureContext_: bool,
            pub freezeBuiltins_: bool,
            pub forceUTC_: bool,
            pub alwaysUseFdlibm_: bool,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union RealmCreationOptions__bindgen_ty_1 {
            pub comp_: *mut root::JS::Compartment,
            pub zone_: *mut root::JS::Zone,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RealmCreationOptions__bindgen_ty_1"]
                [::std::mem::size_of::<RealmCreationOptions__bindgen_ty_1>() - 8usize];
            ["Alignment of RealmCreationOptions__bindgen_ty_1"]
                [::std::mem::align_of::<RealmCreationOptions__bindgen_ty_1>() - 8usize];
            ["Offset of field: RealmCreationOptions__bindgen_ty_1::comp_"]
                [::std::mem::offset_of!(RealmCreationOptions__bindgen_ty_1, comp_) - 0usize];
            ["Offset of field: RealmCreationOptions__bindgen_ty_1::zone_"]
                [::std::mem::offset_of!(RealmCreationOptions__bindgen_ty_1, zone_) - 0usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RealmCreationOptions"]
                [::std::mem::size_of::<RealmCreationOptions>() - 56usize];
            ["Alignment of RealmCreationOptions"]
                [::std::mem::align_of::<RealmCreationOptions>() - 8usize];
            ["Offset of field: RealmCreationOptions::traceGlobal_"]
                [::std::mem::offset_of!(RealmCreationOptions, traceGlobal_) - 0usize];
            ["Offset of field: RealmCreationOptions::compSpec_"]
                [::std::mem::offset_of!(RealmCreationOptions, compSpec_) - 8usize];
            ["Offset of field: RealmCreationOptions::profilerRealmID_"]
                [::std::mem::offset_of!(RealmCreationOptions, profilerRealmID_) - 24usize];
            ["Offset of field: RealmCreationOptions::locale_"]
                [::std::mem::offset_of!(RealmCreationOptions, locale_) - 32usize];
            ["Offset of field: RealmCreationOptions::invisibleToDebugger_"]
                [::std::mem::offset_of!(RealmCreationOptions, invisibleToDebugger_) - 40usize];
            ["Offset of field: RealmCreationOptions::preserveJitCode_"]
                [::std::mem::offset_of!(RealmCreationOptions, preserveJitCode_) - 41usize];
            ["Offset of field: RealmCreationOptions::sharedMemoryAndAtomics_"]
                [::std::mem::offset_of!(RealmCreationOptions, sharedMemoryAndAtomics_) - 42usize];
            ["Offset of field: RealmCreationOptions::defineSharedArrayBufferConstructor_"][::std::mem::offset_of!(
                RealmCreationOptions,
                defineSharedArrayBufferConstructor_
            )
                - 43usize];
            ["Offset of field: RealmCreationOptions::coopAndCoep_"]
                [::std::mem::offset_of!(RealmCreationOptions, coopAndCoep_) - 44usize];
            ["Offset of field: RealmCreationOptions::toSource_"]
                [::std::mem::offset_of!(RealmCreationOptions, toSource_) - 45usize];
            ["Offset of field: RealmCreationOptions::secureContext_"]
                [::std::mem::offset_of!(RealmCreationOptions, secureContext_) - 46usize];
            ["Offset of field: RealmCreationOptions::freezeBuiltins_"]
                [::std::mem::offset_of!(RealmCreationOptions, freezeBuiltins_) - 47usize];
            ["Offset of field: RealmCreationOptions::forceUTC_"]
                [::std::mem::offset_of!(RealmCreationOptions, forceUTC_) - 48usize];
            ["Offset of field: RealmCreationOptions::alwaysUseFdlibm_"]
                [::std::mem::offset_of!(RealmCreationOptions, alwaysUseFdlibm_) - 49usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RTPCallerTypeToken {
            pub value: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RTPCallerTypeToken"][::std::mem::size_of::<RTPCallerTypeToken>() - 1usize];
            ["Alignment of RTPCallerTypeToken"]
                [::std::mem::align_of::<RTPCallerTypeToken>() - 1usize];
            ["Offset of field: RTPCallerTypeToken::value"]
                [::std::mem::offset_of!(RTPCallerTypeToken, value) - 0usize];
        };
        #[doc = " RealmBehaviors specifies behaviors of a realm that can be changed after the\n realm's been created."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RealmBehaviors {
            pub rtpCallerType: root::__BindgenOpaqueArray<u8, 2usize>,
            pub discardSource_: bool,
            pub clampAndJitterTime_: bool,
            pub isNonLive_: bool,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RealmBehaviors"][::std::mem::size_of::<RealmBehaviors>() - 5usize];
            ["Alignment of RealmBehaviors"][::std::mem::align_of::<RealmBehaviors>() - 1usize];
            ["Offset of field: RealmBehaviors::rtpCallerType"]
                [::std::mem::offset_of!(RealmBehaviors, rtpCallerType) - 0usize];
            ["Offset of field: RealmBehaviors::discardSource_"]
                [::std::mem::offset_of!(RealmBehaviors, discardSource_) - 2usize];
            ["Offset of field: RealmBehaviors::clampAndJitterTime_"]
                [::std::mem::offset_of!(RealmBehaviors, clampAndJitterTime_) - 3usize];
            ["Offset of field: RealmBehaviors::isNonLive_"]
                [::std::mem::offset_of!(RealmBehaviors, isNonLive_) - 4usize];
        };
        #[doc = " RealmOptions specifies realm characteristics: both those that can't be\n changed on a realm once it's been created (RealmCreationOptions), and those\n that can be changed on an existing realm (RealmBehaviors)."]
        #[repr(C)]
        pub struct RealmOptions {
            pub creationOptions_: root::JS::RealmCreationOptions,
            pub behaviors_: root::JS::RealmBehaviors,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RealmOptions"][::std::mem::size_of::<RealmOptions>() - 64usize];
            ["Alignment of RealmOptions"][::std::mem::align_of::<RealmOptions>() - 8usize];
            ["Offset of field: RealmOptions::creationOptions_"]
                [::std::mem::offset_of!(RealmOptions, creationOptions_) - 0usize];
            ["Offset of field: RealmOptions::behaviors_"]
                [::std::mem::offset_of!(RealmOptions, behaviors_) - 56usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEPNS_5RealmE"]
            pub fn RealmCreationOptionsRef(
                realm: *mut root::JS::Realm,
            ) -> *const root::JS::RealmCreationOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEP9JSContext"]
            pub fn RealmCreationOptionsRef1(
                cx: *mut root::JSContext,
            ) -> *const root::JS::RealmCreationOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEPNS_5RealmE"]
            pub fn RealmBehaviorsRef(
                realm: *mut root::JS::Realm,
            ) -> *const root::JS::RealmBehaviors;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEP9JSContext"]
            pub fn RealmBehaviorsRef1(cx: *mut root::JSContext) -> *const root::JS::RealmBehaviors;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetRealmNonLiveEPNS_5RealmE"]
            pub fn SetRealmNonLive(realm: *mut root::JS::Realm);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS38SetRealmReduceTimerPrecisionCallerTypeEPNS_5RealmENS_18RTPCallerTypeTokenE"]
            pub fn SetRealmReduceTimerPrecisionCallerType(
                realm: *mut root::JS::Realm,
                type_: root::JS::RTPCallerTypeToken,
            );
        }
        extern "C" {
            #[doc = " Set a private value associated with a script. Note that this value is shared\n by all nested scripts compiled from a single source file."]
            #[link_name = "\u{1}_ZN2JS16SetScriptPrivateEP8JSScriptRKNS_5ValueE"]
            pub fn SetScriptPrivate(script: *mut root::JSScript, value: *const root::JS::Value);
        }
        #[doc = " Hooks called when references to a script private value are created or\n destroyed. This allows use of a reference counted object as the\n script private."]
        pub type ScriptPrivateReferenceHook =
            ::std::option::Option<unsafe extern "C" fn(arg1: *const root::JS::Value)>;
        extern "C" {
            #[doc = " Set the script private finalize hook for the runtime to the given function."]
            #[link_name = "\u{1}_ZN2JS30SetScriptPrivateReferenceHooksEP9JSRuntimePFvRKNS_5ValueEES6_"]
            pub fn SetScriptPrivateReferenceHooks(
                rt: *mut root::JSRuntime,
                addRefHook: root::JS::ScriptPrivateReferenceHook,
                releaseHook: root::JS::ScriptPrivateReferenceHook,
            );
        }
        #[doc = " Capture all frames."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllFrames {
            pub _address: u8,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AllFrames"][::std::mem::size_of::<AllFrames>() - 1usize];
            ["Alignment of AllFrames"][::std::mem::align_of::<AllFrames>() - 1usize];
        };
        #[doc = " Capture at most this many frames."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MaxFrames {
            pub maxFrames: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MaxFrames"][::std::mem::size_of::<MaxFrames>() - 4usize];
            ["Alignment of MaxFrames"][::std::mem::align_of::<MaxFrames>() - 4usize];
            ["Offset of field: MaxFrames::maxFrames"]
                [::std::mem::offset_of!(MaxFrames, maxFrames) - 0usize];
        };
        #[doc = " Capture the first frame with the given principals. By default, do not\n consider self-hosted frames with the given principals as satisfying the stack\n capture."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct FirstSubsumedFrame {
            pub cx: *mut root::JSContext,
            pub principals: *mut root::JSPrincipals,
            pub ignoreSelfHosted: bool,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of FirstSubsumedFrame"][::std::mem::size_of::<FirstSubsumedFrame>() - 24usize];
            ["Alignment of FirstSubsumedFrame"]
                [::std::mem::align_of::<FirstSubsumedFrame>() - 8usize];
            ["Offset of field: FirstSubsumedFrame::cx"]
                [::std::mem::offset_of!(FirstSubsumedFrame, cx) - 0usize];
            ["Offset of field: FirstSubsumedFrame::principals"]
                [::std::mem::offset_of!(FirstSubsumedFrame, principals) - 8usize];
            ["Offset of field: FirstSubsumedFrame::ignoreSelfHosted"]
                [::std::mem::offset_of!(FirstSubsumedFrame, ignoreSelfHosted) - 16usize];
        };
        #[doc = " # mozilla::Variant\n\n A variant / tagged union / heterogenous disjoint union / sum-type template\n class. Similar in concept to (but not derived from) `boost::variant`.\n\n Sometimes, you may wish to use a C union with non-POD types. However, this is\n forbidden in C++ because it is not clear which type in the union should have\n its constructor and destructor run on creation and deletion\n respectively. This is the problem that `mozilla::Variant` solves.\n\n ## Usage\n\n A `mozilla::Variant` instance is constructed (via move or copy) from one of\n its variant types (ignoring const and references). It does *not* support\n construction from subclasses of variant types or types that coerce to one of\n the variant types.\n\n     Variant<char, uint32_t> v1('a');\n     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());\n     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed\n     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int\n\n Because specifying the full type of a Variant value is often verbose,\n there are two easier ways to construct values:\n\n A. AsVariant() can be used to construct a Variant value using type inference\n in contexts such as expressions or when returning values from functions.\n Because AsVariant() must copy or move the value into a temporary and this\n cannot necessarily be elided by the compiler, it's mostly appropriate only\n for use with primitive or very small types.\n\n     Variant<char, uint32_t> Foo() { return AsVariant('x'); }\n     // ...\n     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x').\n\n B. Brace-construction with VariantType or VariantIndex; this also allows\n in-place construction with any number of arguments.\n\n     struct AB { AB(int, int){...} };\n     static Variant<AB, bool> foo()\n     {\n       return {VariantIndex<0>{}, 1, 2};\n     }\n     // ...\n     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2).\n\n All access to the contained value goes through type-safe accessors.\n Either the stored type, or the type index may be provided.\n\n     void\n     Foo(Variant<A, B, C> v)\n     {\n       if (v.is<A>()) {\n         A& ref = v.as<A>();\n         ...\n       } else (v.is<1>()) { // Instead of v.is<B>.\n         ...\n       } else {\n         ...\n       }\n     }\n\n In some situation, a Variant may be constructed from templated types, in\n which case it is possible that the same type could be given multiple times by\n an external developer. Or seemingly-different types could be aliases.\n In this case, repeated types can only be accessed through their index, to\n prevent ambiguous access by type.\n\n    // Bad!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(int(0)) {} // Error '0' by default\n      ResultOrError(const T& r) : m(r) {}\n      bool IsResult() const { return m.is<T>(); }\n      bool IsError() const { return m.is<int>(); }\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // Fail!\n    // In Variant<int, int>, which 'int' are we refering to, from inside\n    // ResultOrError functions?\n\n    // Good!\n    template <typename T>\n    struct ResultOrError\n    {\n      Variant<T, int> m;\n      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default\n      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}\n      bool IsResult() const { return m.is<0>(); } // 0 -> T\n      bool IsError() const { return m.is<1>(); } // 1 -> int\n    };\n    // Now instantiante with the result being an int too:\n    ResultOrError<int> myResult(123); // It now works!\n\n Attempting to use the contained value as type `T1` when the `Variant`\n instance contains a value of type `T2` causes an assertion failure.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<B>(); // <--- Assertion failure!\n\n Trying to use a `Variant<Ts...>` instance as some type `U` that is not a\n member of the set of `Ts...` is a compiler error.\n\n     A a;\n     Variant<A, B, C> v(a);\n     v.as<SomeRandomType>(); // <--- Compiler error!\n\n Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it\n out of the containing `Variant` instance with the `extract<T>` method:\n\n     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());\n     auto ptr = v.extract<UniquePtr<A>>();\n\n Finally, you can exhaustively match on the contained variant and branch into\n different code paths depending on which type is contained. This is preferred\n to manually checking every variant type T with is<T>() because it provides\n compile-time checking that you handled every type, rather than runtime\n assertion failures.\n\n     // Bad!\n     char* foo(Variant<A, B, C, D>& v) {\n       if (v.is<A>()) {\n         return ...;\n       } else if (v.is<B>()) {\n         return ...;\n       } else {\n         return doSomething(v.as<C>()); // Forgot about case D!\n       }\n     }\n\n     // Instead, a single function object (that can deal with all possible\n     // options) may be provided:\n     struct FooMatcher\n     {\n       // The return type of all matchers must be identical.\n       char* operator()(A& a) { ... }\n       char* operator()(B& b) { ... }\n       char* operator()(C& c) { ... }\n       char* operator()(D& d) { ... } // Compile-time error to forget D!\n     }\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match(FooMatcher());\n     }\n\n     // In some situations, a single generic lambda may also be appropriate:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto&) {...});\n     }\n\n     // Alternatively, multiple function objects may be provided, each one\n     // corresponding to an option, in the same order:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](A&) { ... },\n                      [](B&) { ... },\n                      [](C&) { ... },\n                      [](D&) { ... });\n     }\n\n     // In rare cases, the index of the currently-active alternative is\n     // needed, it may be obtained by adding a first parameter in the matcner\n     // callback, which will receive the index in its most compact type (just\n     // use `size_t` if the exact type is not important), e.g.:\n     char* foo(Variant<A, B, C, D>& v) {\n       return v.match([](auto aIndex, auto& aAlternative) {...});\n       // --OR--\n       return v.match([](size_t aIndex, auto& aAlternative) {...});\n     }\n\n ## Examples\n\n A tree is either an empty leaf, or a node with a value and two children:\n\n     struct Leaf { };\n\n     template<typename T>\n     struct Node\n     {\n       T value;\n       Tree<T>* left;\n       Tree<T>* right;\n     };\n\n     template<typename T>\n     using Tree = Variant<Leaf, Node<T>>;\n\n A copy-on-write string is either a non-owning reference to some existing\n string, or an owning reference to our copy:\n\n     class CopyOnWriteString\n     {\n       Variant<const char*, UniquePtr<char[]>> string;\n\n       ...\n     };\n\n Because Variant must be aligned suitable to hold any value stored within it,\n and because |alignas| requirements don't affect platform ABI with respect to\n how parameters are laid out in memory, Variant can't be used as the type of a\n function parameter.  Pass Variant to functions by pointer or reference\n instead."]
        pub type StackCapture = root::__BindgenOpaqueArray<u64, 4usize>;
        extern "C" {
            #[doc = " Capture the current call stack as a chain of SavedFrame JSObjects, and set\n |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there\n are no JS frames on the stack.\n\n The |capture| parameter describes the portion of the JS stack to capture:\n\n   * |JS::AllFrames|: Capture all frames on the stack.\n\n   * |JS::MaxFrames|: Capture no more than |JS::MaxFrames::maxFrames| from the\n      stack.\n\n   * |JS::FirstSubsumedFrame|: Capture the first frame whose principals are\n     subsumed by |JS::FirstSubsumedFrame::principals|. By default, do not\n     consider self-hosted frames; this can be controlled via the\n     |JS::FirstSubsumedFrame::ignoreSelfHosted| flag. Do not capture any async\n     stack."]
            #[link_name = "\u{1}_ZN2JS19CaptureCurrentStackEP9JSContextNS_13MutableHandleIP8JSObjectEEON7mozilla7VariantIJNS_9AllFramesENS_9MaxFramesENS_18FirstSubsumedFrameEEEENS_6HandleIS4_EE"]
            pub fn CaptureCurrentStack(
                cx: *mut root::JSContext,
                stackp: root::JS::MutableHandleObject,
                capture: *mut root::JS::StackCapture,
                startAfter: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if capturing stack trace data to associate with an asynchronous\n operation is currently enabled for the current context realm.\n\n Users should check this state before capturing a stack that will be passed\n back to AutoSetAsyncStackForNewCalls later, in order to avoid capturing a\n stack for async use when we don't actually want to capture it."]
            #[link_name = "\u{1}_ZN2JS34IsAsyncStackCaptureEnabledForRealmEP9JSContext"]
            pub fn IsAsyncStackCaptureEnabledForRealm(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject stack, stringify it in the same format as\n Error.prototype.stack. The stringified stack out parameter is placed in the\n cx's compartment. Defaults to the empty string.\n\n The same notes above about SavedFrame accessors applies here as well: cx\n doesn't need to be in stack's compartment, and stack can be null, a\n SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object.\n SavedFrames not subsumed by |principals| are skipped.\n\n Optional indent parameter specifies the number of white spaces to indent\n each line."]
            #[link_name = "\u{1}_ZN2JS16BuildStackStringEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEEmN2js11StackFormatE"]
            pub fn BuildStackString(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                stack: root::JS::HandleObject,
                stringp: root::JS::MutableHandleString,
                indent: usize,
                stackFormat: root::js::StackFormat,
            ) -> bool;
        }
        #[repr(C)]
        pub struct OptimizedEncodingListener__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The ConsumeStreamCallback is called from an active JSContext, passing a\n StreamConsumer that wishes to consume the given host object as a stream of\n bytes with the given MIME type. On failure, the embedding must report the\n appropriate error on 'cx'. On success, the embedding must call\n consumer->consumeChunk() repeatedly on any thread until exactly one of:\n  - consumeChunk() returns false\n  - the embedding calls consumer->streamEnd()\n  - the embedding calls consumer->streamError()\n before JS_DestroyContext(cx) or JS::ShutdownAsyncTasks(cx) is called.\n\n Note: consumeChunk(), streamEnd() and streamError() may be called\n synchronously by ConsumeStreamCallback.\n\n When streamEnd() is called, the embedding may optionally pass an\n OptimizedEncodingListener*, indicating that there is a cache entry associated\n with this stream that can store an optimized encoding of the bytes that were\n just streamed at some point in the future by having SpiderMonkey call\n storeOptimizedEncoding(). Until the optimized encoding is ready, SpiderMonkey\n will hold an outstanding refcount to keep the listener alive.\n\n After storeOptimizedEncoding() is called, on cache hit, the embedding\n may call consumeOptimizedEncoding() instead of consumeChunk()/streamEnd().\n The embedding must ensure that the GetOptimizedEncodingBuildId() (see\n js/BuildId.h) at the time when an optimized encoding is created is the same\n as when it is later consumed."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct OptimizedEncodingListener {
            pub vtable_: *const OptimizedEncodingListener__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of OptimizedEncodingListener"]
                [::std::mem::size_of::<OptimizedEncodingListener>() - 8usize];
            ["Alignment of OptimizedEncodingListener"]
                [::std::mem::align_of::<OptimizedEncodingListener>() - 8usize];
        };
        #[repr(C)]
        pub struct StreamConsumer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct StreamConsumer {
            pub vtable_: *const StreamConsumer__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of StreamConsumer"][::std::mem::size_of::<StreamConsumer>() - 8usize];
            ["Alignment of StreamConsumer"][::std::mem::align_of::<StreamConsumer>() - 8usize];
        };
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MimeType {
            Wasm = 0,
        }
        pub type ConsumeStreamCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::HandleObject,
                arg3: root::JS::MimeType,
                arg4: *mut root::JS::StreamConsumer,
            ) -> bool,
        >;
        pub type ReportStreamErrorCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::JSContext, arg2: usize)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25InitConsumeStreamCallbackEP9JSContextPFbS1_NS_6HandleIP8JSObjectEENS_8MimeTypeEPNS_14StreamConsumerEEPFvS1_mE"]
            pub fn InitConsumeStreamCallback(
                cx: *mut root::JSContext,
                consume: root::JS::ConsumeStreamCallback,
                report: root::JS::ReportStreamErrorCallback,
            );
        }
        extern "C" {
            #[doc = " Create a new JSString possibly backed by |buffer|. The contents of |buffer|\n will be interpreted as an array of Latin1 characters.\n\n Note that the returned string is not guaranteed to use |buffer|: as an\n optimization, this API can return an inline string or a previously allocated\n string.\n\n Increments the buffer's refcount iff the JS string holds a reference to it."]
            #[link_name = "\u{1}_ZN2JS25NewStringFromLatin1BufferEP9JSContext6RefPtrIN7mozilla12StringBufferEEm"]
            pub fn NewStringFromLatin1Buffer(
                cx: *mut root::JSContext,
                buffer: root::RefPtr<root::mozilla::StringBuffer>,
                length: usize,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Like NewStringFromLatin1Buffer, but can be used to avoid refcounting overhead\n in cases where the returned string doesn't use the buffer. The caller must\n ensure the buffer outlives this call."]
            #[link_name = "\u{1}_ZN2JS34NewStringFromKnownLiveLatin1BufferEP9JSContextPN7mozilla12StringBufferEm"]
            pub fn NewStringFromKnownLiveLatin1Buffer(
                cx: *mut root::JSContext,
                buffer: *mut root::mozilla::StringBuffer,
                length: usize,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Similar to NewStringFromLatin1Buffer but for char16_t buffers."]
            #[link_name = "\u{1}_ZN2JS26NewStringFromTwoByteBufferEP9JSContext6RefPtrIN7mozilla12StringBufferEEm"]
            pub fn NewStringFromTwoByteBuffer(
                cx: *mut root::JSContext,
                buffer: root::RefPtr<root::mozilla::StringBuffer>,
                length: usize,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Similar to NewStringFromKnownLiveLatin1Buffer but for char16_t buffers."]
            #[link_name = "\u{1}_ZN2JS35NewStringFromKnownLiveTwoByteBufferEP9JSContextPN7mozilla12StringBufferEm"]
            pub fn NewStringFromKnownLiveTwoByteBuffer(
                cx: *mut root::JSContext,
                buffer: *mut root::mozilla::StringBuffer,
                length: usize,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Similar to NewStringFromLatin1Buffer but for UTF8 buffers.\n\n This can create a Latin1 string backed by |buffer| iff the utf8 buffer\n contains only ASCII chars. If there are non-ASCII chars, |buffer| can't be\n used so this API will copy and inflate the characters for the new JS string.\n\n Note that |length| must be the (byte) length of the UTF8 buffer."]
            #[link_name = "\u{1}_ZN2JS23NewStringFromUTF8BufferEP9JSContext6RefPtrIN7mozilla12StringBufferEEm"]
            pub fn NewStringFromUTF8Buffer(
                cx: *mut root::JSContext,
                buffer: root::RefPtr<root::mozilla::StringBuffer>,
                length: usize,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Like NewStringFromUTF8Buffer, but can be used to avoid refcounting overhead\n in cases where the returned string doesn't use the buffer. The caller must\n ensure the buffer outlives this call."]
            #[link_name = "\u{1}_ZN2JS32NewStringFromKnownLiveUTF8BufferEP9JSContextPN7mozilla12StringBufferEm"]
            pub fn NewStringFromKnownLiveUTF8Buffer(
                cx: *mut root::JSContext,
                buffer: *mut root::mozilla::StringBuffer,
                length: usize,
            ) -> *mut root::JSString;
        }
        #[doc = " Timing information for telemetry purposes"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct JSTimers {
            pub executionTime: root::mozilla::TimeDuration,
            pub delazificationTime: root::mozilla::TimeDuration,
            pub xdrEncodingTime: root::mozilla::TimeDuration,
            pub gcTime: root::mozilla::TimeDuration,
            pub protectTime: root::mozilla::TimeDuration,
            pub baselineCompileTime: root::mozilla::TimeDuration,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JSTimers"][::std::mem::size_of::<JSTimers>() - 48usize];
            ["Alignment of JSTimers"][::std::mem::align_of::<JSTimers>() - 8usize];
            ["Offset of field: JSTimers::executionTime"]
                [::std::mem::offset_of!(JSTimers, executionTime) - 0usize];
            ["Offset of field: JSTimers::delazificationTime"]
                [::std::mem::offset_of!(JSTimers, delazificationTime) - 8usize];
            ["Offset of field: JSTimers::xdrEncodingTime"]
                [::std::mem::offset_of!(JSTimers, xdrEncodingTime) - 16usize];
            ["Offset of field: JSTimers::gcTime"]
                [::std::mem::offset_of!(JSTimers, gcTime) - 24usize];
            ["Offset of field: JSTimers::protectTime"]
                [::std::mem::offset_of!(JSTimers, protectTime) - 32usize];
            ["Offset of field: JSTimers::baselineCompileTime"]
                [::std::mem::offset_of!(JSTimers, baselineCompileTime) - 40usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11GetJSTimersEP9JSContext"]
            pub fn GetJSTimers(cx: *mut root::JSContext) -> root::JS::JSTimers;
        }
        pub type Stencil = root::js::frontend::InitialStencilAndDelazifications;
        pub type TranscodeBuffer = u8;
        pub type TranscodeRange = root::mozilla::Range<u8>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TranscodeSource {
            pub range: root::JS::TranscodeRange,
            pub filename: *const ::std::os::raw::c_char,
            pub lineno: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TranscodeSource"][::std::mem::size_of::<TranscodeSource>() - 32usize];
            ["Alignment of TranscodeSource"][::std::mem::align_of::<TranscodeSource>() - 8usize];
            ["Offset of field: TranscodeSource::range"]
                [::std::mem::offset_of!(TranscodeSource, range) - 0usize];
            ["Offset of field: TranscodeSource::filename"]
                [::std::mem::offset_of!(TranscodeSource, filename) - 16usize];
            ["Offset of field: TranscodeSource::lineno"]
                [::std::mem::offset_of!(TranscodeSource, lineno) - 24usize];
        };
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TranscodeResult {
            Ok = 0,
            Failure = 16,
            Failure_BadBuildId = 17,
            Failure_AsmJSNotSupported = 18,
            Failure_BadDecode = 19,
            Throw = 32,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24CheckCompileOptionsMatchERKNS_22ReadOnlyCompileOptionsEP8JSScript"]
            pub fn CheckCompileOptionsMatch(
                options: *const root::JS::ReadOnlyCompileOptions,
                script: *mut root::JSScript,
            ) -> bool;
        }
        pub type BeforeWaitCallback = ::std::option::Option<
            unsafe extern "C" fn(memory: *mut u8) -> *mut ::std::os::raw::c_void,
        >;
        pub type AfterWaitCallback =
            ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetWaitCallbackEP9JSRuntimePFPvPhEPFvS2_Em"]
            pub fn SetWaitCallback(
                rt: *mut root::JSRuntime,
                beforeWait: root::JS::BeforeWaitCallback,
                afterWait: root::JS::AfterWaitCallback,
                requiredMemory: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16NewWeakMapObjectEP9JSContext"]
            pub fn NewWeakMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15IsWeakMapObjectEP8JSObject"]
            pub fn IsWeakMapObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleIS6_EE"]
            pub fn GetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn SetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::HandleValue,
            ) -> bool;
        }
        pub type ValueVector = u8;
        pub type ScriptVector = u8;
        pub type StringVector = u8;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21InformalValueTypeNameERKNS_5ValueE"]
            pub fn InformalValueTypeName(
                v: *const root::JS::Value,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24IdentifyStandardInstanceEP8JSObject"]
            pub fn IdentifyStandardInstance(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25IdentifyStandardPrototypeEP8JSObject"]
            pub fn IdentifyStandardPrototype(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS35IdentifyStandardInstanceOrPrototypeEP8JSObject"]
            pub fn IdentifyStandardInstanceOrPrototype(
                obj: *mut root::JSObject,
            ) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27IdentifyStandardConstructorEP8JSObject"]
            pub fn IdentifyStandardConstructor(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12ProtoKeyToIdEP9JSContext10JSProtoKeyNS_13MutableHandleINS_11PropertyKeyEEE"]
            pub fn ProtoKeyToId(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                idp: root::JS::MutableHandleId,
            );
        }
        extern "C" {
            #[doc = " Tell JS engine whether Profile Timeline Recording is enabled or not.\n If Profile Timeline Recording is enabled, data shown there like stack won't\n be optimized out.\n This is global state and not associated with specific runtime or context."]
            #[link_name = "\u{1}_ZN2JS34SetProfileTimelineRecordingEnabledEb"]
            pub fn SetProfileTimelineRecordingEnabled(enabled: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS33IsProfileTimelineRecordingEnabledEv"]
            pub fn IsProfileTimelineRecordingEnabled() -> bool;
        }
        extern "C" {
            #[doc = " Convert obj to a primitive value. On success, store the result in vp and\n return true.\n\n The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or\n JSTYPE_UNDEFINED (no hint).\n\n Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType])."]
            #[link_name = "\u{1}_ZN2JS11ToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn ToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                hint: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " If args.get(0) is one of the strings \"string\", \"number\", or \"default\", set\n result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_UNDEFINED accordingly and\n return true. Otherwise, return false with a TypeError pending.\n\n This can be useful in implementing a @@toPrimitive method."]
            #[link_name = "\u{1}_ZN2JS26GetFirstArgumentAsTypeHintEP9JSContextRKNS_8CallArgsEP6JSType"]
            pub fn GetFirstArgumentAsTypeHint(
                cx: *mut root::JSContext,
                args: *const root::JS::CallArgs,
                result: *mut root::JSType,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19OrdinaryHasInstanceEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn OrdinaryHasInstance(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
                v: root::JS::HandleValue,
                bp: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isMap| to true if |obj| is a Map object\n or a wrapper around one, or to false if not.  Returns false on failure.\n\n This method returns true with |*isMap == false| when passed an ES6 proxy\n whose target is a Map, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS11IsMapObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsMapObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isMap: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isSet| to true if |obj| is a Set object\n or a wrapper around one, or to false if not.  Returns false on failure.\n\n This method returns true with |*isSet == false| when passed an ES6 proxy\n whose target is a Set, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS11IsSetObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsSetObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isSet: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetSelfHostedFunctionEP9JSContextPKcNS_6HandleINS_11PropertyKeyEEEj"]
            pub fn GetSelfHostedFunction(
                cx: *mut root::JSContext,
                selfHostedName: *const ::std::os::raw::c_char,
                id: root::JS::HandleId,
                nargs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Create a new function based on the given JSFunctionSpec, *fs.\n id is the result of a successful call to\n `PropertySpecNameToId(cx, fs->name, &id)` or\n`PropertySpecNameToPermanentId(cx, fs->name, &id)`.\n\n Unlike JS_DefineFunctions, this does not treat fs as an array.\n *fs must not be JS_FS_END."]
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpecNS_6HandleINS_11PropertyKeyEEE"]
            pub fn NewFunctionFromSpec(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
                id: root::JS::HandleId,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Same as above, but without an id arg, for callers who don't have\n the id already."]
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpec"]
            pub fn NewFunctionFromSpec1(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
            ) -> *mut root::JSFunction;
        }
        #[doc = " Supply an alternative stack to incorporate into captured SavedFrame\n backtraces as the imputed caller of asynchronous JavaScript calls, like async\n function resumptions and DOM callbacks.\n\n When one async function awaits the result of another, it's natural to think\n of that as a sort of function call: just as execution resumes from an\n ordinary call expression when the callee returns, with the return value\n providing the value of the call expression, execution resumes from an 'await'\n expression after the awaited asynchronous function call returns, passing the\n return value along.\n\n Call the two async functions in such a situation the 'awaiter' and the\n 'awaitee'.\n\n As an async function, the awaitee contains 'await' expressions of its own.\n Whenever it executes after its first 'await', there are never any actual\n frames on the JavaScript stack under it; its awaiter is certainly not there.\n An await expression's continuation is invoked as a promise callback, and\n those are always called directly from the event loop in their own microtick.\n (Ignore unusual cases like nested event loops.)\n\n But because await expressions bear such a strong resemblance to calls (and\n deliberately so!), it would be unhelpful for stacks captured within the\n awaitee to be empty; instead, they should present the awaiter as the caller.\n\n The AutoSetAsyncStackForNewCalls RAII class supplies a SavedFrame stack to\n treat as the caller of any JavaScript invocations that occur within its\n lifetime. Any SavedFrame stack captured during such an invocation uses the\n SavedFrame passed to the constructor's 'stack' parameter as the 'asyncParent'\n property of the SavedFrame for the invocation's oldest frame. Its 'parent'\n property will be null, so stack-walking code can distinguish this\n awaiter/awaitee transition from an ordinary caller/callee transition.\n\n The constructor's 'asyncCause' parameter supplies a string explaining what\n sort of asynchronous call caused 'stack' to be spliced into the backtrace;\n for example, async function resumptions use the string \"async\". This appears\n as the 'asyncCause' property of the 'asyncParent' SavedFrame.\n\n Async callers are distinguished in the string form of a SavedFrame chain by\n including the 'asyncCause' string in the frame. It appears before the\n function name, with the two separated by a '*'.\n\n Note that, as each compartment has its own set of SavedFrames, the\n 'asyncParent' may actually point to a copy of 'stack', rather than the exact\n SavedFrame object passed.\n\n The youngest frame of 'stack' is not mutated to take the asyncCause string as\n its 'asyncCause' property; SavedFrame objects are immutable. Rather, a fresh\n clone of the frame is created with the needed 'asyncCause' property.\n\n The 'kind' argument specifies how aggressively 'stack' supplants any\n JavaScript frames older than this AutoSetAsyncStackForNewCalls object. If\n 'kind' is 'EXPLICIT', then all captured SavedFrame chains take on 'stack' as\n their 'asyncParent' where the chain crosses this object's scope. If 'kind' is\n 'IMPLICIT', then 'stack' is only included in captured chains if there are no\n other JavaScript frames on the stack --- that is, only if the stack would\n otherwise end at that point.\n\n AutoSetAsyncStackForNewCalls affects only SavedFrame chains; it does not\n affect Debugger.Frame or js::FrameIter. SavedFrame chains are used for\n Error.stack, allocation profiling, Promise debugging, and so on.\n\n See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async\n stack frames."]
        #[repr(C)]
        pub struct AutoSetAsyncStackForNewCalls {
            pub cx: *mut root::JSContext,
            pub oldAsyncStack: root::JS::RootedObject,
            pub oldAsyncCause: *const ::std::os::raw::c_char,
            pub oldAsyncCallIsExplicit: bool,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
            IMPLICIT = 0,
            EXPLICIT = 1,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoSetAsyncStackForNewCalls"]
                [::std::mem::size_of::<AutoSetAsyncStackForNewCalls>() - 48usize];
            ["Alignment of AutoSetAsyncStackForNewCalls"]
                [::std::mem::align_of::<AutoSetAsyncStackForNewCalls>() - 8usize];
            ["Offset of field: AutoSetAsyncStackForNewCalls::cx"]
                [::std::mem::offset_of!(AutoSetAsyncStackForNewCalls, cx) - 0usize];
            ["Offset of field: AutoSetAsyncStackForNewCalls::oldAsyncStack"]
                [::std::mem::offset_of!(AutoSetAsyncStackForNewCalls, oldAsyncStack) - 8usize];
            ["Offset of field: AutoSetAsyncStackForNewCalls::oldAsyncCause"]
                [::std::mem::offset_of!(AutoSetAsyncStackForNewCalls, oldAsyncCause) - 32usize];
            ["Offset of field: AutoSetAsyncStackForNewCalls::oldAsyncCallIsExplicit"][::std::mem::offset_of!(
                AutoSetAsyncStackForNewCalls,
                oldAsyncCallIsExplicit
            ) - 40usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24PropertySpecNameEqualsIdEN14JSPropertySpec4NameENS_6HandleINS_11PropertyKeyEEE"]
            pub fn PropertySpecNameEqualsId(
                name: root::JSPropertySpec_Name,
                id: root::JS::HandleId,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a jsid that does not need to be marked for GC.\n\n 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The\n resulting jsid, on success, is either an interned string or a well-known\n symbol; either way it is immune to GC so there is no need to visit *idp\n during GC marking."]
            #[link_name = "\u{1}_ZN2JS29PropertySpecNameToPermanentIdEP9JSContextN14JSPropertySpec4NameEPNS_11PropertyKeyE"]
            pub fn PropertySpecNameToPermanentId(
                cx: *mut root::JSContext,
                name: root::JSPropertySpec_Name,
                idp: *mut root::jsid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34DisableSpectreMitigationsAfterInitEv"]
            pub fn DisableSpectreMitigationsAfterInit();
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoFilename {
            pub ss_: *mut root::js::ScriptSource,
            pub filename_: root::__BindgenOpaqueArray<u64, 2usize>,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoFilename"][::std::mem::size_of::<AutoFilename>() - 24usize];
            ["Alignment of AutoFilename"][::std::mem::align_of::<AutoFilename>() - 8usize];
            ["Offset of field: AutoFilename::ss_"]
                [::std::mem::offset_of!(AutoFilename, ss_) - 0usize];
            ["Offset of field: AutoFilename::filename_"]
                [::std::mem::offset_of!(AutoFilename, filename_) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetScriptedCallerGlobalEP9JSContext"]
            pub fn GetScriptedCallerGlobal(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Informs the JS engine that the scripted caller should be hidden. This can be\n used by the embedding to maintain an override of the scripted caller in its\n calculations, by hiding the scripted caller in the JS engine and pushing data\n onto a separate stack, which it inspects when DescribeScriptedCaller returns\n null.\n\n We maintain a counter on each activation record. Add() increments the counter\n of the topmost activation, and Remove() decrements it. The count may never\n drop below zero, and must always be exactly zero when the activation is\n popped from the stack."]
            #[link_name = "\u{1}_ZN2JS18HideScriptedCallerEP9JSContext"]
            pub fn HideScriptedCaller(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UnhideScriptedCallerEP9JSContext"]
            pub fn UnhideScriptedCaller(cx: *mut root::JSContext);
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoHideScriptedCaller {
            pub mContext: *mut root::JSContext,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoHideScriptedCaller"]
                [::std::mem::size_of::<AutoHideScriptedCaller>() - 8usize];
            ["Alignment of AutoHideScriptedCaller"]
                [::std::mem::align_of::<AutoHideScriptedCaller>() - 8usize];
            ["Offset of field: AutoHideScriptedCaller::mContext"]
                [::std::mem::offset_of!(AutoHideScriptedCaller, mContext) - 0usize];
        };
        extern "C" {
            #[doc = " Attempt to disable Wasm's usage of reserving a large virtual memory\n allocation to avoid bounds checking overhead. This must be called before any\n Wasm module or memory is created in this process, or else this function will\n fail."]
            #[link_name = "\u{1}_ZN2JS21DisableWasmHugeMemoryEv"]
            pub fn DisableWasmHugeMemory() -> bool;
        }
        extern "C" {
            #[doc = " Return true iff the given object is either a SavedFrame object or wrapper\n around a SavedFrame object, and it is not the SavedFrame.prototype object."]
            #[link_name = "\u{1}_ZN2JS24IsMaybeWrappedSavedFrameEP8JSObject"]
            pub fn IsMaybeWrappedSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true iff the given object is a SavedFrame object and not the\n SavedFrame.prototype object."]
            #[link_name = "\u{1}_ZN2JS21IsUnwrappedSavedFrameEP8JSObject"]
            pub fn IsUnwrappedSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given byte length."]
            #[link_name = "\u{1}_ZN2JS14NewArrayBufferEP9JSContextm"]
            pub fn NewArrayBuffer(cx: *mut root::JSContext, nbytes: usize) -> *mut root::JSObject;
        }
        #[repr(i32)]
        #[doc = " Marker enum to notify callers that the buffer contents must be freed manually\n when the ArrayBuffer allocation failed."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NewArrayBufferOutOfMemory {
            CallerMustFreeMemory = 0,
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer, whose bytes are set to the values of the bytes in\n the provided ArrayBuffer.\n\n |maybeArrayBuffer| is asserted to be non-null.  An error is thrown if\n |maybeArrayBuffer| would fail the |IsArrayBufferObject| test given further\n below or if |maybeArrayBuffer| is detached.\n\n |maybeArrayBuffer| may store its contents in any fashion (i.e. it doesn't\n matter whether |maybeArrayBuffer| was allocated using |JS::NewArrayBuffer|,\n |JS::NewExternalArrayBuffer|, or any other ArrayBuffer-allocating function).\n\n The newly-created ArrayBuffer is effectively creatd as if by\n |JS::NewArrayBufferWithContents| passing in |maybeArrayBuffer|'s internal\n data pointer and length, in a manner safe against |maybeArrayBuffer|'s data\n being moved around by the GC.  In particular, the new ArrayBuffer will not\n behave like one created for WASM or asm.js, so it *can* be detached."]
            #[link_name = "\u{1}_ZN2JS15CopyArrayBufferEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn CopyArrayBuffer(
                cx: *mut root::JSContext,
                maybeArrayBuffer: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        pub type BufferContentsFreeFunc = ::std::option::Option<
            unsafe extern "C" fn(
                contents: *mut ::std::os::raw::c_void,
                userData: *mut ::std::os::raw::c_void,
            ),
        >;
        #[doc = " UniquePtr deleter for external buffer contents."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferContentsDeleter {
            pub freeFunc_: root::JS::BufferContentsFreeFunc,
            pub userData_: *mut ::std::os::raw::c_void,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of BufferContentsDeleter"]
                [::std::mem::size_of::<BufferContentsDeleter>() - 16usize];
            ["Alignment of BufferContentsDeleter"]
                [::std::mem::align_of::<BufferContentsDeleter>() - 8usize];
            ["Offset of field: BufferContentsDeleter::freeFunc_"]
                [::std::mem::offset_of!(BufferContentsDeleter, freeFunc_) - 0usize];
            ["Offset of field: BufferContentsDeleter::userData_"]
                [::std::mem::offset_of!(BufferContentsDeleter, userData_) - 8usize];
        };
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given non-null |contents|.\n\n Ownership of |contents| remains with the caller: it isn't transferred to the\n returned ArrayBuffer.  Callers of this function *must* ensure that they\n perform these two steps, in this order, to properly relinquish ownership of\n |contents|:\n\n   1. Call |JS::DetachArrayBuffer| on the buffer returned by this function.\n      (|JS::DetachArrayBuffer| is generally fallible, but a call under these\n      circumstances is guaranteed to succeed.)\n   2. |contents| may be deallocated or discarded consistent with the manner\n      in which it was allocated.\n\n Do not simply allow the returned buffer to be garbage-collected before\n deallocating |contents|, because in general there is no way to know *when*\n an object is fully garbage-collected to the point where this would be safe."]
            #[link_name = "\u{1}_ZN2JS35NewArrayBufferWithUserOwnedContentsEP9JSContextmPv"]
            pub fn NewArrayBufferWithUserOwnedContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new mapped ArrayBuffer with the given memory mapped contents. It\n must be legal to free the contents pointer by unmapping it. On success,\n ownership is transferred to the new mapped ArrayBuffer."]
            #[link_name = "\u{1}_ZN2JS32NewMappedArrayBufferWithContentsEP9JSContextmPv"]
            pub fn NewMappedArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create memory mapped ArrayBuffer contents.\n Caller must take care of closing fd after calling this function."]
            #[link_name = "\u{1}_ZN2JS31CreateMappedArrayBufferContentsEimm"]
            pub fn CreateMappedArrayBufferContents(
                fd: ::std::os::raw::c_int,
                offset: usize,
                length: usize,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Release the allocated resource of mapped ArrayBuffer contents before the\n object is created.\n If a new object has been created by JS::NewMappedArrayBufferWithContents()\n with this content, then JS::DetachArrayBuffer() should be used instead to\n release the resource used by the object."]
            #[link_name = "\u{1}_ZN2JS32ReleaseMappedArrayBufferContentsEPvm"]
            pub fn ReleaseMappedArrayBufferContents(
                contents: *mut ::std::os::raw::c_void,
                length: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19IsArrayBufferObjectEP8JSObject"]
            pub fn IsArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Check whether the obj is a detached ArrayBufferObject. Note that this may\n return false if a security wrapper is encountered that denies the\n unwrapping."]
            #[link_name = "\u{1}_ZN2JS27IsDetachedArrayBufferObjectEP8JSObject"]
            pub fn IsDetachedArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Check whether the obj is ArrayBufferObject and memory mapped. Note that this\n may return false if a security wrapper is encountered that denies the\n unwrapping."]
            #[link_name = "\u{1}_ZN2JS25IsMappedArrayBufferObjectEP8JSObject"]
            pub fn IsMappedArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true if the ArrayBuffer |obj| contains any data, i.e. it is not a\n detached ArrayBuffer.  (ArrayBuffer.prototype is not an ArrayBuffer.)\n\n |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known\n that it would pass such a test: it is an ArrayBuffer or a wrapper of an\n ArrayBuffer, and the unwrapping will succeed."]
            #[link_name = "\u{1}_ZN2JS18ArrayBufferHasDataEP8JSObject"]
            pub fn ArrayBufferHasData(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17UnwrapArrayBufferEP8JSObject"]
            pub fn UnwrapArrayBuffer(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Attempt to unwrap |obj| as an ArrayBuffer.\n\n If |obj| *is* an ArrayBuffer, return it unwrapped and set |*length| and\n |*data| to weakly refer to the ArrayBuffer's contents.\n\n If |obj| isn't an ArrayBuffer, return nullptr and do not modify |*length| or\n |*data|."]
            #[link_name = "\u{1}_ZN2JS22GetObjectAsArrayBufferEP8JSObjectPmPPh"]
            pub fn GetObjectAsArrayBuffer(
                obj: *mut root::JSObject,
                length: *mut usize,
                data: *mut *mut u8,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Return the available byte length of an ArrayBuffer.\n\n |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known\n that it would pass such a test: it is an ArrayBuffer or a wrapper of an\n ArrayBuffer, and the unwrapping will succeed."]
            #[link_name = "\u{1}_ZN2JS24GetArrayBufferByteLengthEP8JSObject"]
            pub fn GetArrayBufferByteLength(obj: *mut root::JSObject) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetArrayBufferLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        extern "C" {
            #[doc = " Return a pointer to the start of the data referenced by a typed array. The\n data is still owned by the typed array, and should not be modified on\n another thread. Furthermore, the pointer can become invalid on GC (if the\n data is small and fits inside the array's GC header), so callers must take\n care not to hold on across anything that could GC.\n\n |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known\n that it would pass such a test: it is an ArrayBuffer or a wrapper of an\n ArrayBuffer, and the unwrapping will succeed.\n\n |*isSharedMemory| is always set to false.  The argument is present to\n simplify its use from code that also interacts with SharedArrayBuffer."]
            #[link_name = "\u{1}_ZN2JS18GetArrayBufferDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetArrayBufferData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
        }
        extern "C" {
            #[doc = " Detach an ArrayBuffer, causing all associated views to no longer refer to\n the ArrayBuffer's original attached memory.\n\n This function throws only if it is provided a non-ArrayBuffer object or if\n the provided ArrayBuffer is a WASM-backed ArrayBuffer or an ArrayBuffer used\n in asm.js code."]
            #[link_name = "\u{1}_ZN2JS17DetachArrayBufferEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn DetachArrayBuffer(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30HasDefinedArrayBufferDetachKeyEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn HasDefinedArrayBufferDetachKey(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isDefined: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Steal the contents of the given ArrayBuffer. The ArrayBuffer has its length\n set to 0 and its contents array cleared. The caller takes ownership of the\n return value and must free it or transfer ownership via\n JS::NewArrayBufferWithContents when done using it."]
            #[link_name = "\u{1}_ZN2JS24StealArrayBufferContentsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn StealArrayBufferContents(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Copy data from one array buffer to another.\n\n Both fromBuffer and toBuffer must be (possibly wrapped)\n ArrayBufferObjectMaybeShared.\n\n This method may throw if the sizes don't match, or if unwrapping fails.\n\n The API for this is modelled on CopyDataBlockBytes from the spec:\n https://tc39.es/ecma262/#sec-copydatablockbytes"]
            #[link_name = "\u{1}_ZN2JS19ArrayBufferCopyDataEP9JSContextNS_6HandleIP8JSObjectEEmS5_mm"]
            pub fn ArrayBufferCopyData(
                cx: *mut root::JSContext,
                toBlock: root::JS::Handle<*mut root::JSObject>,
                toIndex: usize,
                fromBlock: root::JS::Handle<*mut root::JSObject>,
                fromIndex: usize,
                count: usize,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Copy data from one array buffer to another.\n\n srcBuffer must be a (possibly wrapped) ArrayBufferObjectMaybeShared.\n\n This method may throw if unwrapping or allocation fails.\n\n The API for this is modelled on CloneArrayBuffer from the spec:\n https://tc39.es/ecma262/#sec-clonearraybuffer"]
            #[link_name = "\u{1}_ZN2JS16ArrayBufferCloneEP9JSContextNS_6HandleIP8JSObjectEEmm"]
            pub fn ArrayBufferClone(
                cx: *mut root::JSContext,
                srcBuffer: root::JS::Handle<*mut root::JSObject>,
                srcByteOffset: usize,
                srcLength: usize,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Check whether obj supports the JS::GetArrayBufferMaybeShared* APIs.  Note\n that this may return false if a security wrapper is encountered that denies\n the unwrapping. If this test succeeds, then it is safe to call the various\n predicate and accessor JSAPI calls defined below."]
            #[link_name = "\u{1}_ZN2JS30IsArrayBufferObjectMaybeSharedEP8JSObject"]
            pub fn IsArrayBufferObjectMaybeShared(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28UnwrapArrayBufferMaybeSharedEP8JSObject"]
            pub fn UnwrapArrayBufferMaybeShared(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the length, sharedness, and data from an ArrayBufferMaybeShared subtypes.\n\n The computed length and data pointer may be invalidated by a GC or by an\n unshared array buffer becoming detached. Callers must take care not to\n perform any actions that could trigger a GC or result in an unshared array\n buffer becoming detached. If such actions nonetheless must be performed,\n callers should perform this call a second time (and sensibly handle results\n that may be different from those returned the first time). (Sharedness is an\n immutable characteristic of an array buffer or shared array buffer, so that\n boolean remains valid across GC or detaching.)\n\n |obj| must be an ArrayBufferMaybeShared subtype: an ArrayBuffer or a\n SharedArrayBuffer.\n\n |*length| will be set to bytes in the buffer.\n\n |*isSharedMemory| will be set to true if it is a SharedArrayBuffer, otherwise\n to false.\n\n |*data| will be set to a pointer to the bytes in the buffer."]
            #[link_name = "\u{1}_ZN2JS38GetArrayBufferMaybeSharedLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferMaybeSharedLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        extern "C" {
            #[doc = " Return a pointer to the start of the array buffer's data, and indicate\n whether the data is from a shared array buffer through an outparam.\n\n The returned data pointer may be invalidated by a GC or by an unshared array\n buffer becoming detached. Callers must take care not to perform any actions\n that could trigger a GC or result in an unshared array buffer becoming\n detached. If such actions nonetheless must be performed, callers should\n perform this call a second time (and sensibly handle results that may be\n different from those returned the first time). (Sharedness is an immutable\n characteristic of an array buffer or shared array buffer, so that boolean\n remains valid across GC or detaching.)\n\n |obj| must have passed a JS::IsArrayBufferObjectMaybeShared test, or somehow\n be known that it would pass such a test: it is an ArrayBuffer or\n SharedArrayBuffer or a wrapper of an ArrayBuffer/SharedArrayBuffer, and the\n unwrapping will succeed.\n\n |*isSharedMemory| will be set to true if the typed array maps a\n SharedArrayBuffer, otherwise to false."]
            #[link_name = "\u{1}_ZN2JS29GetArrayBufferMaybeSharedDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetArrayBufferMaybeSharedData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
        }
        extern "C" {
            #[doc = " Returns whether the passed array buffer is 'large': its byteLength >= 2 GB.\n\n |obj| must pass a JS::IsArrayBufferObjectMaybeShared test."]
            #[link_name = "\u{1}_ZN2JS29IsLargeArrayBufferMaybeSharedEP8JSObject"]
            pub fn IsLargeArrayBufferMaybeShared(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns whether the passed array buffer is resizable or growable for shared\n array buffers.\n\n |obj| must pass a JS::IsArrayBufferObjectMaybeShared test."]
            #[link_name = "\u{1}_ZN2JS33IsResizableArrayBufferMaybeSharedEP8JSObject"]
            pub fn IsResizableArrayBufferMaybeShared(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Create a BigInt from a floating-point value. If the number isn't integral\n (that is, if it's NaN, an infinity, or contains a fractional component),\n this function returns null and throws an exception.\n\n Passing -0.0 will produce the bigint 0n."]
            #[link_name = "\u{1}_ZN2JS14NumberToBigIntEP9JSContextd"]
            pub fn NumberToBigInt(cx: *mut root::JSContext, num: f64) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Create a BigInt by parsing a string using the ECMAScript StringToBigInt\n algorithm (https://tc39.es/ecma262/#sec-stringtobigint). Latin1 and two-byte\n character ranges are supported. It may be convenient to use\n JS::ConstLatin1Chars or JS::ConstTwoByteChars.\n\n (StringToBigInt performs parsing similar to that performed by the |Number|\n global function when passed a string, but it doesn't allow infinities,\n decimal points, or exponential notation, and neither algorithm allows numeric\n separators or an 'n' suffix character. This fast-and-loose description is\n offered purely as a convenience to the reader: see the specification\n algorithm for exact behavior.)\n\n If parsing fails, this function returns null and throws an exception."]
            #[link_name = "\u{1}_ZN2JS14StringToBigIntEP9JSContextRKN7mozilla5RangeIKhEE"]
            pub fn StringToBigInt(
                cx: *mut root::JSContext,
                chars: *const root::mozilla::Range<root::JS::Latin1Char>,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14StringToBigIntEP9JSContextRKN7mozilla5RangeIKDsEE"]
            pub fn StringToBigInt1(
                cx: *mut root::JSContext,
                chars: *const root::mozilla::Range<u16>,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Create a BigInt by parsing a string consisting of an optional sign character\n followed by one or more alphanumeric ASCII digits in the provided radix.\n\n If the radix is not in the range [2, 36], or the string fails to parse, this\n function returns null and throws an exception."]
            #[link_name = "\u{1}_ZN2JS20SimpleStringToBigIntEP9JSContextN7mozilla4SpanIKcLm18446744073709551615EEEh"]
            pub fn SimpleStringToBigInt(
                cx: *mut root::JSContext,
                chars: root::__BindgenOpaqueArray<u64, 2usize>,
                radix: u8,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Convert a JS::Value to a BigInt using the ECMAScript ToBigInt algorithm\n (https://tc39.es/ecma262/#sec-tobigint).\n\n (Note in particular that this will throw if passed a value whose type is\n 'number'. To convert a number to a BigInt, use one of the overloads of\n JS::NumberToBigInt().)"]
            #[link_name = "\u{1}_ZN2JS8ToBigIntEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn ToBigInt(
                cx: *mut root::JSContext,
                val: root::JS::Handle<root::JS::Value>,
            ) -> *mut root::JS::BigInt;
        }
        extern "C" {
            #[doc = " Convert the given BigInt, modulo 2**64, to a signed 64-bit integer."]
            #[link_name = "\u{1}_ZN2JS10ToBigInt64EPKNS_6BigIntE"]
            pub fn ToBigInt64(bi: *const root::JS::BigInt) -> i64;
        }
        extern "C" {
            #[doc = " Convert the given BigInt, modulo 2**64, to an unsigned 64-bit integer."]
            #[link_name = "\u{1}_ZN2JS11ToBigUint64EPKNS_6BigIntE"]
            pub fn ToBigUint64(bi: *const root::JS::BigInt) -> u64;
        }
        extern "C" {
            #[doc = " Convert the given BigInt to a Number value as if calling the Number\n constructor on it\n (https://tc39.es/ecma262/#sec-number-constructor-number-value). The value\n may be rounded if it doesn't fit without loss of precision."]
            #[link_name = "\u{1}_ZN2JS14BigIntToNumberEPKNS_6BigIntE"]
            pub fn BigIntToNumber(bi: *const root::JS::BigInt) -> f64;
        }
        extern "C" {
            #[doc = " Return true if the given BigInt is negative."]
            #[link_name = "\u{1}_ZN2JS16BigIntIsNegativeEPKNS_6BigIntE"]
            pub fn BigIntIsNegative(bi: *const root::JS::BigInt) -> bool;
        }
        extern "C" {
            #[doc = " Same as BigIntFits(), but checks if the value fits inside a JS Number value."]
            #[link_name = "\u{1}_ZN2JS16BigIntFitsNumberEPKNS_6BigIntEPd"]
            pub fn BigIntFitsNumber(bi: *const root::JS::BigInt, out: *mut f64) -> bool;
        }
        extern "C" {
            #[doc = " Convert the given BigInt to a String value as if toString() were called on\n it.\n\n If the radix is not in the range [2, 36], then this function returns null and\n throws an exception."]
            #[link_name = "\u{1}_ZN2JS14BigIntToStringEP9JSContextNS_6HandleIPNS_6BigIntEEEh"]
            pub fn BigIntToString(
                cx: *mut root::JSContext,
                bi: root::JS::Handle<*mut root::JS::BigInt>,
                radix: u8,
            ) -> *mut root::JSString;
        }
        #[doc = " Vector of characters used for holding build ids."]
        pub type BuildIdCharVector = u8;
        #[doc = " Return the buildId (represented as a sequence of characters) associated with\n the currently-executing build. If the JS engine is embedded such that a\n single cache entry can be observed by different compiled versions of the JS\n engine, it is critical that the buildId shall change for each new build of\n the JS engine."]
        pub type BuildIdOp = ::std::option::Option<
            unsafe extern "C" fn(buildId: *mut root::JS::BuildIdCharVector) -> bool,
        >;
        extern "C" {
            #[doc = " Embedder hook to set the buildId-generating function."]
            #[link_name = "\u{1}_ZN2JS19SetProcessBuildIdOpEPFbPN7mozilla6VectorIcLm0EN2js17SystemAllocPolicyEEEE"]
            pub fn SetProcessBuildIdOp(buildIdOp: root::JS::BuildIdOp);
        }
        extern "C" {
            #[doc = " Evaluate the given source buffer in the scope of the current global of cx,\n and return the completion value in |rval|."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " As above, but providing an explicit scope chain.  envChain must not include\n the global object on it; that's implicit.  It needs to contain the other\n objects that should end up on the script's scope chain."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_16EnvironmentChainERKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate1(
                cx: *mut root::JSContext,
                envChain: *const root::JS::EnvironmentChain,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the provided UTF-8 data in the scope of the current global of |cx|,\n and return the completion value in |rval|.  If the data contains invalid\n UTF-8, an error is reported."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate2(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the UTF-8 contents of the file at the given path, and return the\n completion value in |rval|.  (The path itself is UTF-8 encoded, too.)  If\n the contents contain any malformed UTF-8, an error is reported."]
            #[link_name = "\u{1}_ZN2JS16EvaluateUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleINS_5ValueEEE"]
            pub fn EvaluateUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Compile the provided script using the given options.  Return the script on\n success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn Compile(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the provided script using the given options.  Return the script on\n success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn Compile1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the given file into a script.  It is an error\n if the file contains invalid UTF-8.  Return the script on success, or return\n null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS15CompileUtf8FileEP9JSContextRKNS_22ReadOnlyCompileOptionsEP8_IO_FILE"]
            pub fn CompileUtf8File(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                file: *mut root::FILE,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the file at the given path into a script.\n (The path itself is in the system encoding, not [necessarily] UTF-8.)  It\n is an error if the file's contents are invalid UTF-8.  Return the script on\n success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS15CompileUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKc"]
            pub fn CompileUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile a function with envChain plus the global as its scope chain.\n envChain must contain objects in the current compartment of cx.  The actual\n scope chain used for the function will consist of With wrappers for those\n objects, followed by the current global of the compartment cx is in.  This\n global must not be explicitly included in the scope chain."]
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextRKNS_16EnvironmentChainERKNS_22ReadOnlyCompileOptionsEPKcjPKS9_RNS_10SourceTextIDsEE"]
            pub fn CompileFunction(
                cx: *mut root::JSContext,
                envChain: *const root::JS::EnvironmentChain,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Compile a function with envChain plus the global as its scope chain.\n envChain must contain objects in the current compartment of cx.  The actual\n scope chain used for the function will consist of With wrappers for those\n objects, followed by the current global of the compartment cx is in.  This\n global must not be explicitly included in the scope chain."]
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextRKNS_16EnvironmentChainERKNS_22ReadOnlyCompileOptionsEPKcjPKS9_RNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileFunction1(
                cx: *mut root::JSContext,
                envChain: *const root::JS::EnvironmentChain,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Identical to the CompileFunction overload above for UTF-8, but with\n Rust-friendly ergonomics."]
            #[link_name = "\u{1}_ZN2JS19CompileFunctionUtf8EP9JSContextRKNS_16EnvironmentChainERKNS_22ReadOnlyCompileOptionsEPKcjPKS9_S9_m"]
            pub fn CompileFunctionUtf8(
                cx: *mut root::JSContext,
                envChain: *const root::JS::EnvironmentChain,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                utf8: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22ExposeScriptToDebuggerEP9JSContextNS_6HandleIP8JSScriptEE"]
            pub fn ExposeScriptToDebugger(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19UpdateDebugMetadataEP9JSContextNS_6HandleIP8JSScriptEERKNS_18InstantiateOptionsENS2_INS_5ValueEEENS2_IP8JSStringEES5_S5_"]
            pub fn UpdateDebugMetadata(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                options: *const root::JS::InstantiateOptions,
                privateValue: root::JS::HandleValue,
                elementAttributeName: root::JS::HandleString,
                introScript: root::JS::HandleScript,
                scriptOrModule: root::JS::HandleScript,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ContextOptions {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize]>,
            pub compileOptions_: root::JS::PrefableCompileOptions,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ContextOptions"][::std::mem::size_of::<ContextOptions>() - 4usize];
            ["Alignment of ContextOptions"][::std::mem::align_of::<ContextOptions>() - 1usize];
            ["Offset of field: ContextOptions::compileOptions_"]
                [::std::mem::offset_of!(ContextOptions, compileOptions_) - 2usize];
        };
        impl ContextOptions {
            #[inline]
            pub fn wasm_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasm_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn wasm__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        0usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_wasm__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        0usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn wasmForTrustedPrinciples_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmForTrustedPrinciples_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn wasmForTrustedPrinciples__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        1usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_wasmForTrustedPrinciples__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        1usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn wasmBaseline_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmBaseline_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn wasmBaseline__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        2usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_wasmBaseline__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        2usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn wasmIon_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmIon_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn wasmIon__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        3usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_wasmIon__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        3usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn testWasmAwaitTier2_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_testWasmAwaitTier2_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn testWasmAwaitTier2__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        4usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_testWasmAwaitTier2__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        4usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn disableIon_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_disableIon_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn disableIon__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        5usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_disableIon__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        5usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn disableEvalSecurityChecks_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_disableEvalSecurityChecks_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn disableEvalSecurityChecks__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        6usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_disableEvalSecurityChecks__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        6usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn asyncStack_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asyncStack_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn asyncStack__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        7usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_asyncStack__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        7usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn asyncStackCaptureDebuggeeOnly_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asyncStackCaptureDebuggeeOnly_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn asyncStackCaptureDebuggeeOnly__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        8usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_asyncStackCaptureDebuggeeOnly__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        8usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn throwOnDebuggeeWouldRun_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_throwOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn throwOnDebuggeeWouldRun__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        9usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_throwOnDebuggeeWouldRun__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        9usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn dumpStackOnDebuggeeWouldRun_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_dumpStackOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn dumpStackOnDebuggeeWouldRun__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        10usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_dumpStackOnDebuggeeWouldRun__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        10usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn fuzzing_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_fuzzing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn fuzzing__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        11usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_fuzzing__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        11usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                wasm_: bool,
                wasmForTrustedPrinciples_: bool,
                wasmBaseline_: bool,
                wasmIon_: bool,
                testWasmAwaitTier2_: bool,
                disableIon_: bool,
                disableEvalSecurityChecks_: bool,
                asyncStack_: bool,
                asyncStackCaptureDebuggeeOnly_: bool,
                throwOnDebuggeeWouldRun_: bool,
                dumpStackOnDebuggeeWouldRun_: bool,
                fuzzing_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 2usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let wasm_: u8 = unsafe { ::std::mem::transmute(wasm_) };
                    wasm_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let wasmForTrustedPrinciples_: u8 =
                        unsafe { ::std::mem::transmute(wasmForTrustedPrinciples_) };
                    wasmForTrustedPrinciples_ as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let wasmBaseline_: u8 = unsafe { ::std::mem::transmute(wasmBaseline_) };
                    wasmBaseline_ as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let wasmIon_: u8 = unsafe { ::std::mem::transmute(wasmIon_) };
                    wasmIon_ as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let testWasmAwaitTier2_: u8 =
                        unsafe { ::std::mem::transmute(testWasmAwaitTier2_) };
                    testWasmAwaitTier2_ as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let disableIon_: u8 = unsafe { ::std::mem::transmute(disableIon_) };
                    disableIon_ as u64
                });
                __bindgen_bitfield_unit.set(6usize, 1u8, {
                    let disableEvalSecurityChecks_: u8 =
                        unsafe { ::std::mem::transmute(disableEvalSecurityChecks_) };
                    disableEvalSecurityChecks_ as u64
                });
                __bindgen_bitfield_unit.set(7usize, 1u8, {
                    let asyncStack_: u8 = unsafe { ::std::mem::transmute(asyncStack_) };
                    asyncStack_ as u64
                });
                __bindgen_bitfield_unit.set(8usize, 1u8, {
                    let asyncStackCaptureDebuggeeOnly_: u8 =
                        unsafe { ::std::mem::transmute(asyncStackCaptureDebuggeeOnly_) };
                    asyncStackCaptureDebuggeeOnly_ as u64
                });
                __bindgen_bitfield_unit.set(9usize, 1u8, {
                    let throwOnDebuggeeWouldRun_: u8 =
                        unsafe { ::std::mem::transmute(throwOnDebuggeeWouldRun_) };
                    throwOnDebuggeeWouldRun_ as u64
                });
                __bindgen_bitfield_unit.set(10usize, 1u8, {
                    let dumpStackOnDebuggeeWouldRun_: u8 =
                        unsafe { ::std::mem::transmute(dumpStackOnDebuggeeWouldRun_) };
                    dumpStackOnDebuggeeWouldRun_ as u64
                });
                __bindgen_bitfield_unit.set(11usize, 1u8, {
                    let fuzzing_: u8 = unsafe { ::std::mem::transmute(fuzzing_) };
                    fuzzing_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17ContextOptionsRefEP9JSContext"]
            pub fn ContextOptionsRef(cx: *mut root::JSContext) -> *mut root::JS::ContextOptions;
        }
        extern "C" {
            #[doc = " ES6 draft 20141224, 7.1.1, second algorithm.\n\n Most users shouldn't call this -- use JS::ToBoolean, ToNumber, or ToString\n instead.  This will typically only be called from custom convert hooks that\n wish to fall back to the ES6 default conversion behavior shared by most\n objects in JS, codified as OrdinaryToPrimitive."]
            #[link_name = "\u{1}_ZN2JS19OrdinaryToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn OrdinaryToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                type_: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store in |out| the null-terminated, base-10 result of |ToString| applied to\n |d| per <https://tc39.es/ecma262/#sec-tostring-applied-to-the-number-type>.\n (This will produce \"NaN\", \"-Infinity\", or \"Infinity\" for non-finite |d|.)"]
            #[link_name = "\u{1}_ZN2JS14NumberToStringEdRA32_c"]
            pub fn NumberToString(d: f64, out: *mut [::std::os::raw::c_char; 32usize]);
        }
        extern "C" {
            #[doc = " Re-query the system to determine the current time zone adjustment from UTC,\n including any component due to DST.  If the time zone has changed, this will\n cause all Date object non-UTC methods and formatting functions to produce\n appropriately adjusted results.\n\n Left to its own devices, SpiderMonkey itself may occasionally try to detect\n system time changes.  However, no particular frequency of checking is\n guaranteed.  Embedders unable to accept occasional inaccuracies should call\n this method in response to system time changes, or immediately before\n operations requiring instantaneous correctness, to guarantee correct\n behavior."]
            #[link_name = "\u{1}_ZN2JS13ResetTimeZoneEv"]
            pub fn ResetTimeZone();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClippedTime {
            pub t: f64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ClippedTime"][::std::mem::size_of::<ClippedTime>() - 8usize];
            ["Alignment of ClippedTime"][::std::mem::align_of::<ClippedTime>() - 8usize];
            ["Offset of field: ClippedTime::t"][::std::mem::offset_of!(ClippedTime, t) - 0usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextNS_11ClippedTimeE"]
            pub fn NewDateObject(
                cx: *mut root::JSContext,
                time: root::JS::ClippedTime,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new Date object for a year/month/day-of-month/hour/minute/second.\n\n The created date is initialized with the time value\n\n   TimeClip(UTC(MakeDate(MakeDay(year, mon, mday),\n                MakeTime(hour, min, sec, 0.0))))\n\n where each function/operation is as specified in ECMAScript."]
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextiiiiii"]
            pub fn NewDateObject1(
                cx: *mut root::JSContext,
                year: ::std::os::raw::c_int,
                mon: ::std::os::raw::c_int,
                mday: ::std::os::raw::c_int,
                hour: ::std::os::raw::c_int,
                min: ::std::os::raw::c_int,
                sec: ::std::os::raw::c_int,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isDate| to true if |obj| is a Date\n object or a wrapper around one, or to false if not.  Returns false on\n failure.\n\n This method returns true with |*isDate == false| when passed an ES6 proxy\n whose target is a Date, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS12ObjectIsDateEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsDate(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isDate: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjj"]
            pub fn MakeDate(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjjd"]
            pub fn MakeDate1(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
                time: f64,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12YearFromTimeEd"]
            pub fn YearFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13MonthFromTimeEd"]
            pub fn MonthFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11DayFromTimeEd"]
            pub fn DayFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11DayFromYearEd"]
            pub fn DayFromYear(year: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13DayWithinYearEdd"]
            pub fn DayWithinYear(time: f64, year: f64) -> f64;
        }
        pub type ReduceMicrosecondTimePrecisionCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: f64,
                arg2: root::JS::RTPCallerTypeToken,
                arg3: *mut root::JSContext,
            ) -> f64,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS41SetReduceMicrosecondTimePrecisionCallbackEPFddNS_18RTPCallerTypeTokenEP9JSContextE"]
            pub fn SetReduceMicrosecondTimePrecisionCallback(
                callback: root::JS::ReduceMicrosecondTimePrecisionCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS41GetReduceMicrosecondTimePrecisionCallbackEv"]
            pub fn GetReduceMicrosecondTimePrecisionCallback(
            ) -> root::JS::ReduceMicrosecondTimePrecisionCallback;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21SetTimeResolutionUsecEjb"]
            pub fn SetTimeResolutionUsec(resolution: u32, jitter: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14IsISOStyleDateEP9JSContextRKNS_11Latin1CharsE"]
            pub fn IsISOStyleDate(
                cx: *mut root::JSContext,
                str_: *const root::JS::Latin1Chars,
            ) -> bool;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SupportUnscopables {
            No = 0,
            Yes = 1,
        }
        #[doc = " JS::EnvironmentChain stores a list of objects to put on the environment\n chain.\n\n Internally the engine will create a non-syntactic 'with' environment for each\n of these objects. Note that 'with' environments aren't optimized well so you\n should use this class only if you really have to.\n\n The SupportUnscopables enum class controls whether these non-syntactic 'with'\n environments support Symbol.unscopables similar to syntactic 'with'\n statements in JS.\n\n Passing SupportUnscopables::No is better for performance because it lets us\n skip the Symbol.unscopables property lookup. Some Web APIs require supporting\n Symbol.unscopables though. In Firefox, SupportUnscopables::Yes is used for\n event handlers."]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct EnvironmentChain {
            pub _bindgen_opaque_blob: [u64; 16usize],
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of EnvironmentChain"][::std::mem::size_of::<EnvironmentChain>() - 128usize];
            ["Alignment of EnvironmentChain"][::std::mem::align_of::<EnvironmentChain>() - 8usize];
        };
        extern "C" {
            #[doc = " Store |v1 === v2| to |*equal| -- strict equality, which performs no\n conversions on |v1| or |v2| before comparing.\n\n This operation can fail only if an internal error occurs (e.g. OOM while\n linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS13StrictlyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn StrictlyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store |v1 == v2| to |*equal| -- loose equality, which may perform\n user-modifiable conversions on |v1| or |v2|.\n\n This operation can fail if a user-modifiable conversion fails *or* if an\n internal error occurs. (e.g. OOM while linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS12LooselyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn LooselyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Stores |SameValue(v1, v2)| to |*equal| -- using the SameValue operation\n defined in ECMAScript, initially exposed to script as |Object.is|.  SameValue\n behaves identically to strict equality, except that it equates two NaN values\n and does not equate differently-signed zeroes.  It performs no conversions on\n |v1| or |v2| before comparing.\n\n This operation can fail only if an internal error occurs (e.g. OOM while\n linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS9SameValueEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn SameValue(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                same: *mut bool,
            ) -> bool;
        }
        #[doc = " A convenience class for imitating a JS for-of loop. Typical usage:\n\n     JS::ForOfIterator it(cx);\n     if (!it.init(iterable)) {\n       return false;\n     }\n     JS::Rooted<JS::Value> val(cx);\n     while (true) {\n       bool done;\n       if (!it.next(&val, &done)) {\n         return false;\n       }\n       if (done) {\n         break;\n       }\n       if (!DoStuff(cx, val)) {\n         return false;\n       }\n     }"]
        #[repr(C)]
        pub struct ForOfIterator {
            pub cx_: *mut root::JSContext,
            pub iterator: root::JS::Rooted<*mut root::JSObject>,
            pub nextMethod: root::JS::Rooted<root::JS::Value>,
            pub index: u32,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ForOfIterator_NonIterableBehavior {
            ThrowOnNonIterable = 0,
            AllowNonIterable = 1,
        }
        pub const ForOfIterator_NOT_ARRAY: u32 = 4294967295;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ForOfIterator"][::std::mem::size_of::<ForOfIterator>() - 64usize];
            ["Alignment of ForOfIterator"][::std::mem::align_of::<ForOfIterator>() - 8usize];
            ["Offset of field: ForOfIterator::cx_"]
                [::std::mem::offset_of!(ForOfIterator, cx_) - 0usize];
            ["Offset of field: ForOfIterator::iterator"]
                [::std::mem::offset_of!(ForOfIterator, iterator) - 8usize];
            ["Offset of field: ForOfIterator::nextMethod"]
                [::std::mem::offset_of!(ForOfIterator, nextMethod) - 32usize];
            ["Offset of field: ForOfIterator::index"]
                [::std::mem::offset_of!(ForOfIterator, index) - 56usize];
        };
        #[doc = " Span - slices for C++\n\n Span implements Rust's slice concept for C++. It's called \"Span\" instead of\n \"Slice\" to follow the naming used in C++ Core Guidelines.\n\n A Span wraps a pointer and a length that identify a non-owning view to a\n contiguous block of memory of objects of the same type. Various types,\n including (pre-decay) C arrays, XPCOM strings, nsTArray, mozilla::Array,\n mozilla::Range and contiguous standard-library containers, auto-convert\n into Spans when attempting to pass them as arguments to methods that take\n Spans. (Span itself autoconverts into mozilla::Range.)\n\n Like Rust's slices, Span provides safety against out-of-bounds access by\n performing run-time bound checks. However, unlike Rust's slices, Span\n cannot provide safety against use-after-free.\n\n (Note: Span is like Rust's slice only conceptually. Due to the lack of\n ABI guarantees, you should still decompose spans/slices to raw pointer\n and length parts when crossing the FFI. The Elements() and data() methods\n are guaranteed to return a non-null pointer even for zero-length spans,\n so the pointer can be used as a raw part of a Rust slice without further\n checks.)\n\n In addition to having constructors (with the support of deduction guides)\n that take various well-known types, a Span for an arbitrary type can be\n constructed from a pointer and a length or a pointer and another pointer\n pointing just past the last element.\n\n A Span<const char> or Span<const char16_t> can be obtained for const char*\n or const char16_t pointing to a zero-terminated string using the\n MakeStringSpan() function (which treats a nullptr argument equivalently\n to the empty string). Corresponding implicit constructor does not exist\n in order to avoid accidental construction in cases where const char* or\n const char16_t* do not point to a zero-terminated string.\n\n Span has methods that follow the Mozilla naming style and methods that\n don't. The methods that follow the Mozilla naming style are meant to be\n used directly from Mozilla code. The methods that don't are meant for\n integration with C++11 range-based loops and with meta-programming that\n expects the same methods that are found on the standard-library\n containers. For example, to decompose a Span into its parts in Mozilla\n code, use Elements() and Length() (as with nsTArray) instead of data()\n and size() (as with std::vector).\n\n The pointer and length wrapped by a Span cannot be changed after a Span has\n been created. When new values are required, simply create a new Span. Span\n has a method called Subspan() that works analogously to the Substring()\n method of XPCOM strings taking a start index and an optional length. As a\n Mozilla extension (relative to Microsoft's gsl::span that mozilla::Span is\n based on), Span has methods From(start), To(end) and FromTo(start, end)\n that correspond to Rust's &slice[start..], &slice[..end] and\n &slice[start..end], respectively. (That is, the end index is the index of\n the first element not to be included in the new subspan.)\n\n When indicating a Span that's only read from, const goes inside the type\n parameter. Don't put const in front of Span. That is:\n size_t ReadsFromOneSpanAndWritesToAnother(Span<const uint8_t> aReadFrom,\n                                           Span<uint8_t> aWrittenTo);\n\n Any Span<const T> can be viewed as Span<const uint8_t> using the function\n AsBytes(). Any Span<T> can be viewed as Span<uint8_t> using the function\n AsWritableBytes().\n\n Note that iterators from different Span instances are uncomparable, even if\n they refer to the same memory. This also applies to any spans derived via\n Subspan etc."]
        pub type SelfHostedCache = root::__BindgenOpaqueArray<u64, 2usize>;
        pub type SelfHostedWriter = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::SelfHostedCache,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18InitSelfHostedCodeEP9JSContextN7mozilla4SpanIKhLm18446744073709551615EEEPFbS1_S5_E"]
            pub fn InitSelfHostedCode(
                cx: *mut root::JSContext,
                cache: root::JS::SelfHostedCache,
                writer: root::JS::SelfHostedWriter,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17DisableJitBackendEv"]
            pub fn DisableJitBackend();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13SetAVXEnabledEb"]
            pub fn SetAVXEnabled(enabled: bool);
        }
        extern "C" {
            #[doc = " An API akin to JS_Stringify but with the goal of not having observable\n side-effects when the stringification is performed.  This means it does not\n allow a replacer or a custom space and has the following constraints on its\n input:\n\n 1) The input must be a plain object or array, not an abitrary value.\n 2) Every value in the graph reached by the algorithm starting with this\n    object must be one of the following: null, undefined, a string (NOT a\n    string object!), a boolean, a finite number (i.e. no NaN or Infinity or\n    -Infinity), a plain object with no accessor properties, or an Array with\n    no holes.\n\n The actual behavior differs from JS_Stringify only in asserting the above and\n NOT attempting to get the \"toJSON\" property from things, since that could\n clearly have side-effects."]
            #[link_name = "\u{1}_ZN2JS17ToJSONMaybeSafelyEP9JSContextNS_6HandleIP8JSObjectEEPFbPKDsjPvES8_"]
            pub fn ToJSONMaybeSafely(
                cx: *mut root::JSContext,
                input: root::JS::Handle<*mut root::JSObject>,
                callback: root::JSONWriteCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Performs the JSON.stringify operation, as specified by ECMAScript, except\n writing stringified data by one call of |callback|, passing |data| as\n argument.\n\n In cases where JSON.stringify would return undefined, this function does not\n call |callback| at all."]
            #[link_name = "\u{1}_ZN2JS6ToJSONEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEES4_PFbPKDsjPvESA_"]
            pub fn ToJSON(
                cx: *mut root::JSContext,
                value: root::JS::Handle<root::JS::Value>,
                replacer: root::JS::Handle<*mut root::JSObject>,
                space: root::JS::Handle<root::JS::Value>,
                callback: root::JSONWriteCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given text is valid JSON."]
            #[link_name = "\u{1}_ZN2JS11IsValidJSONEPKhj"]
            pub fn IsValidJSON(chars: *const root::JS::Latin1Char, len: u32) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11IsValidJSONEPKDsj"]
            pub fn IsValidJSON1(chars: *const u16, len: u32) -> bool;
        }
        #[repr(C)]
        pub struct JSONParseHandler__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Handler with callbacks for JS::ParseJSONWithHandler.\n\n Each method is called during parsing the JSON string. If the method returns\n true, the parsing keeps going.  If the method returns false, the parsing\n stops and fails.\n\n The error method is called when syntax error happens while parsing the input.\n This method is not called when handler's method returns false."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JSONParseHandler {
            pub vtable_: *const JSONParseHandler__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JSONParseHandler"][::std::mem::size_of::<JSONParseHandler>() - 8usize];
            ["Alignment of JSONParseHandler"][::std::mem::align_of::<JSONParseHandler>() - 8usize];
        };
        extern "C" {
            #[doc = " Performs the JSON.parse operation as specified by ECMAScript, and call\n callbacks defined by the handler."]
            #[link_name = "\u{1}_ZN2JS20ParseJSONWithHandlerEPKhjPNS_16JSONParseHandlerE"]
            pub fn ParseJSONWithHandler(
                chars: *const root::JS::Latin1Char,
                len: u32,
                handler: *mut root::JS::JSONParseHandler,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20ParseJSONWithHandlerEPKDsjPNS_16JSONParseHandlerE"]
            pub fn ParseJSONWithHandler1(
                chars: *const u16,
                len: u32,
                handler: *mut root::JS::JSONParseHandler,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TabSizes {
            pub objects_: usize,
            pub strings_: usize,
            pub private_: usize,
            pub other_: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TabSizes_Kind {
            Objects = 0,
            Strings = 1,
            Private = 2,
            Other = 3,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TabSizes"][::std::mem::size_of::<TabSizes>() - 32usize];
            ["Alignment of TabSizes"][::std::mem::align_of::<TabSizes>() - 8usize];
            ["Offset of field: TabSizes::objects_"]
                [::std::mem::offset_of!(TabSizes, objects_) - 0usize];
            ["Offset of field: TabSizes::strings_"]
                [::std::mem::offset_of!(TabSizes, strings_) - 8usize];
            ["Offset of field: TabSizes::private_"]
                [::std::mem::offset_of!(TabSizes, private_) - 16usize];
            ["Offset of field: TabSizes::other_"]
                [::std::mem::offset_of!(TabSizes, other_) - 24usize];
        };
        #[doc = " These are the measurements used by Servo."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ServoSizes {
            pub gcHeapUsed: usize,
            pub gcHeapUnused: usize,
            pub gcHeapAdmin: usize,
            pub gcHeapDecommitted: usize,
            pub mallocHeap: usize,
            pub nonHeap: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ServoSizes_Kind {
            GCHeapUsed = 0,
            GCHeapUnused = 1,
            GCHeapAdmin = 2,
            GCHeapDecommitted = 3,
            MallocHeap = 4,
            NonHeap = 5,
            Ignore = 6,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ServoSizes"][::std::mem::size_of::<ServoSizes>() - 48usize];
            ["Alignment of ServoSizes"][::std::mem::align_of::<ServoSizes>() - 8usize];
            ["Offset of field: ServoSizes::gcHeapUsed"]
                [::std::mem::offset_of!(ServoSizes, gcHeapUsed) - 0usize];
            ["Offset of field: ServoSizes::gcHeapUnused"]
                [::std::mem::offset_of!(ServoSizes, gcHeapUnused) - 8usize];
            ["Offset of field: ServoSizes::gcHeapAdmin"]
                [::std::mem::offset_of!(ServoSizes, gcHeapAdmin) - 16usize];
            ["Offset of field: ServoSizes::gcHeapDecommitted"]
                [::std::mem::offset_of!(ServoSizes, gcHeapDecommitted) - 24usize];
            ["Offset of field: ServoSizes::mallocHeap"]
                [::std::mem::offset_of!(ServoSizes, mallocHeap) - 32usize];
            ["Offset of field: ServoSizes::nonHeap"]
                [::std::mem::offset_of!(ServoSizes, nonHeap) - 40usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClassInfo {
            pub objectsGCHeap: usize,
            pub objectsMallocHeapSlots: usize,
            pub objectsMallocHeapElementsNormal: usize,
            pub objectsMallocHeapElementsAsmJS: usize,
            pub objectsMallocHeapGlobalData: usize,
            pub objectsMallocHeapMisc: usize,
            pub objectsNonHeapElementsNormal: usize,
            pub objectsNonHeapElementsShared: usize,
            pub objectsNonHeapElementsWasm: usize,
            pub objectsNonHeapElementsWasmShared: usize,
            pub objectsNonHeapCodeWasm: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ClassInfo"][::std::mem::size_of::<ClassInfo>() - 88usize];
            ["Alignment of ClassInfo"][::std::mem::align_of::<ClassInfo>() - 8usize];
            ["Offset of field: ClassInfo::objectsGCHeap"]
                [::std::mem::offset_of!(ClassInfo, objectsGCHeap) - 0usize];
            ["Offset of field: ClassInfo::objectsMallocHeapSlots"]
                [::std::mem::offset_of!(ClassInfo, objectsMallocHeapSlots) - 8usize];
            ["Offset of field: ClassInfo::objectsMallocHeapElementsNormal"]
                [::std::mem::offset_of!(ClassInfo, objectsMallocHeapElementsNormal) - 16usize];
            ["Offset of field: ClassInfo::objectsMallocHeapElementsAsmJS"]
                [::std::mem::offset_of!(ClassInfo, objectsMallocHeapElementsAsmJS) - 24usize];
            ["Offset of field: ClassInfo::objectsMallocHeapGlobalData"]
                [::std::mem::offset_of!(ClassInfo, objectsMallocHeapGlobalData) - 32usize];
            ["Offset of field: ClassInfo::objectsMallocHeapMisc"]
                [::std::mem::offset_of!(ClassInfo, objectsMallocHeapMisc) - 40usize];
            ["Offset of field: ClassInfo::objectsNonHeapElementsNormal"]
                [::std::mem::offset_of!(ClassInfo, objectsNonHeapElementsNormal) - 48usize];
            ["Offset of field: ClassInfo::objectsNonHeapElementsShared"]
                [::std::mem::offset_of!(ClassInfo, objectsNonHeapElementsShared) - 56usize];
            ["Offset of field: ClassInfo::objectsNonHeapElementsWasm"]
                [::std::mem::offset_of!(ClassInfo, objectsNonHeapElementsWasm) - 64usize];
            ["Offset of field: ClassInfo::objectsNonHeapElementsWasmShared"]
                [::std::mem::offset_of!(ClassInfo, objectsNonHeapElementsWasmShared) - 72usize];
            ["Offset of field: ClassInfo::objectsNonHeapCodeWasm"]
                [::std::mem::offset_of!(ClassInfo, objectsNonHeapCodeWasm) - 80usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ShapeInfo {
            pub shapesGCHeapShared: usize,
            pub shapesGCHeapDict: usize,
            pub shapesGCHeapBase: usize,
            pub shapesMallocHeapCache: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ShapeInfo"][::std::mem::size_of::<ShapeInfo>() - 32usize];
            ["Alignment of ShapeInfo"][::std::mem::align_of::<ShapeInfo>() - 8usize];
            ["Offset of field: ShapeInfo::shapesGCHeapShared"]
                [::std::mem::offset_of!(ShapeInfo, shapesGCHeapShared) - 0usize];
            ["Offset of field: ShapeInfo::shapesGCHeapDict"]
                [::std::mem::offset_of!(ShapeInfo, shapesGCHeapDict) - 8usize];
            ["Offset of field: ShapeInfo::shapesGCHeapBase"]
                [::std::mem::offset_of!(ShapeInfo, shapesGCHeapBase) - 16usize];
            ["Offset of field: ShapeInfo::shapesMallocHeapCache"]
                [::std::mem::offset_of!(ShapeInfo, shapesMallocHeapCache) - 24usize];
        };
        #[doc = " Holds data about a notable class (one whose combined object and shape\n instances use more than a certain amount of memory) so we can report it\n individually.\n\n The only difference between this class and ClassInfo is that this class\n holds a copy of the filename."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotableClassInfo {
            pub _base: root::JS::ClassInfo,
            pub className_: root::JS::UniqueChars,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of NotableClassInfo"][::std::mem::size_of::<NotableClassInfo>() - 96usize];
            ["Alignment of NotableClassInfo"][::std::mem::align_of::<NotableClassInfo>() - 8usize];
            ["Offset of field: NotableClassInfo::className_"]
                [::std::mem::offset_of!(NotableClassInfo, className_) - 88usize];
        };
        #[doc = " Data for tracking JIT-code memory usage."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CodeSizes {
            pub ion: usize,
            pub baseline: usize,
            pub regexp: usize,
            pub other: usize,
            pub unused: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CodeSizes"][::std::mem::size_of::<CodeSizes>() - 40usize];
            ["Alignment of CodeSizes"][::std::mem::align_of::<CodeSizes>() - 8usize];
            ["Offset of field: CodeSizes::ion"][::std::mem::offset_of!(CodeSizes, ion) - 0usize];
            ["Offset of field: CodeSizes::baseline"]
                [::std::mem::offset_of!(CodeSizes, baseline) - 8usize];
            ["Offset of field: CodeSizes::regexp"]
                [::std::mem::offset_of!(CodeSizes, regexp) - 16usize];
            ["Offset of field: CodeSizes::other"]
                [::std::mem::offset_of!(CodeSizes, other) - 24usize];
            ["Offset of field: CodeSizes::unused"]
                [::std::mem::offset_of!(CodeSizes, unused) - 32usize];
        };
        #[doc = " Data for tracking GC memory usage."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCSizes {
            pub marker: usize,
            pub nurseryCommitted: usize,
            pub nurseryMallocedBuffers: usize,
            pub nurseryMallocedBlockCache: usize,
            pub nurseryTrailerBlockSets: usize,
            pub storeBufferVals: usize,
            pub storeBufferCells: usize,
            pub storeBufferSlots: usize,
            pub storeBufferWasmAnyRefs: usize,
            pub storeBufferWholeCells: usize,
            pub storeBufferGenerics: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of GCSizes"][::std::mem::size_of::<GCSizes>() - 88usize];
            ["Alignment of GCSizes"][::std::mem::align_of::<GCSizes>() - 8usize];
            ["Offset of field: GCSizes::marker"][::std::mem::offset_of!(GCSizes, marker) - 0usize];
            ["Offset of field: GCSizes::nurseryCommitted"]
                [::std::mem::offset_of!(GCSizes, nurseryCommitted) - 8usize];
            ["Offset of field: GCSizes::nurseryMallocedBuffers"]
                [::std::mem::offset_of!(GCSizes, nurseryMallocedBuffers) - 16usize];
            ["Offset of field: GCSizes::nurseryMallocedBlockCache"]
                [::std::mem::offset_of!(GCSizes, nurseryMallocedBlockCache) - 24usize];
            ["Offset of field: GCSizes::nurseryTrailerBlockSets"]
                [::std::mem::offset_of!(GCSizes, nurseryTrailerBlockSets) - 32usize];
            ["Offset of field: GCSizes::storeBufferVals"]
                [::std::mem::offset_of!(GCSizes, storeBufferVals) - 40usize];
            ["Offset of field: GCSizes::storeBufferCells"]
                [::std::mem::offset_of!(GCSizes, storeBufferCells) - 48usize];
            ["Offset of field: GCSizes::storeBufferSlots"]
                [::std::mem::offset_of!(GCSizes, storeBufferSlots) - 56usize];
            ["Offset of field: GCSizes::storeBufferWasmAnyRefs"]
                [::std::mem::offset_of!(GCSizes, storeBufferWasmAnyRefs) - 64usize];
            ["Offset of field: GCSizes::storeBufferWholeCells"]
                [::std::mem::offset_of!(GCSizes, storeBufferWholeCells) - 72usize];
            ["Offset of field: GCSizes::storeBufferGenerics"]
                [::std::mem::offset_of!(GCSizes, storeBufferGenerics) - 80usize];
        };
        #[doc = " This class holds information about the memory taken up by identical copies of\n a particular string.  Multiple JSStrings may have their sizes aggregated\n together into one StringInfo object.  Note that two strings with identical\n chars will not be aggregated together if one is a short string and the other\n is not."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StringInfo {
            pub gcHeapLatin1: usize,
            pub gcHeapTwoByte: usize,
            pub mallocHeapLatin1: usize,
            pub mallocHeapTwoByte: usize,
            pub numCopies: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of StringInfo"][::std::mem::size_of::<StringInfo>() - 40usize];
            ["Alignment of StringInfo"][::std::mem::align_of::<StringInfo>() - 8usize];
            ["Offset of field: StringInfo::gcHeapLatin1"]
                [::std::mem::offset_of!(StringInfo, gcHeapLatin1) - 0usize];
            ["Offset of field: StringInfo::gcHeapTwoByte"]
                [::std::mem::offset_of!(StringInfo, gcHeapTwoByte) - 8usize];
            ["Offset of field: StringInfo::mallocHeapLatin1"]
                [::std::mem::offset_of!(StringInfo, mallocHeapLatin1) - 16usize];
            ["Offset of field: StringInfo::mallocHeapTwoByte"]
                [::std::mem::offset_of!(StringInfo, mallocHeapTwoByte) - 24usize];
            ["Offset of field: StringInfo::numCopies"]
                [::std::mem::offset_of!(StringInfo, numCopies) - 32usize];
        };
        #[doc = " Holds data about a notable string (one which, counting all duplicates, uses\n more than a certain amount of memory) so we can report it individually.\n\n The only difference between this class and StringInfo is that\n NotableStringInfo holds a copy of some or all of the string's chars."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotableStringInfo {
            pub _base: root::JS::StringInfo,
            pub buffer: root::JS::UniqueChars,
            pub length: usize,
        }
        pub const NotableStringInfo_MAX_SAVED_CHARS: usize = 1024;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of NotableStringInfo"][::std::mem::size_of::<NotableStringInfo>() - 56usize];
            ["Alignment of NotableStringInfo"]
                [::std::mem::align_of::<NotableStringInfo>() - 8usize];
            ["Offset of field: NotableStringInfo::buffer"]
                [::std::mem::offset_of!(NotableStringInfo, buffer) - 40usize];
            ["Offset of field: NotableStringInfo::length"]
                [::std::mem::offset_of!(NotableStringInfo, length) - 48usize];
        };
        #[doc = " This class holds information about the memory taken up by script sources\n from a particular file."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ScriptSourceInfo {
            pub misc: usize,
            pub numScripts: u32,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ScriptSourceInfo"][::std::mem::size_of::<ScriptSourceInfo>() - 16usize];
            ["Alignment of ScriptSourceInfo"][::std::mem::align_of::<ScriptSourceInfo>() - 8usize];
            ["Offset of field: ScriptSourceInfo::misc"]
                [::std::mem::offset_of!(ScriptSourceInfo, misc) - 0usize];
            ["Offset of field: ScriptSourceInfo::numScripts"]
                [::std::mem::offset_of!(ScriptSourceInfo, numScripts) - 8usize];
        };
        #[doc = " Holds data about a notable script source file (one whose combined\n script sources use more than a certain amount of memory) so we can report it\n individually.\n\n The only difference between this class and ScriptSourceInfo is that this\n class holds a copy of the filename."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotableScriptSourceInfo {
            pub _base: root::JS::ScriptSourceInfo,
            pub filename_: root::JS::UniqueChars,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of NotableScriptSourceInfo"]
                [::std::mem::size_of::<NotableScriptSourceInfo>() - 24usize];
            ["Alignment of NotableScriptSourceInfo"]
                [::std::mem::align_of::<NotableScriptSourceInfo>() - 8usize];
            ["Offset of field: NotableScriptSourceInfo::filename_"]
                [::std::mem::offset_of!(NotableScriptSourceInfo, filename_) - 16usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HelperThreadStats {
            pub stateData: usize,
            pub ionCompileTask: usize,
            pub wasmCompile: usize,
            pub contexts: usize,
            pub idleThreadCount: ::std::os::raw::c_uint,
            pub activeThreadCount: ::std::os::raw::c_uint,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of HelperThreadStats"][::std::mem::size_of::<HelperThreadStats>() - 40usize];
            ["Alignment of HelperThreadStats"]
                [::std::mem::align_of::<HelperThreadStats>() - 8usize];
            ["Offset of field: HelperThreadStats::stateData"]
                [::std::mem::offset_of!(HelperThreadStats, stateData) - 0usize];
            ["Offset of field: HelperThreadStats::ionCompileTask"]
                [::std::mem::offset_of!(HelperThreadStats, ionCompileTask) - 8usize];
            ["Offset of field: HelperThreadStats::wasmCompile"]
                [::std::mem::offset_of!(HelperThreadStats, wasmCompile) - 16usize];
            ["Offset of field: HelperThreadStats::contexts"]
                [::std::mem::offset_of!(HelperThreadStats, contexts) - 24usize];
            ["Offset of field: HelperThreadStats::idleThreadCount"]
                [::std::mem::offset_of!(HelperThreadStats, idleThreadCount) - 32usize];
            ["Offset of field: HelperThreadStats::activeThreadCount"]
                [::std::mem::offset_of!(HelperThreadStats, activeThreadCount) - 36usize];
        };
        #[doc = " Measurements that not associated with any individual runtime."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GlobalStats {
            pub helperThread: root::JS::HelperThreadStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of GlobalStats"][::std::mem::size_of::<GlobalStats>() - 48usize];
            ["Alignment of GlobalStats"][::std::mem::align_of::<GlobalStats>() - 8usize];
            ["Offset of field: GlobalStats::helperThread"]
                [::std::mem::offset_of!(GlobalStats, helperThread) - 0usize];
            ["Offset of field: GlobalStats::mallocSizeOf_"]
                [::std::mem::offset_of!(GlobalStats, mallocSizeOf_) - 40usize];
        };
        #[doc = " These measurements relate directly to the JSRuntime, and not to zones,\n compartments, and realms within it."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RuntimeSizes {
            pub object: usize,
            pub atomsTable: usize,
            pub atomsMarkBitmaps: usize,
            pub selfHostStencil: usize,
            pub contexts: usize,
            pub temporary: usize,
            pub interpreterStack: usize,
            pub sharedImmutableStringsCache: usize,
            pub sharedIntlData: usize,
            pub uncompressedSourceCache: usize,
            pub scriptData: usize,
            pub wasmRuntime: usize,
            pub wasmGuardPages: usize,
            pub jitLazyLink: usize,
            pub scriptSourceInfo: root::JS::ScriptSourceInfo,
            pub gc: root::JS::GCSizes,
            pub allScriptSources: root::__BindgenOpaqueArray<u64, 4usize>,
            pub notableScriptSources: root::__BindgenOpaqueArray<u64, 3usize>,
        }
        pub type RuntimeSizes_ScriptSourcesHashMap = root::__BindgenOpaqueArray<u64, 3usize>;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RuntimeSizes"][::std::mem::size_of::<RuntimeSizes>() - 272usize];
            ["Alignment of RuntimeSizes"][::std::mem::align_of::<RuntimeSizes>() - 8usize];
            ["Offset of field: RuntimeSizes::object"]
                [::std::mem::offset_of!(RuntimeSizes, object) - 0usize];
            ["Offset of field: RuntimeSizes::atomsTable"]
                [::std::mem::offset_of!(RuntimeSizes, atomsTable) - 8usize];
            ["Offset of field: RuntimeSizes::atomsMarkBitmaps"]
                [::std::mem::offset_of!(RuntimeSizes, atomsMarkBitmaps) - 16usize];
            ["Offset of field: RuntimeSizes::selfHostStencil"]
                [::std::mem::offset_of!(RuntimeSizes, selfHostStencil) - 24usize];
            ["Offset of field: RuntimeSizes::contexts"]
                [::std::mem::offset_of!(RuntimeSizes, contexts) - 32usize];
            ["Offset of field: RuntimeSizes::temporary"]
                [::std::mem::offset_of!(RuntimeSizes, temporary) - 40usize];
            ["Offset of field: RuntimeSizes::interpreterStack"]
                [::std::mem::offset_of!(RuntimeSizes, interpreterStack) - 48usize];
            ["Offset of field: RuntimeSizes::sharedImmutableStringsCache"]
                [::std::mem::offset_of!(RuntimeSizes, sharedImmutableStringsCache) - 56usize];
            ["Offset of field: RuntimeSizes::sharedIntlData"]
                [::std::mem::offset_of!(RuntimeSizes, sharedIntlData) - 64usize];
            ["Offset of field: RuntimeSizes::uncompressedSourceCache"]
                [::std::mem::offset_of!(RuntimeSizes, uncompressedSourceCache) - 72usize];
            ["Offset of field: RuntimeSizes::scriptData"]
                [::std::mem::offset_of!(RuntimeSizes, scriptData) - 80usize];
            ["Offset of field: RuntimeSizes::wasmRuntime"]
                [::std::mem::offset_of!(RuntimeSizes, wasmRuntime) - 88usize];
            ["Offset of field: RuntimeSizes::wasmGuardPages"]
                [::std::mem::offset_of!(RuntimeSizes, wasmGuardPages) - 96usize];
            ["Offset of field: RuntimeSizes::jitLazyLink"]
                [::std::mem::offset_of!(RuntimeSizes, jitLazyLink) - 104usize];
            ["Offset of field: RuntimeSizes::scriptSourceInfo"]
                [::std::mem::offset_of!(RuntimeSizes, scriptSourceInfo) - 112usize];
            ["Offset of field: RuntimeSizes::gc"]
                [::std::mem::offset_of!(RuntimeSizes, gc) - 128usize];
            ["Offset of field: RuntimeSizes::allScriptSources"]
                [::std::mem::offset_of!(RuntimeSizes, allScriptSources) - 216usize];
            ["Offset of field: RuntimeSizes::notableScriptSources"]
                [::std::mem::offset_of!(RuntimeSizes, notableScriptSources) - 248usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UnusedGCThingSizes {
            pub object: usize,
            pub script: usize,
            pub shape: usize,
            pub baseShape: usize,
            pub getterSetter: usize,
            pub propMap: usize,
            pub string: usize,
            pub symbol: usize,
            pub bigInt: usize,
            pub jitcode: usize,
            pub scope: usize,
            pub regExpShared: usize,
            pub smallBuffer: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of UnusedGCThingSizes"][::std::mem::size_of::<UnusedGCThingSizes>() - 104usize];
            ["Alignment of UnusedGCThingSizes"]
                [::std::mem::align_of::<UnusedGCThingSizes>() - 8usize];
            ["Offset of field: UnusedGCThingSizes::object"]
                [::std::mem::offset_of!(UnusedGCThingSizes, object) - 0usize];
            ["Offset of field: UnusedGCThingSizes::script"]
                [::std::mem::offset_of!(UnusedGCThingSizes, script) - 8usize];
            ["Offset of field: UnusedGCThingSizes::shape"]
                [::std::mem::offset_of!(UnusedGCThingSizes, shape) - 16usize];
            ["Offset of field: UnusedGCThingSizes::baseShape"]
                [::std::mem::offset_of!(UnusedGCThingSizes, baseShape) - 24usize];
            ["Offset of field: UnusedGCThingSizes::getterSetter"]
                [::std::mem::offset_of!(UnusedGCThingSizes, getterSetter) - 32usize];
            ["Offset of field: UnusedGCThingSizes::propMap"]
                [::std::mem::offset_of!(UnusedGCThingSizes, propMap) - 40usize];
            ["Offset of field: UnusedGCThingSizes::string"]
                [::std::mem::offset_of!(UnusedGCThingSizes, string) - 48usize];
            ["Offset of field: UnusedGCThingSizes::symbol"]
                [::std::mem::offset_of!(UnusedGCThingSizes, symbol) - 56usize];
            ["Offset of field: UnusedGCThingSizes::bigInt"]
                [::std::mem::offset_of!(UnusedGCThingSizes, bigInt) - 64usize];
            ["Offset of field: UnusedGCThingSizes::jitcode"]
                [::std::mem::offset_of!(UnusedGCThingSizes, jitcode) - 72usize];
            ["Offset of field: UnusedGCThingSizes::scope"]
                [::std::mem::offset_of!(UnusedGCThingSizes, scope) - 80usize];
            ["Offset of field: UnusedGCThingSizes::regExpShared"]
                [::std::mem::offset_of!(UnusedGCThingSizes, regExpShared) - 88usize];
            ["Offset of field: UnusedGCThingSizes::smallBuffer"]
                [::std::mem::offset_of!(UnusedGCThingSizes, smallBuffer) - 96usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCBufferStats {
            pub usedBytes: usize,
            pub freeBytes: usize,
            pub adminBytes: usize,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of GCBufferStats"][::std::mem::size_of::<GCBufferStats>() - 24usize];
            ["Alignment of GCBufferStats"][::std::mem::align_of::<GCBufferStats>() - 8usize];
            ["Offset of field: GCBufferStats::usedBytes"]
                [::std::mem::offset_of!(GCBufferStats, usedBytes) - 0usize];
            ["Offset of field: GCBufferStats::freeBytes"]
                [::std::mem::offset_of!(GCBufferStats, freeBytes) - 8usize];
            ["Offset of field: GCBufferStats::adminBytes"]
                [::std::mem::offset_of!(GCBufferStats, adminBytes) - 16usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ZoneStats {
            pub symbolsGCHeap: usize,
            pub bigIntsGCHeap: usize,
            pub bigIntsMallocHeap: usize,
            pub gcHeapArenaAdmin: usize,
            pub jitCodesGCHeap: usize,
            pub getterSettersGCHeap: usize,
            pub compactPropMapsGCHeap: usize,
            pub normalPropMapsGCHeap: usize,
            pub dictPropMapsGCHeap: usize,
            pub propMapChildren: usize,
            pub propMapTables: usize,
            pub scopesGCHeap: usize,
            pub scopesMallocHeap: usize,
            pub regExpSharedsGCHeap: usize,
            pub regExpSharedsMallocHeap: usize,
            pub smallBuffersGCHeap: usize,
            pub zoneObject: usize,
            pub regexpZone: usize,
            pub jitZone: usize,
            pub cacheIRStubs: usize,
            pub uniqueIdMap: usize,
            pub initialPropMapTable: usize,
            pub shapeTables: usize,
            pub compartmentObjects: usize,
            pub crossCompartmentWrappersTables: usize,
            pub compartmentsPrivateData: usize,
            pub scriptCountsMap: usize,
            pub gcBuffers: root::JS::GCBufferStats,
            pub unusedGCThings: root::JS::UnusedGCThingSizes,
            pub stringInfo: root::JS::StringInfo,
            pub shapeInfo: root::JS::ShapeInfo,
            pub code: root::JS::CodeSizes,
            pub extra: *mut ::std::os::raw::c_void,
            pub allStrings: root::__BindgenOpaqueArray<u64, 4usize>,
            pub notableStrings: root::__BindgenOpaqueArray<u64, 3usize>,
            pub isTotals: bool,
        }
        pub type ZoneStats_StringsHashMap = root::__BindgenOpaqueArray<u64, 3usize>;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ZoneStats"][::std::mem::size_of::<ZoneStats>() - 528usize];
            ["Alignment of ZoneStats"][::std::mem::align_of::<ZoneStats>() - 8usize];
            ["Offset of field: ZoneStats::symbolsGCHeap"]
                [::std::mem::offset_of!(ZoneStats, symbolsGCHeap) - 0usize];
            ["Offset of field: ZoneStats::bigIntsGCHeap"]
                [::std::mem::offset_of!(ZoneStats, bigIntsGCHeap) - 8usize];
            ["Offset of field: ZoneStats::bigIntsMallocHeap"]
                [::std::mem::offset_of!(ZoneStats, bigIntsMallocHeap) - 16usize];
            ["Offset of field: ZoneStats::gcHeapArenaAdmin"]
                [::std::mem::offset_of!(ZoneStats, gcHeapArenaAdmin) - 24usize];
            ["Offset of field: ZoneStats::jitCodesGCHeap"]
                [::std::mem::offset_of!(ZoneStats, jitCodesGCHeap) - 32usize];
            ["Offset of field: ZoneStats::getterSettersGCHeap"]
                [::std::mem::offset_of!(ZoneStats, getterSettersGCHeap) - 40usize];
            ["Offset of field: ZoneStats::compactPropMapsGCHeap"]
                [::std::mem::offset_of!(ZoneStats, compactPropMapsGCHeap) - 48usize];
            ["Offset of field: ZoneStats::normalPropMapsGCHeap"]
                [::std::mem::offset_of!(ZoneStats, normalPropMapsGCHeap) - 56usize];
            ["Offset of field: ZoneStats::dictPropMapsGCHeap"]
                [::std::mem::offset_of!(ZoneStats, dictPropMapsGCHeap) - 64usize];
            ["Offset of field: ZoneStats::propMapChildren"]
                [::std::mem::offset_of!(ZoneStats, propMapChildren) - 72usize];
            ["Offset of field: ZoneStats::propMapTables"]
                [::std::mem::offset_of!(ZoneStats, propMapTables) - 80usize];
            ["Offset of field: ZoneStats::scopesGCHeap"]
                [::std::mem::offset_of!(ZoneStats, scopesGCHeap) - 88usize];
            ["Offset of field: ZoneStats::scopesMallocHeap"]
                [::std::mem::offset_of!(ZoneStats, scopesMallocHeap) - 96usize];
            ["Offset of field: ZoneStats::regExpSharedsGCHeap"]
                [::std::mem::offset_of!(ZoneStats, regExpSharedsGCHeap) - 104usize];
            ["Offset of field: ZoneStats::regExpSharedsMallocHeap"]
                [::std::mem::offset_of!(ZoneStats, regExpSharedsMallocHeap) - 112usize];
            ["Offset of field: ZoneStats::smallBuffersGCHeap"]
                [::std::mem::offset_of!(ZoneStats, smallBuffersGCHeap) - 120usize];
            ["Offset of field: ZoneStats::zoneObject"]
                [::std::mem::offset_of!(ZoneStats, zoneObject) - 128usize];
            ["Offset of field: ZoneStats::regexpZone"]
                [::std::mem::offset_of!(ZoneStats, regexpZone) - 136usize];
            ["Offset of field: ZoneStats::jitZone"]
                [::std::mem::offset_of!(ZoneStats, jitZone) - 144usize];
            ["Offset of field: ZoneStats::cacheIRStubs"]
                [::std::mem::offset_of!(ZoneStats, cacheIRStubs) - 152usize];
            ["Offset of field: ZoneStats::uniqueIdMap"]
                [::std::mem::offset_of!(ZoneStats, uniqueIdMap) - 160usize];
            ["Offset of field: ZoneStats::initialPropMapTable"]
                [::std::mem::offset_of!(ZoneStats, initialPropMapTable) - 168usize];
            ["Offset of field: ZoneStats::shapeTables"]
                [::std::mem::offset_of!(ZoneStats, shapeTables) - 176usize];
            ["Offset of field: ZoneStats::compartmentObjects"]
                [::std::mem::offset_of!(ZoneStats, compartmentObjects) - 184usize];
            ["Offset of field: ZoneStats::crossCompartmentWrappersTables"]
                [::std::mem::offset_of!(ZoneStats, crossCompartmentWrappersTables) - 192usize];
            ["Offset of field: ZoneStats::compartmentsPrivateData"]
                [::std::mem::offset_of!(ZoneStats, compartmentsPrivateData) - 200usize];
            ["Offset of field: ZoneStats::scriptCountsMap"]
                [::std::mem::offset_of!(ZoneStats, scriptCountsMap) - 208usize];
            ["Offset of field: ZoneStats::gcBuffers"]
                [::std::mem::offset_of!(ZoneStats, gcBuffers) - 216usize];
            ["Offset of field: ZoneStats::unusedGCThings"]
                [::std::mem::offset_of!(ZoneStats, unusedGCThings) - 240usize];
            ["Offset of field: ZoneStats::stringInfo"]
                [::std::mem::offset_of!(ZoneStats, stringInfo) - 344usize];
            ["Offset of field: ZoneStats::shapeInfo"]
                [::std::mem::offset_of!(ZoneStats, shapeInfo) - 384usize];
            ["Offset of field: ZoneStats::code"]
                [::std::mem::offset_of!(ZoneStats, code) - 416usize];
            ["Offset of field: ZoneStats::extra"]
                [::std::mem::offset_of!(ZoneStats, extra) - 456usize];
            ["Offset of field: ZoneStats::allStrings"]
                [::std::mem::offset_of!(ZoneStats, allStrings) - 464usize];
            ["Offset of field: ZoneStats::notableStrings"]
                [::std::mem::offset_of!(ZoneStats, notableStrings) - 496usize];
            ["Offset of field: ZoneStats::isTotals"]
                [::std::mem::offset_of!(ZoneStats, isTotals) - 520usize];
        };
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RealmStats {
            pub objectsPrivate: usize,
            pub scriptsGCHeap: usize,
            pub scriptsMallocHeapData: usize,
            pub baselineData: usize,
            pub allocSites: usize,
            pub ionData: usize,
            pub jitScripts: usize,
            pub realmObject: usize,
            pub realmTables: usize,
            pub innerViewsTable: usize,
            pub objectMetadataTable: usize,
            pub savedStacksSet: usize,
            pub nonSyntacticLexicalScopesTable: usize,
            pub classInfo: root::JS::ClassInfo,
            pub extra: *mut ::std::os::raw::c_void,
            pub allClasses: root::__BindgenOpaqueArray<u64, 4usize>,
            pub notableClasses: root::__BindgenOpaqueArray<u64, 3usize>,
            pub isTotals: bool,
        }
        pub type RealmStats_ClassesHashMap = root::__BindgenOpaqueArray<u64, 3usize>;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RealmStats"][::std::mem::size_of::<RealmStats>() - 264usize];
            ["Alignment of RealmStats"][::std::mem::align_of::<RealmStats>() - 8usize];
            ["Offset of field: RealmStats::objectsPrivate"]
                [::std::mem::offset_of!(RealmStats, objectsPrivate) - 0usize];
            ["Offset of field: RealmStats::scriptsGCHeap"]
                [::std::mem::offset_of!(RealmStats, scriptsGCHeap) - 8usize];
            ["Offset of field: RealmStats::scriptsMallocHeapData"]
                [::std::mem::offset_of!(RealmStats, scriptsMallocHeapData) - 16usize];
            ["Offset of field: RealmStats::baselineData"]
                [::std::mem::offset_of!(RealmStats, baselineData) - 24usize];
            ["Offset of field: RealmStats::allocSites"]
                [::std::mem::offset_of!(RealmStats, allocSites) - 32usize];
            ["Offset of field: RealmStats::ionData"]
                [::std::mem::offset_of!(RealmStats, ionData) - 40usize];
            ["Offset of field: RealmStats::jitScripts"]
                [::std::mem::offset_of!(RealmStats, jitScripts) - 48usize];
            ["Offset of field: RealmStats::realmObject"]
                [::std::mem::offset_of!(RealmStats, realmObject) - 56usize];
            ["Offset of field: RealmStats::realmTables"]
                [::std::mem::offset_of!(RealmStats, realmTables) - 64usize];
            ["Offset of field: RealmStats::innerViewsTable"]
                [::std::mem::offset_of!(RealmStats, innerViewsTable) - 72usize];
            ["Offset of field: RealmStats::objectMetadataTable"]
                [::std::mem::offset_of!(RealmStats, objectMetadataTable) - 80usize];
            ["Offset of field: RealmStats::savedStacksSet"]
                [::std::mem::offset_of!(RealmStats, savedStacksSet) - 88usize];
            ["Offset of field: RealmStats::nonSyntacticLexicalScopesTable"]
                [::std::mem::offset_of!(RealmStats, nonSyntacticLexicalScopesTable) - 96usize];
            ["Offset of field: RealmStats::classInfo"]
                [::std::mem::offset_of!(RealmStats, classInfo) - 104usize];
            ["Offset of field: RealmStats::extra"]
                [::std::mem::offset_of!(RealmStats, extra) - 192usize];
            ["Offset of field: RealmStats::allClasses"]
                [::std::mem::offset_of!(RealmStats, allClasses) - 200usize];
            ["Offset of field: RealmStats::notableClasses"]
                [::std::mem::offset_of!(RealmStats, notableClasses) - 232usize];
            ["Offset of field: RealmStats::isTotals"]
                [::std::mem::offset_of!(RealmStats, isTotals) - 256usize];
        };
        pub type RealmStatsVector = root::__BindgenOpaqueArray<u64, 3usize>;
        pub type ZoneStatsVector = root::__BindgenOpaqueArray<u64, 3usize>;
        #[repr(C)]
        pub struct RuntimeStats__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RuntimeStats {
            pub vtable_: *const RuntimeStats__bindgen_vtable,
            pub gcHeapChunkTotal: usize,
            pub gcHeapDecommittedPages: usize,
            pub gcHeapUnusedChunks: usize,
            pub gcHeapUnusedArenas: usize,
            pub gcHeapChunkAdmin: usize,
            pub gcHeapGCThings: usize,
            pub runtime: root::JS::RuntimeSizes,
            pub realmTotals: root::JS::RealmStats,
            pub zTotals: root::JS::ZoneStats,
            pub realmStatsVector: root::JS::RealmStatsVector,
            pub zoneStatsVector: root::JS::ZoneStatsVector,
            pub currZoneStats: *mut root::JS::ZoneStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RuntimeStats"][::std::mem::size_of::<RuntimeStats>() - 1184usize];
            ["Alignment of RuntimeStats"][::std::mem::align_of::<RuntimeStats>() - 8usize];
            ["Offset of field: RuntimeStats::gcHeapChunkTotal"]
                [::std::mem::offset_of!(RuntimeStats, gcHeapChunkTotal) - 8usize];
            ["Offset of field: RuntimeStats::gcHeapDecommittedPages"]
                [::std::mem::offset_of!(RuntimeStats, gcHeapDecommittedPages) - 16usize];
            ["Offset of field: RuntimeStats::gcHeapUnusedChunks"]
                [::std::mem::offset_of!(RuntimeStats, gcHeapUnusedChunks) - 24usize];
            ["Offset of field: RuntimeStats::gcHeapUnusedArenas"]
                [::std::mem::offset_of!(RuntimeStats, gcHeapUnusedArenas) - 32usize];
            ["Offset of field: RuntimeStats::gcHeapChunkAdmin"]
                [::std::mem::offset_of!(RuntimeStats, gcHeapChunkAdmin) - 40usize];
            ["Offset of field: RuntimeStats::gcHeapGCThings"]
                [::std::mem::offset_of!(RuntimeStats, gcHeapGCThings) - 48usize];
            ["Offset of field: RuntimeStats::runtime"]
                [::std::mem::offset_of!(RuntimeStats, runtime) - 56usize];
            ["Offset of field: RuntimeStats::realmTotals"]
                [::std::mem::offset_of!(RuntimeStats, realmTotals) - 328usize];
            ["Offset of field: RuntimeStats::zTotals"]
                [::std::mem::offset_of!(RuntimeStats, zTotals) - 592usize];
            ["Offset of field: RuntimeStats::realmStatsVector"]
                [::std::mem::offset_of!(RuntimeStats, realmStatsVector) - 1120usize];
            ["Offset of field: RuntimeStats::zoneStatsVector"]
                [::std::mem::offset_of!(RuntimeStats, zoneStatsVector) - 1144usize];
            ["Offset of field: RuntimeStats::currZoneStats"]
                [::std::mem::offset_of!(RuntimeStats, currZoneStats) - 1168usize];
            ["Offset of field: RuntimeStats::mallocSizeOf_"]
                [::std::mem::offset_of!(RuntimeStats, mallocSizeOf_) - 1176usize];
        };
        #[repr(C)]
        pub struct ObjectPrivateVisitor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ObjectPrivateVisitor {
            pub vtable_: *const ObjectPrivateVisitor__bindgen_vtable,
            pub getISupports_: root::JS::ObjectPrivateVisitor_GetISupportsFun,
        }
        pub type ObjectPrivateVisitor_GetISupportsFun = ::std::option::Option<
            unsafe extern "C" fn(
                obj: *mut root::JSObject,
                iface: *mut *mut root::nsISupports,
            ) -> bool,
        >;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ObjectPrivateVisitor"]
                [::std::mem::size_of::<ObjectPrivateVisitor>() - 16usize];
            ["Alignment of ObjectPrivateVisitor"]
                [::std::mem::align_of::<ObjectPrivateVisitor>() - 8usize];
            ["Offset of field: ObjectPrivateVisitor::getISupports_"]
                [::std::mem::offset_of!(ObjectPrivateVisitor, getISupports_) - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18CollectGlobalStatsEPNS_11GlobalStatsE"]
            pub fn CollectGlobalStats(gStats: *mut root::JS::GlobalStats) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19CollectRuntimeStatsEP9JSContextPNS_12RuntimeStatsEPNS_20ObjectPrivateVisitorEb"]
            pub fn CollectRuntimeStats(
                cx: *mut root::JSContext,
                rtStats: *mut root::JS::RuntimeStats,
                opv: *mut root::JS::ObjectPrivateVisitor,
                anonymize: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SystemCompartmentCountEP9JSContext"]
            pub fn SystemCompartmentCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UserCompartmentCountEP9JSContext"]
            pub fn UserCompartmentCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16SystemRealmCountEP9JSContext"]
            pub fn SystemRealmCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14UserRealmCountEP9JSContext"]
            pub fn UserRealmCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19PeakSizeOfTemporaryEPK9JSContext"]
            pub fn PeakSizeOfTemporary(cx: *const root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12AddSizeOfTabEP9JSContextNS_6HandleIP8JSObjectEEPFmPKvEPNS_20ObjectPrivateVisitorEPNS_8TabSizesE"]
            pub fn AddSizeOfTab(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::TabSizes,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14AddServoSizeOfEP9JSContextPFmPKvEPNS_20ObjectPrivateVisitorEPNS_10ServoSizesE"]
            pub fn AddServoSizeOf(
                cx: *mut root::JSContext,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::ServoSizes,
            ) -> bool;
        }
        impl root::JS::ModuleType {
            pub const Limit: root::JS::ModuleType = ModuleType::JSON;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ModuleType {
            Unknown = 0,
            JavaScript = 1,
            JSON = 2,
        }
        #[doc = " The HostResolveImportedModule hook.\n\n See: https://tc39.es/ecma262/#sec-hostresolveimportedmodule\n\n This embedding-defined hook is used to implement module loading. It is called\n to get or create a module object corresponding to |moduleRequest| occurring\n in the context of the script or module with private value\n |referencingPrivate|.\n\n The module specifier string for the request can be obtained by calling\n JS::GetModuleRequestSpecifier.\n\n The private value for a script or module is set with JS::SetScriptPrivate or\n JS::SetModulePrivate. It's assumed that the embedding can handle receiving\n either here.\n\n This hook must obey the restrictions defined in the spec:\n  - Each time the hook is called with the same arguemnts, the same module must\n    be returned.\n  - If a module cannot be created for the given arguments, an exception must\n    be thrown.\n\n This is a synchronous operation."]
        pub type ModuleResolveHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject,
        >;
        extern "C" {
            #[doc = " Get the HostResolveImportedModule hook for the runtime."]
            #[link_name = "\u{1}_ZN2JS20GetModuleResolveHookEP9JSRuntime"]
            pub fn GetModuleResolveHook(rt: *mut root::JSRuntime) -> root::JS::ModuleResolveHook;
        }
        extern "C" {
            #[doc = " Set the HostResolveImportedModule hook for the runtime to the given function."]
            #[link_name = "\u{1}_ZN2JS20SetModuleResolveHookEP9JSRuntimePFP8JSObjectP9JSContextNS_6HandleINS_5ValueEEENS6_IS3_EEE"]
            pub fn SetModuleResolveHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleResolveHook,
            );
        }
        #[doc = " The module metadata hook.\n\n See: https://tc39.es/ecma262/#sec-hostgetimportmetaproperties\n\n Populate the |metaObject| object returned when import.meta is evaluated in\n the context of the script or module with private value |privateValue|.\n\n This is based on the spec's HostGetImportMetaProperties hook but defines\n properties on the meta object directly rather than returning a list."]
        pub type ModuleMetadataHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                privateValue: root::JS::Handle<root::JS::Value>,
                metaObject: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        extern "C" {
            #[doc = " Get the hook for populating the import.meta metadata object."]
            #[link_name = "\u{1}_ZN2JS21GetModuleMetadataHookEP9JSRuntime"]
            pub fn GetModuleMetadataHook(rt: *mut root::JSRuntime) -> root::JS::ModuleMetadataHook;
        }
        extern "C" {
            #[doc = " Set the hook for populating the import.meta metadata object to the given\n function."]
            #[link_name = "\u{1}_ZN2JS21SetModuleMetadataHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSObjectEEE"]
            pub fn SetModuleMetadataHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleMetadataHook,
            );
        }
        #[doc = " The HostImportModuleDynamically hook.\n\n See https://tc39.es/ecma262/#sec-hostimportmoduledynamically\n\n Used to implement dynamic module import. Called when evaluating import()\n expressions.\n\n This starts an asynchronous operation. Some time after this hook is called\n the embedding must call JS::FinishDynamicModuleImport() passing the\n |referencingPrivate|, |moduleRequest| and |promise| arguments from the\n call. This must happen for both success and failure cases.\n\n In the meantime the embedding can take whatever steps it needs to make the\n module available. If successful, after calling FinishDynamicModuleImport()\n the module should be returned by the resolve hook when passed\n |referencingPrivate| and |moduleRequest|."]
        pub type ModuleDynamicImportHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        extern "C" {
            #[doc = " Get the HostImportModuleDynamically hook for the runtime."]
            #[link_name = "\u{1}_ZN2JS26GetModuleDynamicImportHookEP9JSRuntime"]
            pub fn GetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
            ) -> root::JS::ModuleDynamicImportHook;
        }
        extern "C" {
            #[doc = " Set the HostImportModuleDynamically hook for the runtime to the given\n function.\n\n If this hook is not set (or set to nullptr) then the JS engine will throw an\n exception if dynamic module import is attempted."]
            #[link_name = "\u{1}_ZN2JS26SetModuleDynamicImportHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSObjectEES9_E"]
            pub fn SetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleDynamicImportHook,
            );
        }
        extern "C" {
            #[doc = " This must be called after a dynamic import operation is complete.\n\n If |evaluationPromise| is rejected, the rejection reason will be used to\n complete the user's promise."]
            #[link_name = "\u{1}_ZN2JS25FinishDynamicModuleImportEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES5_S5_"]
            pub fn FinishDynamicModuleImport(
                cx: *mut root::JSContext,
                evaluationPromise: root::JS::Handle<*mut root::JSObject>,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a module in the scope of the current global\n of cx and return a source text module record."]
            #[link_name = "\u{1}_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileModule(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a module in the scope of the current global\n of cx and return a source text module record.  An error is reported if a\n UTF-8 encoding error is encountered."]
            #[link_name = "\u{1}_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileModule1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a JSON module in the scope of the current\n global of cx and return a synthetic module record."]
            #[link_name = "\u{1}_ZN2JS17CompileJsonModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileJsonModule(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a JSON module in the scope of the current\n global of cx and return a synthetic module record. An error is reported if a\n UTF-8 encoding error is encountered."]
            #[link_name = "\u{1}_ZN2JS17CompileJsonModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileJsonModule1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Set a private value associated with a source text module record."]
            #[link_name = "\u{1}_ZN2JS16SetModulePrivateEP8JSObjectRKNS_5ValueE"]
            pub fn SetModulePrivate(module: *mut root::JSObject, value: *const root::JS::Value);
        }
        extern "C" {
            #[doc = " Clear the private value associated with a source text module record.\n\n This is used during unlinking and can be called on a gray module, skipping\n the usual checks."]
            #[link_name = "\u{1}_ZN2JS18ClearModulePrivateEP8JSObject"]
            pub fn ClearModulePrivate(module: *mut root::JSObject);
        }
        extern "C" {
            #[doc = " Checks if the given module is a cyclic module."]
            #[link_name = "\u{1}_ZN2JS14IsCyclicModuleEP8JSObject"]
            pub fn IsCyclicModule(module: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10ModuleLinkEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ModuleLink(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14ModuleEvaluateEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn ModuleEvaluate(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ModuleErrorBehaviour {
            ReportModuleErrorsAsync = 0,
            ThrowModuleErrorsSync = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30ThrowOnModuleEvaluationFailureEP9JSContextNS_6HandleIP8JSObjectEENS_20ModuleErrorBehaviourE"]
            pub fn ThrowOnModuleEvaluationFailure(
                cx: *mut root::JSContext,
                evaluationPromise: root::JS::Handle<*mut root::JSObject>,
                errorBehaviour: root::JS::ModuleErrorBehaviour,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetRequestedModulesCountEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRequestedModulesCount(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSpecifierEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn GetRequestedModuleSpecifier(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                index: u32,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSourcePosEP9JSContextNS_6HandleIP8JSObjectEEjPjPNS_21ColumnNumberOneOriginE"]
            pub fn GetRequestedModuleSourcePos(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                index: u32,
                lineNumber: *mut u32,
                columnNumber: *mut root::JS::ColumnNumberOneOrigin,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22GetRequestedModuleTypeEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn GetRequestedModuleType(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                index: u32,
            ) -> root::JS::ModuleType;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetModuleScriptENS_6HandleIP8JSObjectEE"]
            pub fn GetModuleScript(
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19CreateModuleRequestEP9JSContextNS_6HandleIP8JSStringEENS_10ModuleTypeE"]
            pub fn CreateModuleRequest(
                cx: *mut root::JSContext,
                specifierArg: root::JS::Handle<*mut root::JSString>,
                moduleType: root::JS::ModuleType,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetModuleRequestSpecifierEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleRequestSpecifier(
                cx: *mut root::JSContext,
                moduleRequestArg: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetModuleRequestTypeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleRequestType(
                cx: *mut root::JSContext,
                moduleRequestArg: root::JS::Handle<*mut root::JSObject>,
            ) -> root::JS::ModuleType;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetModuleObjectENS_6HandleIP8JSScriptEE"]
            pub fn GetModuleObject(
                moduleScript: root::JS::Handle<*mut root::JSScript>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetModuleNamespaceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleNamespace(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetModuleForNamespaceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleForNamespace(
                cx: *mut root::JSContext,
                moduleNamespace: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetModuleEnvironmentEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleEnvironment(
                cx: *mut root::JSContext,
                moduleObj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22ClearModuleEnvironmentEP8JSObject"]
            pub fn ClearModuleEnvironment(moduleObj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14ModuleIsLinkedEP8JSObject"]
            pub fn ModuleIsLinked(moduleObj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Determine the ECMAScript \"class\" -- Date, String, RegExp, and all the other\n builtin object types (described in ECMAScript in terms of an objecting having\n \"an [[ArrayBufferData]] internal slot\" or similar language for other kinds of\n object -- of the provided object.\n\n If this function is passed a wrapper that can be unwrapped, the determination\n is performed on that object.  If the wrapper can't be unwrapped, and it's not\n a wrapper that prefers to treat this operation as a failure, this function\n will indicate that the object is |js::ESClass::Other|."]
            #[link_name = "\u{1}_ZN2JS15GetBuiltinClassEP9JSContextNS_6HandleIP8JSObjectEEPN2js7ESClassE"]
            pub fn GetBuiltinClass(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                cls: *mut root::js::ESClass,
            ) -> bool;
        }
        #[repr(C)]
        pub struct JobQueue__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Abstract base class for an ECMAScript Job Queue:\n https://www.ecma-international.org/ecma-262/9.0/index.html#sec-jobs-and-job-queues\n\n SpiderMonkey doesn't schedule Promise resolution jobs itself; instead, the\n embedding can provide an instance of this class SpiderMonkey can use to do\n that scheduling.\n\n The JavaScript shell includes a simple implementation adequate for running\n tests. Browsers need to augment job handling to meet their own additional\n requirements, so they can provide their own implementation."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JobQueue {
            pub vtable_: *const JobQueue__bindgen_vtable,
        }
        #[repr(C)]
        pub struct JobQueue_SavedJobQueue__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " A saved job queue, represented however the JobQueue implementation pleases.\n Use AutoDebuggerJobQueueInterruption rather than trying to construct one of\n these directly; see documentation there.\n\n Destructing an instance of this class should assert that the current queue\n is empty, and then restore the queue the instance captured."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JobQueue_SavedJobQueue {
            pub vtable_: *const JobQueue_SavedJobQueue__bindgen_vtable,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JobQueue_SavedJobQueue"]
                [::std::mem::size_of::<JobQueue_SavedJobQueue>() - 8usize];
            ["Alignment of JobQueue_SavedJobQueue"]
                [::std::mem::align_of::<JobQueue_SavedJobQueue>() - 8usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of JobQueue"][::std::mem::size_of::<JobQueue>() - 8usize];
            ["Alignment of JobQueue"][::std::mem::align_of::<JobQueue>() - 8usize];
        };
        extern "C" {
            #[doc = " Tell SpiderMonkey to use `queue` to schedule promise reactions.\n\n SpiderMonkey does not take ownership of the queue; it is the embedding's\n responsibility to clean it up after the runtime is destroyed."]
            #[link_name = "\u{1}_ZN2JS11SetJobQueueEP9JSContextPNS_8JobQueueE"]
            pub fn SetJobQueue(cx: *mut root::JSContext, queue: *mut root::JS::JobQueue);
        }
        #[doc = " [SMDOC] Protecting the debuggee's job/microtask queue from debugger activity.\n\n When the JavaScript debugger interrupts the execution of some debuggee code\n (for a breakpoint, for example), the debuggee's execution must be paused\n while the developer takes time to look at it. During this interruption, other\n tabs should remain active and usable. If the debuggee shares a main thread\n with non-debuggee tabs, that means that the thread will have to process\n non-debuggee HTML tasks and microtasks as usual, even as the debuggee's are\n on hold until the debugger lets it continue execution. (Letting debuggee\n microtasks run during the interruption would mean that, from the debuggee's\n point of view, their side effects would take place wherever the breakpoint\n was set - in general, not a place other code should ever run, and a violation\n of the run-to-completion rule.)\n\n This means that, even though the timing and ordering of microtasks is\n carefully specified by the standard - and important to preserve for\n compatibility and predictability - debugger use may, correctly, have the\n effect of reordering microtasks. During the interruption, microtasks enqueued\n by non-debuggee tabs must run immediately alongside their HTML tasks as\n usual, whereas any debuggee microtasks that were in the queue when the\n interruption began must wait for the debuggee to be continued - and thus run\n after microtasks enqueued after they were.\n\n Fortunately, this reordering is visible only at the global level: when\n implemented correctly, it is not detectable by an individual debuggee. Note\n that a debuggee should generally be a complete unit of similar-origin related\n browsing contexts. Since non-debuggee activity falls outside that unit, it\n should never be visible to the debuggee (except via mechanisms that are\n already asynchronous, like events), so the debuggee should be unable to\n detect non-debuggee microtasks running when they normally would not. As long\n as behavior *visible to the debuggee* is unaffected by the interruption, we\n have respected the spirit of the rule.\n\n Of course, even as we accept the general principle that interrupting the\n debuggee should have as little detectable effect as possible, we still permit\n the developer to do things like evaluate expressions at the console that have\n arbitrary effects on the debuggee's stateeffects that could never occur\n naturally at that point in the program. But since these are explicitly\n requested by the developer, who presumably knows what they're doing, we\n support this as best we can. If the developer evaluates an expression in the\n console that resolves a promise, it seems most natural for the promise's\n reaction microtasks to run immediately, within the interruption. This is an\n 'unnatural' time for the microtasks to run, but no more unnatural than the\n evaluation that triggered them.\n\n So the overall behavior we need is as follows:\n\n - When the debugger interrupts a debuggee, the debuggee's microtask queue\n   must be saved.\n\n - When debuggee execution resumes, the debuggee's microtask queue must be\n   restored exactly as it was when the interruption occurred.\n\n - Non-debuggee task and microtask execution must take place normally during\n   the interruption.\n\n Since each HTML task begins with an empty microtask queue, and it should not\n be possible for a task to mix debuggee and non-debuggee code, interrupting a\n debuggee should always find a microtask queue containing exclusively debuggee\n microtasks, if any. So saving and restoring the microtask queue should affect\n only the debuggee, not any non-debuggee content.\n\n AutoDebuggerJobQueueInterruption\n --------------------------------\n\n AutoDebuggerJobQueueInterruption is an RAII class, meant for use by the\n Debugger API implementation, that takes care of saving and restoring the\n queue.\n\n Constructing and initializing an instance of AutoDebuggerJobQueueInterruption\n sets aside the given JSContext's job queue, leaving the JSContext's queue\n empty. When the AutoDebuggerJobQueueInterruption instance is destroyed, it\n asserts that the JSContext's current job queue (holding jobs enqueued while\n the AutoDebuggerJobQueueInterruption was alive) is empty, and restores the\n saved queue to the JSContext.\n\n Since the Debugger API's behavior is up to us, we can specify that Debugger\n hooks begin execution with an empty job queue, and that we drain the queue\n after each hook function has run. This drain will be visible to debugger\n hooks, and makes hook calls resemble HTML tasks, with their own automatic\n microtask checkpoint. But, the drain will be invisible to the debuggee, as\n its queue is preserved across the hook invocation.\n\n To protect the debuggee's job queue, Debugger takes care to invoke callback\n functions only within the scope of an AutoDebuggerJobQueueInterruption\n instance.\n\n Why not let the hook functions themselves take care of this?\n ------------------------------------------------------------\n\n Certainly, we could leave responsibility for saving and restoring the job\n queue to the Debugger hook functions themselves.\n\n In fact, early versions of this change tried making the devtools server save\n and restore the queue explicitly, but because hooks are set and changed in\n numerous places, it was hard to be confident that every case had been\n covered, and it seemed that future changes could easily introduce new holes.\n\n Later versions of this change modified the accessor properties on the\n Debugger objects' prototypes to automatically protect the job queue when\n calling hooks, but the effect was essentially a monkeypatch applied to an API\n we defined and control, which doesn't make sense.\n\n In the end, since promises have become such a pervasive part of JavaScript\n programming, almost any imaginable use of Debugger would need to provide some\n kind of protection for the debuggee's job queue, so it makes sense to simply\n handle it once, carefully, in the implementation of Debugger itself."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoDebuggerJobQueueInterruption {
            pub cx: *mut root::JSContext,
            pub saved: u64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoDebuggerJobQueueInterruption"]
                [::std::mem::size_of::<AutoDebuggerJobQueueInterruption>() - 16usize];
            ["Alignment of AutoDebuggerJobQueueInterruption"]
                [::std::mem::align_of::<AutoDebuggerJobQueueInterruption>() - 8usize];
            ["Offset of field: AutoDebuggerJobQueueInterruption::cx"]
                [::std::mem::offset_of!(AutoDebuggerJobQueueInterruption, cx) - 0usize];
            ["Offset of field: AutoDebuggerJobQueueInterruption::saved"]
                [::std::mem::offset_of!(AutoDebuggerJobQueueInterruption, saved) - 8usize];
        };
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseRejectionHandlingState {
            Unhandled = 0,
            Handled = 1,
        }
        pub type PromiseRejectionTrackerCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                mutedErrors: bool,
                promise: root::JS::HandleObject,
                state: root::JS::PromiseRejectionHandlingState,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[doc = " Sets the callback that's invoked whenever a Promise is rejected without\n a rejection handler, and when a Promise that was previously rejected\n without a handler gets a handler attached."]
            #[link_name = "\u{1}_ZN2JS34SetPromiseRejectionTrackerCallbackEP9JSContextPFvS1_bNS_6HandleIP8JSObjectEENS_29PromiseRejectionHandlingStateEPvES7_"]
            pub fn SetPromiseRejectionTrackerCallback(
                cx: *mut root::JSContext,
                callback: root::JS::PromiseRejectionTrackerCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Inform the runtime that the job queue is empty and the embedding is going to\n execute its last promise job. The runtime may now choose to skip creating\n promise jobs for asynchronous execution and instead continue execution\n synchronously. More specifically, this optimization is used to skip the\n standard job queuing behavior for `await` operations in async functions.\n\n This function may be called before executing the last job in the job queue.\n When it was called, JobQueueMayNotBeEmpty must be called in order to restore\n the default job queuing behavior before the embedding enqueues its next job\n into the job queue."]
            #[link_name = "\u{1}_ZN2JS15JobQueueIsEmptyEP9JSContext"]
            pub fn JobQueueIsEmpty(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Inform the runtime that job queue is no longer empty. The runtime can now no\n longer skip creating promise jobs for asynchronous execution, because\n pending jobs in the job queue must be executed first to preserve the FIFO\n (first in - first out) property of the queue. This effectively undoes\n JobQueueIsEmpty and re-enables the standard job queuing behavior.\n\n This function must be called whenever enqueuing a job to the job queue when\n JobQueueIsEmpty was called previously."]
            #[link_name = "\u{1}_ZN2JS21JobQueueMayNotBeEmptyEP9JSContext"]
            pub fn JobQueueMayNotBeEmpty(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns a new instance of the Promise builtin class in the current\n compartment, with the right slot layout.\n\n The `executor` can be a `nullptr`. In that case, the only way to resolve or\n reject the returned promise is via the `JS::ResolvePromise` and\n `JS::RejectPromise` JSAPI functions."]
            #[link_name = "\u{1}_ZN2JS16NewPromiseObjectEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn NewPromiseObject(
                cx: *mut root::JSContext,
                executor: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns true if the given object is an unwrapped PromiseObject, false\n otherwise."]
            #[link_name = "\u{1}_ZN2JS15IsPromiseObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsPromiseObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns the current compartment's original Promise constructor."]
            #[link_name = "\u{1}_ZN2JS21GetPromiseConstructorEP9JSContext"]
            pub fn GetPromiseConstructor(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns the current compartment's original Promise.prototype."]
            #[link_name = "\u{1}_ZN2JS19GetPromisePrototypeEP9JSContext"]
            pub fn GetPromisePrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseState {
            Pending = 0,
            Fulfilled = 1,
            Rejected = 2,
        }
        extern "C" {
            #[doc = " Returns the given Promise's state as a JS::PromiseState enum value.\n\n Returns JS::PromiseState::Pending if the given object is a wrapper that\n can't safely be unwrapped."]
            #[link_name = "\u{1}_ZN2JS15GetPromiseStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseState(promise: root::JS::HandleObject) -> root::JS::PromiseState;
        }
        extern "C" {
            #[doc = " Returns the given Promise's process-unique ID."]
            #[link_name = "\u{1}_ZN2JS12GetPromiseIDENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseID(promise: root::JS::HandleObject) -> u64;
        }
        extern "C" {
            #[doc = " Returns whether the given promise's rejection is already handled or not.\n\n The caller must check the given promise is rejected before checking it's\n handled or not."]
            #[link_name = "\u{1}_ZN2JS19GetPromiseIsHandledENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseIsHandled(promise: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26SetSettledPromiseIsHandledEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetSettledPromiseIsHandled(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SetAnyPromiseIsHandledEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetAnyPromiseIsHandled(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns a js::SavedFrame linked list of the stack that lead to the given\n Promise's allocation."]
            #[link_name = "\u{1}_ZN2JS24GetPromiseAllocationSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseAllocationSite(promise: root::JS::HandleObject)
                -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetPromiseResolutionSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseResolutionSite(promise: root::JS::HandleObject)
                -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Calls the current compartment's original Promise.resolve on the original\n Promise constructor, with `resolutionValue` passed as an argument."]
            #[link_name = "\u{1}_ZN2JS26CallOriginalPromiseResolveEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseResolve(
                cx: *mut root::JSContext,
                resolutionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Calls the current compartment's original Promise.reject on the original\n Promise constructor, with `resolutionValue` passed as an argument."]
            #[link_name = "\u{1}_ZN2JS25CallOriginalPromiseRejectEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseReject(
                cx: *mut root::JSContext,
                rejectionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Resolves the given Promise with the given `resolutionValue`.\n\n Calls the `resolve` function that was passed to the executor function when\n the Promise was created."]
            #[link_name = "\u{1}_ZN2JS14ResolvePromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ResolvePromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                resolutionValue: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Rejects the given `promise` with the given `rejectionValue`.\n\n Calls the `reject` function that was passed to the executor function when\n the Promise was created."]
            #[link_name = "\u{1}_ZN2JS13RejectPromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn RejectPromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                rejectionValue: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a Promise with the given fulfill/reject handlers, that will be\n fulfilled/rejected with the value/reason that the promise `promise` is\n fulfilled/rejected with.\n\n This function basically acts like `promise.then(onFulfilled, onRejected)`,\n except that its behavior is unaffected by changes to `Promise`,\n `Promise[Symbol.species]`, `Promise.prototype.then`, `promise.constructor`,\n `promise.then`, and so on.\n\n This function throws if `promise` is not a Promise from this or another\n realm.\n\n This function will assert if `onFulfilled` or `onRejected` is non-null and\n also not IsCallable."]
            #[link_name = "\u{1}_ZN2JS23CallOriginalPromiseThenEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn CallOriginalPromiseThen(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Unforgeable, optimized version of the JS builtin Promise.prototype.then.\n\n Takes a Promise instance and nullable `onFulfilled`/`onRejected` callables to\n enqueue as reactions for that promise. In contrast to Promise.prototype.then,\n this doesn't create and return a new Promise instance.\n\n Throws a TypeError if `promise` isn't a Promise (or possibly a different\n error if it's a security wrapper or dead object proxy)."]
            #[link_name = "\u{1}_ZN2JS19AddPromiseReactionsEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn AddPromiseReactions(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Unforgeable, optimized version of the JS builtin Promise.prototype.then.\n\n Takes a Promise instance and nullable `onFulfilled`/`onRejected` callables to\n enqueue as reactions for that promise. In contrast to Promise.prototype.then,\n this doesn't create and return a new Promise instance.\n\n Throws a TypeError if `promise` isn't a Promise (or possibly a different\n error if it's a security wrapper or dead object proxy).\n\n If `onRejected` is null and `promise` is rejected, this function -- unlike\n the function above -- will not report an unhandled rejection."]
            #[link_name = "\u{1}_ZN2JS45AddPromiseReactionsIgnoringUnhandledRejectionEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn AddPromiseReactionsIgnoringUnhandledRejection(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseUserInputEventHandlingState {
            DontCare = 0,
            HadUserInteractionAtCreation = 1,
            DidntHaveUserInteractionAtCreation = 2,
        }
        extern "C" {
            #[doc = " Returns the given Promise's activation behavior state flag per above as a\n JS::PromiseUserInputEventHandlingState value.  All promises are created with\n the DontCare state by default.\n\n Returns JS::PromiseUserInputEventHandlingState::DontCare if the given object\n is a wrapper that can't safely be unwrapped."]
            #[link_name = "\u{1}_ZN2JS37GetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
            ) -> root::JS::PromiseUserInputEventHandlingState;
        }
        extern "C" {
            #[doc = " Sets the given Promise's activation behavior state flag per above as a\n JS::PromiseUserInputEventHandlingState value.\n\n Returns false if the given object is a wrapper that can't safely be\n unwrapped."]
            #[link_name = "\u{1}_ZN2JS37SetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEENS_34PromiseUserInputEventHandlingStateE"]
            pub fn SetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
                state: root::JS::PromiseUserInputEventHandlingState,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Unforgeable version of the JS builtin Promise.all.\n\n Takes a HandleObjectVector of Promise objects and returns a promise that's\n resolved with an array of resolution values when all those promises have\n been resolved, or rejected with the rejection value of the first rejected\n promise.\n\n Asserts that all objects in the `promises` vector are, maybe wrapped,\n instances of `Promise` or a subclass of `Promise`."]
            #[link_name = "\u{1}_ZN2JS20GetWaitForAllPromiseEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEE"]
            pub fn GetWaitForAllPromise(
                cx: *mut root::JSContext,
                promises: root::JS::HandleObjectVector,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        pub struct Dispatchable__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The Dispatchable interface allows the embedding to call SpiderMonkey\n on a JSContext thread when requested via DispatchToEventLoopCallback."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct Dispatchable {
            pub vtable_: *const Dispatchable__bindgen_vtable,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Dispatchable_MaybeShuttingDown {
            NotShuttingDown = 0,
            ShuttingDown = 1,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of Dispatchable"][::std::mem::size_of::<Dispatchable>() - 8usize];
            ["Alignment of Dispatchable"][::std::mem::align_of::<Dispatchable>() - 8usize];
        };
        #[doc = " Callbacks to dispatch a JS::Dispatchable to a JSContext's thread's event\n loop.\n\n The DispatchToEventLoopCallback set on a particular JSContext must accept\n JS::Dispatchable instances and arrange for their `run` methods to be called\n eventually on the JSContext's thread. This is used for cross-thread dispatch,\n so the callback itself must be safe to call from any thread. It cannot\n trigger a GC.\n\n The DelayedDispatchToEventLoopCallback in addition takes a delay, and it\n must accept JS::Dispatchable instances and arrange for their `run` methods\n to be called after the delay on the JSContext's thread.\n The embeddings must have its own timeout manager to handle the delay.\n If a timeout manager is not available for given context, it should return\n false, optionally with a warning message printed.\n\n If the callback returns `true`, it must eventually run the given\n Dispatchable; otherwise, SpiderMonkey may leak memory or hang.\n\n The callback may return `false` to indicate that the JSContext's thread is\n shutting down and is no longer accepting runnables. Shutting down is a\n one-way transition: once the callback has rejected a runnable, it must reject\n all subsequently submitted runnables as well.\n\n To establish a DispatchToEventLoopCallback, the embedding may either call\n InitDispatchsToEventLoop to provide its own, or call js::UseInternalJobQueues\n to select a default implementation built into SpiderMonkey. This latter\n depends on the embedding to call js::RunJobs on the JavaScript thread to\n process queued Dispatchables at appropriate times."]
        pub type DispatchToEventLoopCallback = ::std::option::Option<
            unsafe extern "C" fn(
                closure: *mut ::std::os::raw::c_void,
                dispatchable: *mut u8,
            ) -> bool,
        >;
        pub type DelayedDispatchToEventLoopCallback = ::std::option::Option<
            unsafe extern "C" fn(
                closure: *mut ::std::os::raw::c_void,
                dispatchable: *mut u8,
                delay: u32,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InitDispatchsToEventLoopEP9JSContextPFbPvON7mozilla9UniquePtrINS_12DispatchableENS_12DeletePolicyIS5_EEEEEPFbS2_S9_jES2_"]
            pub fn InitDispatchsToEventLoop(
                cx: *mut root::JSContext,
                callback: root::JS::DispatchToEventLoopCallback,
                delayedCallback: root::JS::DelayedDispatchToEventLoopCallback,
                closure: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " When a JSRuntime is destroyed it implicitly cancels all async tasks in\n progress, releasing any roots held by the task. However, this is not soon\n enough for cycle collection, which needs to have roots dropped earlier so\n that the cycle collector can transitively remove roots for a future GC. For\n these and other cases, the set of pending async tasks can be canceled\n with this call earlier than JSRuntime destruction."]
            #[link_name = "\u{1}_ZN2JS18ShutdownAsyncTasksEP9JSContext"]
            pub fn ShutdownAsyncTasks(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Create an Array from the current realm with the given contents."]
            #[link_name = "\u{1}_ZN2JS14NewArrayObjectEP9JSContextRKNS_16HandleValueArrayE"]
            pub fn NewArrayObject(
                cx: *mut root::JSContext,
                contents: *const root::JS::HandleValueArray,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create an Array from the current realm with the given length and allocate\n memory for all its elements.  (The elements nonetheless will not exist as\n properties on the returned array until values have been assigned to them.)"]
            #[link_name = "\u{1}_ZN2JS14NewArrayObjectEP9JSContextm"]
            pub fn NewArrayObject1(cx: *mut root::JSContext, length: usize) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Determine whether |value| is an Array object or a wrapper around one.  (An\n ES6 proxy whose target is an Array object, e.g.\n |var target = [], handler = {}; Proxy.revocable(target, handler).proxy|, is\n not considered to be an Array.)\n\n On success set |*isArray| accordingly and return true; on failure return\n false."]
            #[link_name = "\u{1}_ZN2JS13IsArrayObjectEP9JSContextNS_6HandleINS_5ValueEEEPb"]
            pub fn IsArrayObject(
                cx: *mut root::JSContext,
                value: root::JS::Handle<root::JS::Value>,
                isArray: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Determine whether |obj| is an Array object or a wrapper around one.  (An\n ES6 proxy whose target is an Array object, e.g.\n |var target = [], handler = {}; Proxy.revocable(target, handler).proxy|, is\n not considered to be an Array.)\n\n On success set |*isArray| accordingly and return true; on failure return\n false."]
            #[link_name = "\u{1}_ZN2JS13IsArrayObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsArrayObject1(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isArray: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store |*lengthp = ToLength(obj.length)| and return true on success, else\n return false.\n\n If the length does not fit in |uint32_t|, an exception is reported and false\n is returned.\n\n |ToLength| converts its input to an integer usable to index an\n array-like object.\n\n If |obj| is an Array, this overall operation is the same as getting\n |obj.length|."]
            #[link_name = "\u{1}_ZN2JS14GetArrayLengthEP9JSContextNS_6HandleIP8JSObjectEEPj"]
            pub fn GetArrayLength(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                lengthp: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Perform |obj.length = length| as if in strict mode code, with a fast path for\n the case where |obj| is an Array.\n\n This operation is exactly and only assigning to a \"length\" property.  In\n general, it can invoke an existing \"length\" setter, throw if the property is\n non-writable, or do anything else a property-set operation might do."]
            #[link_name = "\u{1}_ZN2JS14SetArrayLengthEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn SetArrayLength(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                length: u32,
            ) -> bool;
        }
        #[repr(i32)]
        #[doc = " The answer to a successful query as to whether an object is an Array per\n ES6's internal |IsArray| operation (as exposed by |Array.isArray|)."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum IsArrayAnswer {
            Array = 0,
            NotArray = 1,
            RevokedProxy = 2,
        }
        extern "C" {
            #[doc = " ES6 7.2.2.\n\n Returns false on failure, otherwise returns true and sets |*isArray|\n indicating whether the object passes ECMAScript's IsArray test.  This is the\n same test performed by |Array.isArray|.\n\n This is NOT the same as asking whether |obj| is an Array or a wrapper around\n one.  If |obj| is a proxy created by |Proxy.revocable()| and has been\n revoked, or if |obj| is a proxy whose target (at any number of hops) is a\n revoked proxy, this method throws a TypeError and returns false."]
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsArray(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isArray: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Identical to IsArray above, but the nature of the object (if successfully\n determined) is communicated via |*answer|.  In particular this method\n returns true and sets |*answer = IsArrayAnswer::RevokedProxy| when called on\n a revoked proxy.\n\n Most users will want the overload above, not this one."]
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPNS_13IsArrayAnswerE"]
            pub fn IsArray1(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                answer: *mut root::JS::IsArrayAnswer,
            ) -> bool;
        }
        pub type IsAcceptableThis =
            ::std::option::Option<unsafe extern "C" fn(v: root::JS::HandleValue) -> bool>;
        pub type NativeImpl = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, args: *const root::JS::CallArgs) -> bool,
        >;
        #[doc = " Regular expression flag values, suitable for initializing a collection of\n regular expression flags as defined below in |RegExpFlags|.  Flags are listed\n in alphabetical order by syntax -- /d, /g, /i, /m, /s, /u, /v, /y."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RegExpFlag {
            pub _address: u8,
        }
        #[doc = " Add .indices property to the match result, i.e. /d"]
        pub const RegExpFlag_HasIndices: u8 = 64;
        #[doc = " Act globally and find *all* matches (rather than stopping after just the\n first one), i.e. /g."]
        pub const RegExpFlag_Global: u8 = 2;
        #[doc = " Interpret regular expression source text case-insensitively by folding\n uppercase letters to lowercase, i.e. /i."]
        pub const RegExpFlag_IgnoreCase: u8 = 1;
        #[doc = " Treat ^ and $ as begin and end of line, i.e. /m."]
        pub const RegExpFlag_Multiline: u8 = 4;
        pub const RegExpFlag_DotAll: u8 = 32;
        #[doc = " Use Unicode semantics, i.e. /u."]
        pub const RegExpFlag_Unicode: u8 = 16;
        #[doc = " Use Unicode Sets semantics, i.e. /v."]
        pub const RegExpFlag_UnicodeSets: u8 = 128;
        #[doc = " Only match starting from <regular expression>.lastIndex, i.e. /y."]
        pub const RegExpFlag_Sticky: u8 = 8;
        #[doc = " No regular expression flags."]
        pub const RegExpFlag_NoFlags: u8 = 0;
        #[doc = " All regular expression flags."]
        pub const RegExpFlag_AllFlags: u8 = 255;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RegExpFlag"][::std::mem::size_of::<RegExpFlag>() - 1usize];
            ["Alignment of RegExpFlag"][::std::mem::align_of::<RegExpFlag>() - 1usize];
        };
        #[doc = " A collection of regular expression flags.  Individual flag values may be\n combined into a collection using bitwise operators."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RegExpFlags {
            pub flags_: root::JS::RegExpFlags_Flag,
        }
        pub type RegExpFlags_Flag = u8;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of RegExpFlags"][::std::mem::size_of::<RegExpFlags>() - 1usize];
            ["Alignment of RegExpFlags"][::std::mem::align_of::<RegExpFlags>() - 1usize];
            ["Offset of field: RegExpFlags::flags_"]
                [::std::mem::offset_of!(RegExpFlags, flags_) - 0usize];
        };
        extern "C" {
            #[doc = " Create a new RegExp for the given Latin-1-encoded bytes and flags."]
            #[link_name = "\u{1}_ZN2JS15NewRegExpObjectEP9JSContextPKcmNS_11RegExpFlagsE"]
            pub fn NewRegExpObject(
                cx: *mut root::JSContext,
                bytes: *const ::std::os::raw::c_char,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new RegExp for the given source and flags."]
            #[link_name = "\u{1}_ZN2JS17NewUCRegExpObjectEP9JSContextPKDsmNS_11RegExpFlagsE"]
            pub fn NewUCRegExpObject(
                cx: *mut root::JSContext,
                chars: *const u16,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14SetRegExpInputEP9JSContextNS_6HandleIP8JSObjectEENS2_IP8JSStringEE"]
            pub fn SetRegExpInput(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                input: root::JS::Handle<*mut root::JSString>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18ClearRegExpStaticsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ClearRegExpStatics(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a regexp on a given input, starting from |indexp|.\n Returns false on OOM or over-recursion.\n\n On no match, |rval| is set to Null.\n On a match, |indexp| and the RegExp statics are updated.\n Then, if |test| is true, |rval| is set to true.\n Otherwise, |rval| is set to a match result object."]
            #[link_name = "\u{1}_ZN2JS13ExecuteRegExpEP9JSContextNS_6HandleIP8JSObjectEES5_PKDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *const u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Execute a regexp on a given input, starting from |indexp|.\n This is the same as ExecuteRegExp, except it does not update the RegExp\n statics and can be called without a global object."]
            #[link_name = "\u{1}_ZN2JS22ExecuteRegExpNoStaticsEP9JSContextNS_6HandleIP8JSObjectEEPKDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExpNoStatics(
                cx: *mut root::JSContext,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *const u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isRegExp| to true if |obj| is a RegExp\n object or a wrapper around one, or to false if not.  Returns false on\n failure.\n\n This method returns true with |*isRegExp == false| when passed an ES6 proxy\n whose target is a RegExp, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS14ObjectIsRegExpEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isRegExp: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Return the source text for a RegExp object (or a wrapper around one), or null\n on failure."]
            #[link_name = "\u{1}_ZN2JS15GetRegExpSourceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRegExpSource(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Check whether the given source is a valid regexp. If the regexp parses\n successfully, returns true and sets |error| to undefined. If the regexp\n has a syntax error, returns true, sets |error| to that error object, and\n clears the exception. Returns false on OOM or over-recursion."]
            #[link_name = "\u{1}_ZN2JS17CheckRegExpSyntaxEP9JSContextPKDsmNS_11RegExpFlagsENS_13MutableHandleINS_5ValueEEE"]
            pub fn CheckRegExpSyntax(
                cx: *mut root::JSContext,
                chars: *const u16,
                length: usize,
                flags: root::JS::RegExpFlags,
                error: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SavedFrameResult {
            Ok = 0,
            AccessDenied = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SavedFrameSelfHosted {
            Include = 0,
            Exclude = 1,
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its source property. Defaults to the empty\n string."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameSourceEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSource(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourcep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get an ID identifying its ScriptSource.\n Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS21GetSavedFrameSourceIdEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSourceId(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourceIdp: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its line property (1-origin).\n Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS17GetSavedFrameLineEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameLine(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                linep: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its column property. Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameColumnEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPNS_27TaggedColumnNumberOneOriginENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameColumn(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                columnp: *mut root::JS::TaggedColumnNumberOneOrigin,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its functionDisplayName string, or nullptr\n if SpiderMonkey was unable to infer a name for the captured frame's\n function. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS32GetSavedFrameFunctionDisplayNameEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameFunctionDisplayName(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                namep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its asyncCause string. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS23GetSavedFrameAsyncCauseEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncCause(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncCausep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its asyncParent SavedFrame object or nullptr\n if there is no asyncParent. The `asyncParentp` out parameter is _NOT_\n guaranteed to be in the cx's compartment. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS24GetSavedFrameAsyncParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncParentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its parent SavedFrame object or nullptr if\n it is the oldest frame in the stack. The `parentp` out parameter is _NOT_\n guaranteed to be in the cx's compartment. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                parentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame object, convert it and its transitive parents to plain\n objects. Because SavedFrame objects store their properties on the prototype,\n they cannot be usefully stringified to JSON. Assigning their properties to\n plain objects allow those objects to be stringified and the saved frame stack\n can be encoded as a string."]
            #[link_name = "\u{1}_ZN2JS30ConvertSavedFrameToPlainObjectEP9JSContextNS_6HandleIP8JSObjectEENS_20SavedFrameSelfHostedE"]
            pub fn ConvertSavedFrameToPlainObject(
                cx: *mut root::JSContext,
                savedFrame: root::JS::HandleObject,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
        }
        pub mod Scalar {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Type {
                Int8 = 0,
                Uint8 = 1,
                Int16 = 2,
                Uint16 = 3,
                Int32 = 4,
                Uint32 = 5,
                Float32 = 6,
                Float64 = 7,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256).\n Treat the raw data type as a uint8_t."]
                Uint8Clamped = 8,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256).\n Treat the raw data type as a uint8_t."]
                BigInt64 = 9,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256).\n Treat the raw data type as a uint8_t."]
                BigUint64 = 10,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256).\n Treat the raw data type as a uint8_t."]
                Float16 = 11,
                #[doc = " Types that don't have their own TypedArray equivalent, for now.\n E.g. DataView"]
                MaxTypedArrayViewType = 12,
                #[doc = " Types that don't have their own TypedArray equivalent, for now.\n E.g. DataView"]
                Int64 = 13,
                #[doc = " Types that don't have their own TypedArray equivalent, for now.\n E.g. DataView"]
                Simd128 = 14,
            }
        }
        extern "C" {
            #[doc = " Create a new SharedArrayBuffer with the given byte length.  This\n may only be called if\n JS::RealmCreationOptionsRef(cx).getSharedMemoryAndAtomicsEnabled() is\n true."]
            #[link_name = "\u{1}_ZN2JS20NewSharedArrayBufferEP9JSContextm"]
            pub fn NewSharedArrayBuffer(
                cx: *mut root::JSContext,
                nbytes: usize,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Check whether obj supports the JS::GetSharedArrayBuffer* APIs.  Note that\n this may return false if a security wrapper is encountered that denies the\n unwrapping. If this test succeeds, then it is safe to call the various\n accessor JSAPI calls defined below."]
            #[link_name = "\u{1}_ZN2JS25IsSharedArrayBufferObjectEP8JSObject"]
            pub fn IsSharedArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23UnwrapSharedArrayBufferEP8JSObject"]
            pub fn UnwrapSharedArrayBuffer(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30GetSharedArrayBufferByteLengthEP8JSObject"]
            pub fn GetSharedArrayBufferByteLength(obj: *mut root::JSObject) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetSharedArrayBufferDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetSharedArrayBufferData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS33GetSharedArrayBufferLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetSharedArrayBufferLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        extern "C" {
            #[doc = " Returns true if there are any live SharedArrayBuffer objects, including those\n for wasm memories, associated with the context.  This is conservative,\n because it does not run GC.  Some dead objects may not have been collected\n yet and thus will be thought live."]
            #[link_name = "\u{1}_ZN2JS25ContainsSharedArrayBufferEP9JSContext"]
            pub fn ContainsSharedArrayBuffer(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Return the isShared flag of a ArrayBufferView subtypes, which denotes whether\n the underlying buffer is a SharedArrayBuffer.\n\n |obj| must have passed a JS_IsArrayBufferViewObject test, or somehow\n be known that it would pass such a test: it is a ArrayBufferView subtypes or\n a wrapper of a ArrayBufferView subtypes, and the unwrapping will succeed."]
            #[link_name = "\u{1}_ZN2JS23IsArrayBufferViewSharedEP8JSObject"]
            pub fn IsArrayBufferViewShared(obj: *mut root::JSObject) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoStableStringChars {
            _unused: [u8; 0],
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SourceOwnership {
            Borrowed = 0,
            TakeOwnership = 1,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SourceText<Unit> {
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Unit>>,
            #[doc = " |char16_t| or |Utf8Unit| source units of uncertain validity."]
            pub units_: *const Unit,
            #[doc = " The length in code units of |units_|."]
            pub length_: u32,
            #[doc = " Whether this owns |units_| or merely observes source units owned by some\n other object."]
            pub ownsUnits_: bool,
        }
        pub type SourceText_CharT = root::std::conditional_t;
        impl root::JS::StructuredCloneScope {
            pub const LastResolvedScope: root::JS::StructuredCloneScope =
                StructuredCloneScope::DifferentProcess;
        }
        #[repr(u32)]
        #[doc = " Indicates the \"scope of validity\" of serialized data.\n\n Writing plain JS data produces an array of bytes that can be copied and\n read in another process or whatever. The serialized data is Plain Old Data.\n However, HTML also supports `Transferable` objects, which, when cloned, can\n be moved from the source object into the clone, like when you take a\n photograph of someone and it steals their soul.\n See <https://developer.mozilla.org/en-US/docs/Web/API/Transferable>.\n We support cloning and transferring objects of many types.\n\n For example, when we transfer an ArrayBuffer (within a process), we \"detach\"\n the ArrayBuffer, embed the raw buffer pointer in the serialized data, and\n later install it in a new ArrayBuffer in the destination realm. Ownership\n of that buffer memory is transferred from the original ArrayBuffer to the\n serialized data and then to the clone.\n\n This only makes sense within a single address space. When we transfer an\n ArrayBuffer to another process, the contents of the buffer must be copied\n into the serialized data. (The original ArrayBuffer is still detached,\n though, for consistency; in some cases the caller shouldn't know or care if\n the recipient is in the same process.)\n\n ArrayBuffers are actually a lucky case; some objects (like MessagePorts)\n can't reasonably be stored by value in serialized data -- it's pointers or\n nothing.\n\n So there is a tradeoff between scope of validity -- how far away the\n serialized data may be sent and still make sense -- and efficiency or\n features. The read and write algorithms therefore take an argument of this\n type, allowing the user to control those trade-offs."]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StructuredCloneScope {
            #[doc = " The most restrictive scope, with greatest efficiency and features.\n\n When writing, this means: The caller promises that the serialized data\n will **not** be shipped off to a different process or stored in a\n database. However, it may be shipped to another thread. It's OK to\n produce serialized data that contains pointers to data that is safe to\n send across threads, such as array buffers. In Rust terms, the\n serialized data will be treated as `Send` but not `Copy`.\n\n When reading, this means: Accept transferred objects and buffers\n (pointers). The caller promises that the serialized data was written\n using this API (otherwise, the serialized data may contain bogus\n pointers, leading to undefined behavior).\n\n Starts from 1 because there used to be a SameProcessSameThread enum value\n of 0 and these values are encoded into the structured serialization format\n as part of the SCTAG_HEADER, and IndexedDB persists the representation to\n disk."]
            SameProcess = 1,
            #[doc = " When writing, this means we're writing for an audience in a different\n process. Produce serialized data that can be sent to other processes,\n bitwise copied, or even stored as bytes in a database and read by later\n versions of Firefox years from now. The HTML5 spec refers to this as\n \"ForStorage\" as in StructuredSerializeForStorage, though we use\n DifferentProcess for IPC as well as storage.\n\n Transferable objects are limited to ArrayBuffers, whose contents are\n copied into the serialized data (rather than just writing a pointer).\n\n When reading, this means: Do not accept pointers."]
            DifferentProcess = 2,
            #[doc = " Handle a backwards-compatibility case with IndexedDB (bug 1434308): when\n reading, this means to treat legacy SameProcess data as if it were\n DifferentProcess.\n\n Do not use this for writing; use DifferentProcess instead."]
            DifferentProcessForIndexedDB = 3,
            #[doc = " Existing code wants to be able to create an uninitialized\n JSStructuredCloneData without knowing the scope, then populate it with\n data (at which point the scope *is* known.)"]
            Unassigned = 4,
            #[doc = " This scope is used when the deserialization context is unknown. When\n writing, DifferentProcess or SameProcess scope is chosen based on the\n nature of the object."]
            UnknownDestination = 5,
        }
        impl root::JS::TransferableOwnership {
            pub const SCTAG_TMO_ALLOC_DATA: root::JS::TransferableOwnership =
                TransferableOwnership::SCTAG_TMO_FIRST_OWNED;
        }
        #[repr(u32)]
        #[doc = " Values used to describe the ownership individual Transferables.\n\n Note that these *can* show up in DifferentProcess clones, since\n DifferentProcess ArrayBuffers can be Transferred. In that case, this will\n distinguish the specific ownership mechanism: is it a malloc pointer or a\n memory mapping?"]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TransferableOwnership {
            #[doc = " Transferable data has not been filled in yet."]
            SCTAG_TMO_UNFILLED = 0,
            #[doc = " Structured clone buffer does not yet own the data."]
            SCTAG_TMO_UNOWNED = 1,
            #[doc = " All enum values at least this large are owned by the clone buffer."]
            SCTAG_TMO_FIRST_OWNED = 2,
            #[doc = " Data is a memory mapped pointer."]
            SCTAG_TMO_MAPPED_DATA = 3,
            #[doc = " Data is embedding-specific. The engine can free it by calling the\n freeTransfer op."]
            SCTAG_TMO_CUSTOM = 4,
            #[doc = " Same as SCTAG_TMO_CUSTOM, but the embedding can also use\n SCTAG_TMO_USER_MIN and greater, up to 2^32-1, to distinguish specific\n ownership variants."]
            SCTAG_TMO_USER_MIN = 5,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CloneDataPolicy {
            pub allowIntraClusterClonableSharedObjects_: bool,
            pub allowSharedMemoryObjects_: bool,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CloneDataPolicy"][::std::mem::size_of::<CloneDataPolicy>() - 2usize];
            ["Alignment of CloneDataPolicy"][::std::mem::align_of::<CloneDataPolicy>() - 1usize];
            ["Offset of field: CloneDataPolicy::allowIntraClusterClonableSharedObjects_"][::std::mem::offset_of!(
                CloneDataPolicy,
                allowIntraClusterClonableSharedObjects_
            )
                - 0usize];
            ["Offset of field: CloneDataPolicy::allowSharedMemoryObjects_"]
                [::std::mem::offset_of!(CloneDataPolicy, allowSharedMemoryObjects_) - 1usize];
        };
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of ASCII format\n filled from trailing ASCII arguments.\n\n Return true iff the warning was successfully reported without reporting an\n error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS9WarnASCIIEP9JSContextPKcz"]
            pub fn WarnASCII(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of Latin-1 format\n filled from trailing Latin-1 arguments.\n\n Return true iff the warning was successfully reported without reporting an\n error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS10WarnLatin1EP9JSContextPKcz"]
            pub fn WarnLatin1(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of UTF-8 format\n filled from trailing UTF-8 arguments.\n\n Return true iff the warning was successfully reported without reporting an\n error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS8WarnUTF8EP9JSContextPKcz"]
            pub fn WarnUTF8(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        pub type WarningReporter = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, report: *mut root::JSErrorReport),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetWarningReporterEP9JSContext"]
            pub fn GetWarningReporter(cx: *mut root::JSContext) -> root::JS::WarningReporter;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18SetWarningReporterEP9JSContextPFvS1_P13JSErrorReportE"]
            pub fn SetWarningReporter(
                cx: *mut root::JSContext,
                reporter: root::JS::WarningReporter,
            ) -> root::JS::WarningReporter;
        }
        #[doc = " A simple RAII class that clears the registered warning reporter on\n construction and restores it on destruction.\n\n A fresh warning reporter *may* be set while an instance of this class is\n live, but it must be unset in LIFO fashion by the time that instance is\n destroyed."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoSuppressWarningReporter {
            pub context_: *mut root::JSContext,
            pub prevReporter_: root::JS::WarningReporter,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of AutoSuppressWarningReporter"]
                [::std::mem::size_of::<AutoSuppressWarningReporter>() - 16usize];
            ["Alignment of AutoSuppressWarningReporter"]
                [::std::mem::align_of::<AutoSuppressWarningReporter>() - 8usize];
            ["Offset of field: AutoSuppressWarningReporter::context_"]
                [::std::mem::offset_of!(AutoSuppressWarningReporter, context_) - 0usize];
            ["Offset of field: AutoSuppressWarningReporter::prevReporter_"]
                [::std::mem::offset_of!(AutoSuppressWarningReporter, prevReporter_) - 8usize];
        };
        #[repr(C)]
        pub struct WasmModule__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The WasmModule interface allows the embedding to hold a reference to the\n underying C++ implementation of a JS WebAssembly.Module object for purposes\n of efficient postMessage() and (de)serialization from a random thread.\n\n In particular, this allows postMessage() of a WebAssembly.Module:\n GetWasmModule() is called when making a structured clone of a payload\n containing a WebAssembly.Module object. The structured clone buffer holds a\n refcount of the JS::WasmModule until createObject() is called in the target\n agent's JSContext. The new WebAssembly.Module object continues to hold the\n JS::WasmModule and thus the final reference of a JS::WasmModule may be\n dropped from any thread and so the virtual destructor (and all internal\n methods of the C++ module) must be thread-safe."]
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct WasmModule {
            pub vtable_: *const WasmModule__bindgen_vtable,
            pub _base: root::js::AtomicRefCounted,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of WasmModule"][::std::mem::size_of::<WasmModule>() - 16usize];
            ["Alignment of WasmModule"][::std::mem::align_of::<WasmModule>() - 8usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18IsWasmModuleObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsWasmModuleObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13GetWasmModuleENS_6HandleIP8JSObjectEE"]
            pub fn GetWasmModule(obj: root::JS::HandleObject)
                -> root::RefPtr<root::JS::WasmModule>;
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct InstantiationStorage {
            pub gcOutput_: *mut root::js::frontend::PreallocatedCompilationGCOutput,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of InstantiationStorage"]
                [::std::mem::size_of::<InstantiationStorage>() - 8usize];
            ["Alignment of InstantiationStorage"]
                [::std::mem::align_of::<InstantiationStorage>() - 8usize];
            ["Offset of field: InstantiationStorage::gcOutput_"]
                [::std::mem::offset_of!(InstantiationStorage, gcOutput_) - 0usize];
        };
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StencilAddRefEPN2js8frontend32InitialStencilAndDelazificationsE"]
            pub fn StencilAddRef(stencil: *mut root::JS::Stencil);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14StencilReleaseEPN2js8frontend32InitialStencilAndDelazificationsE"]
            pub fn StencilRelease(stencil: *mut root::JS::Stencil);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17StencilIsBorrowedEPN2js8frontend32InitialStencilAndDelazificationsE"]
            pub fn StencilIsBorrowed(stencil: *mut root::JS::Stencil) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13SizeOfStencilEPN2js8frontend32InitialStencilAndDelazificationsEPFmPKvE"]
            pub fn SizeOfStencil(
                stencil: *mut root::JS::Stencil,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileGlobalScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileGlobalScriptToStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileGlobalScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileGlobalScriptToStencil1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileModuleScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileModuleScriptToStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CompileModuleScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileModuleScriptToStencil1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InstantiateGlobalStencilEP9JSContextRKNS_18InstantiateOptionsEPN2js8frontend32InitialStencilAndDelazificationsEPNS_20InstantiationStorageE"]
            pub fn InstantiateGlobalStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::InstantiateOptions,
                stencil: *mut root::JS::Stencil,
                storage: *mut root::JS::InstantiationStorage,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InstantiateModuleStencilEP9JSContextRKNS_18InstantiateOptionsEPN2js8frontend32InitialStencilAndDelazificationsEPNS_20InstantiationStorageE"]
            pub fn InstantiateModuleStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::InstantiateOptions,
                stencil: *mut root::JS::Stencil,
                storage: *mut root::JS::InstantiationStorage,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13DecodeStencilEP9JSContextRKNS_21ReadOnlyDecodeOptionsERKN7mozilla5RangeIKhEEPPN2js8frontend32InitialStencilAndDelazificationsE"]
            pub fn DecodeStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyDecodeOptions,
                range: *const root::JS::TranscodeRange,
                stencilOut: *mut *mut root::JS::Stencil,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13DecodeStencilEPN2js15FrontendContextERKNS_21ReadOnlyDecodeOptionsERKN7mozilla5RangeIKhEEPPNS0_8frontend32InitialStencilAndDelazificationsE"]
            pub fn DecodeStencil1(
                fc: *mut root::JS::FrontendContext,
                options: *const root::JS::ReadOnlyDecodeOptions,
                range: *const root::JS::TranscodeRange,
                stencilOut: *mut *mut root::JS::Stencil,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30StartCollectingDelazificationsEP9JSContextNS_6HandleIP8JSScriptEEPN2js8frontend32InitialStencilAndDelazificationsERb"]
            pub fn StartCollectingDelazifications(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                stencil: *mut root::JS::Stencil,
                alreadyStarted: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30StartCollectingDelazificationsEP9JSContextNS_6HandleIP8JSObjectEEPN2js8frontend32InitialStencilAndDelazificationsERb"]
            pub fn StartCollectingDelazifications1(
                cx: *mut root::JSContext,
                module: root::JS::Handle<*mut root::JSObject>,
                stencil: *mut root::JS::Stencil,
                alreadyStarted: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31FinishCollectingDelazificationsEP9JSContextNS_6HandleIP8JSScriptEERN7mozilla6VectorIhLm0ENS6_17MallocAllocPolicyEEE"]
            pub fn FinishCollectingDelazifications(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                buffer: *mut root::JS::TranscodeBuffer,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31FinishCollectingDelazificationsEP9JSContextNS_6HandleIP8JSObjectEERN7mozilla6VectorIhLm0ENS6_17MallocAllocPolicyEEE"]
            pub fn FinishCollectingDelazifications1(
                cx: *mut root::JSContext,
                module: root::JS::Handle<*mut root::JSObject>,
                buffer: *mut root::JS::TranscodeBuffer,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31FinishCollectingDelazificationsEP9JSContextNS_6HandleIP8JSScriptEEPPN2js8frontend32InitialStencilAndDelazificationsE"]
            pub fn FinishCollectingDelazifications2(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                stencilOut: *mut *mut root::JS::Stencil,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30AbortCollectingDelazificationsENS_6HandleIP8JSScriptEE"]
            pub fn AbortCollectingDelazifications(script: root::JS::Handle<*mut root::JSScript>);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS30AbortCollectingDelazificationsENS_6HandleIP8JSObjectEE"]
            pub fn AbortCollectingDelazifications1(module: root::JS::Handle<*mut root::JSObject>);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18IsStencilCacheableEPN2js8frontend32InitialStencilAndDelazificationsE"]
            pub fn IsStencilCacheable(stencil: *mut root::JS::Stencil) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22IsLargeArrayBufferViewEP8JSObject"]
            pub fn IsLargeArrayBufferView(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IsResizableArrayBufferViewEP8JSObject"]
            pub fn IsResizableArrayBufferView(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26PinArrayBufferOrViewLengthEP8JSObjectb"]
            pub fn PinArrayBufferOrViewLength(obj: *mut root::JSObject, pin: bool) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS32EnsureNonInlineArrayBufferOrViewEP9JSContextP8JSObject"]
            pub fn EnsureNonInlineArrayBufferOrView(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ArrayBufferOrView {
            pub obj: *mut root::JSObject,
        }
        pub type ArrayBufferOrView_DataType = u8;
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ArrayBufferOrView"][::std::mem::size_of::<ArrayBufferOrView>() - 8usize];
            ["Alignment of ArrayBufferOrView"]
                [::std::mem::align_of::<ArrayBufferOrView>() - 8usize];
            ["Offset of field: ArrayBufferOrView::obj"]
                [::std::mem::offset_of!(ArrayBufferOrView, obj) - 0usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ArrayBuffer {
            pub _base: root::JS::ArrayBufferOrView,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer24FixedLengthUnsharedClassE"]
            pub static ArrayBuffer_FixedLengthUnsharedClass: *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer22ResizableUnsharedClassE"]
            pub static ArrayBuffer_ResizableUnsharedClass: *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer22FixedLengthSharedClassE"]
            pub static ArrayBuffer_FixedLengthSharedClass: *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer19GrowableSharedClassE"]
            pub static ArrayBuffer_GrowableSharedClass: *const root::JSClass;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ArrayBuffer"][::std::mem::size_of::<ArrayBuffer>() - 8usize];
            ["Alignment of ArrayBuffer"][::std::mem::align_of::<ArrayBuffer>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ArrayBufferView {
            pub _base: root::JS::ArrayBufferOrView,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ArrayBufferView"][::std::mem::size_of::<ArrayBufferView>() - 8usize];
            ["Alignment of ArrayBufferView"][::std::mem::align_of::<ArrayBufferView>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DataView {
            pub _base: root::JS::ArrayBufferView,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8DataView19FixedLengthClassPtrE"]
            pub static DataView_FixedLengthClassPtr: *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8DataView17ResizableClassPtrE"]
            pub static DataView_ResizableClassPtr: *const root::JSClass;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of DataView"][::std::mem::size_of::<DataView>() - 8usize];
            ["Alignment of DataView"][::std::mem::align_of::<DataView>() - 8usize];
        };
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TypedArray_base {
            pub _base: root::JS::ArrayBufferView,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15TypedArray_base18fixedLengthClassesE"]
            pub static TypedArray_base_fixedLengthClasses: *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15TypedArray_base16resizableClassesE"]
            pub static TypedArray_base_resizableClasses: *const root::JSClass;
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of TypedArray_base"][::std::mem::size_of::<TypedArray_base>() - 8usize];
            ["Alignment of TypedArray_base"][::std::mem::align_of::<TypedArray_base>() - 8usize];
        };
        pub type TypedArray_DataType = root::JS::detail::ExternalTypeOf_t;
        extern "C" {
            #[link_name = "\u{1}Scalar"]
            pub static TypedArray_Scalar: root::JS::Scalar::Type;
        }
        pub type Int8Array = u64;
        pub type Uint8Array = u64;
        pub type Int16Array = u64;
        pub type Uint16Array = u64;
        pub type Int32Array = u64;
        pub type Uint32Array = u64;
        pub type Float32Array = u64;
        pub type Float64Array = u64;
        pub type Uint8ClampedArray = u64;
        pub type BigInt64Array = u64;
        pub type BigUint64Array = u64;
        pub type Float16Array = u64;
        #[repr(C)]
        pub struct ExpandoAndGeneration {
            pub expando: root::JS::Heap<root::JS::Value>,
            pub generation: u64,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of ExpandoAndGeneration"]
                [::std::mem::size_of::<ExpandoAndGeneration>() - 16usize];
            ["Alignment of ExpandoAndGeneration"]
                [::std::mem::align_of::<ExpandoAndGeneration>() - 8usize];
            ["Offset of field: ExpandoAndGeneration::expando"]
                [::std::mem::offset_of!(ExpandoAndGeneration, expando) - 0usize];
            ["Offset of field: ExpandoAndGeneration::generation"]
                [::std::mem::offset_of!(ExpandoAndGeneration, generation) - 8usize];
        };
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DOMProxyShadowsResult {
            ShadowCheckFailed = 0,
            Shadows = 1,
            DoesntShadow = 2,
            DoesntShadowUnique = 3,
            ShadowsViaDirectExpando = 4,
            ShadowsViaIndirectExpando = 5,
        }
        pub type DOMProxyShadowsCheck = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::Handle<*mut root::JSObject>,
                arg3: root::JS::Handle<root::JS::PropertyKey>,
            ) -> root::JS::DOMProxyShadowsResult,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SetDOMProxyInformationEPKvPFNS_21DOMProxyShadowsResultEP9JSContextNS_6HandleIP8JSObjectEENS5_INS_11PropertyKeyEEEES1_"]
            pub fn SetDOMProxyInformation(
                domProxyHandlerFamily: *const ::std::os::raw::c_void,
                domProxyShadowsCheck: root::JS::DOMProxyShadowsCheck,
                domRemoteProxyHandlerFamily: *const ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Set all of the uninitialized lexicals on an object to undefined. Return\n true if any lexicals were initialized and false otherwise."]
            #[link_name = "\u{1}_ZN2JS26ForceLexicalInitializationEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ForceLexicalInitialization(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether we are poisoning unused/released data for error detection. Governed\n by the JS_GC_ALLOW_EXTRA_POISONING #ifdef as well as the\n javascript.options.extra_gc_poisoning pref."]
            #[link_name = "\u{1}_ZN2JS13IsGCPoisoningEv"]
            pub fn IsGCPoisoning() -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetRealmPrincipalsEPNS_5RealmE"]
            pub fn GetRealmPrincipals(realm: *mut root::JS::Realm) -> *mut root::JSPrincipals;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18SetRealmPrincipalsEPNS_5RealmEP12JSPrincipals"]
            pub fn SetRealmPrincipals(
                realm: *mut root::JS::Realm,
                principals: *mut root::JSPrincipals,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetIsSecureContextEPNS_5RealmE"]
            pub fn GetIsSecureContext(realm: *mut root::JS::Realm) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetDebuggerObservesWasmEPNS_5RealmE"]
            pub fn GetDebuggerObservesWasm(realm: *mut root::JS::Realm) -> bool;
        }
        #[doc = " <div rustbindgen replaces=\"JS::CallArgs\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CallArgs {
            pub argv_: *mut root::JS::Value,
            pub argc_: ::std::os::raw::c_uint,
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of CallArgs"][::std::mem::size_of::<CallArgs>() - 16usize];
            ["Alignment of CallArgs"][::std::mem::align_of::<CallArgs>() - 8usize];
            ["Offset of field: CallArgs::argv_"][::std::mem::offset_of!(CallArgs, argv_) - 0usize];
            ["Offset of field: CallArgs::argc_"][::std::mem::offset_of!(CallArgs, argc_) - 8usize];
        };
        impl CallArgs {
            #[inline]
            pub fn constructing_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_constructing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn constructing__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        0usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_constructing__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        0usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn ignoresReturnValue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_ignoresReturnValue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub unsafe fn ignoresReturnValue__raw(this: *const Self) -> bool {
                unsafe {
                    ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                        ::std::ptr::addr_of!((*this)._bitfield_1),
                        1usize,
                        1u8,
                    ) as u8)
                }
            }
            #[inline]
            pub unsafe fn set_ignoresReturnValue__raw(this: *mut Self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                        1usize,
                        1u8,
                        val as u64,
                    )
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                constructing_: bool,
                ignoresReturnValue_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let constructing_: u8 = unsafe { ::std::mem::transmute(constructing_) };
                    constructing_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let ignoresReturnValue_: u8 =
                        unsafe { ::std::mem::transmute(ignoresReturnValue_) };
                    ignoresReturnValue_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " <div rustbindgen replaces=\"JS::MutableHandleIdVector\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandleIdVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MutableHandleIdVector"]
                [::std::mem::size_of::<MutableHandleIdVector>() - 8usize];
            ["Alignment of MutableHandleIdVector"]
                [::std::mem::align_of::<MutableHandleIdVector>() - 8usize];
            ["Offset of field: MutableHandleIdVector::ptr"]
                [::std::mem::offset_of!(MutableHandleIdVector, ptr) - 0usize];
        };
        #[doc = " <div rustbindgen replaces=\"JS::HandleObjectVector\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of HandleObjectVector"][::std::mem::size_of::<HandleObjectVector>() - 8usize];
            ["Alignment of HandleObjectVector"]
                [::std::mem::align_of::<HandleObjectVector>() - 8usize];
            ["Offset of field: HandleObjectVector::ptr"]
                [::std::mem::offset_of!(HandleObjectVector, ptr) - 0usize];
        };
        #[doc = " <div rustbindgen replaces=\"JS::MutableHandleObjectVector\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of MutableHandleObjectVector"]
                [::std::mem::size_of::<MutableHandleObjectVector>() - 8usize];
            ["Alignment of MutableHandleObjectVector"]
                [::std::mem::align_of::<MutableHandleObjectVector>() - 8usize];
            ["Offset of field: MutableHandleObjectVector::ptr"]
                [::std::mem::offset_of!(MutableHandleObjectVector, ptr) - 0usize];
        };
        #[allow(clippy::unnecessary_operation, clippy::identity_op)]
        const _: () = {
            ["Size of template specialization: GCPolicy_open0_ptr_Realm_close0"]
                [::std::mem::size_of::<root::JS::GCPolicy>() - 1usize];
            ["Align of template specialization: GCPolicy_open0_ptr_Realm_close0"]
                [::std::mem::align_of::<root::JS::GCPolicy>() - 1usize];
        };
    }
    pub type jsbytecode = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtom {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunction {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSObject {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSRuntime {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSScript {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSString {
        _unused: [u8; 0],
    }
    pub type jsid = root::JS::PropertyKey;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSLinearString {
        _unused: [u8; 0],
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSType {
        JSTYPE_UNDEFINED = 0,
        JSTYPE_OBJECT = 1,
        JSTYPE_FUNCTION = 2,
        JSTYPE_STRING = 3,
        JSTYPE_NUMBER = 4,
        JSTYPE_BOOLEAN = 5,
        JSTYPE_SYMBOL = 6,
        JSTYPE_BIGINT = 7,
        JSTYPE_LIMIT = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSProtoKey {
        JSProto_Null = 0,
        JSProto_Object = 1,
        JSProto_Function = 2,
        JSProto_BoundFunction = 3,
        JSProto_Array = 4,
        JSProto_Boolean = 5,
        JSProto_JSON = 6,
        JSProto_Date = 7,
        JSProto_Math = 8,
        JSProto_Number = 9,
        JSProto_String = 10,
        JSProto_RegExp = 11,
        JSProto_Error = 12,
        JSProto_InternalError = 13,
        JSProto_AggregateError = 14,
        JSProto_EvalError = 15,
        JSProto_RangeError = 16,
        JSProto_ReferenceError = 17,
        JSProto_SyntaxError = 18,
        JSProto_TypeError = 19,
        JSProto_URIError = 20,
        JSProto_DebuggeeWouldRun = 21,
        JSProto_CompileError = 22,
        JSProto_LinkError = 23,
        JSProto_RuntimeError = 24,
        JSProto_SuspendError = 25,
        JSProto_ArrayBuffer = 26,
        JSProto_Int8Array = 27,
        JSProto_Uint8Array = 28,
        JSProto_Int16Array = 29,
        JSProto_Uint16Array = 30,
        JSProto_Int32Array = 31,
        JSProto_Uint32Array = 32,
        JSProto_Float32Array = 33,
        JSProto_Float64Array = 34,
        JSProto_Uint8ClampedArray = 35,
        JSProto_BigInt64Array = 36,
        JSProto_BigUint64Array = 37,
        JSProto_Float16Array = 38,
        JSProto_BigInt = 39,
        JSProto_Proxy = 40,
        JSProto_WeakMap = 41,
        JSProto_Map = 42,
        JSProto_Set = 43,
        JSProto_DataView = 44,
        JSProto_Symbol = 45,
        JSProto_ShadowRealm = 46,
        JSProto_SharedArrayBuffer = 47,
        JSProto_Intl = 48,
        JSProto_Collator = 49,
        JSProto_DateTimeFormat = 50,
        JSProto_DisplayNames = 51,
        JSProto_DurationFormat = 52,
        JSProto_ListFormat = 53,
        JSProto_Locale = 54,
        JSProto_NumberFormat = 55,
        JSProto_PluralRules = 56,
        JSProto_RelativeTimeFormat = 57,
        JSProto_Segmenter = 58,
        JSProto_Reflect = 59,
        JSProto_WeakSet = 60,
        JSProto_TypedArray = 61,
        JSProto_Atomics = 62,
        JSProto_SavedFrame = 63,
        JSProto_Promise = 64,
        JSProto_AsyncFunction = 65,
        JSProto_GeneratorFunction = 66,
        JSProto_AsyncGeneratorFunction = 67,
        JSProto_WebAssembly = 68,
        JSProto_WasmModule = 69,
        JSProto_WasmInstance = 70,
        JSProto_WasmMemory = 71,
        JSProto_WasmTable = 72,
        JSProto_WasmGlobal = 73,
        JSProto_WasmTag = 74,
        JSProto_WasmFunction = 75,
        JSProto_WasmSuspending = 76,
        JSProto_WasmException = 77,
        JSProto_FinalizationRegistry = 78,
        JSProto_WeakRef = 79,
        JSProto_Iterator = 80,
        JSProto_AsyncIterator = 81,
        JSProto_Temporal = 82,
        JSProto_Duration = 83,
        JSProto_Instant = 84,
        JSProto_PlainDate = 85,
        JSProto_PlainDateTime = 86,
        JSProto_PlainMonthDay = 87,
        JSProto_PlainYearMonth = 88,
        JSProto_PlainTime = 89,
        JSProto_TemporalNow = 90,
        JSProto_ZonedDateTime = 91,
        JSProto_LIMIT = 92,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneReader {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneWriter {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSConstScalarSpec {
        pub _address: u8,
    }
    pub type JSConstDoubleSpec = root::JSConstScalarSpec;
    pub type JSConstIntegerSpec = root::JSConstScalarSpec;
    pub type arena_id_t = usize;
    extern "C" {
        #[link_name = "\u{1}_Z9JS_AssertPKcS0_i"]
        pub fn JS_Assert(
            s: *const ::std::os::raw::c_char,
            file: *const ::std::os::raw::c_char,
            ln: ::std::os::raw::c_int,
        ) -> !;
    }
    extern "C" {
        #[doc = " Complain when out of memory."]
        #[link_name = "\u{1}_Z20JS_ReportOutOfMemoryP9JSContext"]
        pub fn JS_ReportOutOfMemory(cx: *mut root::JSContext);
    }
    #[repr(C)]
    pub struct JSTracer__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSTracer {
        pub vtable_: *const JSTracer__bindgen_vtable,
        pub runtime_: *mut root::JSRuntime,
        pub kind_: root::JS::TracerKind,
        pub options_: root::JS::TraceOptions,
        pub context_: root::JS::TracingContext,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSTracer"][::std::mem::size_of::<JSTracer>() - 48usize];
        ["Alignment of JSTracer"][::std::mem::align_of::<JSTracer>() - 8usize];
        ["Offset of field: JSTracer::runtime_"]
            [::std::mem::offset_of!(JSTracer, runtime_) - 8usize];
        ["Offset of field: JSTracer::kind_"][::std::mem::offset_of!(JSTracer, kind_) - 16usize];
        ["Offset of field: JSTracer::options_"]
            [::std::mem::offset_of!(JSTracer, options_) - 20usize];
        ["Offset of field: JSTracer::context_"]
            [::std::mem::offset_of!(JSTracer, context_) - 32usize];
    };
    #[doc = " MozRefCountType is Mozilla's reference count type.\n\n We use the same type to represent the refcount of RefCounted objects\n as well, in order to be able to use the leak detection facilities\n that are implemented by XPCOM.\n\n Note that this type is not in the mozilla namespace so that it is\n usable for both C and C++ code."]
    pub type MozRefCountType = usize;
    pub type MozExternalRefCountType = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct Flow {
        pub mFlowId: u64,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of Flow"][::std::mem::size_of::<Flow>() - 8usize];
        ["Alignment of Flow"][::std::mem::align_of::<Flow>() - 8usize];
        ["Offset of field: Flow::mFlowId"][::std::mem::offset_of!(Flow, mFlowId) - 0usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: ProfileBufferEntryWriter_Serializer_open0_Flow_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
        ["Align of template specialization: ProfileBufferEntryWriter_Serializer_open0_Flow_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryWriter_Serializer > () - 1usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: ProfileBufferEntryReader_Deserializer_open0_Flow_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
        ["Align of template specialization: ProfileBufferEntryReader_Deserializer_open0_Flow_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: ProfileBufferEntryReader_Deserializer > () - 1usize] ;
    };
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct ProfilingStack {
        pub capacity: u32,
        pub frames: u64,
        pub stackPointer: u32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of ProfilingStack"][::std::mem::size_of::<ProfilingStack>() - 24usize];
        ["Alignment of ProfilingStack"][::std::mem::align_of::<ProfilingStack>() - 8usize];
        ["Offset of field: ProfilingStack::capacity"]
            [::std::mem::offset_of!(ProfilingStack, capacity) - 0usize];
        ["Offset of field: ProfilingStack::frames"]
            [::std::mem::offset_of!(ProfilingStack, frames) - 8usize];
        ["Offset of field: ProfilingStack::stackPointer"]
            [::std::mem::offset_of!(ProfilingStack, stackPointer) - 16usize];
    };
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSAutoRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSAutoRealm"][::std::mem::size_of::<JSAutoRealm>() - 16usize];
        ["Alignment of JSAutoRealm"][::std::mem::align_of::<JSAutoRealm>() - 8usize];
        ["Offset of field: JSAutoRealm::cx_"][::std::mem::offset_of!(JSAutoRealm, cx_) - 0usize];
        ["Offset of field: JSAutoRealm::oldRealm_"]
            [::std::mem::offset_of!(JSAutoRealm, oldRealm_) - 8usize];
    };
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSAutoNullableRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSAutoNullableRealm"][::std::mem::size_of::<JSAutoNullableRealm>() - 16usize];
        ["Alignment of JSAutoNullableRealm"]
            [::std::mem::align_of::<JSAutoNullableRealm>() - 8usize];
        ["Offset of field: JSAutoNullableRealm::cx_"]
            [::std::mem::offset_of!(JSAutoNullableRealm, cx_) - 0usize];
        ["Offset of field: JSAutoNullableRealm::oldRealm_"]
            [::std::mem::offset_of!(JSAutoNullableRealm, oldRealm_) - 8usize];
    };
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueType {
        JSVAL_TYPE_DOUBLE = 0,
        JSVAL_TYPE_INT32 = 1,
        JSVAL_TYPE_BOOLEAN = 2,
        JSVAL_TYPE_UNDEFINED = 3,
        JSVAL_TYPE_NULL = 4,
        JSVAL_TYPE_MAGIC = 5,
        JSVAL_TYPE_STRING = 6,
        JSVAL_TYPE_SYMBOL = 7,
        JSVAL_TYPE_PRIVATE_GCTHING = 8,
        JSVAL_TYPE_BIGINT = 9,
        JSVAL_TYPE_OBJECT = 12,
        JSVAL_TYPE_UNKNOWN = 32,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueTag {
        JSVAL_TAG_MAX_DOUBLE = 131056,
        JSVAL_TAG_INT32 = 131057,
        JSVAL_TAG_UNDEFINED = 131059,
        JSVAL_TAG_NULL = 131060,
        JSVAL_TAG_BOOLEAN = 131058,
        JSVAL_TAG_MAGIC = 131061,
        JSVAL_TAG_STRING = 131062,
        JSVAL_TAG_SYMBOL = 131063,
        JSVAL_TAG_PRIVATE_GCTHING = 131064,
        JSVAL_TAG_BIGINT = 131065,
        JSVAL_TAG_OBJECT = 131068,
    }
    #[repr(u64)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueShiftedTag {
        JSVAL_SHIFTED_TAG_MAX_DOUBLE = 18444492278190833663,
        JSVAL_SHIFTED_TAG_INT32 = 18444633011384221696,
        JSVAL_SHIFTED_TAG_UNDEFINED = 18444914486360932352,
        JSVAL_SHIFTED_TAG_NULL = 18445055223849287680,
        JSVAL_SHIFTED_TAG_BOOLEAN = 18444773748872577024,
        JSVAL_SHIFTED_TAG_MAGIC = 18445195961337643008,
        JSVAL_SHIFTED_TAG_STRING = 18445336698825998336,
        JSVAL_SHIFTED_TAG_SYMBOL = 18445477436314353664,
        JSVAL_SHIFTED_TAG_PRIVATE_GCTHING = 18445618173802708992,
        JSVAL_SHIFTED_TAG_BIGINT = 18445758911291064320,
        JSVAL_SHIFTED_TAG_OBJECT = 18446181123756130304,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSWhyMagic {
        #[doc = " a hole in a native object's elements"]
        JS_ELEMENTS_HOLE = 0,
        #[doc = " there is not a pending iterator value"]
        JS_NO_ITER_VALUE = 1,
        #[doc = " exception value thrown when closing a generator"]
        JS_GENERATOR_CLOSING = 2,
        #[doc = " used in debug builds to catch tracing errors"]
        JS_ARG_POISON = 3,
        #[doc = " an empty subnode in the AST serializer"]
        JS_SERIALIZE_NO_NODE = 4,
        #[doc = " magic value passed to natives to indicate construction"]
        JS_IS_CONSTRUCTING = 5,
        #[doc = " see class js::HashableValue"]
        JS_HASH_KEY_EMPTY = 6,
        #[doc = " error while running Ion code"]
        JS_ION_ERROR = 7,
        #[doc = " missing recover instruction result"]
        JS_ION_BAILOUT = 8,
        #[doc = " optimized out slot"]
        JS_OPTIMIZED_OUT = 9,
        #[doc = " uninitialized lexical bindings that produce ReferenceError on touch."]
        JS_UNINITIALIZED_LEXICAL = 10,
        #[doc = " arguments object can't be created because environment is dead."]
        JS_MISSING_ARGUMENTS = 11,
        #[doc = " exception value thrown when interrupting irregexp"]
        JS_INTERRUPT_REGEXP = 12,
        #[doc = " for local use"]
        JS_GENERIC_MAGIC = 13,
        #[doc = " When an error object is created without the error cause argument, we set\n the error's cause slot to this magic value."]
        JS_ERROR_WITHOUT_CAUSE = 14,
        #[doc = " When an error object is created without the error cause argument, we set\n the error's cause slot to this magic value."]
        JS_WHY_MAGIC_COUNT = 15,
    }
    pub type JSNative = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool,
    >;
    extern "C" {
        #[doc = " Call a function, passing a this-value and arguments. This is the C++\n equivalent of `rval = Reflect.apply(fun, obj, args)`.\n\n Implements: ES6 7.3.12 Call(F, V, [argumentsList]).\n Use this function to invoke the [[Call]] internal method."]
        #[link_name = "\u{1}_Z20JS_CallFunctionValueP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEERKNS1_16HandleValueArrayENS1_13MutableHandleIS6_EE"]
        pub fn JS_CallFunctionValue(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fval: root::JS::Handle<root::JS::Value>,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_CallFunctionP9JSContextN2JS6HandleIP8JSObjectEENS2_IP10JSFunctionEERKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fun: root::JS::Handle<*mut root::JSFunction>,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the method call `rval = obj[name](args)`."]
        #[link_name = "\u{1}_Z19JS_CallFunctionNameP9JSContextN2JS6HandleIP8JSObjectEEPKcRKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunctionName(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " DEPRECATED\n\n Allocate memory sufficient to contain the characters of |str| truncated to\n Latin-1 and a trailing null terminator, fill the memory with the characters\n interpreted in that manner plus the null terminator, and return a pointer to\n the memory.\n\n This function *loses information* when it copies the characters of |str| if\n |str| contains code units greater than 0xFF.  Additionally, users that\n depend on null-termination will misinterpret the copied characters if |str|\n contains any nulls.  Avoid using this function if possible, because it will\n eventually be removed."]
        #[link_name = "\u{1}_Z23JS_EncodeStringToLatin1P9JSContextP8JSString"]
        pub fn JS_EncodeStringToLatin1(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[doc = " DEPRECATED\n\n Same behavior as JS_EncodeStringToLatin1(), but encode into a UTF-8 string.\n\n This function *loses information* when it copies the characters of |str| if\n |str| contains invalid UTF-16: U+FFFD REPLACEMENT CHARACTER will be copied\n instead.\n\n The returned string is also subject to misinterpretation if |str| contains\n any nulls (which are faithfully transcribed into the returned string, but\n which will implicitly truncate the string if it's passed to functions that\n expect null-terminated strings).\n\n Avoid using this function if possible, because we'll remove it once we can\n devise a better API for the task."]
        #[link_name = "\u{1}_Z21JS_EncodeStringToUTF8P9JSContextN2JS6HandleIP8JSStringEE"]
        pub fn JS_EncodeStringToUTF8(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[doc = " DEPRECATED\n\n Same behavior as JS_EncodeStringToLatin1(), but encode into an ASCII string.\n\n This function asserts in debug mode that the input string contains only\n ASCII characters.\n\n The returned string is also subject to misinterpretation if |str| contains\n any nulls (which are faithfully transcribed into the returned string, but\n which will implicitly truncate the string if it's passed to functions that\n expect null-terminated strings).\n\n Avoid using this function if possible, because we'll remove it once we can\n devise a better API for the task."]
        #[link_name = "\u{1}_Z22JS_EncodeStringToASCIIP9JSContextP8JSString"]
        pub fn JS_EncodeStringToASCII(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueChars;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtomState {
        _unused: [u8; 0],
    }
    #[doc = " Add a property named by id to obj."]
    pub type JSAddPropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            v: root::JS::HandleValue,
        ) -> bool,
    >;
    #[doc = " Delete a property named by id in obj.\n\n If an error occurred, return false as per normal JSAPI error practice.\n\n If no error occurred, but the deletion attempt wasn't allowed (perhaps\n because the property was non-configurable), call result.fail() and\n return true.  This will cause |delete obj[id]| to evaluate to false in\n non-strict mode code, and to throw a TypeError in strict mode code.\n\n If no error occurred and the deletion wasn't disallowed (this is *not* the\n same as saying that a deletion actually occurred -- deleting a non-existent\n property, or an inherited property, is allowed -- it's just pointless),\n call result.succeed() and return true."]
    pub type JSDeletePropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool,
    >;
    #[doc = " The type of ObjectOps::enumerate. This callback overrides a portion of\n SpiderMonkey's default [[Enumerate]] internal method. When an ordinary object\n is enumerated, that object and each object on its prototype chain is tested\n for an enumerate op, and those ops are called in order. The properties each\n op adds to the 'properties' vector are added to the set of values the for-in\n loop will iterate over. All of this is nonstandard.\n\n An object is \"enumerated\" when it's the target of a for-in loop or\n JS_Enumerate(). The callback's job is to populate 'properties' with the\n object's property keys. If `enumerableOnly` is true, the callback should only\n add enumerable properties."]
    pub type JSNewEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool,
    >;
    #[doc = " The old-style JSClass.enumerate op should define all lazy properties not\n yet reflected in obj."]
    pub type JSEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool,
    >;
    #[doc = " The type of ObjectOps::funToString.  This callback allows an object to\n provide a custom string to use when Function.prototype.toString is invoked on\n that object.  A null return value means OOM."]
    pub type JSFunToStringOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isToSource: bool,
        ) -> *mut root::JSString,
    >;
    #[doc = " Resolve a lazy property named by id in obj by defining it directly in obj.\n Lazy properties are those reflected from some peer native property space\n (e.g., the DOM attributes for a given node reflected as obj) on demand.\n\n JS looks for a property in an object, and if not found, tries to resolve\n the given id. *resolvedp should be set to true iff the property was defined\n on |obj|.\n\n See JS::dbg::ShouldAvoidSideEffects in Debug.h if this function has any\n other side-effect than just resolving the property."]
    pub type JSResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolvedp: *mut bool,
        ) -> bool,
    >;
    #[doc = " A class with a resolve hook can optionally have a mayResolve hook. This hook\n must have no side effects and must return true for a given id if the resolve\n hook may resolve this id. This is useful when we're doing a \"pure\" lookup: if\n mayResolve returns false, we know we don't have to call the effectful resolve\n hook.\n\n maybeObj, if non-null, is the object on which we're doing the lookup. This\n can be nullptr: during JIT compilation we sometimes know the Class but not\n the object."]
    pub type JSMayResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool,
    >;
    #[doc = " Finalize obj, which the garbage collector has determined to be unreachable\n from other live objects or from GC roots.  Obviously, finalizers must never\n store a reference to obj."]
    pub type JSFinalizeOp = ::std::option::Option<
        unsafe extern "C" fn(gcx: *mut root::JS::GCContext, obj: *mut root::JSObject),
    >;
    #[doc = " Function type for trace operation of the class called to enumerate all\n traceable things reachable from obj's private data structure. For each such\n thing, a trace implementation must call JS::TraceEdge on the thing's\n location.\n\n JSTraceOp implementation can assume that no other threads mutates object\n state. It must not change state of the object or corresponding native\n structures. The only exception for this rule is the case when the embedding\n needs a tight integration with GC. In that case the embedding can check if\n the traversal is a part of the marking phase through calling\n JS_IsGCMarkingTracer and apply a special code like emptying caches or\n marking its native structures."]
    pub type JSTraceOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, obj: *mut root::JSObject),
    >;
    pub type JSObjectMovedOp = ::std::option::Option<
        unsafe extern "C" fn(obj: *mut root::JSObject, old: *mut root::JSObject) -> usize,
    >;
    extern "C" {
        #[link_name = "\u{1}_ZL18JS_NULL_CLASS_SPEC"]
        pub static JS_NULL_CLASS_SPEC: *const root::js::ClassSpec;
    }
    extern "C" {
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_EXT"]
        pub static JS_NULL_CLASS_EXT: *const root::js::ClassExtension;
    }
    extern "C" {
        #[link_name = "\u{1}_ZL18JS_NULL_OBJECT_OPS"]
        pub static JS_NULL_OBJECT_OPS: *const root::js::ObjectOps;
    }
    pub const JSCLASS_DELAY_METADATA_BUILDER: u32 = 2;
    pub const JSCLASS_IS_WRAPPED_NATIVE: u32 = 4;
    pub const JSCLASS_SLOT0_IS_NSISUPPORTS: u32 = 8;
    pub const JSCLASS_IS_DOMJSCLASS: u32 = 16;
    pub const JSCLASS_HAS_XRAYED_CONSTRUCTOR: u32 = 32;
    pub const JSCLASS_EMULATES_UNDEFINED: u32 = 64;
    pub const JSCLASS_USERBIT1: u32 = 128;
    pub const JSCLASS_RESERVED_SLOTS_SHIFT: usize = 8;
    pub const JSCLASS_RESERVED_SLOTS_WIDTH: u32 = 8;
    pub const JSCLASS_RESERVED_SLOTS_MASK: u32 = 255;
    pub const JSCLASS_HIGH_FLAGS_SHIFT: u32 = 16;
    pub const JSCLASS_INTERNAL_FLAG1: u32 = 65536;
    pub const JSCLASS_IS_GLOBAL: u32 = 131072;
    pub const JSCLASS_INTERNAL_FLAG2: u32 = 262144;
    pub const JSCLASS_IS_PROXY: u32 = 524288;
    pub const JSCLASS_SKIP_NURSERY_FINALIZE: u32 = 1048576;
    pub const JSCLASS_USERBIT2: u32 = 2097152;
    pub const JSCLASS_USERBIT3: u32 = 4194304;
    pub const JSCLASS_BACKGROUND_FINALIZE: u32 = 8388608;
    pub const JSCLASS_FOREGROUND_FINALIZE: u32 = 16777216;
    pub const JSCLASS_GLOBAL_APPLICATION_SLOTS: u32 = 5;
    pub const JSCLASS_GLOBAL_SLOT_COUNT: u32 = 6;
    pub const JSCLASS_GLOBAL_FLAGS: u32 = 132608;
    pub const JSCLASS_CACHED_PROTO_SHIFT: u32 = 25;
    pub const JSCLASS_CACHED_PROTO_MASK: u32 = 127;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSClassOps {
        pub addProperty: root::JSAddPropertyOp,
        pub delProperty: root::JSDeletePropertyOp,
        pub enumerate: root::JSEnumerateOp,
        pub newEnumerate: root::JSNewEnumerateOp,
        pub resolve: root::JSResolveOp,
        pub mayResolve: root::JSMayResolveOp,
        pub finalize: root::JSFinalizeOp,
        pub call: root::JSNative,
        pub construct: root::JSNative,
        pub trace: root::JSTraceOp,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSClassOps"][::std::mem::size_of::<JSClassOps>() - 80usize];
        ["Alignment of JSClassOps"][::std::mem::align_of::<JSClassOps>() - 8usize];
        ["Offset of field: JSClassOps::addProperty"]
            [::std::mem::offset_of!(JSClassOps, addProperty) - 0usize];
        ["Offset of field: JSClassOps::delProperty"]
            [::std::mem::offset_of!(JSClassOps, delProperty) - 8usize];
        ["Offset of field: JSClassOps::enumerate"]
            [::std::mem::offset_of!(JSClassOps, enumerate) - 16usize];
        ["Offset of field: JSClassOps::newEnumerate"]
            [::std::mem::offset_of!(JSClassOps, newEnumerate) - 24usize];
        ["Offset of field: JSClassOps::resolve"]
            [::std::mem::offset_of!(JSClassOps, resolve) - 32usize];
        ["Offset of field: JSClassOps::mayResolve"]
            [::std::mem::offset_of!(JSClassOps, mayResolve) - 40usize];
        ["Offset of field: JSClassOps::finalize"]
            [::std::mem::offset_of!(JSClassOps, finalize) - 48usize];
        ["Offset of field: JSClassOps::call"][::std::mem::offset_of!(JSClassOps, call) - 56usize];
        ["Offset of field: JSClassOps::construct"]
            [::std::mem::offset_of!(JSClassOps, construct) - 64usize];
        ["Offset of field: JSClassOps::trace"][::std::mem::offset_of!(JSClassOps, trace) - 72usize];
    };
    extern "C" {
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_OPS"]
        pub static JS_NULL_CLASS_OPS: *const root::JSClassOps;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSClass {
        pub name: *const ::std::os::raw::c_char,
        pub flags: u32,
        pub cOps: *const root::JSClassOps,
        pub spec: *const root::js::ClassSpec,
        pub ext: *const root::js::ClassExtension,
        pub oOps: *const root::js::ObjectOps,
    }
    pub const JSClass_NON_NATIVE: u32 = 262144;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSClass"][::std::mem::size_of::<JSClass>() - 48usize];
        ["Alignment of JSClass"][::std::mem::align_of::<JSClass>() - 8usize];
        ["Offset of field: JSClass::name"][::std::mem::offset_of!(JSClass, name) - 0usize];
        ["Offset of field: JSClass::flags"][::std::mem::offset_of!(JSClass, flags) - 8usize];
        ["Offset of field: JSClass::cOps"][::std::mem::offset_of!(JSClass, cOps) - 16usize];
        ["Offset of field: JSClass::spec"][::std::mem::offset_of!(JSClass, spec) - 24usize];
        ["Offset of field: JSClass::ext"][::std::mem::offset_of!(JSClass, ext) - 32usize];
        ["Offset of field: JSClass::oOps"][::std::mem::offset_of!(JSClass, oOps) - 40usize];
    };
    extern "C" {
        #[link_name = "\u{1}_Z13JS_NewContextjP9JSRuntime"]
        pub fn JS_NewContext(
            maxbytes: u32,
            parentRuntime: *mut root::JSRuntime,
        ) -> *mut root::JSContext;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DestroyContextP9JSContext"]
        pub fn JS_DestroyContext(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetContextPrivateP9JSContext"]
        pub fn JS_GetContextPrivate(cx: *mut root::JSContext) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_SetContextPrivateP9JSContextPv"]
        pub fn JS_SetContextPrivate(cx: *mut root::JSContext, data: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetParentRuntimeP9JSContext"]
        pub fn JS_GetParentRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_GetRuntimeP9JSContext"]
        pub fn JS_GetRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetFutexCanWaitP9JSContext"]
        pub fn JS_SetFutexCanWait(cx: *mut root::JSContext);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSGCParamKey {
        #[doc = " Maximum nominal heap before last ditch GC.\n\n Soft limit on the number of bytes we are allowed to allocate in the GC\n heap. Attempts to allocate gcthings over this limit will return null and\n subsequently invoke the standard OOM machinery, independent of available\n physical memory.\n\n Pref: javascript.options.mem.max\n Default: 0xffffffff"]
        JSGC_MAX_BYTES = 0,
        #[doc = " Maximum size of the generational GC nurseries.\n\n This will be rounded to the nearest gc::ChunkSize.\n\n Pref: javascript.options.mem.nursery.max_kb\n Default: JS::DefaultNurseryMaxBytes"]
        JSGC_MAX_NURSERY_BYTES = 2,
        #[doc = " Amount of bytes allocated by the GC."]
        JSGC_BYTES = 3,
        #[doc = " Number of times GC has been invoked. Includes both major and minor GC."]
        JSGC_NUMBER = 4,
        #[doc = " Whether incremental GC is enabled. If not, GC will always run to\n completion.\n\n prefs: javascript.options.mem.gc_incremental.\n Default: false"]
        JSGC_INCREMENTAL_GC_ENABLED = 5,
        #[doc = " Whether per-zone GC is enabled. If not, all zones are collected every time.\n\n prefs: javascript.options.mem.gc_per_zone\n Default: false"]
        JSGC_PER_ZONE_GC_ENABLED = 6,
        #[doc = " Number of cached empty GC chunks."]
        JSGC_UNUSED_CHUNKS = 7,
        #[doc = " Total number of allocated GC chunks."]
        JSGC_TOTAL_CHUNKS = 8,
        #[doc = " Max milliseconds to spend in an incremental GC slice.\n\n A value of zero means there is no maximum.\n\n Pref: javascript.options.mem.gc_incremental_slice_ms\n Default: DefaultTimeBudgetMS."]
        JSGC_SLICE_TIME_BUDGET_MS = 9,
        #[doc = " GCs less than this far apart in milliseconds will be considered\n 'high-frequency GCs'.\n\n Pref: javascript.options.mem.gc_high_frequency_time_limit_ms\n Default: HighFrequencyThreshold"]
        JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,
        #[doc = " Upper limit for classifying a heap as small (MB).\n\n Dynamic heap growth thresholds are based on whether the heap is small,\n medium or large. Heaps smaller than this size are classified as small;\n larger heaps are classified as medium or large.\n\n Pref: javascript.options.mem.gc_small_heap_size_max_mb\n Default: SmallHeapSizeMaxBytes"]
        JSGC_SMALL_HEAP_SIZE_MAX = 12,
        #[doc = " Lower limit for classifying a heap as large (MB).\n\n Dynamic heap growth thresholds are based on whether the heap is small,\n medium or large. Heaps larger than this size are classified as large;\n smaller heaps are classified as small or medium.\n\n Pref: javascript.options.mem.gc_large_heap_size_min_mb\n Default: LargeHeapSizeMinBytes"]
        JSGC_LARGE_HEAP_SIZE_MIN = 13,
        #[doc = " Heap growth factor for small heaps in the high-frequency GC state.\n\n Pref: javascript.options.mem.gc_high_frequency_small_heap_growth\n Default: HighFrequencySmallHeapGrowth"]
        JSGC_HIGH_FREQUENCY_SMALL_HEAP_GROWTH = 14,
        #[doc = " Heap growth factor for large heaps in the high-frequency GC state.\n\n Pref: javascript.options.mem.gc_high_frequency_large_heap_growth\n Default: HighFrequencyLargeHeapGrowth"]
        JSGC_HIGH_FREQUENCY_LARGE_HEAP_GROWTH = 15,
        #[doc = " Heap growth factor for low frequency GCs.\n\n This factor is applied regardless of the size of the heap when not in the\n high-frequency GC state.\n\n Pref: javascript.options.mem.gc_low_frequency_heap_growth\n Default: LowFrequencyHeapGrowth"]
        JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,
        #[doc = " Whether balanced heap limits are enabled.\n\n If this is set to true then heap limits are calculated in a way designed to\n balance memory usage optimally between many heaps.\n\n Otherwise, heap limits are set based on a linear multiple of the retained\n size after the last collection.\n\n Pref: javascript.options.mem.gc_balanced_heap_limits\n Default: BalancedHeapLimitsEnabled"]
        JSGC_BALANCED_HEAP_LIMITS_ENABLED = 17,
        #[doc = " Heap growth parameter for balanced heap limit calculation.\n\n This parameter trades off GC time for memory usage. Smaller values result\n in lower memory use and larger values result in less time spent collecting.\n\n Heap limits are set to the heap's retained size plus some extra space. The\n extra space is calculated based on several factors but is scaled\n proportionally to this parameter.\n\n Pref: javascript.options.mem.gc_heap_growth_factor\n Default: HeapGrowthFactor"]
        JSGC_HEAP_GROWTH_FACTOR = 18,
        #[doc = " Lower limit for collecting a zone (MB).\n\n Zones smaller than this size will not normally be collected.\n\n Pref: javascript.options.mem.gc_allocation_threshold_mb\n Default GCZoneAllocThresholdBase"]
        JSGC_ALLOCATION_THRESHOLD = 19,
        #[doc = " We try to keep at least this many unused chunks in the free chunk pool at\n all times, even after a shrinking GC.\n\n Pref: javascript.options.mem.gc_min_empty_chunk_count\n Default: MinEmptyChunkCount"]
        JSGC_MIN_EMPTY_CHUNK_COUNT = 21,
        #[doc = " Whether compacting GC is enabled.\n\n Pref: javascript.options.mem.gc_compacting\n Default: CompactingEnabled"]
        JSGC_COMPACTING_ENABLED = 23,
        #[doc = " Whether parallel marking is enabled.\n\n Pref: javascript.options.mem.gc_parallel_marking\n Default: ParallelMarkingEnabled"]
        JSGC_PARALLEL_MARKING_ENABLED = 24,
        #[doc = " Limit of how far over the incremental trigger threshold we allow the heap\n to grow before finishing a collection non-incrementally, for small heaps.\n\n We trigger an incremental GC when a trigger threshold is reached but the\n collection may not be fast enough to keep up with the mutator. At some\n point we finish the collection non-incrementally.\n\n Default: SmallHeapIncrementalLimit\n Pref: javascript.options.mem.gc_small_heap_incremental_limit"]
        JSGC_SMALL_HEAP_INCREMENTAL_LIMIT = 25,
        #[doc = " Limit of how far over the incremental trigger threshold we allow the heap\n to grow before finishing a collection non-incrementally, for large heaps.\n\n Default: LargeHeapIncrementalLimit\n Pref: javascript.options.mem.gc_large_heap_incremental_limit"]
        JSGC_LARGE_HEAP_INCREMENTAL_LIMIT = 26,
        #[doc = " Free space bytes threshold for eager nursery collection.\n\n Default: NurseryChunkUsableSize / 4\n Pref: javascript.options.mem.nursery_eager_collection_threshold_kb"]
        JSGC_NURSERY_EAGER_COLLECTION_THRESHOLD_KB = 27,
        #[doc = " Free space fraction threshold for eager nursery collection. This is a\n percentage (from 0 to 99).\n\n Default: 25\n Pref: javascript.options.mem.nursery_eager_collection_threshold_percent"]
        JSGC_NURSERY_EAGER_COLLECTION_THRESHOLD_PERCENT = 30,
        #[doc = " Minimum size of the generational GC nurseries.\n\n This value will be rounded to the nearest Nursery::SubChunkStep if below\n gc::ChunkSize, otherwise it'll be rounded to the nearest gc::ChunkSize.\n\n Default: Nursery::SubChunkLimit\n Pref: javascript.options.mem.nursery.min_kb"]
        JSGC_MIN_NURSERY_BYTES = 31,
        #[doc = " The minimum time to allow between triggering last ditch GCs in seconds.\n\n Default: 60 seconds\n Pref: None"]
        JSGC_MIN_LAST_DITCH_GC_PERIOD = 32,
        #[doc = " The delay (in heapsize kilobytes) between slices of an incremental GC.\n\n Default: ZoneAllocDelayBytes"]
        JSGC_ZONE_ALLOC_DELAY_KB = 33,
        #[doc = " The delay (in heapsize kilobytes) between slices of an incremental GC.\n\n Default: ZoneAllocDelayBytes"]
        JSGC_NURSERY_BYTES = 34,
        #[doc = " Retained size base value for calculating malloc heap threshold.\n\n Default: MallocThresholdBase"]
        JSGC_MALLOC_THRESHOLD_BASE = 35,
        #[doc = " Whether incremental weakmap marking is enabled.\n\n Pref: javascript.options.mem.incremental_weakmap\n Default: IncrementalWeakMarkEnabled"]
        JSGC_INCREMENTAL_WEAKMAP_ENABLED = 37,
        #[doc = " The chunk size in bytes for this system.\n\n This parameter is read-only."]
        JSGC_CHUNK_BYTES = 38,
        #[doc = " The number of background threads to use for parallel GC work for each CPU\n core, expressed as an integer percentage.\n\n Pref: javascript.options.mem.gc_helper_thread_ratio"]
        JSGC_HELPER_THREAD_RATIO = 39,
        #[doc = " The maximum number of background threads to use for parallel GC work.\n\n Pref: javascript.options.mem.gc_max_helper_threads"]
        JSGC_MAX_HELPER_THREADS = 40,
        #[doc = " The number of background threads to use for parallel GC work.\n\n This parameter is read-only and is set based on the\n JSGC_HELPER_THREAD_RATIO and JSGC_MAX_HELPER_THREADS parameters."]
        JSGC_HELPER_THREAD_COUNT = 41,
        #[doc = " A number that is incremented on every major GC slice."]
        JSGC_MAJOR_GC_NUMBER = 44,
        #[doc = " A number that is incremented on every minor GC."]
        JSGC_MINOR_GC_NUMBER = 45,
        #[doc = " JS::MaybeRunNurseryCollection will collect the nursery if it hasn't been\n collected in this many milliseconds.\n\n Default: 5000\n Pref: javascript.options.mem.nursery_eager_collection_timeout_ms"]
        JSGC_NURSERY_EAGER_COLLECTION_TIMEOUT_MS = 46,
        #[doc = " The system page size in KB.\n\n This parameter is read-only."]
        JSGC_SYSTEM_PAGE_SIZE_KB = 47,
        #[doc = " In an incremental GC, this determines the point at which to start\n increasing the slice budget and frequency of allocation triggered slices to\n try to avoid reaching the incremental limit and finishing the collection\n synchronously.\n\n The threshold is calculated by subtracting this value from the heap's\n incremental limit."]
        JSGC_URGENT_THRESHOLD_MB = 48,
        #[doc = " Get the number of threads used for parallel marking.\n\n Pref: None."]
        JSGC_MARKING_THREAD_COUNT = 49,
        #[doc = " The heap size above which to use parallel marking.\n\n Pref: javascript.options.mem.gc_parallel_marking_threshold_mb\n Default: ParallelMarkingThresholdMB"]
        JSGC_PARALLEL_MARKING_THRESHOLD_MB = 50,
        #[doc = " Whether the semispace nursery is enabled.\n\n Pref: javascript.options.mem.gc_experimental_semispace_nursery\n Default: SemispaceNurseryEnabled"]
        JSGC_SEMISPACE_NURSERY_ENABLED = 51,
        #[doc = " Set the maximum number of threads to use for parallel marking, if enabled.\n\n The actual number used is calculated based on the number of available\n helper threads and can be found by getting the JSGC_MARKING_THREAD_COUNT\n parameter.\n\n Pref: javascript.options.mem.gc_max_parallel_marking_threads\n Default: 2."]
        JSGC_MAX_MARKING_THREADS = 52,
        #[doc = " Whether to automatically generate missing allocation sites so data about\n them can be gathered.\n\n Pref: None, this is an internal engine feature.\n Default: false."]
        JSGC_GENERATE_MISSING_ALLOC_SITES = 53,
        #[doc = " A number that is incremented every GC slice."]
        JSGC_SLICE_NUMBER = 54,
        #[doc = " Whether the nursery is enabled.\n\n Pref: javascript.options.mem.gc_generational\n Default: true"]
        JSGC_NURSERY_ENABLED = 55,
        #[doc = " Whether the nursery is enabled.\n\n Pref: javascript.options.mem.gc_generational\n Default: true"]
        JSGC_HIGH_FREQUENCY_MODE = 56,
        #[doc = " The engine attempts to keep nursery collection time less than this limit by\n restricting the size of the nursery.\n\n This only happens in optimized builds. It does not happen during pageload\n (as indicated by js::gc::SetPerformanceHint).\n\n Setting this to zero disables this feature.\n\n Default: 4\n Pref: javascript.options.mem.nursery_max_time_goal_ms"]
        JSGC_NURSERY_MAX_TIME_GOAL_MS = 57,
    }
    pub type JSTraceDataOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, data: *mut ::std::os::raw::c_void),
    >;
    pub type JSGrayRootsTracer = ::std::option::Option<
        unsafe extern "C" fn(
            trc: *mut root::JSTracer,
            budget: *mut root::JS::SliceBudget,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSGCStatus {
        JSGC_BEGIN = 0,
        JSGC_END = 1,
    }
    pub type JSObjectsTenuredCallback = ::std::option::Option<
        unsafe extern "C" fn(gcx: *mut root::JS::GCContext, data: *mut ::std::os::raw::c_void),
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSFinalizeStatus {
        #[doc = " Called when preparing to sweep a group of zones, before anything has been\n swept.  The collector will not yield to the mutator before calling the\n callback with JSFINALIZE_GROUP_START status."]
        JSFINALIZE_GROUP_PREPARE = 0,
        #[doc = " Called after preparing to sweep a group of zones. Weak references to\n unmarked things have been removed at this point, but no GC things have\n been swept. The collector may yield to the mutator after this point."]
        JSFINALIZE_GROUP_START = 1,
        #[doc = " Called after sweeping a group of zones. All dead GC things have been\n swept at this point."]
        JSFINALIZE_GROUP_END = 2,
        #[doc = " Called at the end of collection when everything has been swept."]
        JSFINALIZE_COLLECTION_END = 3,
    }
    pub type JSFinalizeCallback = ::std::option::Option<
        unsafe extern "C" fn(
            gcx: *mut root::JS::GCContext,
            status: root::JSFinalizeStatus,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSWeakPointerZonesCallback = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, data: *mut ::std::os::raw::c_void),
    >;
    pub type JSWeakPointerCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            trc: *mut root::JSTracer,
            comp: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSHostCleanupFinalizationRegistryCallback = ::std::option::Option<
        unsafe extern "C" fn(
            doCleanup: *mut root::JSFunction,
            incumbentGlobal: *mut root::JSObject,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    #[repr(C)]
    pub struct JSExternalStringCallbacks__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Each external string has a pointer to JSExternalStringCallbacks. Embedders\n can use this to implement custom finalization or memory reporting behavior."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSExternalStringCallbacks {
        pub vtable_: *const JSExternalStringCallbacks__bindgen_vtable,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSExternalStringCallbacks"]
            [::std::mem::size_of::<JSExternalStringCallbacks>() - 8usize];
        ["Alignment of JSExternalStringCallbacks"]
            [::std::mem::align_of::<JSExternalStringCallbacks>() - 8usize];
    };
    pub type JSGCCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            status: root::JSGCStatus,
            reason: root::JS::GCReason,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    extern "C" {
        #[doc = " Register externally maintained GC roots.\n\n traceOp: the trace operation. For each root the implementation should call\n          JS::TraceEdge whenever the root contains a traceable thing.\n data:    the data argument to pass to each invocation of traceOp."]
        #[link_name = "\u{1}_Z24JS_AddExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_AddExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Undo a call to JS_AddExtraGCRootsTracer."]
        #[link_name = "\u{1}_Z27JS_RemoveExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_RemoveExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z5JS_GCP9JSContextN2JS8GCReasonE"]
        pub fn JS_GC(cx: *mut root::JSContext, reason: root::JS::GCReason);
    }
    extern "C" {
        #[link_name = "\u{1}_Z10JS_MaybeGCP9JSContext"]
        pub fn JS_MaybeGC(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_SetGCCallbackP9JSContextPFvS0_10JSGCStatusN2JS8GCReasonEPvES4_"]
        pub fn JS_SetGCCallback(
            cx: *mut root::JSContext,
            cb: root::JSGCCallback,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_SetObjectsTenuredCallbackP9JSContextPFvPN2JS9GCContextEPvES4_"]
        pub fn JS_SetObjectsTenuredCallback(
            cx: *mut root::JSContext,
            cb: root::JSObjectsTenuredCallback,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_AddFinalizeCallbackP9JSContextPFvPN2JS9GCContextE16JSFinalizeStatusPvES5_"]
        pub fn JS_AddFinalizeCallback(
            cx: *mut root::JSContext,
            cb: root::JSFinalizeCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_RemoveFinalizeCallbackP9JSContextPFvPN2JS9GCContextE16JSFinalizeStatusPvE"]
        pub fn JS_RemoveFinalizeCallback(cx: *mut root::JSContext, cb: root::JSFinalizeCallback);
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_AddWeakPointerZonesCallbackP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_AddWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_RemoveWeakPointerZonesCallbackP9JSContextPFvP8JSTracerPvE"]
        pub fn JS_RemoveWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z36JS_AddWeakPointerCompartmentCallbackP9JSContextPFvP8JSTracerPN2JS11CompartmentEPvES6_"]
        pub fn JS_AddWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z39JS_RemoveWeakPointerCompartmentCallbackP9JSContextPFvP8JSTracerPN2JS11CompartmentEPvE"]
        pub fn JS_RemoveWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_UpdateWeakPointerAfterGCP8JSTracerPN2JS4HeapIP8JSObjectEE"]
        pub fn JS_UpdateWeakPointerAfterGC(
            trc: *mut root::JSTracer,
            objp: *mut root::JS::Heap<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z38JS_UpdateWeakPointerAfterGCUnbarrieredP8JSTracerPP8JSObject"]
        pub fn JS_UpdateWeakPointerAfterGCUnbarriered(
            trc: *mut root::JSTracer,
            objp: *mut *mut root::JSObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_SetGCParameterP9JSContext12JSGCParamKeyj"]
        pub fn JS_SetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey, value: u32);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_ResetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_ResetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_GetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey) -> u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z40JS_SetGCParametersBasedOnAvailableMemoryP9JSContextj"]
        pub fn JS_SetGCParametersBasedOnAvailableMemory(cx: *mut root::JSContext, availMemMB: u32);
    }
    extern "C" {
        #[doc = " Create a new JSString whose chars member refers to external memory, i.e.,\n memory requiring application-specific finalization."]
        #[link_name = "\u{1}_Z26JS_NewExternalStringLatin1P9JSContextPKhmPK25JSExternalStringCallbacks"]
        pub fn JS_NewExternalStringLatin1(
            cx: *mut root::JSContext,
            chars: *const root::JS::Latin1Char,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_NewExternalUCStringP9JSContextPKDsmPK25JSExternalStringCallbacks"]
        pub fn JS_NewExternalUCString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Create a new JSString whose chars member may refer to external memory.\n If a new external string is allocated, |*allocatedExternal| is set to true.\n Otherwise the returned string is either not an external string or an\n external string allocated by a previous call and |*allocatedExternal| is set\n to false. If |*allocatedExternal| is false, |fin| won't be called."]
        #[link_name = "\u{1}_Z31JS_NewMaybeExternalStringLatin1P9JSContextPKhmPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalStringLatin1(
            cx: *mut root::JSContext,
            chars: *const root::JS::Latin1Char,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewMaybeExternalUCStringP9JSContextPKDsmPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalUCString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Similar to JS_NewMaybeExternalStringLatin1.\n\n Create an external Latin1 string if the utf8 buffer contains only ASCII\n chars, otherwise copy the chars into a non-external string."]
        #[link_name = "\u{1}_Z29JS_NewMaybeExternalStringUTF8P9JSContextRKN2JS9UTF8CharsEPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalStringUTF8(
            cx: *mut root::JSContext,
            utf8: *const root::JS::UTF8Chars,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Return the 'callbacks' arg passed to JS_NewExternalStringLatin1,\n JS_NewExternalUCString, JS_NewMaybeExternalStringLatin1,\n or JS_NewMaybeExternalUCString."]
        #[link_name = "\u{1}_Z29JS_GetExternalStringCallbacksP8JSString"]
        pub fn JS_GetExternalStringCallbacks(
            str_: *mut root::JSString,
        ) -> *const root::JSExternalStringCallbacks;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_DefineDebuggerObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineDebuggerObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_TracerEnterLabelLatin1P9JSContextPKc"]
        pub fn JS_TracerEnterLabelLatin1(
            cx: *mut root::JSContext,
            label: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_TracerEnterLabelTwoByteP9JSContextPKDs"]
        pub fn JS_TracerEnterLabelTwoByte(cx: *mut root::JSContext, label: *const u16);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_TracerIsTracingP9JSContext"]
        pub fn JS_TracerIsTracing(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_TracerLeaveLabelLatin1P9JSContextPKc"]
        pub fn JS_TracerLeaveLabelLatin1(
            cx: *mut root::JSContext,
            label: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_TracerLeaveLabelTwoByteP9JSContextPKDs"]
        pub fn JS_TracerLeaveLabelTwoByte(cx: *mut root::JSContext, label: *const u16);
    }
    #[repr(C)]
    pub struct JSErrorInterceptor__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Callback used to intercept JavaScript errors."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSErrorInterceptor {
        pub vtable_: *const JSErrorInterceptor__bindgen_vtable,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSErrorInterceptor"][::std::mem::size_of::<JSErrorInterceptor>() - 8usize];
        ["Alignment of JSErrorInterceptor"][::std::mem::align_of::<JSErrorInterceptor>() - 8usize];
    };
    extern "C" {
        #[link_name = "\u{1}_Z30JS_SetErrorInterceptorCallbackP9JSRuntimeP18JSErrorInterceptor"]
        pub fn JS_SetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
            callback: *mut root::JSErrorInterceptor,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_GetErrorInterceptorCallbackP9JSRuntime"]
        pub fn JS_GetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
        ) -> *mut root::JSErrorInterceptor;
    }
    impl root::JSExnType {
        pub const JSEXN_FIRST: root::JSExnType = JSExnType::JSEXN_ERR;
    }
    impl root::JSExnType {
        pub const JSEXN_WARN: root::JSExnType = JSExnType::JSEXN_ERROR_LIMIT;
    }
    #[repr(u32)]
    #[doc = " Possible exception types. These types are part of a JSErrorFormatString\n structure. They define which error to throw in case of a runtime error.\n\n JSEXN_WARN is used for warnings, that are not strictly errors but are handled\n using the generalized error reporting mechanism.  (One side effect of this\n type is to not prepend 'Error:' to warning messages.)  This value can go away\n if we ever decide to use an entirely separate mechanism for warnings.\n\n The errors and warnings are arranged in alphabetically within their\n respective categories as defined in the comments below."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSExnType {
        JSEXN_ERR = 0,
        JSEXN_INTERNALERR = 1,
        JSEXN_AGGREGATEERR = 2,
        JSEXN_EVALERR = 3,
        JSEXN_RANGEERR = 4,
        JSEXN_REFERENCEERR = 5,
        JSEXN_SYNTAXERR = 6,
        JSEXN_TYPEERR = 7,
        JSEXN_URIERR = 8,
        JSEXN_DEBUGGEEWOULDRUN = 9,
        JSEXN_WASMCOMPILEERROR = 10,
        JSEXN_WASMLINKERROR = 11,
        JSEXN_WASMRUNTIMEERROR = 12,
        JSEXN_WASMSUSPENDERROR = 13,
        JSEXN_ERROR_LIMIT = 14,
        JSEXN_NOTE = 15,
        JSEXN_LIMIT = 16,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSErrorFormatString {
        #[doc = " The error message name in ASCII."]
        pub name: *const ::std::os::raw::c_char,
        #[doc = " The error format string in ASCII."]
        pub format: *const ::std::os::raw::c_char,
        #[doc = " The number of arguments to expand in the formatted error message."]
        pub argCount: u16,
        #[doc = " One of the JSExnType constants above."]
        pub exnType: i16,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSErrorFormatString"][::std::mem::size_of::<JSErrorFormatString>() - 24usize];
        ["Alignment of JSErrorFormatString"]
            [::std::mem::align_of::<JSErrorFormatString>() - 8usize];
        ["Offset of field: JSErrorFormatString::name"]
            [::std::mem::offset_of!(JSErrorFormatString, name) - 0usize];
        ["Offset of field: JSErrorFormatString::format"]
            [::std::mem::offset_of!(JSErrorFormatString, format) - 8usize];
        ["Offset of field: JSErrorFormatString::argCount"]
            [::std::mem::offset_of!(JSErrorFormatString, argCount) - 16usize];
        ["Offset of field: JSErrorFormatString::exnType"]
            [::std::mem::offset_of!(JSErrorFormatString, exnType) - 18usize];
    };
    pub type JSErrorCallback = ::std::option::Option<
        unsafe extern "C" fn(
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
        ) -> *const root::JSErrorFormatString,
    >;
    #[doc = " Base class that implements parts shared by JSErrorReport and\n JSErrorNotes::Note."]
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorBase {
        pub message_: root::JS::ConstUTF8CharsZ,
        pub filename: root::JS::ConstUTF8CharsZ,
        pub sourceId: ::std::os::raw::c_uint,
        pub lineno: u32,
        pub column: root::JS::ColumnNumberOneOrigin,
        pub errorNumber: ::std::os::raw::c_uint,
        pub errorMessageName: *const ::std::os::raw::c_char,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 7usize],
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSErrorBase"][::std::mem::size_of::<JSErrorBase>() - 48usize];
        ["Alignment of JSErrorBase"][::std::mem::align_of::<JSErrorBase>() - 8usize];
        ["Offset of field: JSErrorBase::message_"]
            [::std::mem::offset_of!(JSErrorBase, message_) - 0usize];
        ["Offset of field: JSErrorBase::filename"]
            [::std::mem::offset_of!(JSErrorBase, filename) - 8usize];
        ["Offset of field: JSErrorBase::sourceId"]
            [::std::mem::offset_of!(JSErrorBase, sourceId) - 16usize];
        ["Offset of field: JSErrorBase::lineno"]
            [::std::mem::offset_of!(JSErrorBase, lineno) - 20usize];
        ["Offset of field: JSErrorBase::column"]
            [::std::mem::offset_of!(JSErrorBase, column) - 24usize];
        ["Offset of field: JSErrorBase::errorNumber"]
            [::std::mem::offset_of!(JSErrorBase, errorNumber) - 28usize];
        ["Offset of field: JSErrorBase::errorMessageName"]
            [::std::mem::offset_of!(JSErrorBase, errorMessageName) - 32usize];
    };
    impl JSErrorBase {
        #[inline]
        pub fn ownsMessage_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsMessage_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn ownsMessage__raw(this: *const Self) -> bool {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u8)
            }
        }
        #[inline]
        pub unsafe fn set_ownsMessage__raw(this: *mut Self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    0usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn new_bitfield_1(ownsMessage_: bool) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let ownsMessage_: u8 = unsafe { ::std::mem::transmute(ownsMessage_) };
                ownsMessage_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[doc = " Notes associated with JSErrorReport."]
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorNotes {
        pub notes_: root::__BindgenOpaqueArray<u64, 4usize>,
    }
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorNotes_Note {
        pub _base: root::JSErrorBase,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSErrorNotes_Note"][::std::mem::size_of::<JSErrorNotes_Note>() - 48usize];
        ["Alignment of JSErrorNotes_Note"][::std::mem::align_of::<JSErrorNotes_Note>() - 8usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSErrorNotes_iterator {
        pub note_: *mut u64,
    }
    pub type JSErrorNotes_iterator_iterator_category = root::std::input_iterator_tag;
    #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be\n transferred out of a UniquePtr through explicit action, but otherwise the\n resource is destroyed when the UniquePtr is destroyed.\n\n UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr\n in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr\n obviously *can't* copy ownership of its singly-owned resource.  So what\n happens if you try to copy one?  Bizarrely, ownership is implicitly\n *transferred*, preserving single ownership but breaking code that assumes a\n copy of an object is identical to the original.  (This is why auto_ptr is\n prohibited in STL containers.)\n\n UniquePtr solves this problem by being *movable* rather than copyable.\n Instead of passing a |UniquePtr u| directly to the constructor or assignment\n operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*\n ownership out of |u|, into the target of the construction/assignment.  After\n the transfer completes, |u| contains |nullptr| and may be safely destroyed.\n This preserves single ownership but also allows UniquePtr to be moved by\n algorithms that have been made move-safe.  (Note: if |u| is instead a\n temporary expression, don't use |Move()|: just pass the expression, because\n it's already move-ready.  For more information see Move.h.)\n\n UniquePtr is also better than std::auto_ptr in that the deletion operation is\n customizable.  An optional second template parameter specifies a class that\n (through its operator()(T*)) implements the desired deletion policy.  If no\n policy is specified, mozilla::DefaultDelete<T> is used -- which will either\n |delete| or |delete[]| the resource, depending whether the resource is an\n array.  Custom deletion policies ideally should be empty classes (no member\n fields, no member fields in base classes, no virtual methods/inheritance),\n because then UniquePtr can be just as efficient as a raw pointer.\n\n Use of UniquePtr proceeds like so:\n\n   UniquePtr<int> g1; // initializes to nullptr\n   g1.reset(new int); // switch resources using reset()\n   g1 = nullptr; // clears g1, deletes the int\n\n   UniquePtr<int> g2(new int); // owns that int\n   int* p = g2.release(); // g2 leaks its int -- still requires deletion\n   delete p; // now freed\n\n   struct S { int x; S(int x) : x(x) {} };\n   UniquePtr<S> g3, g4(new S(5));\n   g3 = std::move(g4); // g3 owns the S, g4 cleared\n   S* p = g3.get(); // g3 still owns |p|\n   assert(g3->x == 5); // operator-> works (if .get() != nullptr)\n   assert((*g3).x == 5); // also operator* (again, if not cleared)\n   std::swap(g3, g4); // g4 now owns the S, g3 cleared\n   g3.swap(g4);  // g3 now owns the S, g4 cleared\n   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared\n   g5.reset(); // deletes the S, g5 cleared\n\n   struct FreePolicy { void operator()(void* p) { free(p); } };\n   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));\n   int* ptr = g6.get();\n   g6 = nullptr; // calls free(ptr)\n\n Now, carefully note a few things you *can't* do:\n\n   UniquePtr<int> b1;\n   b1 = new int; // BAD: can only assign another UniquePtr\n   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()\n\n   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr\n   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr\n\n (Note that changing a UniquePtr to store a direct |new| expression is\n permitted, but usually you should use MakeUnique, defined at the end of this\n header.)\n\n A few miscellaneous notes:\n\n UniquePtr, when not instantiated for an array type, can be move-constructed\n and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>\n instantiations where U converts to T and E converts to D.  If you want to use\n this, you're going to have to specify a deletion policy for both UniquePtr\n instantations, and T pretty much has to have a virtual destructor.  In other\n words, this doesn't work:\n\n   struct Base { virtual ~Base() {} };\n   struct Derived : Base {};\n\n   UniquePtr<Base> b1;\n   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert\n   UniquePtr<Derived> d1(std::move(b));\n\n   UniquePtr<Base> b2;\n   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay\n\n UniquePtr is specialized for array types.  Specializing with an array type\n creates a smart-pointer version of that array -- not a pointer to such an\n array.\n\n   UniquePtr<int[]> arr(new int[5]);\n   arr[0] = 4;\n\n What else is different?  Deletion of course uses |delete[]|.  An operator[]\n is provided.  Functionality that doesn't make sense for arrays is removed.\n The constructors and mutating methods only accept array pointers (not T*, U*\n that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.\n\n It's perfectly okay for a function to return a UniquePtr. This transfers\n the UniquePtr's sole ownership of the data, to the fresh UniquePtr created\n in the calling function, that will then solely own that data. Such functions\n can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where\n |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.\n\n UniquePtr will commonly be a member of a class, with lifetime equivalent to\n that of that class.  If you want to expose the related resource, you could\n expose a raw pointer via |get()|, but ownership of a raw pointer is\n inherently unclear.  So it's better to expose a |const UniquePtr&| instead.\n This prohibits mutation but still allows use of |get()| when needed (but\n operator-> is preferred).  Of course, you can only use this smart pointer as\n long as the enclosing class instance remains live -- no different than if you\n exposed the |get()| raw pointer.\n\n To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|\n argument.  To specify an inout parameter (where the method may or may not\n take ownership of the resource, or reset it), or to specify an out parameter\n (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|\n argument.  To unconditionally transfer ownership of a UniquePtr\n into a method, use a |UniquePtr| argument.  To conditionally transfer\n ownership of a resource into a method, should the method want it, use a\n |UniquePtr&&| argument."]
    pub type JSErrorNotes_iterator_value_type = u64;
    pub type JSErrorNotes_iterator_difference_type = isize;
    pub type JSErrorNotes_iterator_pointer = *mut root::JSErrorNotes_iterator_value_type;
    pub type JSErrorNotes_iterator_reference = *mut root::JSErrorNotes_iterator_value_type;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSErrorNotes_iterator"][::std::mem::size_of::<JSErrorNotes_iterator>() - 8usize];
        ["Alignment of JSErrorNotes_iterator"]
            [::std::mem::align_of::<JSErrorNotes_iterator>() - 8usize];
        ["Offset of field: JSErrorNotes_iterator::note_"]
            [::std::mem::offset_of!(JSErrorNotes_iterator, note_) - 0usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSErrorNotes"][::std::mem::size_of::<JSErrorNotes>() - 32usize];
        ["Alignment of JSErrorNotes"][::std::mem::align_of::<JSErrorNotes>() - 8usize];
        ["Offset of field: JSErrorNotes::notes_"]
            [::std::mem::offset_of!(JSErrorNotes, notes_) - 0usize];
    };
    #[doc = " Describes a single error or warning that occurs in the execution of script."]
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorReport {
        pub _base: root::JSErrorBase,
        pub linebuf_: *const u16,
        pub linebufLength_: usize,
        pub tokenOffset_: usize,
        pub notes: u64,
        pub exnType: i16,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 5usize],
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSErrorReport"][::std::mem::size_of::<JSErrorReport>() - 88usize];
        ["Alignment of JSErrorReport"][::std::mem::align_of::<JSErrorReport>() - 8usize];
        ["Offset of field: JSErrorReport::linebuf_"]
            [::std::mem::offset_of!(JSErrorReport, linebuf_) - 48usize];
        ["Offset of field: JSErrorReport::linebufLength_"]
            [::std::mem::offset_of!(JSErrorReport, linebufLength_) - 56usize];
        ["Offset of field: JSErrorReport::tokenOffset_"]
            [::std::mem::offset_of!(JSErrorReport, tokenOffset_) - 64usize];
        ["Offset of field: JSErrorReport::notes"]
            [::std::mem::offset_of!(JSErrorReport, notes) - 72usize];
        ["Offset of field: JSErrorReport::exnType"]
            [::std::mem::offset_of!(JSErrorReport, exnType) - 80usize];
    };
    impl JSErrorReport {
        #[inline]
        pub fn isMuted(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_isMuted(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isMuted_raw(this: *const Self) -> bool {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u8)
            }
        }
        #[inline]
        pub unsafe fn set_isMuted_raw(this: *mut Self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    0usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn isWarning_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_isWarning_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isWarning__raw(this: *const Self) -> bool {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    1u8,
                ) as u8)
            }
        }
        #[inline]
        pub unsafe fn set_isWarning__raw(this: *mut Self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    1usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn ownsLinebuf_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsLinebuf_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn ownsLinebuf__raw(this: *const Self) -> bool {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    2usize,
                    1u8,
                ) as u8)
            }
        }
        #[inline]
        pub unsafe fn set_ownsLinebuf__raw(this: *mut Self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    2usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            isMuted: bool,
            isWarning_: bool,
            ownsLinebuf_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let isMuted: u8 = unsafe { ::std::mem::transmute(isMuted) };
                isMuted as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let isWarning_: u8 = unsafe { ::std::mem::transmute(isWarning_) };
                isWarning_ as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let ownsLinebuf_: u8 = unsafe { ::std::mem::transmute(ownsLinebuf_) };
                ownsLinebuf_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    extern "C" {
        #[doc = " Report an exception represented by the sprintf-like conversion of format\n and its arguments."]
        #[link_name = "\u{1}_Z19JS_ReportErrorASCIIP9JSContextPKcz"]
        pub fn JS_ReportErrorASCII(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_ReportErrorLatin1P9JSContextPKcz"]
        pub fn JS_ReportErrorLatin1(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_ReportErrorUTF8P9JSContextPKcz"]
        pub fn JS_ReportErrorUTF8(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_ReportErrorNumberASCIIP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberASCII(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberASCIIVAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberASCIIVA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberLatin1P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberLatin1(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_ReportErrorNumberLatin1VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberLatin1VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_ReportErrorNumberUTF8P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUTF8(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberUTF8VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberUTF8VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_ReportErrorNumberUTF8ArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKc"]
        pub fn JS_ReportErrorNumberUTF8Array(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            args: *mut *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_ReportErrorNumberUCP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUC(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberUCArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKDs"]
        pub fn JS_ReportErrorNumberUCArray(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            args: *mut *const u16,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_ExpandErrorArgumentsASCIIP9JSContextPFPK19JSErrorFormatStringPvjEjP13JSErrorReportz"]
        pub fn JS_ExpandErrorArgumentsASCII(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            errorNumber: ::std::os::raw::c_uint,
            reportp: *mut root::JSErrorReport,
            ...
        ) -> bool;
    }
    extern "C" {
        #[doc = " Complain when an allocation size overflows the maximum supported limit."]
        #[link_name = "\u{1}_Z27JS_ReportAllocationOverflowP9JSContext"]
        pub fn JS_ReportAllocationOverflow(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_IsExceptionPendingP9JSContext"]
        pub fn JS_IsExceptionPending(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_IsThrowingOutOfMemoryP9JSContext"]
        pub fn JS_IsThrowingOutOfMemory(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetPendingExceptionP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPendingException(
            cx: *mut root::JSContext,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_SetPendingExceptionP9JSContextN2JS6HandleINS1_5ValueEEENS1_22ExceptionStackBehaviorE"]
        pub fn JS_SetPendingException(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            behavior: root::JS::ExceptionStackBehavior,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_ClearPendingExceptionP9JSContext"]
        pub fn JS_ClearPendingException(cx: *mut root::JSContext);
    }
    extern "C" {
        #[doc = " If the given object is an exception object, the exception will have (or be\n able to lazily create) an error report struct, and this function will return\n the address of that struct.  Otherwise, it returns nullptr. The lifetime\n of the error report struct that might be returned is the same as the\n lifetime of the exception object."]
        #[link_name = "\u{1}_Z21JS_ErrorFromExceptionP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ErrorFromException(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSErrorReport;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_IsGlobalObjectP8JSObject"]
        pub fn JS_IsGlobalObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewGlobalObjectP9JSContextPK7JSClassP12JSPrincipalsN2JS21OnNewGlobalHookOptionERKNS6_12RealmOptionsE"]
        pub fn JS_NewGlobalObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            principals: *mut root::JSPrincipals,
            hookOption: root::JS::OnNewGlobalHookOption,
            options: *const root::JS::RealmOptions,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Spidermonkey does not have a good way of keeping track of what compartments\n should be marked on their own. We can mark the roots unconditionally, but\n marking GC things only relevant in live compartments is hard. To mitigate\n this, we create a static trace hook, installed on each global object, from\n which we can be sure the compartment is relevant, and mark it.\n\n It is still possible to specify custom trace hooks for global object classes.\n They can be provided via the RealmOptions passed to JS_NewGlobalObject."]
        #[link_name = "\u{1}_Z24JS_GlobalObjectTraceHookP8JSTracerP8JSObject"]
        pub fn JS_GlobalObjectTraceHook(trc: *mut root::JSTracer, global: *mut root::JSObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_FireOnNewGlobalObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FireOnNewGlobalObject(cx: *mut root::JSContext, global: root::JS::HandleObject);
    }
    pub type JSInterruptCallback =
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::JSContext) -> bool>;
    extern "C" {
        #[link_name = "\u{1}_Z20JS_CheckForInterruptP9JSContext"]
        pub fn JS_CheckForInterrupt(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AddInterruptCallbackP9JSContextPFbS0_E"]
        pub fn JS_AddInterruptCallback(
            cx: *mut root::JSContext,
            callback: root::JSInterruptCallback,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_DisableInterruptCallbackP9JSContext"]
        pub fn JS_DisableInterruptCallback(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_ResetInterruptCallbackP9JSContextb"]
        pub fn JS_ResetInterruptCallback(cx: *mut root::JSContext, enable: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_RequestInterruptCallbackP9JSContext"]
        pub fn JS_RequestInterruptCallback(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_RequestInterruptCallbackCanWaitP9JSContext"]
        pub fn JS_RequestInterruptCallbackCanWait(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z9JS_mallocP9JSContextm"]
        pub fn JS_malloc(cx: *mut root::JSContext, nbytes: usize) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z10JS_reallocP9JSContextPvmm"]
        pub fn JS_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " A wrapper for |js_free(p)| that may delay |js_free(p)| invocation as a\n performance optimization.  |cx| may be nullptr."]
        #[link_name = "\u{1}_Z7JS_freeP9JSContextPv"]
        pub fn JS_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Same as above, but for buffers that will be used with the BYOB\n (Bring Your Own Buffer) JSString creation functions, such as\n JS_NewLatin1String and JS_NewUCString"]
        #[link_name = "\u{1}_Z16JS_string_mallocP9JSContextm"]
        pub fn JS_string_malloc(
            cx: *mut root::JSContext,
            nbytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_string_reallocP9JSContextPvmm"]
        pub fn JS_string_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_string_freeP9JSContextPv"]
        pub fn JS_string_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
    }
    #[repr(C)]
    pub struct JSPrincipals__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSPrincipals {
        pub vtable_: *const JSPrincipals__bindgen_vtable,
        pub refcount: u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSPrincipals_RefCount {
        pub value: i32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPrincipals_RefCount"][::std::mem::size_of::<JSPrincipals_RefCount>() - 4usize];
        ["Alignment of JSPrincipals_RefCount"]
            [::std::mem::align_of::<JSPrincipals_RefCount>() - 4usize];
        ["Offset of field: JSPrincipals_RefCount::value"]
            [::std::mem::offset_of!(JSPrincipals_RefCount, value) - 0usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPrincipals"][::std::mem::size_of::<JSPrincipals>() - 16usize];
        ["Alignment of JSPrincipals"][::std::mem::align_of::<JSPrincipals>() - 8usize];
        ["Offset of field: JSPrincipals::refcount"]
            [::std::mem::offset_of!(JSPrincipals, refcount) - 8usize];
    };
    extern "C" {
        #[link_name = "\u{1}_Z17JS_HoldPrincipalsP12JSPrincipals"]
        pub fn JS_HoldPrincipals(principals: *mut root::JSPrincipals);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DropPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_DropPrincipals(cx: *mut root::JSContext, principals: *mut root::JSPrincipals);
    }
    pub type JSSubsumesOp = ::std::option::Option<
        unsafe extern "C" fn(
            first: *mut root::JSPrincipals,
            second: *mut root::JSPrincipals,
        ) -> bool,
    >;
    pub type JSCSPEvalChecker = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            kind: root::JS::RuntimeCode,
            codeString: root::JS::Handle<*mut root::JSString>,
            compilationType: root::JS::CompilationType,
            parameterStrings: root::JS::Handle<
                root::JS::StackGCVector<*mut root::JSString, root::js::TempAllocPolicy>,
            >,
            bodyString: root::JS::Handle<*mut root::JSString>,
            parameterArgs: root::JS::Handle<
                root::JS::StackGCVector<root::JS::Value, root::js::TempAllocPolicy>,
            >,
            bodyArg: root::JS::Handle<root::JS::Value>,
            outCanCompileStrings: *mut bool,
        ) -> bool,
    >;
    pub type JSCodeForEvalOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            code: root::JS::HandleObject,
            outCode: root::JS::MutableHandle<*mut root::JSString>,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSSecurityCallbacks {
        pub contentSecurityPolicyAllows: root::JSCSPEvalChecker,
        pub codeForEvalGets: root::JSCodeForEvalOp,
        pub subsumes: root::JSSubsumesOp,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSSecurityCallbacks"][::std::mem::size_of::<JSSecurityCallbacks>() - 24usize];
        ["Alignment of JSSecurityCallbacks"]
            [::std::mem::align_of::<JSSecurityCallbacks>() - 8usize];
        ["Offset of field: JSSecurityCallbacks::contentSecurityPolicyAllows"]
            [::std::mem::offset_of!(JSSecurityCallbacks, contentSecurityPolicyAllows) - 0usize];
        ["Offset of field: JSSecurityCallbacks::codeForEvalGets"]
            [::std::mem::offset_of!(JSSecurityCallbacks, codeForEvalGets) - 8usize];
        ["Offset of field: JSSecurityCallbacks::subsumes"]
            [::std::mem::offset_of!(JSSecurityCallbacks, subsumes) - 16usize];
    };
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetSecurityCallbacksP9JSContextPK19JSSecurityCallbacks"]
        pub fn JS_SetSecurityCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSSecurityCallbacks,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetSecurityCallbacksP9JSContext"]
        pub fn JS_GetSecurityCallbacks(
            cx: *mut root::JSContext,
        ) -> *const root::JSSecurityCallbacks;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetTrustedPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_SetTrustedPrincipals(cx: *mut root::JSContext, prin: *mut root::JSPrincipals);
    }
    pub type JSDestroyPrincipalsOp =
        ::std::option::Option<unsafe extern "C" fn(principals: *mut root::JSPrincipals)>;
    extern "C" {
        #[link_name = "\u{1}_Z32JS_InitDestroyPrincipalsCallbackP9JSContextPFvP12JSPrincipalsE"]
        pub fn JS_InitDestroyPrincipalsCallback(
            cx: *mut root::JSContext,
            destroyPrincipals: root::JSDestroyPrincipalsOp,
        );
    }
    pub type JSReadPrincipalsOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            reader: *mut root::JSStructuredCloneReader,
            outPrincipals: *mut *mut root::JSPrincipals,
        ) -> bool,
    >;
    extern "C" {
        #[link_name = "\u{1}_Z29JS_InitReadPrincipalsCallbackP9JSContextPFbS0_P23JSStructuredCloneReaderPP12JSPrincipalsE"]
        pub fn JS_InitReadPrincipalsCallback(
            cx: *mut root::JSContext,
            read: root::JSReadPrincipalsOp,
        );
    }
    extern "C" {
        #[doc = " Define a property on obj.\n\n This function uses JS::ObjectOpResult to indicate conditions that ES6\n specifies as non-error failures. This is inconvenient at best, so use this\n function only if you are implementing a proxy handler's defineProperty()\n method. For all other purposes, use one of the many DefineProperty functions\n below that throw an exception in all failure cases.\n\n Implements: ES6 [[DefineOwnProperty]] internal method."]
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefinePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Define a property on obj, throwing a TypeError if the attempt fails.\n This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`."]
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefinePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEEj"]
        pub fn JS_DefinePropertyById2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefinePropertyById3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_S5_j"]
        pub fn JS_DefinePropertyById4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_j"]
        pub fn JS_DefinePropertyById5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_IP8JSStringEEj"]
        pub fn JS_DefinePropertyById6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEij"]
        pub fn JS_DefinePropertyById7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEjj"]
        pub fn JS_DefinePropertyById8(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEdj"]
        pub fn JS_DefinePropertyById9(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefineProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_S5_j"]
        pub fn JS_DefineProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_j"]
        pub fn JS_DefineProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_IP8JSStringEEj"]
        pub fn JS_DefineProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcij"]
        pub fn JS_DefineProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcjj"]
        pub fn JS_DefineProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcdj"]
        pub fn JS_DefineProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefineUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefineUCProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineUCProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_S5_j"]
        pub fn JS_DefineUCProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_j"]
        pub fn JS_DefineUCProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_IP8JSStringEEj"]
        pub fn JS_DefineUCProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmij"]
        pub fn JS_DefineUCProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmjj"]
        pub fn JS_DefineUCProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmdj"]
        pub fn JS_DefineUCProperty8(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_S5_j"]
        pub fn JS_DefineElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_j"]
        pub fn JS_DefineElement2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEEj"]
        pub fn JS_DefineElement3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjij"]
        pub fn JS_DefineElement4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjjj"]
        pub fn JS_DefineElement5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjdj"]
        pub fn JS_DefineElement6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Compute the expression `id in obj`.\n\n If obj has an own or inherited property obj[id], set *foundp = true and\n return true. If not, set *foundp = false and return true. On error, return\n false with an exception pending.\n\n Implements: ES6 [[Has]] internal method."]
        #[link_name = "\u{1}_Z18JS_HasPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_HasPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_HasUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_HasUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            vp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_HasElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_HasElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether obj has an own property with the key `id`.\n\n Implements: ES6 7.3.11 HasOwnProperty(O, P)."]
        #[link_name = "\u{1}_Z21JS_HasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_HasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the value of the property `obj[id]`, or undefined if no such property\n exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`.\n\n Most callers don't need the `receiver` argument. Consider using\n JS_GetProperty instead. (But if you're implementing a proxy handler's set()\n method, it's often correct to call this function and pass the receiver\n through.)\n\n Implements: ES6 [[Get]] internal method."]
        #[link_name = "\u{1}_Z23JS_ForwardGetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEENS1_13MutableHandleIS8_EE"]
        pub fn JS_ForwardGetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            receiver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_ForwardGetElementToP9JSContextN2JS6HandleIP8JSObjectEEjS5_NS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ForwardGetElementTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            receiver: root::JS::Handle<*mut root::JSObject>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the value of the property `obj[id]`, or undefined if no such property\n exists. The result is stored in vp.\n\n Implements: ES6 7.3.1 Get(O, P)."]
        #[link_name = "\u{1}_Z18JS_GetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_GetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_GetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_GetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`.\n\n This function has a `receiver` argument that most callers don't need.\n Consider using JS_SetProperty instead.\n\n Implements: ES6 [[Set]] internal method."]
        #[link_name = "\u{1}_Z23JS_ForwardSetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEES9_RNS1_14ObjectOpResultE"]
        pub fn JS_ForwardSetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            v: root::JS::Handle<root::JS::Value>,
            receiver: root::JS::Handle<root::JS::Value>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the assignment `obj[id] = v`.\n\n This function performs non-strict assignment, so if the property is\n read-only, nothing happens and no error is thrown."]
        #[link_name = "\u{1}_Z18JS_SetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEE"]
        pub fn JS_SetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_SetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEE"]
        pub fn JS_SetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_SetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEE"]
        pub fn JS_SetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEE"]
        pub fn JS_SetElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_"]
        pub fn JS_SetElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEE"]
        pub fn JS_SetElement2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<*mut root::JSString>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_SetElement3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: i32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjj"]
        pub fn JS_SetElement4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjd"]
        pub fn JS_SetElement5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: f64,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Delete a property. This is the C++ equivalent of\n `result = Reflect.deleteProperty(obj, id)`.\n\n This function has a `result` out parameter that most callers don't need.\n Unless you can pass through an ObjectOpResult provided by your caller, it's\n probably best to use the JS_DeletePropertyById signature with just 3\n arguments.\n\n Implements: ES6 [[Delete]] internal method."]
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEERNS1_14ObjectOpResultE"]
        pub fn JS_DeletePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DeleteUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEjRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Delete a property, ignoring strict failures. This is the C++ equivalent of\n the JS `delete obj[id]` in non-strict mode code."]
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEE"]
        pub fn JS_DeletePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKc"]
        pub fn JS_DeleteProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEj"]
        pub fn JS_DeleteElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get an array of the non-symbol enumerable properties of obj.\n This function is roughly equivalent to:\n\n     var result = [];\n     for (key in obj) {\n         result.push(key);\n     }\n     return result;\n\n This is the closest thing we currently have to the ES6 [[Enumerate]]\n internal method.\n\n The array of ids returned by JS_Enumerate must be rooted to protect its\n contents from garbage collection. Use JS::Rooted<JS::IdVector>."]
        #[link_name = "\u{1}_Z12JS_EnumerateP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_8GCVectorINS1_11PropertyKeyELm0EN2js15TempAllocPolicyEEEEE"]
        pub fn JS_Enumerate(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            props: root::JS::MutableHandle<root::JS::IdVector>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Other property-defining functions"]
        #[link_name = "\u{1}_Z15JS_DefineObjectP9JSContextN2JS6HandleIP8JSObjectEEPKcPK7JSClassj"]
        pub fn JS_DefineObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            clasp: *const root::JSClass,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefinePropertiesP9JSContextN2JS6HandleIP8JSObjectEEPK14JSPropertySpec"]
        pub fn JS_DefineProperties(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            ps: *const root::JSPropertySpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_AlreadyHasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_AlreadyHasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_AlreadyHasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_AlreadyHasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_AlreadyHasOwnUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_AlreadyHasOwnUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AlreadyHasOwnElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_AlreadyHasOwnElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_DefineFunctionsP9JSContextN2JS6HandleIP8JSObjectEEPK14JSFunctionSpec"]
        pub fn JS_DefineFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fs: *const root::JSFunctionSpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefineFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineUCFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefineFunctionByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunctionById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    #[doc = " The property is visible in for/in loops."]
    pub const JSPROP_ENUMERATE: u8 = 1;
    #[doc = " The property is non-writable.  This flag is only valid for data properties."]
    pub const JSPROP_READONLY: u8 = 2;
    #[doc = " The property is non-configurable: it can't be deleted, and if it's an\n accessor descriptor, its getter and setter can't be changed."]
    pub const JSPROP_PERMANENT: u8 = 4;
    #[doc = " Resolve hooks and enumerate hooks must pass this flag when calling\n JS_Define* APIs to reify lazily-defined properties.\n\n JSPROP_RESOLVING is used only with property-defining APIs. It tells the\n engine to skip the resolve hook when performing the lookup at the beginning\n of property definition. This keeps the resolve hook from accidentally\n triggering itself: unchecked recursion.\n\n For enumerate hooks, triggering the resolve hook would be merely silly, not\n fatal, except in some cases involving non-configurable properties."]
    pub const JSPROP_RESOLVING: ::std::os::raw::c_uint = 8;
    pub const JSPROP_FLAGS_MASK: ::std::os::raw::c_uint = 15;
    #[doc = " Wrapper to relace JSNative for JSPropertySpecs and JSFunctionSpecs. This will\n allow us to pass one JSJitInfo per function with the property/function spec,\n without additional field overhead."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSNativeWrapper {
        pub op: root::JSNative,
        pub info: *const root::JSJitInfo,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSNativeWrapper"][::std::mem::size_of::<JSNativeWrapper>() - 16usize];
        ["Alignment of JSNativeWrapper"][::std::mem::align_of::<JSNativeWrapper>() - 8usize];
        ["Offset of field: JSNativeWrapper::op"]
            [::std::mem::offset_of!(JSNativeWrapper, op) - 0usize];
        ["Offset of field: JSNativeWrapper::info"]
            [::std::mem::offset_of!(JSNativeWrapper, info) - 8usize];
    };
    #[doc = " Description of a property. JS_DefineProperties and JS_InitClass take arrays\n of these and define many properties at once. JS_PSG, JS_PSGS and JS_PS_END\n are helper macros for defining such arrays."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec {
        pub name: root::JSPropertySpec_Name,
        pub attributes_: u8,
        pub kind_: root::JSPropertySpec_Kind,
        pub u: root::JSPropertySpec_AccessorsOrValue,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSPropertySpec_SelfHostedWrapper {
        pub unused: root::JSNative,
        pub funname: *const ::std::os::raw::c_char,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec_SelfHostedWrapper"]
            [::std::mem::size_of::<JSPropertySpec_SelfHostedWrapper>() - 16usize];
        ["Alignment of JSPropertySpec_SelfHostedWrapper"]
            [::std::mem::align_of::<JSPropertySpec_SelfHostedWrapper>() - 8usize];
        ["Offset of field: JSPropertySpec_SelfHostedWrapper::unused"]
            [::std::mem::offset_of!(JSPropertySpec_SelfHostedWrapper, unused) - 0usize];
        ["Offset of field: JSPropertySpec_SelfHostedWrapper::funname"]
            [::std::mem::offset_of!(JSPropertySpec_SelfHostedWrapper, funname) - 8usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_ValueWrapper {
        pub type_: root::JSPropertySpec_ValueWrapper_Type,
        pub __bindgen_anon_1: root::JSPropertySpec_ValueWrapper__bindgen_ty_1,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSPropertySpec_ValueWrapper_Type {
        String = 0,
        Int32 = 1,
        Double = 2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_ValueWrapper__bindgen_ty_1 {
        pub string: *const ::std::os::raw::c_char,
        pub int32: i32,
        pub double_: f64,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec_ValueWrapper__bindgen_ty_1"]
            [::std::mem::size_of::<JSPropertySpec_ValueWrapper__bindgen_ty_1>() - 8usize];
        ["Alignment of JSPropertySpec_ValueWrapper__bindgen_ty_1"]
            [::std::mem::align_of::<JSPropertySpec_ValueWrapper__bindgen_ty_1>() - 8usize];
        ["Offset of field: JSPropertySpec_ValueWrapper__bindgen_ty_1::string"]
            [::std::mem::offset_of!(JSPropertySpec_ValueWrapper__bindgen_ty_1, string) - 0usize];
        ["Offset of field: JSPropertySpec_ValueWrapper__bindgen_ty_1::int32"]
            [::std::mem::offset_of!(JSPropertySpec_ValueWrapper__bindgen_ty_1, int32) - 0usize];
        ["Offset of field: JSPropertySpec_ValueWrapper__bindgen_ty_1::double_"]
            [::std::mem::offset_of!(JSPropertySpec_ValueWrapper__bindgen_ty_1, double_) - 0usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec_ValueWrapper"]
            [::std::mem::size_of::<JSPropertySpec_ValueWrapper>() - 16usize];
        ["Alignment of JSPropertySpec_ValueWrapper"]
            [::std::mem::align_of::<JSPropertySpec_ValueWrapper>() - 8usize];
        ["Offset of field: JSPropertySpec_ValueWrapper::type_"]
            [::std::mem::offset_of!(JSPropertySpec_ValueWrapper, type_) - 0usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Accessor {
        pub native: root::JSNativeWrapper,
        pub selfHosted: root::JSPropertySpec_SelfHostedWrapper,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec_Accessor"]
            [::std::mem::size_of::<JSPropertySpec_Accessor>() - 16usize];
        ["Alignment of JSPropertySpec_Accessor"]
            [::std::mem::align_of::<JSPropertySpec_Accessor>() - 8usize];
        ["Offset of field: JSPropertySpec_Accessor::native"]
            [::std::mem::offset_of!(JSPropertySpec_Accessor, native) - 0usize];
        ["Offset of field: JSPropertySpec_Accessor::selfHosted"]
            [::std::mem::offset_of!(JSPropertySpec_Accessor, selfHosted) - 0usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_AccessorsOrValue {
        pub accessors: root::JSPropertySpec_AccessorsOrValue_Accessors,
        pub value: root::JSPropertySpec_ValueWrapper,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_AccessorsOrValue_Accessors {
        pub getter: root::JSPropertySpec_Accessor,
        pub setter: root::JSPropertySpec_Accessor,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec_AccessorsOrValue_Accessors"]
            [::std::mem::size_of::<JSPropertySpec_AccessorsOrValue_Accessors>() - 32usize];
        ["Alignment of JSPropertySpec_AccessorsOrValue_Accessors"]
            [::std::mem::align_of::<JSPropertySpec_AccessorsOrValue_Accessors>() - 8usize];
        ["Offset of field: JSPropertySpec_AccessorsOrValue_Accessors::getter"]
            [::std::mem::offset_of!(JSPropertySpec_AccessorsOrValue_Accessors, getter) - 0usize];
        ["Offset of field: JSPropertySpec_AccessorsOrValue_Accessors::setter"]
            [::std::mem::offset_of!(JSPropertySpec_AccessorsOrValue_Accessors, setter) - 16usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec_AccessorsOrValue"]
            [::std::mem::size_of::<JSPropertySpec_AccessorsOrValue>() - 32usize];
        ["Alignment of JSPropertySpec_AccessorsOrValue"]
            [::std::mem::align_of::<JSPropertySpec_AccessorsOrValue>() - 8usize];
        ["Offset of field: JSPropertySpec_AccessorsOrValue::accessors"]
            [::std::mem::offset_of!(JSPropertySpec_AccessorsOrValue, accessors) - 0usize];
        ["Offset of field: JSPropertySpec_AccessorsOrValue::value"]
            [::std::mem::offset_of!(JSPropertySpec_AccessorsOrValue, value) - 0usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Name {
        pub string_: *const ::std::os::raw::c_char,
        pub symbol_: usize,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec_Name"][::std::mem::size_of::<JSPropertySpec_Name>() - 8usize];
        ["Alignment of JSPropertySpec_Name"]
            [::std::mem::align_of::<JSPropertySpec_Name>() - 8usize];
        ["Offset of field: JSPropertySpec_Name::string_"]
            [::std::mem::offset_of!(JSPropertySpec_Name, string_) - 0usize];
        ["Offset of field: JSPropertySpec_Name::symbol_"]
            [::std::mem::offset_of!(JSPropertySpec_Name, symbol_) - 0usize];
    };
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSPropertySpec_Kind {
        Value = 0,
        SelfHostedAccessor = 1,
        NativeAccessor = 2,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSPropertySpec"][::std::mem::size_of::<JSPropertySpec>() - 48usize];
        ["Alignment of JSPropertySpec"][::std::mem::align_of::<JSPropertySpec>() - 8usize];
        ["Offset of field: JSPropertySpec::name"]
            [::std::mem::offset_of!(JSPropertySpec, name) - 0usize];
        ["Offset of field: JSPropertySpec::attributes_"]
            [::std::mem::offset_of!(JSPropertySpec, attributes_) - 8usize];
        ["Offset of field: JSPropertySpec::kind_"]
            [::std::mem::offset_of!(JSPropertySpec, kind_) - 9usize];
        ["Offset of field: JSPropertySpec::u"][::std::mem::offset_of!(JSPropertySpec, u) - 16usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSFunctionSpec {
        pub name: root::JSFunctionSpec_Name,
        pub call: root::JSNativeWrapper,
        pub nargs: u16,
        pub flags: u16,
        pub selfHostedName: *const ::std::os::raw::c_char,
    }
    pub type JSFunctionSpec_Name = root::JSPropertySpec_Name;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSFunctionSpec"][::std::mem::size_of::<JSFunctionSpec>() - 40usize];
        ["Alignment of JSFunctionSpec"][::std::mem::align_of::<JSFunctionSpec>() - 8usize];
        ["Offset of field: JSFunctionSpec::name"]
            [::std::mem::offset_of!(JSFunctionSpec, name) - 0usize];
        ["Offset of field: JSFunctionSpec::call"]
            [::std::mem::offset_of!(JSFunctionSpec, call) - 8usize];
        ["Offset of field: JSFunctionSpec::nargs"]
            [::std::mem::offset_of!(JSFunctionSpec, nargs) - 24usize];
        ["Offset of field: JSFunctionSpec::flags"]
            [::std::mem::offset_of!(JSFunctionSpec, flags) - 26usize];
        ["Offset of field: JSFunctionSpec::selfHostedName"]
            [::std::mem::offset_of!(JSFunctionSpec, selfHostedName) - 32usize];
    };
    pub type JSIterateCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut root::JS::Compartment,
        ) -> root::JS::CompartmentIterResult,
    >;
    extern "C" {
        #[doc = " This function calls |compartmentCallback| on every compartment until either\n all compartments have been iterated or CompartmentIterResult::Stop is\n returned. Beware that there is no guarantee that the compartment will survive\n after the callback returns. Also, barriers are disabled via the TraceSession."]
        #[link_name = "\u{1}_Z22JS_IterateCompartmentsP9JSContextPvPFN2JS21CompartmentIterResultES0_S1_PNS2_11CompartmentEE"]
        pub fn JS_IterateCompartments(
            cx: *mut root::JSContext,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
    }
    extern "C" {
        #[doc = " This function calls |compartmentCallback| on every compartment in the given\n zone until either all compartments have been iterated or\n CompartmentIterResult::Stop is returned. Beware that there is no guarantee\n that the compartment will survive after the callback returns. Also, barriers\n are disabled via the TraceSession."]
        #[link_name = "\u{1}_Z28JS_IterateCompartmentsInZoneP9JSContextPN2JS4ZoneEPvPFNS1_21CompartmentIterResultES0_S4_PNS1_11CompartmentEE"]
        pub fn JS_IterateCompartmentsInZone(
            cx: *mut root::JSContext,
            zone: *mut root::JS::Zone,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
    }
    extern "C" {
        #[doc = " Set the size of the native stack that should not be exceed. To disable\n stack size checking pass 0.\n\n SpiderMonkey allows for a distinction between system code (such as GCs, which\n may incidentally be triggered by script but are not strictly performed on\n behalf of such script), trusted script (as determined by\n JS_SetTrustedPrincipals), and untrusted script. Each kind of code may have a\n different stack quota, allowing embedders to keep higher-priority machinery\n running in the face of scripted stack exhaustion by something else.\n\n The stack quotas for each kind of code should be monotonically descending,\n and may be specified with this function. If 0 is passed for a given kind\n of code, it defaults to the value of the next-highest-priority kind.\n\n This function may only be called immediately after the runtime is initialized\n and before any code is executed and/or interrupts requested."]
        #[link_name = "\u{1}_Z22JS_SetNativeStackQuotaP9JSContextmmm"]
        pub fn JS_SetNativeStackQuota(
            cx: *mut root::JSContext,
            systemCodeStackSize: root::JS::NativeStackSize,
            trustedScriptStackSize: root::JS::NativeStackSize,
            untrustedScriptStackSize: root::JS::NativeStackSize,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetEmptyStringP9JSContext"]
        pub fn JS_GetEmptyString(cx: *mut root::JSContext) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewStringCopyNP9JSContextPKcm"]
        pub fn JS_NewStringCopyN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            n: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewStringCopyZP9JSContextPKc"]
        pub fn JS_NewStringCopyZ(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8ZP9JSContextN2JS15ConstUTF8CharsZE"]
        pub fn JS_NewStringCopyUTF8Z(
            cx: *mut root::JSContext,
            s: root::JS::ConstUTF8CharsZ,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8NP9JSContextRKN2JS9UTF8CharsE"]
        pub fn JS_NewStringCopyUTF8N(
            cx: *mut root::JSContext,
            s: *const root::JS::UTF8Chars,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_AtomizeStringNP9JSContextPKcm"]
        pub fn JS_AtomizeStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_AtomizeStringP9JSContextPKc"]
        pub fn JS_AtomizeString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AtomizeAndPinStringNP9JSContextPKcm"]
        pub fn JS_AtomizeAndPinStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_AtomizeAndPinStringP9JSContextPKc"]
        pub fn JS_AtomizeAndPinString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyNP9JSContextPKDsm"]
        pub fn JS_NewUCStringCopyN(
            cx: *mut root::JSContext,
            s: *const u16,
            n: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyZP9JSContextPKDs"]
        pub fn JS_NewUCStringCopyZ(cx: *mut root::JSContext, s: *const u16) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_AtomizeUCStringNP9JSContextPKDsm"]
        pub fn JS_AtomizeUCStringN(
            cx: *mut root::JSContext,
            s: *const u16,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_AtomizeUCStringP9JSContextPKDs"]
        pub fn JS_AtomizeUCString(cx: *mut root::JSContext, s: *const u16) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_CompareStringsP9JSContextP8JSStringS2_Pi"]
        pub fn JS_CompareStrings(
            cx: *mut root::JSContext,
            str1: *mut root::JSString,
            str2: *mut root::JSString,
            result: *mut i32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcPb"]
        pub fn JS_StringEqualsAscii(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            match_: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcmPb"]
        pub fn JS_StringEqualsAscii1(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
            match_: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_PutEscapedStringP9JSContextPcmP8JSStringc"]
        pub fn JS_PutEscapedString(
            cx: *mut root::JSContext,
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str_: *mut root::JSString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetStringLengthP8JSString"]
        pub fn JS_GetStringLength(str_: *mut root::JSString) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_StringIsLinearP8JSString"]
        pub fn JS_StringIsLinear(str_: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_GetLatin1StringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetLatin1StringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str_: *mut root::JSString,
            length: *mut usize,
        ) -> *const root::JS::Latin1Char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_GetTwoByteStringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetTwoByteStringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str_: *mut root::JSString,
            length: *mut usize,
        ) -> *const u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetStringCharAtP9JSContextP8JSStringmPDs"]
        pub fn JS_GetStringCharAt(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            index: usize,
            res: *mut u16,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_GetTwoByteExternalStringCharsP8JSString"]
        pub fn JS_GetTwoByteExternalStringChars(str_: *mut root::JSString) -> *const u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_CopyStringCharsP9JSContextRKN7mozilla5RangeIDsEEP8JSString"]
        pub fn JS_CopyStringChars(
            cx: *mut root::JSContext,
            dest: *const root::mozilla::Range<u16>,
            str_: *mut root::JSString,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Copies the string's characters to a null-terminated char16_t buffer.\n\n Returns nullptr on OOM."]
        #[link_name = "\u{1}_Z19JS_CopyStringCharsZP9JSContextP8JSString"]
        pub fn JS_CopyStringCharsZ(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueTwoByteChars;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_EnsureLinearStringP9JSContextP8JSString"]
        pub fn JS_EnsureLinearString(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> *mut root::JSLinearString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKc"]
        pub fn JS_LinearStringEqualsAscii(
            str_: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKcm"]
        pub fn JS_LinearStringEqualsAscii1(
            str_: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_PutEscapedLinearStringPcmP14JSLinearStringc"]
        pub fn JS_PutEscapedLinearString(
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str_: *mut root::JSLinearString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
    }
    extern "C" {
        #[doc = " Create a dependent string, i.e., a string that owns no character storage,\n but that refers to a slice of another string's chars.  Dependent strings\n are mutable by definition, so the thread safety comments above apply."]
        #[link_name = "\u{1}_Z21JS_NewDependentStringP9JSContextN2JS6HandleIP8JSStringEEmm"]
        pub fn JS_NewDependentString(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            start: usize,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Concatenate two strings, possibly resulting in a rope.\n See above for thread safety comments."]
        #[link_name = "\u{1}_Z16JS_ConcatStringsP9JSContextN2JS6HandleIP8JSStringEES5_"]
        pub fn JS_ConcatStrings(
            cx: *mut root::JSContext,
            left: root::JS::Handle<*mut root::JSString>,
            right: root::JS::Handle<*mut root::JSString>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before\n the call; on return, *dstlenp contains the number of characters actually\n stored. To determine the necessary destination buffer size, make a sizing\n call that passes nullptr for dst.\n\n On errors, the functions report the error. In that case, *dstlenp contains\n the number of characters or bytes transferred so far.  If cx is nullptr, no\n error is reported on failure, and the functions simply return false.\n\n NB: This function does not store an additional zero byte or char16_t after\n the transcoded string."]
        #[link_name = "\u{1}_Z14JS_DecodeBytesP9JSContextPKcmPDsPm"]
        pub fn JS_DecodeBytes(
            cx: *mut root::JSContext,
            src: *const ::std::os::raw::c_char,
            srclen: usize,
            dst: *mut u16,
            dstlenp: *mut usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get number of bytes in the string encoding (without accounting for a\n terminating zero bytes. The function returns (size_t) -1 if the string\n can not be encoded into bytes and reports an error using cx accordingly."]
        #[link_name = "\u{1}_Z26JS_GetStringEncodingLengthP9JSContextP8JSString"]
        pub fn JS_GetStringEncodingLength(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> usize;
    }
    extern "C" {
        #[doc = " Encode string into a buffer. The function does not stores an additional\n zero byte. The function returns (size_t) -1 if the string can not be\n encoded into bytes with no error reported. Otherwise it returns the number\n of bytes that are necessary to encode the string. If that exceeds the\n length parameter, the string will be cut and only length bytes will be\n written into the buffer."]
        #[link_name = "\u{1}_Z23JS_EncodeStringToBufferP9JSContextP8JSStringPcm"]
        pub fn JS_EncodeStringToBuffer(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            buffer: *mut ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " DO NOT USE, only present for Rust bindings as a temporary hack"]
        #[link_name = "\u{1}_Z33JS_DeprecatedStringHasLatin1CharsP8JSString"]
        pub fn JS_DeprecatedStringHasLatin1Chars(str_: *mut root::JSString) -> bool;
    }
    #[doc = " Callback used to ask the embedding for the cross compartment wrapper handler\n that implements the desired prolicy for this kind of object in the\n destination compartment. |obj| is the object to be wrapped. If |existing| is\n non-nullptr, it will point to an existing wrapper object that should be\n re-used if possible. |existing| is guaranteed to be a cross-compartment\n wrapper with a lazily-defined prototype and the correct global. It is\n guaranteed not to wrap a function."]
    pub type JSWrapObjectCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::HandleObject,
            arg3: root::JS::HandleObject,
        ) -> *mut root::JSObject,
    >;
    #[doc = " Callback used by the wrap hook to ask the embedding to prepare an object\n for wrapping in a context. This might include unwrapping other wrappers\n or even finding a more suitable object for the new compartment. If |origObj|\n is non-null, then it is the original object we are going to swap into during\n a transplant."]
    pub type JSPreWrapCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::HandleObject,
            arg3: root::JS::HandleObject,
            arg4: root::JS::HandleObject,
            arg5: root::JS::HandleObject,
            arg6: root::JS::MutableHandleObject,
        ),
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSWrapObjectCallbacks {
        pub wrap: root::JSWrapObjectCallback,
        pub preWrap: root::JSPreWrapCallback,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSWrapObjectCallbacks"][::std::mem::size_of::<JSWrapObjectCallbacks>() - 16usize];
        ["Alignment of JSWrapObjectCallbacks"]
            [::std::mem::align_of::<JSWrapObjectCallbacks>() - 8usize];
        ["Offset of field: JSWrapObjectCallbacks::wrap"]
            [::std::mem::offset_of!(JSWrapObjectCallbacks, wrap) - 0usize];
        ["Offset of field: JSWrapObjectCallbacks::preWrap"]
            [::std::mem::offset_of!(JSWrapObjectCallbacks, preWrap) - 8usize];
    };
    pub type JSDestroyZoneCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::JS::GCContext, arg2: *mut root::JS::Zone),
    >;
    pub type JSDestroyCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::JS::GCContext, arg2: *mut root::JS::Compartment),
    >;
    pub type JSSizeOfIncludingThisCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: root::mozilla::MallocSizeOf,
            arg2: *mut root::JS::Compartment,
        ) -> usize,
    >;
    extern "C" {
        #[link_name = "\u{1}_Z25JS_SetDestroyZoneCallbackP9JSContextPFvPN2JS9GCContextEPNS1_4ZoneEE"]
        pub fn JS_SetDestroyZoneCallback(
            cx: *mut root::JSContext,
            callback: root::JSDestroyZoneCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_SetDestroyCompartmentCallbackP9JSContextPFvPN2JS9GCContextEPNS1_11CompartmentEE"]
        pub fn JS_SetDestroyCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSDestroyCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z44JS_SetSizeOfIncludingThisCompartmentCallbackP9JSContextPFmPFmPKvEPN2JS11CompartmentEE"]
        pub fn JS_SetSizeOfIncludingThisCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSSizeOfIncludingThisCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_SetCompartmentPrivatePN2JS11CompartmentEPv"]
        pub fn JS_SetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetCompartmentPrivatePN2JS11CompartmentE"]
        pub fn JS_GetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetZoneUserDataPN2JS4ZoneEPv"]
        pub fn JS_SetZoneUserData(zone: *mut root::JS::Zone, data: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetZoneUserDataPN2JS4ZoneE"]
        pub fn JS_GetZoneUserData(zone: *mut root::JS::Zone) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_RefreshCrossCompartmentWrappersP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_RefreshCrossCompartmentWrappers(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Mark a jsid after entering a new compartment. Different zones separately\n mark the ids in a runtime, and this must be used any time an id is obtained\n from one compartment and then used in another compartment, unless the two\n compartments are guaranteed to be in the same zone."]
        #[link_name = "\u{1}_Z18JS_MarkCrossZoneIdP9JSContextN2JS11PropertyKeyE"]
        pub fn JS_MarkCrossZoneId(cx: *mut root::JSContext, id: root::jsid);
    }
    extern "C" {
        #[doc = " If value stores a jsid (an atomized string or symbol), mark that id as for\n JS_MarkCrossZoneId."]
        #[link_name = "\u{1}_Z23JS_MarkCrossZoneIdValueP9JSContextRKN2JS5ValueE"]
        pub fn JS_MarkCrossZoneIdValue(cx: *mut root::JSContext, value: *const root::JS::Value);
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_StringHasBeenPinnedP9JSContextP8JSString"]
        pub fn JS_StringHasBeenPinned(cx: *mut root::JSContext, str_: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[doc = " Microseconds since the epoch, midnight, January 1, 1970 UTC."]
        #[link_name = "\u{1}_Z6JS_Nowv"]
        pub fn JS_Now() -> i64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ValueToObjectP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIP8JSObjectEE"]
        pub fn JS_ValueToObject(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            objp: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_ValueToFunctionP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToFunction(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_ValueToConstructorP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToConstructor(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ValueToSourceP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToSource(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DoubleIsInt32dPi"]
        pub fn JS_DoubleIsInt32(d: f64, ip: *mut i32) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_TypeOfValueP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_TypeOfValue(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> root::JSType;
    }
    extern "C" {
        #[doc = " True iff fun is the global eval function."]
        #[link_name = "\u{1}_Z24JS_IsBuiltinEvalFunctionP10JSFunction"]
        pub fn JS_IsBuiltinEvalFunction(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[doc = " True iff fun is the Function constructor."]
        #[link_name = "\u{1}_Z31JS_IsBuiltinFunctionConstructorP10JSFunction"]
        pub fn JS_IsBuiltinFunctionConstructor(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetImplementationVersionv"]
        pub fn JS_GetImplementationVersion() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_SetWrapObjectCallbacksP9JSContextPK21JSWrapObjectCallbacks"]
        pub fn JS_SetWrapObjectCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSWrapObjectCallbacks,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_WrapObjectP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_WrapObject(cx: *mut root::JSContext, objp: root::JS::MutableHandleObject)
            -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_WrapValueP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_WrapValue(cx: *mut root::JSContext, vp: root::JS::MutableHandleValue) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_TransplantObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_TransplantObject(
            cx: *mut root::JSContext,
            origobj: root::JS::HandleObject,
            target: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Resolve id, which must contain either a string or an int, to a standard\n class name in obj if possible, defining the class's constructor and/or\n prototype and storing true in *resolved.  If id does not name a standard\n class or a top-level property induced by initializing a standard class,\n store false in *resolved and just return true.  Return false on error,\n as usual for bool result-typed API entry points.\n\n This API can be called directly from a global object class's resolve op,\n to define standard classes lazily. The class should either have an enumerate\n hook that calls JS_EnumerateStandardClasses, or a newEnumerate hook that\n calls JS_NewEnumerateStandardClasses. newEnumerate is preferred because it's\n faster (does not define all standard classes)."]
        #[link_name = "\u{1}_Z23JS_ResolveStandardClassP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_ResolveStandardClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolved: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_MayResolveStandardClassRK11JSAtomStateN2JS11PropertyKeyEP8JSObject"]
        pub fn JS_MayResolveStandardClass(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_EnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_EnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Fill \"properties\" with a list of standard class names that have not yet been\n resolved on \"obj\".  This can be used as (part of) a newEnumerate class hook\n on a global.  Already-resolved things are excluded because they might have\n been deleted by script after being resolved and enumeration considers\n already-defined properties anyway."]
        #[link_name = "\u{1}_Z30JS_NewEnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Fill \"properties\" with a list of standard class names.  This can be used for\n proxies that want to define behavior that looks like enumerating a global\n without touching the global itself."]
        #[link_name = "\u{1}_Z47JS_NewEnumerateStandardClassesIncludingResolvedP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClassesIncludingResolved(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetClassObjectP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassObject(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetClassPrototypeP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassPrototype(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_IdToProtoKeyP9JSContextN2JS6HandleINS1_11PropertyKeyEEE"]
        pub fn JS_IdToProtoKey(
            cx: *mut root::JSContext,
            id: root::JS::HandleId,
        ) -> root::JSProtoKey;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GlobalLexicalEnvironmentP8JSObject"]
        pub fn JS_GlobalLexicalEnvironment(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_HasExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_HasExtensibleLexicalEnvironment(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31JS_ExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_ExtensibleLexicalEnvironment(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the\n given global."]
        #[link_name = "\u{1}_Z19JS_InitReflectParseP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_InitReflectParse(
            cx: *mut root::JSContext,
            global: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Add various profiling-related functions as properties of the given object.\n Defined in builtin/Profilers.cpp."]
        #[link_name = "\u{1}_Z27JS_DefineProfilingFunctionsP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineProfilingFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_ValueToIdP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_ValueToId(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            idp: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_StringToIdP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_StringToId(
            cx: *mut root::JSContext,
            s: root::JS::HandleString,
            idp: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_IdToValueP9JSContextN2JS11PropertyKeyENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_IdToValue(
            cx: *mut root::JSContext,
            id: root::jsid,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Defines a builtin constructor and prototype. Returns the prototype object.\n\n - Defines a property named `name` on `obj`, with its value set to a\n   newly-created JS function that invokes the `constructor` JSNative. The\n   `length` of the function is `nargs`.\n\n - Creates a prototype object with proto `protoProto` and class `protoClass`.\n   If `protoProto` is `nullptr`, `Object.prototype` will be used instead.\n   If `protoClass` is `nullptr`, the prototype object will be a plain JS\n   object.\n\n - The `ps` and `fs` properties/functions will be defined on the prototype\n   object.\n\n - The `static_ps` and `static_fs` properties/functions will be defined on the\n   constructor."]
        #[link_name = "\u{1}_Z12JS_InitClassP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassS5_PKcPFbS0_jPNS1_5ValueEEjPK14JSPropertySpecPK14JSFunctionSpecSH_SK_"]
        pub fn JS_InitClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            protoClass: *const root::JSClass,
            protoProto: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            constructor: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            ps: *const root::JSPropertySpec,
            fs: *const root::JSFunctionSpec,
            static_ps: *const root::JSPropertySpec,
            static_fs: *const root::JSFunctionSpec,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Set up ctor.prototype = proto and proto.constructor = ctor with the\n right property flags."]
        #[link_name = "\u{1}_Z30JS_LinkConstructorAndPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_LinkConstructorAndPrototype(
            cx: *mut root::JSContext,
            ctor: root::JS::Handle<*mut root::JSObject>,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_InstanceOfP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassPNS1_8CallArgsE"]
        pub fn JS_InstanceOf(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            clasp: *const root::JSClass,
            args: *mut root::JS::CallArgs,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_HasInstanceP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEEPb"]
        pub fn JS_HasInstance(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            v: root::JS::Handle<root::JS::Value>,
            bp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetConstructorP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_GetConstructor(
            cx: *mut root::JSContext,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_NewObjectP9JSContextPK7JSClass"]
        pub fn JS_NewObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z11JS_IsNativeP8JSObject"]
        pub fn JS_IsNative(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default\n proto. If proto is nullptr, the JS object will have `null` as [[Prototype]]."]
        #[link_name = "\u{1}_Z26JS_NewObjectWithGivenProtoP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithGivenProto(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Creates a new plain object, like `new Object()`, with Object.prototype as\n [[Prototype]]."]
        #[link_name = "\u{1}_Z17JS_NewPlainObjectP9JSContext"]
        pub fn JS_NewPlainObject(cx: *mut root::JSContext) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Freeze obj, and all objects it refers to, recursively. This will not recurse\n through non-extensible objects, on the assumption that those are already\n deep-frozen."]
        #[link_name = "\u{1}_Z19JS_DeepFreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DeepFreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Freezes an object; see ES5's Object.freeze(obj) method."]
        #[link_name = "\u{1}_Z15JS_FreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the prototype of |obj|, storing it in |proto|.\n\n Implements: ES6 [[GetPrototypeOf]] internal method."]
        #[link_name = "\u{1}_Z15JS_GetPrototypeP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " If |obj| (underneath any functionally-transparent wrapper proxies) has as\n its [[GetPrototypeOf]] trap the ordinary [[GetPrototypeOf]] behavior defined\n for ordinary objects, set |*isOrdinary = true| and store |obj|'s prototype\n in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both\n outparams have unspecified value."]
        #[link_name = "\u{1}_Z25JS_GetPrototypeIfOrdinaryP9JSContextN2JS6HandleIP8JSObjectEEPbNS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototypeIfOrdinary(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isOrdinary: *mut bool,
            result: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Change the prototype of obj.\n\n Implements: ES6 [[SetPrototypeOf]] internal method.\n\n In cases where ES6 [[SetPrototypeOf]] returns false without an exception,\n JS_SetPrototype throws a TypeError and returns false.\n\n Performance warning: JS_SetPrototype is very bad for performance. It may\n cause compiled jit-code to be invalidated. It also causes not only obj but\n all other objects in the same \"group\" as obj to be permanently deoptimized.\n It's better to create the object with the right prototype from the start."]
        #[link_name = "\u{1}_Z15JS_SetPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_SetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether obj is extensible. Extensible objects can have new\n properties defined on them. Inextensible objects can't, and their\n [[Prototype]] slot is fixed as well.\n\n Implements: ES6 [[IsExtensible]] internal method."]
        #[link_name = "\u{1}_Z15JS_IsExtensibleP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_IsExtensible(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            extensible: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Attempt to make |obj| non-extensible.\n\n Not all failures are treated as errors. See the comment on\n JS::ObjectOpResult in js/public/Class.h.\n\n Implements: ES6 [[PreventExtensions]] internal method."]
        #[link_name = "\u{1}_Z20JS_PreventExtensionsP9JSContextN2JS6HandleIP8JSObjectEERNS1_14ObjectOpResultE"]
        pub fn JS_PreventExtensions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt\n to modify it will fail.  If an error occurs during the attempt, return false\n (with a pending exception set, depending upon the nature of the error).  If\n no error occurs, return true with |*succeeded| set to indicate whether the\n attempt successfully made the [[Prototype]] immutable.\n\n This is a nonstandard internal method."]
        #[link_name = "\u{1}_Z24JS_SetImmutablePrototypeP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_SetImmutablePrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            succeeded: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Equivalent to `Object.assign(target, src)`: Copies the properties from the\n `src` object (which must not be null) to `target` (which also must not be\n null)."]
        #[link_name = "\u{1}_Z15JS_AssignObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_AssignObject(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Assign 'undefined' to all of the object's non-reserved slots. Note: this is\n done for all slots, regardless of the associated property descriptor."]
        #[link_name = "\u{1}_Z36JS_SetAllNonReservedSlotsToUndefinedN2JS6HandleIP8JSObjectEE"]
        pub fn JS_SetAllNonReservedSlotsToUndefined(obj: root::JS::HandleObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetReservedSlotP8JSObjectjRKN2JS5ValueE"]
        pub fn JS_SetReservedSlot(obj: *mut root::JSObject, index: u32, v: *const root::JS::Value);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_InitReservedSlotP8JSObjectjPvmN2JS9MemoryUseE"]
        pub fn JS_InitReservedSlot(
            obj: *mut root::JSObject,
            index: u32,
            ptr: *mut ::std::os::raw::c_void,
            nbytes: usize,
            use_: root::JS::MemoryUse,
        );
    }
    pub const JSFUN_CONSTRUCTOR: ::std::os::raw::c_uint = 1024;
    pub const JSFUN_FLAGS_MASK: ::std::os::raw::c_uint = 1024;
    extern "C" {
        #[link_name = "\u{1}_Z14JS_NewFunctionP9JSContextPFbS0_jPN2JS5ValueEEjjPKc"]
        pub fn JS_NewFunction(
            cx: *mut root::JSContext,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
            name: *const ::std::os::raw::c_char,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionObjectP10JSFunction"]
        pub fn JS_GetFunctionObject(fun: *mut root::JSFunction) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Return the function's identifier as a JSString, or null if fun is unnamed.\n\n The returned string lives as long as fun, so you don't need to root a saved\n reference to it if fun is well-connected or rooted, and provided you bound\n the use of the saved reference by fun's lifetime.\n\n This function returns false if any error happens while generating the\n function name string for a function with lazy name."]
        #[link_name = "\u{1}_Z16JS_GetFunctionIdP9JSContextN2JS6HandleIP10JSFunctionEENS1_13MutableHandleIP8JSStringEE"]
        pub fn JS_GetFunctionId(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
            name: root::JS::MutableHandle<*mut root::JSString>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Almost same as JS_GetFunctionId.\n\n If the function has lazy name, this returns partial name, such as the\n function name without \"get \" or \"set \" prefix."]
        #[link_name = "\u{1}_Z28JS_GetMaybePartialFunctionIdP10JSFunction"]
        pub fn JS_GetMaybePartialFunctionId(fun: *mut root::JSFunction) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Return a function's display name as `name` out-parameter.\n\n This is the defined name if one was given where the function was defined, or\n it could be an inferred name by the JS engine in the case that the function\n was defined to be anonymous.\n\n This can still return nullptr as `name` out-parameter if a useful display\n name could not be inferred.\n\n This function returns false if any error happens while generating the\n function name string for a function with lazy name."]
        #[link_name = "\u{1}_Z23JS_GetFunctionDisplayIdP9JSContextN2JS6HandleIP10JSFunctionEENS1_13MutableHandleIP8JSStringEE"]
        pub fn JS_GetFunctionDisplayId(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
            name: root::JS::MutableHandle<*mut root::JSString>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Almost same as JS_GetFunctionDisplayId.\n\n If the function has lazy name, this returns partial name, such as the\n function name without \"get \" or \"set \" prefix."]
        #[link_name = "\u{1}_Z35JS_GetMaybePartialFunctionDisplayIdP10JSFunction"]
        pub fn JS_GetMaybePartialFunctionDisplayId(
            arg1: *mut root::JSFunction,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetFunctionArityP10JSFunction"]
        pub fn JS_GetFunctionArity(fun: *mut root::JSFunction) -> u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionLengthP9JSContextN2JS6HandleIP10JSFunctionEEPt"]
        pub fn JS_GetFunctionLength(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
            length: *mut u16,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Infallible predicate to test whether obj is a function object (faster than\n comparing obj's class name to \"Function\", but equivalent unless someone has\n overwritten the \"Function\" identifier with a different constructor and then\n created instances using that constructor that might be passed in as obj)."]
        #[link_name = "\u{1}_Z19JS_ObjectIsFunctionP8JSObject"]
        pub fn JS_ObjectIsFunction(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_IsNativeFunctionP8JSObjectPFbP9JSContextjPN2JS5ValueEE"]
        pub fn JS_IsNativeFunction(funobj: *mut root::JSObject, call: root::JSNative) -> bool;
    }
    extern "C" {
        #[doc = " Return whether the given function is a valid constructor."]
        #[link_name = "\u{1}_Z16JS_IsConstructorP10JSFunction"]
        pub fn JS_IsConstructor(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_ObjectIsBoundFunctionP8JSObject"]
        pub fn JS_ObjectIsBoundFunction(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetBoundFunctionTargetP8JSObject"]
        pub fn JS_GetBoundFunctionTarget(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetGlobalFromScriptP8JSScript"]
        pub fn JS_GetGlobalFromScript(script: *mut root::JSScript) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetScriptFilenameP8JSScript"]
        pub fn JS_GetScriptFilename(script: *mut root::JSScript) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetScriptBaseLineNumberP9JSContextP8JSScript"]
        pub fn JS_GetScriptBaseLineNumber(
            cx: *mut root::JSContext,
            script: *mut root::JSScript,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionScriptP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_GetFunctionScript(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
        ) -> *mut root::JSScript;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_DecompileScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_DecompileScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_DecompileFunctionP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_DecompileFunction(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " A JS context always has an \"owner thread\". The owner thread is set when the\n context is created (to the current thread) and practically all entry points\n into the JS engine check that a context (or anything contained in the\n context: runtime, compartment, object, etc) is only touched by its owner\n thread. Embeddings may check this invariant outside the JS engine by calling\n JS_AbortIfWrongThread (which will abort if not on the owner thread, even for\n non-debug builds)."]
        #[link_name = "\u{1}_Z21JS_AbortIfWrongThreadP9JSContext"]
        pub fn JS_AbortIfWrongThread(cx: *mut root::JSContext);
    }
    extern "C" {
        #[doc = " A constructor can request that the JS engine create a default new 'this'\n object of the given class, using the callee to determine parentage and\n [[Prototype]]."]
        #[link_name = "\u{1}_Z26JS_NewObjectForConstructorP9JSContextPK7JSClassRKN2JS8CallArgsE"]
        pub fn JS_NewObjectForConstructor(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            args: *const root::JS::CallArgs,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z41JS_SetOffthreadBaselineCompilationEnabledP9JSContextb"]
        pub fn JS_SetOffthreadBaselineCompilationEnabled(cx: *mut root::JSContext, enabled: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z36JS_SetOffthreadIonCompilationEnabledP9JSContextb"]
        pub fn JS_SetOffthreadIonCompilationEnabled(cx: *mut root::JSContext, enabled: bool);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitCompilerOption {
        JSJITCOMPILER_BASELINE_INTERPRETER_WARMUP_TRIGGER = 0,
        JSJITCOMPILER_BASELINE_WARMUP_TRIGGER = 1,
        JSJITCOMPILER_IC_FORCE_MEGAMORPHIC = 2,
        JSJITCOMPILER_ION_NORMAL_WARMUP_TRIGGER = 3,
        JSJITCOMPILER_ION_GVN_ENABLE = 4,
        JSJITCOMPILER_ION_FORCE_IC = 5,
        JSJITCOMPILER_ION_ENABLE = 6,
        JSJITCOMPILER_JIT_TRUSTEDPRINCIPALS_ENABLE = 7,
        JSJITCOMPILER_ION_CHECK_RANGE_ANALYSIS = 8,
        JSJITCOMPILER_ION_FREQUENT_BAILOUT_THRESHOLD = 9,
        JSJITCOMPILER_BASE_REG_FOR_LOCALS = 10,
        JSJITCOMPILER_INLINING_BYTECODE_MAX_LENGTH = 11,
        JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE = 12,
        JSJITCOMPILER_BASELINE_ENABLE = 13,
        JSJITCOMPILER_PORTABLE_BASELINE_ENABLE = 14,
        JSJITCOMPILER_PORTABLE_BASELINE_WARMUP_THRESHOLD = 15,
        JSJITCOMPILER_OFFTHREAD_COMPILATION_ENABLE = 16,
        JSJITCOMPILER_FULL_DEBUG_CHECKS = 17,
        JSJITCOMPILER_JUMP_THRESHOLD = 18,
        JSJITCOMPILER_NATIVE_REGEXP_ENABLE = 19,
        JSJITCOMPILER_JIT_HINTS_ENABLE = 20,
        JSJITCOMPILER_SIMULATOR_ALWAYS_INTERRUPT = 21,
        JSJITCOMPILER_SPECTRE_INDEX_MASKING = 22,
        JSJITCOMPILER_SPECTRE_OBJECT_MITIGATIONS = 23,
        JSJITCOMPILER_SPECTRE_STRING_MITIGATIONS = 24,
        JSJITCOMPILER_SPECTRE_VALUE_MASKING = 25,
        JSJITCOMPILER_SPECTRE_JIT_TO_CXX_CALLS = 26,
        JSJITCOMPILER_WRITE_PROTECT_CODE = 27,
        JSJITCOMPILER_WASM_FOLD_OFFSETS = 28,
        JSJITCOMPILER_WASM_DELAY_TIER2 = 29,
        JSJITCOMPILER_WASM_JIT_BASELINE = 30,
        JSJITCOMPILER_WASM_JIT_OPTIMIZING = 31,
        JSJITCOMPILER_REGEXP_DUPLICATE_NAMED_GROUPS = 32,
        JSJITCOMPILER_REGEXP_MODIFIERS = 33,
        JSJITCOMPILER_NOT_AN_OPTION = 34,
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_SetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionj"]
        pub fn JS_SetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            value: u32,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionPj"]
        pub fn JS_GetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            valueOut: *mut u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Convert a uint32_t index into a jsid."]
        #[link_name = "\u{1}_Z12JS_IndexToIdP9JSContextjN2JS13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_IndexToId(
            cx: *mut root::JSContext,
            index: u32,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Convert chars into a jsid.\n\n |chars| may not be an index."]
        #[link_name = "\u{1}_Z12JS_CharsToIdP9JSContextN2JS12TwoByteCharsENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_CharsToId(
            cx: *mut root::JSContext,
            chars: root::JS::TwoByteChars,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[doc = "  Test if the given string is a valid ECMAScript identifier"]
        #[link_name = "\u{1}_Z15JS_IsIdentifierP9JSContextN2JS6HandleIP8JSStringEEPb"]
        pub fn JS_IsIdentifier(
            cx: *mut root::JSContext,
            str_: root::JS::HandleString,
            isIdentifier: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Test whether the given chars + length are a valid ECMAScript identifier.\n This version is infallible, so just returns whether the chars are an\n identifier."]
        #[link_name = "\u{1}_Z15JS_IsIdentifierPKDsm"]
        pub fn JS_IsIdentifier1(chars: *const u16, length: usize) -> bool;
    }
    extern "C" {
        #[doc = " Given a buffer, return false if the buffer might become a valid JavaScript\n script with the addition of more lines, or true if the validity of such a\n script is conclusively known (because it's the prefix of a valid script --\n and possibly the entirety of such a script).\n\n The intent of this function is to enable interactive compilation: accumulate\n lines in a buffer until JS_Utf8BufferIsCompilableUnit is true, then pass it\n to the compiler.\n\n The provided buffer is interpreted as UTF-8 data.  If a UTF-8 encoding error\n is encountered, reports an error to JSContext and returns *true*."]
        #[link_name = "\u{1}_Z29JS_Utf8BufferIsCompilableUnitP9JSContextN2JS6HandleIP8JSObjectEEPKcm"]
        pub fn JS_Utf8BufferIsCompilableUnit(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            utf8: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Evaluate a script in the scope of the current global of cx."]
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_ExecuteScript1(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " As above, but providing an explicit scope chain.  envChain must not include\n the global object on it; that's implicit.  It needs to contain the other\n objects that should end up on the script's scope chain."]
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextRKN2JS16EnvironmentChainENS1_6HandleIP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript2(
            cx: *mut root::JSContext,
            envChain: *const root::JS::EnvironmentChain,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextRKN2JS16EnvironmentChainENS1_6HandleIP8JSScriptEE"]
        pub fn JS_ExecuteScript3(
            cx: *mut root::JSContext,
            envChain: *const root::JS::EnvironmentChain,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
    }
    pub type JS_ICUAllocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUReallocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            p: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUFreeFn = ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, p: *mut ::std::os::raw::c_void),
    >;
    extern "C" {
        #[doc = " This function can be used to track memory used by ICU.  If it is called, it\n *must* be called before JS_Init.  Don't use it unless you know what you're\n doing!"]
        #[link_name = "\u{1}_Z24JS_SetICUMemoryFunctionsPFPvPKvmEPFS_S1_S_mEPFvS1_S_E"]
        pub fn JS_SetICUMemoryFunctions(
            allocFn: root::JS_ICUAllocFn,
            reallocFn: root::JS_ICUReallocFn,
            freeFn: root::JS_ICUFreeFn,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Destroy free-standing resources allocated by SpiderMonkey, not associated\n with any runtime, context, or other structure.\n\n This method should be called after all other JSAPI data has been properly\n cleaned up: every new runtime must have been destroyed, every new context\n must have been destroyed, and so on.  Calling this method before all other\n resources have been destroyed has undefined behavior.\n\n Failure to call this method, at present, has no adverse effects other than\n leaking memory.  This may not always be the case; it's recommended that all\n embedders call this method when all other JSAPI operations have completed.\n\n It is currently not possible to initialize SpiderMonkey multiple times (that\n is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so\n again).  This restriction may eventually be lifted."]
        #[link_name = "\u{1}_Z11JS_ShutDownv"]
        pub fn JS_ShutDown();
    }
    extern "C" {
        #[doc = " A variant of JS_ShutDown for process which used JS_FrontendOnlyInit instead\n of JS_Init."]
        #[link_name = "\u{1}_Z23JS_FrontendOnlyShutDownv"]
        pub fn JS_FrontendOnlyShutDown();
    }
    pub type JSONWriteCallback = ::std::option::Option<
        unsafe extern "C" fn(buf: *const u16, len: u32, data: *mut ::std::os::raw::c_void) -> bool,
    >;
    extern "C" {
        #[doc = " Performs the JSON.stringify operation, as specified by ECMAScript, except\n writing stringified data by exactly one call of |callback|, passing |data| as\n argument.\n\n In cases where JSON.stringify would return undefined, this function calls\n |callback| with the string \"null\".\n\n If a length hint is passed, space will be reserved for at least that many\n characters."]
        #[link_name = "\u{1}_Z12JS_StringifyP9JSContextN2JS13MutableHandleINS1_5ValueEEENS1_6HandleIP8JSObjectEENS5_IS3_EEPFbPKDsjPvESC_"]
        pub fn JS_Stringify(
            cx: *mut root::JSContext,
            value: root::JS::MutableHandle<root::JS::Value>,
            replacer: root::JS::Handle<*mut root::JSObject>,
            space: root::JS::Handle<root::JS::Value>,
            callback: root::JSONWriteCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_StringifyWithLengthHintP9JSContextN2JS13MutableHandleINS1_5ValueEEENS1_6HandleIP8JSObjectEENS5_IS3_EEPFbPKDsjPvESC_m"]
        pub fn JS_StringifyWithLengthHint(
            cx: *mut root::JSContext,
            value: root::JS::MutableHandle<root::JS::Value>,
            replacer: root::JS::Handle<*mut root::JSObject>,
            space: root::JS::Handle<root::JS::Value>,
            callback: root::JSONWriteCallback,
            data: *mut ::std::os::raw::c_void,
            lengthHint: usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript."]
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextPKDsjN2JS13MutableHandleINS3_5ValueEEE"]
        pub fn JS_ParseJSON(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript."]
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ParseJSON1(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript."]
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextPKhjN2JS13MutableHandleINS3_5ValueEEE"]
        pub fn JS_ParseJSON2(
            cx: *mut root::JSContext,
            chars: *const root::JS::Latin1Char,
            len: u32,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript, using the\n given |reviver| argument as the corresponding optional argument to that\n function."]
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextPKDsjN2JS6HandleINS3_5ValueEEENS3_13MutableHandleIS5_EE"]
        pub fn JS_ParseJSONWithReviver(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript, using the\n given |reviver| argument as the corresponding optional argument to that\n function."]
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextN2JS6HandleIP8JSStringEENS2_INS1_5ValueEEENS1_13MutableHandleIS6_EE"]
        pub fn JS_ParseJSONWithReviver1(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    #[doc = " Read structured data from the reader r. This hook is used to read a value\n previously serialized by a call to the WriteStructuredCloneOp hook.\n\n tag and data are the pair of uint32_t values from the header. The callback\n may use the JS_Read* APIs to read any other relevant parts of the object\n from the reader r. closure is any value passed to the JS_ReadStructuredClone\n function.\n\n Return the new object on success, or raise an exception and return nullptr on\n error."]
    pub type ReadStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            tag: u32,
            data: u32,
            closure: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSObject,
    >;
    #[doc = " Structured data serialization hook. The engine can write primitive values,\n Objects, Arrays, Dates, RegExps, TypedArrays, ArrayBuffers, Sets, Maps,\n and SharedTypedArrays. Any other type of object requires application support.\n This callback must first use the JS_WriteUint32Pair API to write an object\n header, passing a value greater than JS_SCTAG_USER to the tag parameter.\n Then it can use the JS_Write* APIs to write any other relevant parts of\n the value v to the writer w. closure is any value passed to the\n JS_WriteStructuredClone function.\n\n Return true on success, false on error. On error, an exception should\n normally be set."]
    pub type WriteStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
            sameProcessScopeRequired: *mut bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[doc = " This is called when serialization or deserialization encounters an error.\n To follow HTML5, the application must throw a DATA_CLONE_ERR DOMException\n with error set to one of the JS_SCERR_* values.\n\n Note that if the .reportError field of the JSStructuredCloneCallbacks is\n set (to a function with this signature), then an exception will *not* be\n set on the JSContext when an error is encountered. The clone operation\n will still be aborted and will return false, however, so it is up to the\n embedding to do what it needs to for the error.\n\n Example: for the DOM, mozilla::dom::StructuredCloneHolder will save away\n the error message during its reportError callback. Then when the overall\n operation fails, it will clear any exception that might have been set\n from other ways to fail and pass the saved error message to\n ErrorResult::ThrowDataCloneError()."]
    pub type StructuredCloneErrorOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            errorid: u32,
            closure: *mut ::std::os::raw::c_void,
            errorMessage: *const ::std::os::raw::c_char,
        ),
    >;
    #[doc = " This is called when JS_ReadStructuredClone receives a transferable object\n not known to the engine. If this hook does not exist or returns false, the\n JS engine calls the reportError op if set, otherwise it throws a\n DATA_CLONE_ERR DOM Exception. This method is called before any other\n callback and must return a non-null object in returnObject on success.\n\n If this readTransfer() hook is called and produces an object, then the\n read() hook will *not* be called for the same object, since the main data\n will only contain a backreference to the already-read object.\n\n The clone buffer will relinquish ownership of this Transferable if and only\n if this hook returns true -- as in, the freeTransfer hook will not be called\n on this entry if this hook returns true, but it will still be called if it\n returns false."]
    pub type ReadTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            aCloneDataPolicy: *const root::JS::CloneDataPolicy,
            tag: u32,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
            returnObject: root::JS::MutableHandleObject,
        ) -> bool,
    >;
    #[doc = " Called when JS_WriteStructuredClone receives a transferable object not\n handled by the engine. If this hook does not exist or returns false, the JS\n engine will call the reportError hook or fall back to throwing a\n DATA_CLONE_ERR DOM Exception. This method is called before any other\n callback.\n\n  tag: indicates what type of transferable this is. Must be greater than\n       0xFFFF0201 (value of the internal SCTAG_TRANSFER_MAP_PENDING_ENTRY)\n\n  ownership: see TransferableOwnership, above. Used to communicate any needed\n       ownership info to the FreeTransferStructuredCloneOp.\n\n  content, extraData: what the ReadTransferStructuredCloneOp will receive"]
    pub type TransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            closure: *mut ::std::os::raw::c_void,
            tag: *mut u32,
            ownership: *mut root::JS::TransferableOwnership,
            content: *mut *mut ::std::os::raw::c_void,
            extraData: *mut u64,
        ) -> bool,
    >;
    #[doc = " Called when freeing a transferable handled by the embedding. Note that it\n should never trigger a garbage collection (and will assert in a\n debug build if it does.)\n\n This callback will be used to release ownership in three situations:\n\n 1. During serialization: an object is Transferred from, then an error is\n    encountered later and the incomplete serialization is discarded.\n\n 2. During deserialization: before an object is Transferred to, an error\n    is encountered and the incompletely deserialized clone is discarded. This\n    will happen with internally-implemented Transferables as well as those\n    where the readTransfer hook returns false.\n\n 3. Serialized data that includes Transferring is never deserialized (eg when\n    the receiver disappears before reading in the message), and the clone data\n    is destroyed.\n"]
    pub type FreeTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            tag: u32,
            ownership: root::JS::TransferableOwnership,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
        ),
    >;
    #[doc = " Called when the transferring objects are checked. If this function returns\n false, the serialization ends throwing a DataCloneError exception."]
    pub type CanTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            sameProcessScopeRequired: *mut bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[doc = " Called when a SharedArrayBuffer (including one owned by a Wasm memory object)\n has been processed in context `cx` by structured cloning.  If `receiving` is\n true then the SAB has been received from a channel and a new SAB object has\n been created; if false then an existing SAB has been serialized onto a\n channel.\n\n If the callback returns false then the clone operation (read or write) will\n signal a failure."]
    pub type SharedArrayBufferClonedOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            receiving: bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSStructuredCloneCallbacks {
        pub read: root::ReadStructuredCloneOp,
        pub write: root::WriteStructuredCloneOp,
        pub reportError: root::StructuredCloneErrorOp,
        pub readTransfer: root::ReadTransferStructuredCloneOp,
        pub writeTransfer: root::TransferStructuredCloneOp,
        pub freeTransfer: root::FreeTransferStructuredCloneOp,
        pub canTransfer: root::CanTransferStructuredCloneOp,
        pub sabCloned: root::SharedArrayBufferClonedOp,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSStructuredCloneCallbacks"]
            [::std::mem::size_of::<JSStructuredCloneCallbacks>() - 64usize];
        ["Alignment of JSStructuredCloneCallbacks"]
            [::std::mem::align_of::<JSStructuredCloneCallbacks>() - 8usize];
        ["Offset of field: JSStructuredCloneCallbacks::read"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, read) - 0usize];
        ["Offset of field: JSStructuredCloneCallbacks::write"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, write) - 8usize];
        ["Offset of field: JSStructuredCloneCallbacks::reportError"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, reportError) - 16usize];
        ["Offset of field: JSStructuredCloneCallbacks::readTransfer"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, readTransfer) - 24usize];
        ["Offset of field: JSStructuredCloneCallbacks::writeTransfer"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, writeTransfer) - 32usize];
        ["Offset of field: JSStructuredCloneCallbacks::freeTransfer"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, freeTransfer) - 40usize];
        ["Offset of field: JSStructuredCloneCallbacks::canTransfer"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, canTransfer) - 48usize];
        ["Offset of field: JSStructuredCloneCallbacks::sabCloned"]
            [::std::mem::offset_of!(JSStructuredCloneCallbacks, sabCloned) - 56usize];
    };
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum OwnTransferablePolicy {
        #[doc = " The buffer owns any Transferables that it might contain, and should\n properly release them upon destruction."]
        OwnsTransferablesIfAny = 0,
        #[doc = " Do not free any Transferables within this buffer when deleting it. This\n is used to mark a clone buffer as containing data from another process,\n and so it can't legitimately contain pointers. If the buffer claims to\n have transferables, it's a bug or an attack. This is also used for\n abandon(), where a buffer still contains raw data but the ownership has\n been given over to some other entity."]
        IgnoreTransferablesIfAny = 1,
        #[doc = " A buffer that cannot contain Transferables at all. This usually means\n the buffer is empty (not yet filled in, or having been cleared)."]
        NoTransferables = 2,
    }
    #[doc = " JSStructuredCloneData represents structured clone data together with the\n information needed to read/write/transfer/free the records within it, in the\n form of a set of callbacks."]
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSStructuredCloneData {
        pub bufList_: root::JSStructuredCloneData_BufferList,
        pub scope_: root::JS::StructuredCloneScope,
        pub callbacks_: *const root::JSStructuredCloneCallbacks,
        pub closure_: *mut ::std::os::raw::c_void,
        pub ownTransferables_: root::OwnTransferablePolicy,
        pub refsHeld_: root::js::SharedArrayRawBufferRefs,
        pub stringBufferRefsHeld_: root::JSStructuredCloneData_StringBuffers,
    }
    pub type JSStructuredCloneData_BufferList = root::__BindgenOpaqueArray<u64, 9usize>;
    pub type JSStructuredCloneData_Iterator = root::IterImpl;
    pub type JSStructuredCloneData_StringBuffers = root::__BindgenOpaqueArray<u64, 7usize>;
    pub const JSStructuredCloneData_kStandardCapacity: usize = 4096;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSStructuredCloneData"]
            [::std::mem::size_of::<JSStructuredCloneData>() - 184usize];
        ["Alignment of JSStructuredCloneData"]
            [::std::mem::align_of::<JSStructuredCloneData>() - 8usize];
        ["Offset of field: JSStructuredCloneData::bufList_"]
            [::std::mem::offset_of!(JSStructuredCloneData, bufList_) - 0usize];
        ["Offset of field: JSStructuredCloneData::scope_"]
            [::std::mem::offset_of!(JSStructuredCloneData, scope_) - 72usize];
        ["Offset of field: JSStructuredCloneData::callbacks_"]
            [::std::mem::offset_of!(JSStructuredCloneData, callbacks_) - 80usize];
        ["Offset of field: JSStructuredCloneData::closure_"]
            [::std::mem::offset_of!(JSStructuredCloneData, closure_) - 88usize];
        ["Offset of field: JSStructuredCloneData::ownTransferables_"]
            [::std::mem::offset_of!(JSStructuredCloneData, ownTransferables_) - 96usize];
        ["Offset of field: JSStructuredCloneData::refsHeld_"]
            [::std::mem::offset_of!(JSStructuredCloneData, refsHeld_) - 104usize];
        ["Offset of field: JSStructuredCloneData::stringBufferRefsHeld_"]
            [::std::mem::offset_of!(JSStructuredCloneData, stringBufferRefsHeld_) - 128usize];
    };
    extern "C" {
        #[doc = " Implements StructuredDeserialize and StructuredDeserializeWithTransfer.\n\n Note: If `data` contains transferable objects, it can be read only once."]
        #[link_name = "\u{1}_Z22JS_ReadStructuredCloneP9JSContextRK21JSStructuredCloneDatajN2JS20StructuredCloneScopeENS4_13MutableHandleINS4_5ValueEEERKNS4_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_ReadStructuredClone(
            cx: *mut root::JSContext,
            data: *const root::JSStructuredCloneData,
            version: u32,
            scope: root::JS::StructuredCloneScope,
            vp: root::JS::MutableHandleValue,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Implements StructuredSerialize, StructuredSerializeForStorage, and\n StructuredSerializeWithTransfer.\n\n Note: If the scope is DifferentProcess then the cloneDataPolicy must deny\n shared-memory objects, or an error will be signaled if a shared memory object\n is seen."]
        #[link_name = "\u{1}_Z23JS_WriteStructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEEP21JSStructuredCloneDataNS1_20StructuredCloneScopeERKNS1_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPvS4_"]
        pub fn JS_WriteStructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            data: *mut root::JSStructuredCloneData,
            scope: root::JS::StructuredCloneScope,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
            transferable: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_StructuredCloneHasTransferablesR21JSStructuredCloneDataPb"]
        pub fn JS_StructuredCloneHasTransferables(
            data: *mut root::JSStructuredCloneData,
            hasTransferable: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_StructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIS3_EEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_StructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            vp: root::JS::MutableHandleValue,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    #[doc = " The C-style API calls to read and write structured clones are fragile --\n they rely on the caller to properly handle ownership of the clone data, and\n the handling of the input data as well as the interpretation of the contents\n of the clone buffer are dependent on the callbacks passed in. If you\n serialize and deserialize with different callbacks, the results are\n questionable.\n\n JSAutoStructuredCloneBuffer wraps things up in an RAII class for data\n management, and uses the same callbacks for both writing and reading\n (serializing and deserializing)."]
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSAutoStructuredCloneBuffer {
        pub data_: root::JSStructuredCloneData,
        pub version_: u32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSAutoStructuredCloneBuffer"]
            [::std::mem::size_of::<JSAutoStructuredCloneBuffer>() - 192usize];
        ["Alignment of JSAutoStructuredCloneBuffer"]
            [::std::mem::align_of::<JSAutoStructuredCloneBuffer>() - 8usize];
        ["Offset of field: JSAutoStructuredCloneBuffer::data_"]
            [::std::mem::offset_of!(JSAutoStructuredCloneBuffer, data_) - 0usize];
        ["Offset of field: JSAutoStructuredCloneBuffer::version_"]
            [::std::mem::offset_of!(JSAutoStructuredCloneBuffer, version_) - 184usize];
    };
    extern "C" {
        #[link_name = "\u{1}_Z17JS_ReadUint32PairP23JSStructuredCloneReaderPjS1_"]
        pub fn JS_ReadUint32Pair(
            r: *mut root::JSStructuredCloneReader,
            p1: *mut u32,
            p2: *mut u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_ReadBytesP23JSStructuredCloneReaderPvm"]
        pub fn JS_ReadBytes(
            r: *mut root::JSStructuredCloneReader,
            p: *mut ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_ReadStringP23JSStructuredCloneReaderN2JS13MutableHandleIP8JSStringEE"]
        pub fn JS_ReadString(
            r: *mut root::JSStructuredCloneReader,
            str_: root::JS::MutableHandleString,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_ReadDoubleP23JSStructuredCloneReaderPd"]
        pub fn JS_ReadDouble(r: *mut root::JSStructuredCloneReader, v: *mut f64) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_ReadTypedArrayP23JSStructuredCloneReaderN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ReadTypedArray(
            r: *mut root::JSStructuredCloneReader,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_WriteUint32PairP23JSStructuredCloneWriterjj"]
        pub fn JS_WriteUint32Pair(
            w: *mut root::JSStructuredCloneWriter,
            tag: u32,
            data: u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_WriteBytesP23JSStructuredCloneWriterPKvm"]
        pub fn JS_WriteBytes(
            w: *mut root::JSStructuredCloneWriter,
            p: *const ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_WriteStringP23JSStructuredCloneWriterN2JS6HandleIP8JSStringEE"]
        pub fn JS_WriteString(
            w: *mut root::JSStructuredCloneWriter,
            str_: root::JS::HandleString,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_WriteDoubleP23JSStructuredCloneWriterd"]
        pub fn JS_WriteDouble(w: *mut root::JSStructuredCloneWriter, v: f64) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_WriteTypedArrayP23JSStructuredCloneWriterN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_WriteTypedArray(
            w: *mut root::JSStructuredCloneWriter,
            v: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_ObjectNotWrittenP23JSStructuredCloneWriterN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ObjectNotWritten(
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetStructuredCloneScopeP23JSStructuredCloneWriter"]
        pub fn JS_GetStructuredCloneScope(
            w: *mut root::JSStructuredCloneWriter,
        ) -> root::JS::StructuredCloneScope;
    }
    #[doc = " A class, expected to be passed by value, which represents the CallArgs for a\n JSJitGetterOp."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitGetterCallArgs {
        pub _base: root::JS::MutableHandle<root::JS::Value>,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitGetterCallArgs"][::std::mem::size_of::<JSJitGetterCallArgs>() - 8usize];
        ["Alignment of JSJitGetterCallArgs"]
            [::std::mem::align_of::<JSJitGetterCallArgs>() - 8usize];
    };
    #[doc = " A class, expected to be passed by value, which represents the CallArgs for a\n JSJitSetterOp."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitSetterCallArgs {
        pub _base: root::JS::MutableHandle<root::JS::Value>,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitSetterCallArgs"][::std::mem::size_of::<JSJitSetterCallArgs>() - 8usize];
        ["Alignment of JSJitSetterCallArgs"]
            [::std::mem::align_of::<JSJitSetterCallArgs>() - 8usize];
    };
    pub type JSJitMethodCallArgs_Base = root::__BindgenOpaqueArray<u64, 2usize>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitMethodCallArgsTraits {
        pub _address: u8,
    }
    pub const JSJitMethodCallArgsTraits_offsetOfArgv: usize = 0;
    pub const JSJitMethodCallArgsTraits_offsetOfArgc: usize = 8;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitMethodCallArgsTraits"]
            [::std::mem::size_of::<JSJitMethodCallArgsTraits>() - 1usize];
        ["Alignment of JSJitMethodCallArgsTraits"]
            [::std::mem::align_of::<JSJitMethodCallArgsTraits>() - 1usize];
    };
    pub type JSJitGetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: root::JSJitGetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitSetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: root::JSJitSetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitMethodOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: *const root::JSJitMethodCallArgs,
        ) -> bool,
    >;
    #[doc = " This struct contains metadata passed from the DOM to the JS Engine for JIT\n optimizations on DOM property accessors.\n\n Eventually, this should be made available to general JSAPI users as *not*\n experimental and *not* a friend API, but we're not ready to do so yet."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSJitInfo {
        pub __bindgen_anon_1: root::JSJitInfo__bindgen_ty_1,
        pub __bindgen_anon_2: root::JSJitInfo__bindgen_ty_2,
        pub __bindgen_anon_3: root::JSJitInfo__bindgen_ty_3,
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_OpType {
        Getter = 0,
        Setter = 1,
        Method = 2,
        StaticMethod = 3,
        InlinableNative = 4,
        TrampolineNative = 5,
        IgnoresReturnValueNative = 6,
        OpTypeCount = 7,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_ArgType {
        String = 1,
        Integer = 2,
        Double = 4,
        Boolean = 8,
        Object = 16,
        Null = 32,
        Numeric = 6,
        Primitive = 47,
        ObjectOrNull = 48,
        Any = 63,
        ArgTypeListEnd = -2147483648,
    }
    #[repr(u32)]
    #[doc = " An enum that describes what this getter/setter/method aliases.  This\n determines what things can be hoisted past this call, and if this\n call is movable what it can be hoisted past."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_AliasSet {
        #[doc = " Alias nothing: a constant value, getting it can't affect any other\n values, nothing can affect it."]
        AliasNone = 0,
        #[doc = " Alias things that can modify the DOM but nothing else.  Doing the\n call can't affect the behavior of any other function."]
        AliasDOMSets = 1,
        #[doc = " Alias the world.  Calling this can change arbitrary values anywhere\n in the system.  Most things fall in this bucket."]
        AliasEverything = 2,
        #[doc = " Must be last."]
        AliasSetCount = 3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_1 {
        pub getter: root::JSJitGetterOp,
        pub setter: root::JSJitSetterOp,
        pub method: root::JSJitMethodOp,
        #[doc = " A DOM static method, used for Promise wrappers"]
        pub staticMethod: root::JSNative,
        pub ignoresReturnValueMethod: root::JSNative,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitInfo__bindgen_ty_1"]
            [::std::mem::size_of::<JSJitInfo__bindgen_ty_1>() - 8usize];
        ["Alignment of JSJitInfo__bindgen_ty_1"]
            [::std::mem::align_of::<JSJitInfo__bindgen_ty_1>() - 8usize];
        ["Offset of field: JSJitInfo__bindgen_ty_1::getter"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_1, getter) - 0usize];
        ["Offset of field: JSJitInfo__bindgen_ty_1::setter"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_1, setter) - 0usize];
        ["Offset of field: JSJitInfo__bindgen_ty_1::method"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_1, method) - 0usize];
        ["Offset of field: JSJitInfo__bindgen_ty_1::staticMethod"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_1, staticMethod) - 0usize];
        ["Offset of field: JSJitInfo__bindgen_ty_1::ignoresReturnValueMethod"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_1, ignoresReturnValueMethod) - 0usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_2 {
        pub protoID: u16,
        pub inlinableNative: root::js::jit::InlinableNative,
        pub trampolineNative: root::js::jit::TrampolineNative,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitInfo__bindgen_ty_2"]
            [::std::mem::size_of::<JSJitInfo__bindgen_ty_2>() - 2usize];
        ["Alignment of JSJitInfo__bindgen_ty_2"]
            [::std::mem::align_of::<JSJitInfo__bindgen_ty_2>() - 2usize];
        ["Offset of field: JSJitInfo__bindgen_ty_2::protoID"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_2, protoID) - 0usize];
        ["Offset of field: JSJitInfo__bindgen_ty_2::inlinableNative"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_2, inlinableNative) - 0usize];
        ["Offset of field: JSJitInfo__bindgen_ty_2::trampolineNative"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_2, trampolineNative) - 0usize];
    };
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_3 {
        pub depth: u16,
        pub nativeOp: u16,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitInfo__bindgen_ty_3"]
            [::std::mem::size_of::<JSJitInfo__bindgen_ty_3>() - 2usize];
        ["Alignment of JSJitInfo__bindgen_ty_3"]
            [::std::mem::align_of::<JSJitInfo__bindgen_ty_3>() - 2usize];
        ["Offset of field: JSJitInfo__bindgen_ty_3::depth"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_3, depth) - 0usize];
        ["Offset of field: JSJitInfo__bindgen_ty_3::nativeOp"]
            [::std::mem::offset_of!(JSJitInfo__bindgen_ty_3, nativeOp) - 0usize];
    };
    pub const JSJitInfo_OpTypeBits: usize = 4;
    pub const JSJitInfo_AliasSetBits: usize = 4;
    pub const JSJitInfo_ReturnTypeBits: usize = 8;
    pub const JSJitInfo_SlotIndexBits: usize = 10;
    pub const JSJitInfo_maxSlotIndex: usize = 1023;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitInfo"][::std::mem::size_of::<JSJitInfo>() - 16usize];
        ["Alignment of JSJitInfo"][::std::mem::align_of::<JSJitInfo>() - 8usize];
    };
    impl JSJitInfo {
        #[inline]
        pub fn type_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_type_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn type__raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    4u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_type__raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    0usize,
                    4u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn aliasSet_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_aliasSet_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn aliasSet__raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    4usize,
                    4u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_aliasSet__raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    4usize,
                    4u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn returnType_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_returnType_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(8usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn returnType__raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    8usize,
                    8u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_returnType__raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    8usize,
                    8u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn isInfallible(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isInfallible(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isInfallible_raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    16usize,
                    1u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_isInfallible_raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    16usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn isMovable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isMovable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(17usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isMovable_raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    17usize,
                    1u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_isMovable_raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    17usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn isEliminatable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isEliminatable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(18usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isEliminatable_raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    18usize,
                    1u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_isEliminatable_raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    18usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn isAlwaysInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isAlwaysInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(19usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isAlwaysInSlot_raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    19usize,
                    1u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_isAlwaysInSlot_raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    19usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn isLazilyCachedInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isLazilyCachedInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(20usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isLazilyCachedInSlot_raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    20usize,
                    1u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_isLazilyCachedInSlot_raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    20usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn isTypedMethod(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isTypedMethod(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(21usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn isTypedMethod_raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    21usize,
                    1u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_isTypedMethod_raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    21usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn slotIndex(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
        }
        #[inline]
        pub fn set_slotIndex(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(22usize, 10u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn slotIndex_raw(this: *const Self) -> u32 {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    22usize,
                    10u8,
                ) as u32)
            }
        }
        #[inline]
        pub unsafe fn set_slotIndex_raw(this: *mut Self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    22usize,
                    10u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            type_: u32,
            aliasSet_: u32,
            returnType_: u32,
            isInfallible: u32,
            isMovable: u32,
            isEliminatable: u32,
            isAlwaysInSlot: u32,
            isLazilyCachedInSlot: u32,
            isTypedMethod: u32,
            slotIndex: u32,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let type_: u32 = unsafe { ::std::mem::transmute(type_) };
                type_ as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let aliasSet_: u32 = unsafe { ::std::mem::transmute(aliasSet_) };
                aliasSet_ as u64
            });
            __bindgen_bitfield_unit.set(8usize, 8u8, {
                let returnType_: u32 = unsafe { ::std::mem::transmute(returnType_) };
                returnType_ as u64
            });
            __bindgen_bitfield_unit.set(16usize, 1u8, {
                let isInfallible: u32 = unsafe { ::std::mem::transmute(isInfallible) };
                isInfallible as u64
            });
            __bindgen_bitfield_unit.set(17usize, 1u8, {
                let isMovable: u32 = unsafe { ::std::mem::transmute(isMovable) };
                isMovable as u64
            });
            __bindgen_bitfield_unit.set(18usize, 1u8, {
                let isEliminatable: u32 = unsafe { ::std::mem::transmute(isEliminatable) };
                isEliminatable as u64
            });
            __bindgen_bitfield_unit.set(19usize, 1u8, {
                let isAlwaysInSlot: u32 = unsafe { ::std::mem::transmute(isAlwaysInSlot) };
                isAlwaysInSlot as u64
            });
            __bindgen_bitfield_unit.set(20usize, 1u8, {
                let isLazilyCachedInSlot: u32 =
                    unsafe { ::std::mem::transmute(isLazilyCachedInSlot) };
                isLazilyCachedInSlot as u64
            });
            __bindgen_bitfield_unit.set(21usize, 1u8, {
                let isTypedMethod: u32 = unsafe { ::std::mem::transmute(isTypedMethod) };
                isTypedMethod as u64
            });
            __bindgen_bitfield_unit.set(22usize, 10u8, {
                let slotIndex: u32 = unsafe { ::std::mem::transmute(slotIndex) };
                slotIndex as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSTypedMethodJitInfo {
        pub base: root::JSJitInfo,
        pub argTypes: *const root::JSJitInfo_ArgType,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSTypedMethodJitInfo"][::std::mem::size_of::<JSTypedMethodJitInfo>() - 24usize];
        ["Alignment of JSTypedMethodJitInfo"]
            [::std::mem::align_of::<JSTypedMethodJitInfo>() - 8usize];
        ["Offset of field: JSTypedMethodJitInfo::base"]
            [::std::mem::offset_of!(JSTypedMethodJitInfo, base) - 0usize];
        ["Offset of field: JSTypedMethodJitInfo::argTypes"]
            [::std::mem::offset_of!(JSTypedMethodJitInfo, argTypes) - 16usize];
    };
    extern "C" {
        #[link_name = "\u{1}_Z15JS_NewInt8ArrayP9JSContextm"]
        pub fn JS_NewInt8Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_NewInt8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewInt8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewUint8ArrayP9JSContextm"]
        pub fn JS_NewUint8Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewUint8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewInt16ArrayP9JSContextm"]
        pub fn JS_NewInt16Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewInt16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewInt16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewUint16ArrayP9JSContextm"]
        pub fn JS_NewUint16Array(cx: *mut root::JSContext, nelements: usize)
            -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewUint16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewInt32ArrayP9JSContextm"]
        pub fn JS_NewInt32Array(cx: *mut root::JSContext, nelements: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewInt32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewInt32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewUint32ArrayP9JSContextm"]
        pub fn JS_NewUint32Array(cx: *mut root::JSContext, nelements: usize)
            -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewUint32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewFloat32ArrayP9JSContextm"]
        pub fn JS_NewFloat32Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewFloat32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewFloat32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewFloat32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewFloat64ArrayP9JSContextm"]
        pub fn JS_NewFloat64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewFloat64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewFloat64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewFloat64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_NewUint8ClampedArrayP9JSContextm"]
        pub fn JS_NewUint8ClampedArray(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_NewUint8ClampedArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ClampedArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NewUint8ClampedArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewUint8ClampedArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewBigInt64ArrayP9JSContextm"]
        pub fn JS_NewBigInt64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewBigInt64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewBigInt64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_NewBigInt64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewBigInt64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_NewBigUint64ArrayP9JSContextm"]
        pub fn JS_NewBigUint64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_NewBigUint64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewBigUint64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_NewBigUint64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewBigUint64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewFloat16ArrayP9JSContextm"]
        pub fn JS_NewFloat16Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewFloat16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewFloat16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEml"]
        pub fn JS_NewFloat16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Check whether obj supports JS_GetTypedArray* APIs. Note that this may return\n false if a security wrapper is encountered that denies the unwrapping. If\n this test or one of the JS_Is*Array tests succeeds, then it is safe to call\n the various accessor JSAPI calls defined below."]
        #[link_name = "\u{1}_Z21JS_IsTypedArrayObjectP8JSObject"]
        pub fn JS_IsTypedArrayObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may\n return false if a security wrapper is encountered that denies the\n unwrapping. If this test or one of the more specific tests succeeds, then it\n is safe to call the various ArrayBufferView accessor JSAPI calls defined\n below."]
        #[link_name = "\u{1}_Z26JS_IsArrayBufferViewObjectP8JSObject"]
        pub fn JS_IsArrayBufferViewObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Return the isShared flag of a typed array, which denotes whether\n the underlying buffer is a SharedArrayBuffer.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArraySharednessP8JSObject"]
        pub fn JS_GetTypedArraySharedness(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetObjectAsInt8ArrayP8JSObjectPmPbPPa"]
        pub fn JS_GetObjectAsInt8Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsUint8ArrayP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsUint8Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt16ArrayP8JSObjectPmPbPPs"]
        pub fn JS_GetObjectAsInt16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i16,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint16ArrayP8JSObjectPmPbPPt"]
        pub fn JS_GetObjectAsUint16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt32ArrayP8JSObjectPmPbPPi"]
        pub fn JS_GetObjectAsInt32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint32ArrayP8JSObjectPmPbPPj"]
        pub fn JS_GetObjectAsUint32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat32ArrayP8JSObjectPmPbPPf"]
        pub fn JS_GetObjectAsFloat32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat64ArrayP8JSObjectPmPbPPd"]
        pub fn JS_GetObjectAsFloat64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31JS_GetObjectAsUint8ClampedArrayP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsUint8ClampedArray(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetObjectAsBigInt64ArrayP8JSObjectPmPbPPl"]
        pub fn JS_GetObjectAsBigInt64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_GetObjectAsBigUint64ArrayP8JSObjectPmPbPS1_"]
        pub fn JS_GetObjectAsBigUint64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat16ArrayP8JSObjectPmPbPPt"]
        pub fn JS_GetObjectAsFloat16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetObjectAsArrayBufferViewP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsArrayBufferView(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewTypeP8JSObject"]
        pub fn JS_GetArrayBufferViewType(obj: *mut root::JSObject) -> root::JS::Scalar::Type;
    }
    extern "C" {
        #[doc = " Return the number of elements in a typed array.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z22JS_GetTypedArrayLengthP8JSObject"]
        pub fn JS_GetTypedArrayLength(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " Return the byte offset from the start of an ArrayBuffer to the start of a\n typed array view.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteOffsetP8JSObject"]
        pub fn JS_GetTypedArrayByteOffset(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " Return the byte length of a typed array.\n\n |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow\n be known that it would pass such a test: it is a typed array or a wrapper of\n a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteLengthP8JSObject"]
        pub fn JS_GetTypedArrayByteLength(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " More generic name for JS_GetTypedArrayByteLength to cover DataViews as well"]
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteLengthP8JSObject"]
        pub fn JS_GetArrayBufferViewByteLength(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " More generic name for JS_GetTypedArrayByteOffset to cover DataViews as well"]
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteOffsetP8JSObject"]
        pub fn JS_GetArrayBufferViewByteOffset(obj: *mut root::JSObject) -> usize;
    }
    extern "C" {
        #[doc = " Same as above, but for any kind of ArrayBufferView. Prefer the type-specific\n versions when possible."]
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetArrayBufferViewData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Return a \"fixed\" pointer (one that will not move during a GC) to the\n ArrayBufferView's data. Note that this will not keep the object alive; the\n holding object should be rooted or traced. If the view is storing the data\n inline, this will copy the data to the provided buffer, returning nullptr if\n bufSize is inadequate.\n\n Avoid using this unless necessary. JS_GetArrayBufferViewData is simpler and\n more efficient because it requires the caller to ensure that a GC will not\n occur and thus does not need to handle movable data."]
        #[link_name = "\u{1}_Z30JS_GetArrayBufferViewFixedDataP8JSObjectPhm"]
        pub fn JS_GetArrayBufferViewFixedData(
            obj: *mut root::JSObject,
            buffer: *mut u8,
            bufSize: usize,
        ) -> *mut u8;
    }
    extern "C" {
        #[doc = " If the bufSize passed to JS_GetArrayBufferViewFixedData is at least this\n many bytes, then any copied data is guaranteed to fit into the provided\n buffer."]
        #[link_name = "\u{1}_Z27JS_MaxMovableTypedArraySizev"]
        pub fn JS_MaxMovableTypedArraySize() -> usize;
    }
    extern "C" {
        #[doc = " Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView.\n This may return a detached buffer.  |obj| must be an object that would\n return true for JS_IsArrayBufferViewObject()."]
        #[link_name = "\u{1}_Z27JS_GetArrayBufferViewBufferP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_GetArrayBufferViewBuffer(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            isSharedMemory: *mut bool,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Create a new DataView using the given buffer for storage. The given buffer\n must be an ArrayBuffer or SharedArrayBuffer (or a cross-compartment wrapper\n of either type), and the offset and length must fit within the bounds of the\n buffer. Currently, nullptr will be returned and an exception will be thrown\n if these conditions do not hold, but do not depend on that behavior."]
        #[link_name = "\u{1}_Z14JS_NewDataViewP9JSContextN2JS6HandleIP8JSObjectEEmm"]
        pub fn JS_NewDataView(
            cx: *mut root::JSContext,
            buffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            byteLength: usize,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetInt8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt8ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetUint8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetInt16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_GetUint16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetInt32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_GetUint32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetFloat32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetFloat64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetUint8ClampedArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ClampedArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetBigInt64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetBigInt64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetBigUint64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetBigUint64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetFloat16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u16;
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSErrNum {
        JSMSG_NOT_AN_ERROR = 0,
        JSMSG_NOT_DEFINED = 1,
        JSMSG_MORE_ARGS_NEEDED = 2,
        JSMSG_INCOMPATIBLE_PROTO = 3,
        JSMSG_INCOMPATIBLE_PROTO2 = 4,
        JSMSG_NO_CONSTRUCTOR = 5,
        JSMSG_BAD_SORT_ARG = 6,
        JSMSG_BAD_TOSORTED_ARG = 7,
        JSMSG_BAD_TYPEDARRAY_SORT_ARG = 8,
        JSMSG_READ_ONLY = 9,
        JSMSG_CANT_DELETE = 10,
        JSMSG_CANT_TRUNCATE_ARRAY = 11,
        JSMSG_NOT_FUNCTION = 12,
        JSMSG_PROPERTY_NOT_CALLABLE = 13,
        JSMSG_NOT_CONSTRUCTOR = 14,
        JSMSG_BOGUS_CONSTRUCTOR = 15,
        JSMSG_CANT_CONVERT_TO = 16,
        JSMSG_TOPRIMITIVE_NOT_CALLABLE = 17,
        JSMSG_TOPRIMITIVE_RETURNED_OBJECT = 18,
        JSMSG_NO_PROPERTIES = 19,
        JSMSG_PROPERTY_FAIL = 20,
        JSMSG_PROPERTY_FAIL_EXPR = 21,
        JSMSG_BAD_REGEXP_FLAG = 22,
        JSMSG_INVALID_DATA_VIEW_LENGTH = 23,
        JSMSG_OFFSET_LARGER_THAN_FILESIZE = 24,
        JSMSG_OFFSET_OUT_OF_BUFFER = 25,
        JSMSG_OFFSET_OUT_OF_DATAVIEW = 26,
        JSMSG_SPREAD_TOO_LARGE = 27,
        JSMSG_BAD_WEAKMAP_KEY = 28,
        JSMSG_WEAKMAP_KEY_CANT_BE_HELD_WEAKLY = 29,
        JSMSG_WEAKSET_VAL_CANT_BE_HELD_WEAKLY = 30,
        JSMSG_WEAKMAP_KEY_MUST_BE_AN_OBJECT = 31,
        JSMSG_WEAKSET_VAL_MUST_BE_AN_OBJECT = 32,
        JSMSG_BAD_GETTER_OR_SETTER = 33,
        JSMSG_BAD_ARRAY_LENGTH = 34,
        JSMSG_SOURCE_ARRAY_TOO_LONG = 35,
        JSMSG_PREV_DECLARATION = 36,
        JSMSG_REDECLARED_VAR = 37,
        JSMSG_MISMATCHED_PLACEMENT = 38,
        JSMSG_UNDECLARED_VAR = 39,
        JSMSG_GET_MISSING_PRIVATE = 40,
        JSMSG_SET_MISSING_PRIVATE = 41,
        JSMSG_GETTER_ONLY = 42,
        JSMSG_PRIVATE_SETTER_ONLY = 43,
        JSMSG_OVERWRITING_ACCESSOR = 44,
        JSMSG_INVALID_MAP_ITERABLE = 45,
        JSMSG_NESTING_GENERATOR = 46,
        JSMSG_INCOMPATIBLE_METHOD = 47,
        JSMSG_BAD_SURROGATE_CHAR = 48,
        JSMSG_UTF8_CHAR_TOO_LARGE = 49,
        JSMSG_MALFORMED_UTF8_CHAR = 50,
        JSMSG_BUILTIN_CTOR_NO_NEW = 51,
        JSMSG_EMPTY_ARRAY_REDUCE = 52,
        JSMSG_EMPTY_ITERATOR_REDUCE = 53,
        JSMSG_UNEXPECTED_TYPE = 54,
        JSMSG_MISSING_FUN_ARG = 55,
        JSMSG_OBJECT_REQUIRED = 56,
        JSMSG_OBJECT_REQUIRED_ARG = 57,
        JSMSG_OBJECT_REQUIRED_PROP_DESC = 58,
        JSMSG_OBJECT_REQUIRED_RET_OWNKEYS = 59,
        JSMSG_WRONG_TYPE_ARG = 60,
        JSMSG_SET_NON_OBJECT_RECEIVER = 61,
        JSMSG_INVALID_DESCRIPTOR = 62,
        JSMSG_OBJECT_NOT_EXTENSIBLE = 63,
        JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE = 64,
        JSMSG_CANT_REDEFINE_PROP = 65,
        JSMSG_CANT_REDEFINE_ARRAY_LENGTH = 66,
        JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH = 67,
        JSMSG_BAD_GET_SET_FIELD = 68,
        JSMSG_THROW_TYPE_ERROR = 69,
        JSMSG_NOT_EXPECTED_TYPE = 70,
        JSMSG_NOT_ITERABLE = 71,
        JSMSG_ALREADY_HAS_PRAGMA = 72,
        JSMSG_GET_ITER_RETURNED_PRIMITIVE = 73,
        JSMSG_ITER_METHOD_RETURNED_PRIMITIVE = 74,
        JSMSG_CANT_SET_PROTO = 75,
        JSMSG_CANT_SET_PROTO_OF = 76,
        JSMSG_CANT_SET_PROTO_CYCLE = 77,
        JSMSG_INVALID_ARG_TYPE = 78,
        JSMSG_TERMINATED = 79,
        JSMSG_CANT_CALL_CLASS_CONSTRUCTOR = 80,
        JSMSG_UNINITIALIZED_THIS = 81,
        JSMSG_BAD_DERIVED_RETURN = 82,
        JSMSG_BAD_HERITAGE = 83,
        JSMSG_NOT_OBJORNULL = 84,
        JSMSG_CONSTRUCTOR_DISABLED = 85,
        JSMSG_DISPOSE_NOT_CALLABLE = 86,
        JSMSG_DISPOSABLE_NOT_OBJ = 87,
        JSMSG_JSON_BAD_PARSE = 88,
        JSMSG_JSON_CYCLIC_VALUE = 89,
        JSMSG_JSON_RAW_EMPTY = 90,
        JSMSG_JSON_RAW_ARRAY_OR_OBJECT = 91,
        JSMSG_JSON_RAW_WHITESPACE = 92,
        JSMSG_ASSIGN_TO_CALL = 93,
        JSMSG_ASSIGN_TO_PRIVATE_METHOD = 94,
        JSMSG_BAD_INSTANCEOF_RHS = 95,
        JSMSG_BAD_PROTOTYPE = 96,
        JSMSG_IN_NOT_OBJECT = 97,
        JSMSG_IN_STRING = 98,
        JSMSG_TOO_MANY_CON_SPREADARGS = 99,
        JSMSG_TOO_MANY_FUN_SPREADARGS = 100,
        JSMSG_UNINITIALIZED_LEXICAL = 101,
        JSMSG_BAD_CONST_ASSIGN = 102,
        JSMSG_CANT_DECLARE_GLOBAL_BINDING = 103,
        JSMSG_INVALID_DATE = 104,
        JSMSG_BAD_TOISOSTRING_PROP = 105,
        JSMSG_BAD_URI = 106,
        JSMSG_INVALID_NORMALIZE_FORM = 107,
        JSMSG_NEGATIVE_REPETITION_COUNT = 108,
        JSMSG_NOT_A_CODEPOINT = 109,
        JSMSG_RESULTING_STRING_TOO_LARGE = 110,
        JSMSG_FLAGS_UNDEFINED_OR_NULL = 111,
        JSMSG_REQUIRES_GLOBAL_REGEXP = 112,
        JSMSG_BAD_RADIX = 113,
        JSMSG_PRECISION_RANGE = 114,
        JSMSG_BAD_APPLY_ARGS = 115,
        JSMSG_DEPRECATED_USAGE = 116,
        JSMSG_NO_REST_NAME = 117,
        JSMSG_PARAMETER_AFTER_REST = 118,
        JSMSG_TOO_MANY_ARGUMENTS = 119,
        JSMSG_CSP_BLOCKED_EVAL = 120,
        JSMSG_CSP_BLOCKED_FUNCTION = 121,
        JSMSG_CSP_BLOCKED_WASM = 122,
        JSMSG_CSP_BLOCKED_SHADOWREALM = 123,
        JSMSG_ACCESSOR_DEF_DENIED = 124,
        JSMSG_DEAD_OBJECT = 125,
        JSMSG_OBJECT_ACCESS_DENIED = 126,
        JSMSG_PROPERTY_ACCESS_DENIED = 127,
        JSMSG_CANT_CLONE_OBJECT = 128,
        JSMSG_CANT_OPEN = 129,
        JSMSG_SUPPORT_NOT_ENABLED = 130,
        JSMSG_USER_DEFINED_ERROR = 131,
        JSMSG_ALLOC_OVERFLOW = 132,
        JSMSG_BAD_BYTECODE = 133,
        JSMSG_BUFFER_TOO_SMALL = 134,
        JSMSG_BYTECODE_TOO_BIG = 135,
        JSMSG_NEED_DIET = 136,
        JSMSG_OUT_OF_MEMORY = 137,
        JSMSG_OVER_RECURSED = 138,
        JSMSG_TOO_DEEP = 139,
        JSMSG_UNCAUGHT_EXCEPTION = 140,
        JSMSG_UNKNOWN_FORMAT = 141,
        JSMSG_UNSAFE_FILENAME = 142,
        JSMSG_ACCESSOR_WRONG_ARGS = 143,
        JSMSG_ARRAY_INIT_TOO_BIG = 144,
        JSMSG_AS_AFTER_IMPORT_STAR = 145,
        JSMSG_AS_AFTER_RESERVED_WORD = 146,
        JSMSG_AS_AFTER_STRING = 147,
        JSMSG_AWAIT_IN_PARAMETER = 148,
        JSMSG_AWAIT_OUTSIDE_ASYNC = 149,
        JSMSG_AWAIT_OUTSIDE_ASYNC_OR_MODULE = 150,
        JSMSG_TOP_LEVEL_AWAIT_NOT_SUPPORTED = 151,
        JSMSG_BAD_ARROW_ARGS = 152,
        JSMSG_BAD_CLASS_MEMBER_DEF = 153,
        JSMSG_BAD_COALESCE_MIXING = 154,
        JSMSG_BAD_CONST_DECL = 155,
        JSMSG_BAD_USING_DECL = 156,
        JSMSG_BAD_CONSTRUCTOR_DEF = 157,
        JSMSG_BAD_CONTINUE = 158,
        JSMSG_BAD_DESTRUCT_ASS = 159,
        JSMSG_BAD_DESTRUCT_TARGET = 160,
        JSMSG_BAD_DESTRUCT_PARENS = 161,
        JSMSG_BAD_DESTRUCT_DECL = 162,
        JSMSG_BAD_DUP_ARGS = 163,
        JSMSG_BAD_FOR_LEFTSIDE = 164,
        JSMSG_LEXICAL_DECL_DEFINES_LET = 165,
        JSMSG_BAD_STARTING_FOROF_LHS = 166,
        JSMSG_BAD_INCOP_OPERAND = 167,
        JSMSG_BAD_LEFTSIDE_OF_ASS = 168,
        JSMSG_BAD_LOCAL_STRING_EXPORT = 169,
        JSMSG_BAD_POW_LEFTSIDE = 170,
        JSMSG_BAD_PROP_ID = 171,
        JSMSG_BAD_RETURN_OR_YIELD = 172,
        JSMSG_BAD_STRICT_ASSIGN = 173,
        JSMSG_BAD_STRICT_ASSIGN_ARGUMENTS = 174,
        JSMSG_BAD_STRICT_ASSIGN_EVAL = 175,
        JSMSG_BAD_SWITCH = 176,
        JSMSG_BAD_SUPER = 177,
        JSMSG_BAD_SUPERPROP = 178,
        JSMSG_BAD_SUPERPRIVATE = 179,
        JSMSG_BAD_SUPERCALL = 180,
        JSMSG_BAD_ARGUMENTS = 181,
        JSMSG_BRACKET_AFTER_LIST = 182,
        JSMSG_BRACKET_IN_INDEX = 183,
        JSMSG_BRACKET_OPENED = 184,
        JSMSG_CATCH_IDENTIFIER = 185,
        JSMSG_CATCH_OR_FINALLY = 186,
        JSMSG_CATCH_WITHOUT_TRY = 187,
        JSMSG_CLASS_STATIC_PROTO = 188,
        JSMSG_COLON_AFTER_CASE = 189,
        JSMSG_COLON_AFTER_ID = 190,
        JSMSG_COLON_IN_COND = 191,
        JSMSG_COMP_PROP_UNTERM_EXPR = 192,
        JSMSG_CURLY_AFTER_BODY = 193,
        JSMSG_CURLY_OPENED = 194,
        JSMSG_CURLY_AFTER_CATCH = 195,
        JSMSG_CURLY_AFTER_FINALLY = 196,
        JSMSG_CURLY_AFTER_LIST = 197,
        JSMSG_CURLY_AFTER_TRY = 198,
        JSMSG_CURLY_BEFORE_BODY = 199,
        JSMSG_CURLY_BEFORE_CATCH = 200,
        JSMSG_CURLY_BEFORE_CLASS = 201,
        JSMSG_CURLY_BEFORE_FINALLY = 202,
        JSMSG_CURLY_BEFORE_SWITCH = 203,
        JSMSG_CURLY_BEFORE_TRY = 204,
        JSMSG_CURLY_IN_COMPOUND = 205,
        JSMSG_DECLARATION_AFTER_EXPORT = 206,
        JSMSG_DECLARATION_AFTER_IMPORT = 207,
        JSMSG_DEPRECATED_DELETE_OPERAND = 208,
        JSMSG_DEPRECATED_OCTAL_LITERAL = 209,
        JSMSG_DEPRECATED_OCTAL_ESCAPE = 210,
        JSMSG_DEPRECATED_EIGHT_OR_NINE_ESCAPE = 211,
        JSMSG_DEPRECATED_PRAGMA = 212,
        JSMSG_DUPLICATE_CONSTRUCTOR = 213,
        JSMSG_DUPLICATE_EXPORT_NAME = 214,
        JSMSG_DUPLICATE_FORMAL = 215,
        JSMSG_DUPLICATE_LABEL = 216,
        JSMSG_DUPLICATE_PROTO_PROPERTY = 217,
        JSMSG_EQUAL_AS_ASSIGN = 218,
        JSMSG_EXPORT_DECL_AT_TOP_LEVEL = 219,
        JSMSG_FINALLY_WITHOUT_TRY = 220,
        JSMSG_FORBIDDEN_AS_STATEMENT = 221,
        JSMSG_FOR_AWAIT_OUTSIDE_ASYNC = 222,
        JSMSG_FROM_AFTER_IMPORT_CLAUSE = 223,
        JSMSG_FROM_AFTER_EXPORT_STAR = 224,
        JSMSG_GARBAGE_AFTER_INPUT = 225,
        JSMSG_IDSTART_AFTER_NUMBER = 226,
        JSMSG_BAD_ESCAPE = 227,
        JSMSG_MISSING_PRIVATE_NAME = 228,
        JSMSG_PRIVATE_DELETE = 229,
        JSMSG_MISSING_PRIVATE_DECL = 230,
        JSMSG_ILLEGAL_CHARACTER = 231,
        JSMSG_IMPORT_META_OUTSIDE_MODULE = 232,
        JSMSG_IMPORT_DECL_AT_TOP_LEVEL = 233,
        JSMSG_OF_AFTER_FOR_LOOP_DECL = 234,
        JSMSG_IN_AFTER_LEXICAL_FOR_DECL = 235,
        JSMSG_INVALID_FOR_IN_DECL_WITH_INIT = 236,
        JSMSG_INVALID_ID = 237,
        JSMSG_SEPARATOR_IN_ZERO_PREFIXED_NUMBER = 238,
        JSMSG_LABEL_NOT_FOUND = 239,
        JSMSG_GENERATOR_LABEL = 240,
        JSMSG_FUNCTION_LABEL = 241,
        JSMSG_SLOPPY_FUNCTION_LABEL = 242,
        JSMSG_LINE_BREAK_AFTER_THROW = 243,
        JSMSG_MALFORMED_ESCAPE = 244,
        JSMSG_MISSING_BINARY_DIGITS = 245,
        JSMSG_MISSING_EXPONENT = 246,
        JSMSG_MISSING_EXPR_AFTER_THROW = 247,
        JSMSG_MISSING_FORMAL = 248,
        JSMSG_MISSING_HEXDIGITS = 249,
        JSMSG_MISSING_OCTAL_DIGITS = 250,
        JSMSG_NUMBER_END_WITH_UNDERSCORE = 251,
        JSMSG_NUMBER_MULTIPLE_ADJACENT_UNDERSCORES = 252,
        JSMSG_MODULE_SPEC_AFTER_FROM = 253,
        JSMSG_NAME_AFTER_DOT = 254,
        JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT = 255,
        JSMSG_NO_BINDING_NAME = 256,
        JSMSG_NO_EXPORT_NAME = 257,
        JSMSG_NO_IMPORT_NAME = 258,
        JSMSG_NO_VARIABLE_NAME = 259,
        JSMSG_PAREN_AFTER_ARGS = 260,
        JSMSG_PAREN_AFTER_CATCH = 261,
        JSMSG_PAREN_AFTER_COND = 262,
        JSMSG_PAREN_AFTER_FOR = 263,
        JSMSG_PAREN_AFTER_FORMAL = 264,
        JSMSG_PAREN_AFTER_FOR_CTRL = 265,
        JSMSG_PAREN_AFTER_SWITCH = 266,
        JSMSG_PAREN_AFTER_WITH = 267,
        JSMSG_PAREN_BEFORE_CATCH = 268,
        JSMSG_PAREN_BEFORE_COND = 269,
        JSMSG_PAREN_BEFORE_FORMAL = 270,
        JSMSG_PAREN_BEFORE_SWITCH = 271,
        JSMSG_PAREN_BEFORE_WITH = 272,
        JSMSG_PAREN_IN_PAREN = 273,
        JSMSG_PAREN_AFTER_DECORATOR = 274,
        JSMSG_RC_AFTER_EXPORT_SPEC_LIST = 275,
        JSMSG_RC_AFTER_IMPORT_SPEC_LIST = 276,
        JSMSG_RESERVED_ID = 277,
        JSMSG_REST_WITH_COMMA = 278,
        JSMSG_REST_WITH_DEFAULT = 279,
        JSMSG_SELFHOSTED_METHOD_CALL = 280,
        JSMSG_SELFHOSTED_LEXICAL = 281,
        JSMSG_SELFHOSTED_CLASS = 282,
        JSMSG_SEMI_AFTER_FOR_COND = 283,
        JSMSG_SEMI_AFTER_FOR_INIT = 284,
        JSMSG_SOURCE_TOO_LONG = 285,
        JSMSG_STMT_AFTER_RETURN = 286,
        JSMSG_STRICT_CODE_WITH = 287,
        JSMSG_STRICT_NON_SIMPLE_PARAMS = 288,
        JSMSG_TEMPLSTR_UNTERM_EXPR = 289,
        JSMSG_TOO_MANY_CASES = 290,
        JSMSG_TOO_MANY_CON_ARGS = 291,
        JSMSG_TOO_MANY_DEFAULTS = 292,
        JSMSG_TOO_MANY_FUN_ARGS = 293,
        JSMSG_TOO_MANY_LOCALS = 294,
        JSMSG_TOO_MANY_RESUME_INDEXES = 295,
        JSMSG_TOUGH_BREAK = 296,
        JSMSG_UNEXPECTED_TOKEN = 297,
        JSMSG_UNEXPECTED_TOKEN_NO_EXPECT = 298,
        JSMSG_UNEXPECTED_PARAMLIST_END = 299,
        JSMSG_UNNAMED_CLASS_STMT = 300,
        JSMSG_UNNAMED_FUNCTION_STMT = 301,
        JSMSG_UNPAIRED_SURROGATE_EXPORT = 302,
        JSMSG_UNTERMINATED_COMMENT = 303,
        JSMSG_UNTERMINATED_REGEXP = 304,
        JSMSG_UNTERMINATED_STATIC_CLASS_BLOCK = 305,
        JSMSG_EOF_BEFORE_END_OF_LITERAL = 306,
        JSMSG_EOL_BEFORE_END_OF_STRING = 307,
        JSMSG_EOF_IN_ESCAPE_IN_LITERAL = 308,
        JSMSG_USE_ASM_DIRECTIVE_FAIL = 309,
        JSMSG_VAR_HIDES_ARG = 310,
        JSMSG_WHILE_AFTER_DO = 311,
        JSMSG_YIELD_IN_PARAMETER = 312,
        JSMSG_YIELD_OUTSIDE_GENERATOR = 313,
        JSMSG_BAD_COLUMN_NUMBER = 314,
        JSMSG_BAD_LINE_NUMBER = 315,
        JSMSG_BAD_NEWTARGET = 316,
        JSMSG_BAD_NEW_OPTIONAL = 317,
        JSMSG_BAD_OPTIONAL_TEMPLATE = 318,
        JSMSG_IMPORT_ATTRIBUTES_NOT_SUPPORTED = 319,
        JSMSG_ILLEGAL_PRIVATE_FIELD = 320,
        JSMSG_ILLEGAL_PRIVATE_NAME = 321,
        JSMSG_INVALID_PRIVATE_NAME_PRECEDENCE = 322,
        JSMSG_INVALID_PRIVATE_NAME_IN_UNARY_EXPR = 323,
        JSMSG_ILLEGAL_PRIVATE_EXOTIC = 324,
        JSMSG_PRIVATE_FIELD_DOUBLE = 325,
        JSMSG_PRIVATE_BRAND_DOUBLE = 326,
        JSMSG_CURLY_AFTER_ASSERT = 327,
        JSMSG_DUPLICATE_ASSERT_KEY = 328,
        JSMSG_COLON_AFTER_ASSERT_KEY = 329,
        JSMSG_ASSERT_STRING_LITERAL = 330,
        JSMSG_ASSERT_KEY_EXPECTED = 331,
        JSMSG_DECORATOR_NAME_EXPECTED = 332,
        JSMSG_CLASS_EXPECTED = 333,
        JSMSG_NO_IN_WITH_USING = 334,
        JSMSG_USING_OUTSIDE_BLOCK_OR_MODULE = 335,
        JSMSG_BAD_LEADING_UTF8_UNIT = 336,
        JSMSG_NOT_ENOUGH_CODE_UNITS = 337,
        JSMSG_BAD_TRAILING_UTF8_UNIT = 338,
        JSMSG_FORBIDDEN_UTF8_CODE_POINT = 339,
        JSMSG_BAD_CODE_UNITS = 340,
        JSMSG_CANT_CONVERT_TO_NARROW = 341,
        JSMSG_CANT_CONVERT_TO_WIDE = 342,
        JSMSG_CANT_CONVERT_WIDE_TO_UTF8 = 343,
        JSMSG_CANT_CONVERT_UTF8_TO_WIDE = 344,
        JSMSG_USE_ASM_TYPE_FAIL = 345,
        JSMSG_USE_ASM_LINK_FAIL = 346,
        JSMSG_USE_ASM_TYPE_OK = 347,
        JSMSG_USE_ASM_TYPE_OK_NO_TIME = 348,
        JSMSG_WASM_VERBOSE = 349,
        JSMSG_WASM_COMPILE_WARNING = 350,
        JSMSG_WASM_HUGE_MEMORY_FAILED = 351,
        JSMSG_WASM_COMPILE_ERROR = 352,
        JSMSG_WASM_BAD_IMPORT_TYPE = 353,
        JSMSG_WASM_BAD_IMPORT_SIG = 354,
        JSMSG_WASM_BAD_TAG_SIG = 355,
        JSMSG_WASM_BAD_IMP_ADDRESS = 356,
        JSMSG_WASM_BAD_IMP_SIZE = 357,
        JSMSG_WASM_BAD_IMP_MAX = 358,
        JSMSG_WASM_IMP_SHARED_REQD = 359,
        JSMSG_WASM_IMP_SHARED_BANNED = 360,
        JSMSG_WASM_NO_SHMEM_LINK = 361,
        JSMSG_WASM_NO_MEM64_LINK = 362,
        JSMSG_WASM_BAD_GLOB_MUT_LINK = 363,
        JSMSG_WASM_BAD_GLOB_TYPE_LINK = 364,
        JSMSG_WASM_BAD_TBL_TYPE_LINK = 365,
        JSMSG_WASM_IND_CALL_TO_NULL = 366,
        JSMSG_WASM_IND_CALL_BAD_SIG = 367,
        JSMSG_WASM_UNREACHABLE = 368,
        JSMSG_WASM_INTEGER_OVERFLOW = 369,
        JSMSG_WASM_INVALID_CONVERSION = 370,
        JSMSG_WASM_INT_DIVIDE_BY_ZERO = 371,
        JSMSG_WASM_OUT_OF_BOUNDS = 372,
        JSMSG_WASM_UNALIGNED_ACCESS = 373,
        JSMSG_WASM_WAKE_OVERFLOW = 374,
        JSMSG_WASM_DEREF_NULL = 375,
        JSMSG_WASM_BAD_CAST = 376,
        JSMSG_WASM_MEM_IMP_LIMIT = 377,
        JSMSG_WASM_TABLE_IMP_LIMIT = 378,
        JSMSG_WASM_ARRAY_IMP_LIMIT = 379,
        JSMSG_WASM_ARRAY_NEW_ELEM_NOT_IMPLEMENTED = 380,
        JSMSG_WASM_BAD_RANGE = 381,
        JSMSG_WASM_BAD_GROW = 382,
        JSMSG_WASM_MAX_LT_INITIAL = 383,
        JSMSG_WASM_TABLE_OUT_OF_BOUNDS = 384,
        JSMSG_WASM_BAD_ENFORCE_RANGE = 385,
        JSMSG_WASM_BAD_BUF_ARG = 386,
        JSMSG_WASM_BAD_MOD_ARG = 387,
        JSMSG_WASM_BAD_BUF_MOD_ARG = 388,
        JSMSG_WASM_BAD_DESC_ARG = 389,
        JSMSG_WASM_BAD_IMPORT_ARG = 390,
        JSMSG_WASM_BAD_IMPORT_FIELD = 391,
        JSMSG_WASM_BAD_REF_NONNULLABLE_VALUE = 392,
        JSMSG_WASM_BAD_FUNCREF_VALUE = 393,
        JSMSG_WASM_BAD_NULL_EXNREF_VALUE = 394,
        JSMSG_WASM_BAD_NULL_EXTERNREF_VALUE = 395,
        JSMSG_WASM_BAD_NULL_FUNCREF_VALUE = 396,
        JSMSG_WASM_BAD_NULL_ANYREF_VALUE = 397,
        JSMSG_WASM_BAD_EQREF_VALUE = 398,
        JSMSG_WASM_BAD_I31REF_VALUE = 399,
        JSMSG_WASM_BAD_STRUCTREF_VALUE = 400,
        JSMSG_WASM_BAD_ARRAYREF_VALUE = 401,
        JSMSG_WASM_BAD_TYPEREF_VALUE = 402,
        JSMSG_WASM_BAD_VAL_TYPE = 403,
        JSMSG_WASM_BAD_STRING_VAL_TYPE = 404,
        JSMSG_WASM_BAD_STRING_ADDR_TYPE = 405,
        JSMSG_WASM_BAD_EXN_ARG = 406,
        JSMSG_WASM_BAD_EXN_PAYLOAD = 407,
        JSMSG_WASM_BAD_EXN_PAYLOAD_LEN = 408,
        JSMSG_WASM_BAD_EXN_TAG = 409,
        JSMSG_WASM_BAD_EXN_OPTIONS = 410,
        JSMSG_WASM_BAD_FUNCTION_TYPE = 411,
        JSMSG_WASM_BAD_FUNCTION_VALUE = 412,
        JSMSG_WASM_BAD_COMPILE_OPTIONS = 413,
        JSMSG_WASM_DUPLICATE_BUILTIN = 414,
        JSMSG_WASM_BAD_CODEPOINT = 415,
        JSMSG_WASM_NO_TRANSFER = 416,
        JSMSG_WASM_TEXT_FAIL = 417,
        JSMSG_WASM_MISSING_MAXIMUM = 418,
        JSMSG_WASM_GLOBAL_IMMUTABLE = 419,
        JSMSG_WASM_WRONG_NUMBER_OF_VALUES = 420,
        JSMSG_WASM_NONSHARED_WAIT = 421,
        JSMSG_WASM_SUPPLY_ONLY_ONE = 422,
        JSMSG_WASM_MISSING_REQUIRED = 423,
        JSMSG_WASM_MODIFIED_GC_OBJECT = 424,
        JSMSG_WASM_ARRAYBUFFER_PAGE_MULTIPLE = 425,
        JSMSG_WASM_ARRAYBUFFER_CANNOT_SHRINK = 426,
        JSMSG_WASM_MEMORY_NOT_RESIZABLE = 427,
        JSMSG_WASM_LEGACY_EXCEPTIONS_DEPRECATED = 428,
        JSMSG_USE_ASM_DEPRECATED = 429,
        JSMSG_JSPI_ARG_POSITION = 430,
        JSMSG_JSPI_INVALID_SUSPENDER = 431,
        JSMSG_JSPI_INVALID_STATE = 432,
        JSMSG_JSPI_EXPECTED_SUSPENDER = 433,
        JSMSG_JSPI_EXPECTED_PROMISE = 434,
        JSMSG_JSPI_SIGNATURE_MISMATCH = 435,
        JSMSG_JSPI_SUSPENDER_LIMIT = 436,
        JSMSG_BAD_GETPROTOTYPEOF_TRAP_RETURN = 437,
        JSMSG_INCONSISTENT_GETPROTOTYPEOF_TRAP = 438,
        JSMSG_PROXY_SETPROTOTYPEOF_RETURNED_FALSE = 439,
        JSMSG_INCONSISTENT_SETPROTOTYPEOF_TRAP = 440,
        JSMSG_CANT_CHANGE_EXTENSIBILITY = 441,
        JSMSG_CANT_DEFINE_INVALID = 442,
        JSMSG_CANT_DEFINE_NEW = 443,
        JSMSG_CANT_DEFINE_NE_AS_NC = 444,
        JSMSG_PROXY_DEFINE_RETURNED_FALSE = 445,
        JSMSG_PROXY_DELETE_RETURNED_FALSE = 446,
        JSMSG_PROXY_PREVENTEXTENSIONS_RETURNED_FALSE = 447,
        JSMSG_PROXY_SET_RETURNED_FALSE = 448,
        JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE = 449,
        JSMSG_CANT_DELETE_NON_EXTENSIBLE = 450,
        JSMSG_CANT_REPORT_C_AS_NC = 451,
        JSMSG_CANT_REPORT_E_AS_NE = 452,
        JSMSG_CANT_REPORT_INVALID = 453,
        JSMSG_CANT_REPORT_NC_AS_NE = 454,
        JSMSG_CANT_REPORT_NEW = 455,
        JSMSG_CANT_REPORT_NE_AS_NC = 456,
        JSMSG_CANT_REPORT_W_AS_NW = 457,
        JSMSG_CANT_SET_NW_NC = 458,
        JSMSG_CANT_SET_WO_SETTER = 459,
        JSMSG_CANT_SKIP_NC = 460,
        JSMSG_OWNKEYS_STR_SYM = 461,
        JSMSG_OWNKEYS_DUPLICATE = 462,
        JSMSG_MUST_REPORT_SAME_VALUE = 463,
        JSMSG_MUST_REPORT_UNDEFINED = 464,
        JSMSG_PROXY_CONSTRUCT_OBJECT = 465,
        JSMSG_PROXY_EXTENSIBILITY = 466,
        JSMSG_PROXY_GETOWN_OBJORUNDEF = 467,
        JSMSG_PROXY_REVOKED = 468,
        JSMSG_BAD_TRAP = 469,
        JSMSG_SC_BAD_CLONE_VERSION = 470,
        JSMSG_SC_BAD_SERIALIZED_DATA = 471,
        JSMSG_SC_DUP_TRANSFERABLE = 472,
        JSMSG_SC_NOT_TRANSFERABLE = 473,
        JSMSG_SC_TRANSFERABLE_TWICE = 474,
        JSMSG_SC_UNSUPPORTED_TYPE = 475,
        JSMSG_SC_NOT_CLONABLE = 476,
        JSMSG_SC_NOT_CLONABLE_WITH_COOP_COEP = 477,
        JSMSG_SC_SAB_DISABLED = 478,
        JSMSG_SC_SAB_REFCNT_OFLO = 479,
        JSMSG_SC_SHMEM_TRANSFERABLE = 480,
        JSMSG_SC_SHMEM_POLICY = 481,
        JSMSG_ASSIGN_FUNCTION_OR_NULL = 482,
        JSMSG_DEBUG_BAD_LINE = 483,
        JSMSG_DEBUG_BAD_OFFSET = 484,
        JSMSG_DEBUG_BREAKPOINT_NOT_ALLOWED = 485,
        JSMSG_DEBUG_BAD_REFERENT = 486,
        JSMSG_DEBUG_BAD_RESUMPTION = 487,
        JSMSG_DEBUG_RESUMPTION_CONFLICT = 488,
        JSMSG_DEBUG_CANT_DEBUG_GLOBAL = 489,
        JSMSG_DEBUG_SAME_COMPARTMENT = 490,
        JSMSG_DEBUG_CCW_REQUIRED = 491,
        JSMSG_DEBUG_COMPARTMENT_MISMATCH = 492,
        JSMSG_DEBUG_LOOP = 493,
        JSMSG_DEBUG_NOT_DEBUGGEE = 494,
        JSMSG_DEBUG_NOT_DEBUGGING = 495,
        JSMSG_DEBUG_NOT_IDLE = 496,
        JSMSG_DEBUG_NOT_ON_STACK = 497,
        JSMSG_DEBUG_NOT_ON_STACK_OR_SUSPENDED = 498,
        JSMSG_DEBUG_NO_ENV_OBJECT = 499,
        JSMSG_DEBUG_PROTO = 500,
        JSMSG_DEBUG_WRONG_OWNER = 501,
        JSMSG_DEBUG_OPTIMIZED_OUT = 502,
        JSMSG_DEBUG_OPTIMIZED_OUT_FUN = 503,
        JSMSG_DEBUG_FORCED_RETURN_DISALLOWED = 504,
        JSMSG_DEBUG_RESUMPTION_VALUE_DISALLOWED = 505,
        JSMSG_DEBUG_VARIABLE_NOT_FOUND = 506,
        JSMSG_DEBUG_WRAPPER_IN_WAY = 507,
        JSMSG_DEBUGGEE_WOULD_RUN = 508,
        JSMSG_NOT_CALLABLE_OR_UNDEFINED = 509,
        JSMSG_NOT_TRACKING_ALLOCATIONS = 510,
        JSMSG_OBJECT_METADATA_CALLBACK_ALREADY_SET = 511,
        JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL = 512,
        JSMSG_QUERY_LINE_WITHOUT_URL = 513,
        JSMSG_QUERY_USE_START_AND_END_TOGETHER = 514,
        JSMSG_QUERY_START_LINE_IS_AFTER_END = 515,
        JSMSG_DEBUG_CANT_SET_OPT_ENV = 516,
        JSMSG_DEBUG_INVISIBLE_COMPARTMENT = 517,
        JSMSG_DEBUG_CENSUS_BREAKDOWN = 518,
        JSMSG_DEBUG_CENSUS_BREAKDOWN_NESTED = 519,
        JSMSG_DEBUG_PROMISE_NOT_RESOLVED = 520,
        JSMSG_DEBUG_PROMISE_NOT_FULFILLED = 521,
        JSMSG_DEBUG_PROMISE_NOT_REJECTED = 522,
        JSMSG_DEBUG_NO_BINARY_SOURCE = 523,
        JSMSG_DEBUG_EXCLUSIVE_FRAME_COVERAGE = 524,
        JSMSG_DEBUG_EXCLUSIVE_EXECUTION_TRACE_COVERAGE = 525,
        JSMSG_NATIVE_TRACING_BUFFER_MALFORMED = 526,
        JSMSG_TESTING_SCRIPTS_ONLY = 527,
        JSMSG_INVALID_ARGS = 528,
        JSMSG_TRACELOGGER_ENABLE_FAIL = 529,
        JSMSG_DATE_NOT_FINITE = 530,
        JSMSG_DUPLICATE_VARIANT_SUBTAG = 531,
        JSMSG_INTERNAL_INTL_ERROR = 532,
        JSMSG_INVALID_CURRENCY_CODE = 533,
        JSMSG_INVALID_UNIT_IDENTIFIER = 534,
        JSMSG_INVALID_DIGITS_VALUE = 535,
        JSMSG_INVALID_KEY = 536,
        JSMSG_INVALID_LANGUAGE_TAG = 537,
        JSMSG_INVALID_LOCALES_ELEMENT = 538,
        JSMSG_INVALID_LOCALE_MATCHER = 539,
        JSMSG_INVALID_OPTION_VALUE = 540,
        JSMSG_INVALID_TIME_ZONE = 541,
        JSMSG_INVALID_DATETIME_OPTION = 542,
        JSMSG_INVALID_DATETIME_STYLE = 543,
        JSMSG_UNDEFINED_CURRENCY = 544,
        JSMSG_UNDEFINED_UNIT = 545,
        JSMSG_UNDEFINED_DATE = 546,
        JSMSG_UNDEFINED_NUMBER = 547,
        JSMSG_UNDEFINED_TYPE = 548,
        JSMSG_NAN_NUMBER_RANGE = 549,
        JSMSG_INVALID_NUMBER_OPTION = 550,
        JSMSG_UNEQUAL_FRACTION_DIGITS = 551,
        JSMSG_INTL_DURATION_INVALID_NON_NUMERIC_OPTION = 552,
        JSMSG_INTL_DURATION_INVALID_DISPLAY_OPTION = 553,
        JSMSG_INTL_DURATION_INVALID_DISPLAY_OPTION_DEFAULT_STYLE = 554,
        JSMSG_INTL_DURATION_INVALID_DISPLAY_OPTION_DEFAULT_DISPLAY = 555,
        JSMSG_INTL_DURATION_NOT_INTEGER = 556,
        JSMSG_INTL_DURATION_INVALID_SIGN = 557,
        JSMSG_INTL_DURATION_INVALID_LIMIT = 558,
        JSMSG_INTL_DURATION_MISSING_UNIT = 559,
        JSMSG_INTL_DURATION_UNEXPECTED_STRING = 560,
        JSMSG_INVALID_FORMAT_OPTIONS = 561,
        JSMSG_BAD_CLASS_RANGE = 562,
        JSMSG_ESCAPE_AT_END_OF_REGEXP = 563,
        JSMSG_EXEC_NOT_OBJORNULL = 564,
        JSMSG_INVALID_DECIMAL_ESCAPE = 565,
        JSMSG_INVALID_GROUP = 566,
        JSMSG_REPEATED_FLAG = 567,
        JSMSG_INVALID_FLAG_GROUP = 568,
        JSMSG_INVALID_IDENTITY_ESCAPE = 569,
        JSMSG_INVALID_UNICODE_ESCAPE = 570,
        JSMSG_MISSING_PAREN = 571,
        JSMSG_NEWREGEXP_FLAGGED = 572,
        JSMSG_NOTHING_TO_REPEAT = 573,
        JSMSG_NUMBERS_OUT_OF_ORDER = 574,
        JSMSG_RANGE_WITH_CLASS_ESCAPE = 575,
        JSMSG_RAW_BRACKET_IN_REGEXP = 576,
        JSMSG_TOO_MANY_PARENS = 577,
        JSMSG_UNICODE_OVERFLOW = 578,
        JSMSG_UNMATCHED_RIGHT_PAREN = 579,
        JSMSG_UNTERM_CLASS = 580,
        JSMSG_INVALID_PROPERTY_NAME = 581,
        JSMSG_INVALID_CLASS_PROPERTY_NAME = 582,
        JSMSG_INCOMPLETE_QUANTIFIER = 583,
        JSMSG_INVALID_QUANTIFIER = 584,
        JSMSG_INVALID_CAPTURE_NAME = 585,
        JSMSG_DUPLICATE_CAPTURE_NAME = 586,
        JSMSG_INVALID_NAMED_REF = 587,
        JSMSG_INVALID_NAMED_CAPTURE_REF = 588,
        JSMSG_INCOMPATIBLE_REGEXP_GETTER = 589,
        JSMSG_INVALID_CLASS_SET_OP = 590,
        JSMSG_INVALID_CHAR_IN_CLASS = 591,
        JSMSG_NEGATED_CLASS_WITH_STR = 592,
        JSMSG_MULTIPLE_FLAG_DASHES = 593,
        JSMSG_TYPEDOBJECT_SETTING_IMMUTABLE = 594,
        JSMSG_TOO_LONG_ARRAY = 595,
        JSMSG_BAD_INDEX = 596,
        JSMSG_DEFINE_BAD_INDEX = 597,
        JSMSG_NON_ARRAY_BUFFER_RETURNED = 598,
        JSMSG_SAME_ARRAY_BUFFER_RETURNED = 599,
        JSMSG_SHORT_ARRAY_BUFFER_RETURNED = 600,
        JSMSG_TYPED_ARRAY_BAD_ARGS = 601,
        JSMSG_TYPED_ARRAY_DETACHED = 602,
        JSMSG_ARRAYBUFFER_LENGTH_PINNED = 603,
        JSMSG_TYPED_ARRAY_RESIZED_BOUNDS = 604,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_BOUNDS = 605,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_MISALIGNED = 606,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_LENGTH_BOUNDS = 607,
        JSMSG_TYPED_ARRAY_CONSTRUCT_ARRAY_LENGTH_BOUNDS = 608,
        JSMSG_TYPED_ARRAY_CONSTRUCT_TOO_LARGE = 609,
        JSMSG_TYPED_ARRAY_BAD_HEX_STRING_LENGTH = 610,
        JSMSG_TYPED_ARRAY_BAD_HEX_DIGIT = 611,
        JSMSG_TYPED_ARRAY_BAD_BASE64_ALPHABET = 612,
        JSMSG_TYPED_ARRAY_BAD_BASE64_LAST_CHUNK_HANDLING = 613,
        JSMSG_TYPED_ARRAY_BAD_BASE64_CHAR = 614,
        JSMSG_TYPED_ARRAY_BAD_INCOMPLETE_CHUNK = 615,
        JSMSG_TYPED_ARRAY_BAD_BASE64_AFTER_PADDING = 616,
        JSMSG_TYPED_ARRAY_MISSING_BASE64_PADDING = 617,
        JSMSG_TYPED_ARRAY_EXTRA_BASE64_BITS = 618,
        JSMSG_TYPED_ARRAY_CALL_OR_CONSTRUCT = 619,
        JSMSG_NON_TYPED_ARRAY_RETURNED = 620,
        JSMSG_SHORT_TYPED_ARRAY_RETURNED = 621,
        JSMSG_TYPED_ARRAY_NOT_COMPATIBLE = 622,
        JSMSG_ARRAYBUFFER_REQUIRED = 623,
        JSMSG_ARRAYBUFFER_LENGTH_LARGER_THAN_MAXIMUM = 624,
        JSMSG_ARRAYBUFFER_NON_RESIZABLE = 625,
        JSMSG_ARRAYBUFFER_COPY_RANGE = 626,
        JSMSG_SHARED_ARRAY_BAD_LENGTH = 627,
        JSMSG_NON_SHARED_ARRAY_BUFFER_RETURNED = 628,
        JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED = 629,
        JSMSG_SHORT_SHARED_ARRAY_BUFFER_RETURNED = 630,
        JSMSG_SHARED_ARRAY_LENGTH_SMALLER_THAN_CURRENT = 631,
        JSMSG_BAD_PARSE_NODE = 632,
        JSMSG_SYMBOL_TO_STRING = 633,
        JSMSG_SYMBOL_TO_NUMBER = 634,
        JSMSG_ATOMICS_BAD_ARRAY = 635,
        JSMSG_ATOMICS_WAIT_NOT_ALLOWED = 636,
        JSMSG_ATOMICS_PAUSE_BAD_COUNT = 637,
        JSMSG_CANT_SET_INTERPOSED = 638,
        JSMSG_CANT_DEFINE_WINDOW_ELEMENT = 639,
        JSMSG_CANT_DELETE_WINDOW_ELEMENT = 640,
        JSMSG_CANT_DEFINE_WINDOW_NAMED_PROPERTY = 641,
        JSMSG_CANT_DELETE_WINDOW_NAMED_PROPERTY = 642,
        JSMSG_CANT_PREVENT_EXTENSIONS = 643,
        JSMSG_CANT_DEFINE_WINDOW_NC = 644,
        JSMSG_NO_NAMED_SETTER = 645,
        JSMSG_NO_INDEXED_SETTER = 646,
        JSMSG_NOT_DATA_DESCRIPTOR = 647,
        JSMSG_CANT_DELETE_SUPER = 648,
        JSMSG_REINIT_THIS = 649,
        JSMSG_MODULE_NO_EXPORT = 650,
        JSMSG_MODULE_CIRCULAR_IMPORT = 651,
        JSMSG_MODULE_AMBIGUOUS = 652,
        JSMSG_MISSING_EXPORT = 653,
        JSMSG_BAD_MODULE_STATUS = 654,
        JSMSG_DYNAMIC_IMPORT_FAILED = 655,
        JSMSG_DYNAMIC_IMPORT_NOT_SUPPORTED = 656,
        JSMSG_BAD_MODULE_TYPE = 657,
        JSMSG_IMPORT_MAPS_PARSE_FAILED = 658,
        JSMSG_IMPORT_MAPS_NOT_A_MAP = 659,
        JSMSG_IMPORT_MAPS_IMPORTS_NOT_A_MAP = 660,
        JSMSG_IMPORT_MAPS_SCOPES_NOT_A_MAP = 661,
        JSMSG_IMPORT_MAPS_SCOPE_VALUE_NOT_A_MAP = 662,
        JSMSG_IMPORT_MAPS_INTEGRITY_NOT_A_MAP = 663,
        JSMSG_IMPORT_ATTRIBUTES_STATIC_IMPORT_UNSUPPORTED_ATTRIBUTE = 664,
        JSMSG_IMPORT_ATTRIBUTES_DYNAMIC_IMPORT_UNSUPPORTED_ATTRIBUTE = 665,
        JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF = 666,
        JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY = 667,
        JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE = 668,
        JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE = 669,
        JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON = 670,
        JSMSG_PROMISE_ANY_REJECTION = 671,
        JSMSG_RETURN_NOT_CALLABLE = 672,
        JSMSG_ITERATOR_NO_THROW = 673,
        JSMSG_UNHANDLABLE_PROMISE_REJECTION_WARNING = 674,
        JSMSG_FOR_AWAIT_NOT_OF = 675,
        JSMSG_NOT_AN_ASYNC_GENERATOR = 676,
        JSMSG_GET_ASYNC_ITER_RETURNED_PRIMITIVE = 677,
        JSMSG_SUSPENDED_QUEUE_NOT_EMPTY = 678,
        JSMSG_WASM_ERROR_CONSUMING_RESPONSE = 679,
        JSMSG_WASM_BAD_RESPONSE_VALUE = 680,
        JSMSG_WASM_BAD_RESPONSE_MIME_TYPE = 681,
        JSMSG_WASM_BAD_RESPONSE_CORS_SAME_ORIGIN = 682,
        JSMSG_WASM_BAD_RESPONSE_STATUS = 683,
        JSMSG_WASM_RESPONSE_ALREADY_CONSUMED = 684,
        JSMSG_BIGINT_TO_NUMBER = 685,
        JSMSG_NONINTEGER_NUMBER_TO_BIGINT = 686,
        JSMSG_BIGINT_TOO_LARGE = 687,
        JSMSG_BIGINT_DIVISION_BY_ZERO = 688,
        JSMSG_BIGINT_NEGATIVE_EXPONENT = 689,
        JSMSG_BIGINT_INVALID_SYNTAX = 690,
        JSMSG_BIGINT_NOT_SERIALIZABLE = 691,
        JSMSG_NOT_A_FINALIZATION_REGISTRY = 692,
        JSMSG_BAD_HELD_VALUE = 693,
        JSMSG_BAD_UNREGISTER_TOKEN = 694,
        JSMSG_BAD_FINALIZATION_REGISTRY_OBJECT = 695,
        JSMSG_NOT_A_WEAK_REF = 696,
        JSMSG_BAD_WEAKREF_TARGET = 697,
        JSMSG_NEGATIVE_LIMIT = 698,
        JSMSG_SET_NEGATIVE_SIZE = 699,
        JSMSG_NOT_SHADOW_REALM = 700,
        JSMSG_SHADOW_REALM_EVALUATE_NOT_STRING = 701,
        JSMSG_SHADOW_REALM_INVALID_RETURN = 702,
        JSMSG_SHADOW_REALM_WRAP_FAILURE = 703,
        JSMSG_SHADOW_REALM_EVALUATE_FAILURE = 704,
        JSMSG_SHADOW_REALM_EVALUATE_FAILURE_DETAIL = 705,
        JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE = 706,
        JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE_DETAIL = 707,
        JSMSG_SHADOW_REALM_EXPORT_NOT_STRING = 708,
        JSMSG_SHADOW_REALM_IMPORTVALUE_FAILED = 709,
        JSMSG_SHADOW_REALM_VALUE_NOT_EXPORTED = 710,
        JSMSG_DECORATOR_INVALID_RETURN_TYPE = 711,
        JSMSG_TEMPORAL_INVALID_UNIT_RANGE = 712,
        JSMSG_TEMPORAL_INVALID_UNIT_OPTION = 713,
        JSMSG_TEMPORAL_INVALID_NUMBER = 714,
        JSMSG_TEMPORAL_INVALID_INTEGER = 715,
        JSMSG_TEMPORAL_MISSING_OPTION = 716,
        JSMSG_TEMPORAL_MISSING_PROPERTY = 717,
        JSMSG_TEMPORAL_UNEXPECTED_PROPERTY = 718,
        JSMSG_TEMPORAL_MISSING_TEMPORAL_FIELDS = 719,
        JSMSG_TEMPORAL_INSTANT_INVALID = 720,
        JSMSG_TEMPORAL_INSTANT_NONINTEGER = 721,
        JSMSG_TEMPORAL_INSTANT_BAD_DURATION = 722,
        JSMSG_TEMPORAL_TIMEZONE_INVALID_IDENTIFIER = 723,
        JSMSG_TEMPORAL_TIMEZONE_INCOMPATIBLE = 724,
        JSMSG_TEMPORAL_TIMEZONE_INSTANT_AMBIGUOUS = 725,
        JSMSG_TEMPORAL_DURATION_INVALID_SIGN = 726,
        JSMSG_TEMPORAL_DURATION_INVALID_NON_FINITE = 727,
        JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME = 728,
        JSMSG_TEMPORAL_DURATION_MISSING_UNIT = 729,
        JSMSG_TEMPORAL_DURATION_NOT_INTEGER = 730,
        JSMSG_TEMPORAL_DURATION_MISSING_UNIT_SPECIFIER = 731,
        JSMSG_TEMPORAL_DURATION_UNCOMPARABLE = 732,
        JSMSG_TEMPORAL_CALENDAR_INVALID_ID = 733,
        JSMSG_TEMPORAL_CALENDAR_MISSING_FIELD = 734,
        JSMSG_TEMPORAL_CALENDAR_OVERFLOW_FIELD = 735,
        JSMSG_TEMPORAL_CALENDAR_INVALID_MONTHCODE = 736,
        JSMSG_TEMPORAL_CALENDAR_INVALID_ERA = 737,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE = 738,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_YEAR = 739,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_MONTHCODE = 740,
        JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR = 741,
        JSMSG_TEMPORAL_PLAIN_DATE_INVALID = 742,
        JSMSG_TEMPORAL_PLAIN_DATE_INVALID_VALUE = 743,
        JSMSG_TEMPORAL_PLAIN_DATE_TIME_INVALID = 744,
        JSMSG_TEMPORAL_PLAIN_TIME_INVALID = 745,
        JSMSG_TEMPORAL_PLAIN_TIME_INVALID_VALUE = 746,
        JSMSG_TEMPORAL_PLAIN_TIME_MISSING_UNIT = 747,
        JSMSG_TEMPORAL_PLAIN_MONTH_DAY_INVALID = 748,
        JSMSG_TEMPORAL_PLAIN_YEAR_MONTH_INVALID = 749,
        JSMSG_TEMPORAL_ZONED_DATE_TIME_NO_TIME_FOUND = 750,
        JSMSG_TEMPORAL_ZONED_DATE_TIME_INCONSISTENT_INSTANT = 751,
        JSMSG_TEMPORAL_PARSER_NEGATIVE_ZERO_YEAR = 752,
        JSMSG_TEMPORAL_PARSER_MISSING_EXTENDED_YEAR = 753,
        JSMSG_TEMPORAL_PARSER_MISSING_YEAR = 754,
        JSMSG_TEMPORAL_PARSER_MISSING_MONTH = 755,
        JSMSG_TEMPORAL_PARSER_MISSING_DAY = 756,
        JSMSG_TEMPORAL_PARSER_MISSING_HOUR = 757,
        JSMSG_TEMPORAL_PARSER_MISSING_MINUTE = 758,
        JSMSG_TEMPORAL_PARSER_MISSING_SECOND = 759,
        JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_SIGN = 760,
        JSMSG_TEMPORAL_PARSER_INVALID_MONTH = 761,
        JSMSG_TEMPORAL_PARSER_INVALID_DAY = 762,
        JSMSG_TEMPORAL_PARSER_INVALID_HOUR = 763,
        JSMSG_TEMPORAL_PARSER_INVALID_MINUTE = 764,
        JSMSG_TEMPORAL_PARSER_INVALID_SECOND = 765,
        JSMSG_TEMPORAL_PARSER_INVALID_LEAPSECOND = 766,
        JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_TIMEZONE = 767,
        JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_TIMEZONE = 768,
        JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE = 769,
        JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_NAME = 770,
        JSMSG_TEMPORAL_PARSER_UNEXPECTED_CHARACTERS_AT_END = 771,
        JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DESIGNATOR = 772,
        JSMSG_TEMPORAL_PARSER_MISSING_TIME_DESIGNATOR = 773,
        JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS = 774,
        JSMSG_TEMPORAL_PARSER_MISSING_DURATION_UNIT_DESIGNATOR = 775,
        JSMSG_TEMPORAL_PARSER_INVALID_DURATION_MINUTES = 776,
        JSMSG_TEMPORAL_PARSER_INVALID_DURATION_SECONDS = 777,
        JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_KEY = 778,
        JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_VALUE = 779,
        JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_ANNOTATION = 780,
        JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_ANNOTATION = 781,
        JSMSG_TEMPORAL_PARSER_ASSIGNMENT_IN_ANNOTATION = 782,
        JSMSG_TEMPORAL_PARSER_INVALID_CRITICAL_ANNOTATION = 783,
        JSMSG_TEMPORAL_PARSER_MISSING_DATE_TIME_SEPARATOR = 784,
        JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_MONTH_DAY = 785,
        JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_YEAR_MONTH = 786,
        JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR = 787,
        JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR_WITHOUT_NAME = 788,
        JSMSG_TEMPORAL_PARSER_MONTH_DAY_CALENDAR_NOT_ISO8601 = 789,
        JSMSG_TEMPORAL_PARSER_YEAR_MONTH_CALENDAR_NOT_ISO8601 = 790,
        JSMSG_TEMPORAL_PARSER_INVALID_SUBMINUTE_TIMEZONE = 791,
        JSMSG_TEMPORAL_PARSER_INCONSISTENT_DATE_SEPARATOR = 792,
        JSMSG_TEMPORAL_PARSER_INCONSISTENT_TIME_SEPARATOR = 793,
        JSMSG_TEMPORAL_PARSER_EMPTY_STRING = 794,
        JSMSG_ERROR_WAS_SUPPRESSED = 795,
        JSMSG_DISPOSABLE_STACK_DISPOSED = 796,
        JSMSG_ITERATOR_RANGE_INVALID_START = 797,
        JSMSG_ITERATOR_RANGE_INVALID_START_RANGEERR = 798,
        JSMSG_ITERATOR_RANGE_INVALID_END_RANGEERR = 799,
        JSMSG_ITERATOR_RANGE_INVALID_END = 800,
        JSMSG_ITERATOR_RANGE_START_INFINITY = 801,
        JSMSG_ITERATOR_RANGE_STEP_NAN = 802,
        JSMSG_ITERATOR_RANGE_STEP_NOT_NUMBER = 803,
        JSMSG_ITERATOR_RANGE_STEP_NOT_FINITE = 804,
        JSMSG_ITERATOR_RANGE_STEP_ZERO = 805,
        JSMSG_ITERATOR_RANGE_INVALID_STEP = 806,
        JSMSG_ITERATOR_RANGE_STEP_NOT_BIGINT = 807,
        JSMSG_SUMPRECISE_TOO_MANY_VALUES = 808,
        JSMSG_SUMPRECISE_EXPECTED_NUMBER = 809,
        JSErr_Limit = 810,
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetGrayGCRootsTracerP9JSContextPFbP8JSTracerRN2JS11SliceBudgetEPvES6_"]
        pub fn JS_SetGrayGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSGrayRootsTracer,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_FindCompilationScopeP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FindCompilationScope(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetObjectFunctionP8JSObject"]
        pub fn JS_GetObjectFunction(obj: *mut root::JSObject) -> *mut root::JSFunction;
    }
    extern "C" {
        #[doc = " Allocate an object in exactly the same way as JS_NewObjectWithGivenProto, but\n without invoking the metadata callback on it.  This allows creation of\n internal bookkeeping objects that are guaranteed to not have metadata\n attached to them."]
        #[link_name = "\u{1}_Z27JS_NewObjectWithoutMetadataP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithoutMetadata(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakMapKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakMapKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakSetKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakSetKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether the given object is backed by a DeadObjectProxy.\n\n Such objects hold no other objects (they have no outgoing reference edges)\n and will throw if you touch them (e.g. by reading/writing a property)."]
        #[link_name = "\u{1}_Z16JS_IsDeadWrapperP8JSObject"]
        pub fn JS_IsDeadWrapper(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Creates a new dead wrapper object in the given scope. To be used when\n attempting to wrap objects from scopes which are already dead.\n\n If origObject is passed, it must be an proxy object, and will be\n used to determine the characteristics of the new dead wrapper."]
        #[link_name = "\u{1}_Z17JS_NewDeadWrapperP9JSContextP8JSObject"]
        pub fn JS_NewDeadWrapper(
            cx: *mut root::JSContext,
            origObject: *mut root::JSObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z35JS_TraceShapeCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceShapeCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            shape: root::JS::GCCellPtr,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z41JS_TraceObjectGroupCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceObjectGroupCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            group: root::JS::GCCellPtr,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetScriptPrincipalsP8JSScript"]
        pub fn JS_GetScriptPrincipals(script: *mut root::JSScript) -> *mut root::JSPrincipals;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_ScriptHasMutedErrorsP8JSScript"]
        pub fn JS_ScriptHasMutedErrors(script: *mut root::JSScript) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_CloneObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CloneObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Copy the own properties of src to dst in a fast way.  src and dst must both\n be native and must be in the compartment of cx.  They must have the same\n class, the same parent, and the same prototype.  Class reserved slots will\n NOT be copied.\n\n dst must not have any properties on it before this function is called.\n\n src must have been allocated via JS_NewObjectWithoutMetadata so that we can\n be sure it has no metadata that needs copying to dst.  This also means that\n dst needs to have the compartment global as its parent.  This function will\n preserve the existing metadata on dst, if any."]
        #[link_name = "\u{1}_Z49JS_InitializePropertiesFromCompatibleNativeObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_InitializePropertiesFromCompatibleNativeObject(
            cx: *mut root::JSContext,
            dst: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Copies all own properties and private fields from |obj| to |target|. Both\n |obj| and |target| must not be cross-compartment wrappers because we have to\n enter their realms.\n\n This function immediately enters a realm, and does not impose any\n restrictions on the realm of |cx|."]
        #[link_name = "\u{1}_Z36JS_CopyOwnPropertiesAndPrivateFieldsP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CopyOwnPropertiesAndPrivateFields(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_WrapPropertyDescriptor(
            cx: *mut root::JSContext,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEE"]
        pub fn JS_WrapPropertyDescriptor1(cx: *mut root::JSContext, desc: u64) -> bool;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSFunctionSpecWithHelp {
        pub name: *const ::std::os::raw::c_char,
        pub call: root::JSNative,
        pub nargs: u16,
        pub flags: u16,
        pub jitInfo: *const root::JSJitInfo,
        pub usage: *const ::std::os::raw::c_char,
        pub help: *const ::std::os::raw::c_char,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSFunctionSpecWithHelp"]
            [::std::mem::size_of::<JSFunctionSpecWithHelp>() - 48usize];
        ["Alignment of JSFunctionSpecWithHelp"]
            [::std::mem::align_of::<JSFunctionSpecWithHelp>() - 8usize];
        ["Offset of field: JSFunctionSpecWithHelp::name"]
            [::std::mem::offset_of!(JSFunctionSpecWithHelp, name) - 0usize];
        ["Offset of field: JSFunctionSpecWithHelp::call"]
            [::std::mem::offset_of!(JSFunctionSpecWithHelp, call) - 8usize];
        ["Offset of field: JSFunctionSpecWithHelp::nargs"]
            [::std::mem::offset_of!(JSFunctionSpecWithHelp, nargs) - 16usize];
        ["Offset of field: JSFunctionSpecWithHelp::flags"]
            [::std::mem::offset_of!(JSFunctionSpecWithHelp, flags) - 18usize];
        ["Offset of field: JSFunctionSpecWithHelp::jitInfo"]
            [::std::mem::offset_of!(JSFunctionSpecWithHelp, jitInfo) - 24usize];
        ["Offset of field: JSFunctionSpecWithHelp::usage"]
            [::std::mem::offset_of!(JSFunctionSpecWithHelp, usage) - 32usize];
        ["Offset of field: JSFunctionSpecWithHelp::help"]
            [::std::mem::offset_of!(JSFunctionSpecWithHelp, help) - 40usize];
    };
    extern "C" {
        #[link_name = "\u{1}_Z26JS_DefineFunctionsWithHelpP9JSContextN2JS6HandleIP8JSObjectEEPK22JSFunctionSpecWithHelp"]
        pub fn JS_DefineFunctionsWithHelp(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            fs: *const root::JSFunctionSpecWithHelp,
        ) -> bool;
    }
    pub mod glue {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[link_name = "\u{1}_ZN4glue7JS_InitEv"]
            pub fn JS_Init() -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18JS_NewRealmOptionsEv"]
            pub fn JS_NewRealmOptions() -> *mut root::JS::RealmOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18DeleteRealmOptionsEPN2JS12RealmOptionsE"]
            pub fn DeleteRealmOptions(options: *mut root::JS::RealmOptions);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26JS_NewOwningCompileOptionsEP9JSContext"]
            pub fn JS_NewOwningCompileOptions(
                cx: *mut root::JSContext,
            ) -> *mut root::JS::OwningCompileOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26DeleteOwningCompileOptionsEPN2JS20OwningCompileOptionsE"]
            pub fn DeleteOwningCompileOptions(opts: *mut root::JS::OwningCompileOptions);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_AsShadowZoneEPN2JS4ZoneE"]
            pub fn JS_AsShadowZone(zone: *mut root::JS::Zone) -> *mut root::JS::shadow::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_CallArgsFromVpEjPN2JS5ValueE"]
            pub fn JS_CallArgsFromVp(
                argc: ::std::os::raw::c_uint,
                vp: *mut root::JS::Value,
            ) -> root::JS::CallArgs;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue25JS_StackCapture_AllFramesEPN7mozilla7VariantIJN2JS9AllFramesENS2_9MaxFramesENS2_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_AllFrames(capture: *mut root::JS::StackCapture);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue25JS_StackCapture_MaxFramesEjPN7mozilla7VariantIJN2JS9AllFramesENS2_9MaxFramesENS2_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_MaxFrames(max: u32, capture: *mut root::JS::StackCapture);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue34JS_StackCapture_FirstSubsumedFrameEP9JSContextbPN7mozilla7VariantIJN2JS9AllFramesENS4_9MaxFramesENS4_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_FirstSubsumedFrame(
                cx: *mut root::JSContext,
                ignoreSelfHostedFrames: bool,
                capture: *mut root::JS::StackCapture,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue21GetLinearStringLengthEP14JSLinearString"]
            pub fn GetLinearStringLength(s: *mut root::JSLinearString) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue21GetLinearStringCharAtEP14JSLinearStringm"]
            pub fn GetLinearStringCharAt(s: *mut root::JSLinearString, idx: usize) -> u16;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18AtomToLinearStringEP6JSAtom"]
            pub fn AtomToLinearString(atom: *mut root::JSAtom) -> *mut root::JSLinearString;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given contents. The contents must not be\n modified by any other code, internal or external.\n\n !!! IMPORTANT !!!\n If and only if an ArrayBuffer is successfully created and returned,\n ownership of |contents| is transferred to the new ArrayBuffer.\n\n When the ArrayBuffer is ready to be disposed of, `freeFunc(contents,\n freeUserData)` will be called to release the ArrayBuffer's reference on the\n contents.\n\n `freeFunc()` must not call any JSAPI functions that could cause a garbage\n collection.\n\n The caller must keep the buffer alive until `freeFunc()` is called, or, if\n `freeFunc` is null, until the JSRuntime is destroyed.\n\n The caller must not access the buffer on other threads. The JS engine will\n not allow the buffer to be transferred to other threads. If you try to\n transfer an external ArrayBuffer to another thread, the data is copied to a\n new malloc buffer. `freeFunc()` must be threadsafe, and may be called from\n any thread.\n\n This allows ArrayBuffers to be used with embedder objects that use reference\n counting, for example. In that case the caller is responsible\n for incrementing the reference count before passing the contents to this\n function. This also allows using non-reference-counted contents that must be\n freed with some function other than free()."]
            #[link_name = "\u{1}_ZN4glue22NewExternalArrayBufferEP9JSContextmPvPFvS2_S2_ES2_"]
            pub fn NewExternalArrayBuffer(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
                freeFunc: root::JS::BufferContentsFreeFunc,
                freeUserData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26NewArrayBufferWithContentsEP9JSContextmPv"]
            pub fn NewArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue20JS_ForOfIteratorInitEPN2JS13ForOfIteratorENS0_6HandleINS0_5ValueEEENS1_19NonIterableBehaviorE"]
            pub fn JS_ForOfIteratorInit(
                iterator: *mut root::JS::ForOfIterator,
                iterable: root::JS::HandleValue,
                nonIterableBehavior: root::JS::ForOfIterator_NonIterableBehavior,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue20JS_ForOfIteratorNextEPN2JS13ForOfIteratorENS0_13MutableHandleINS0_5ValueEEEPb"]
            pub fn JS_ForOfIteratorNext(
                iterator: *mut root::JS::ForOfIterator,
                val: root::JS::MutableHandleValue,
                done: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18JS_ValueSetBooleanEPN2JS5ValueEb"]
            pub fn JS_ValueSetBoolean(value: *mut root::JS::Value, x: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueIsBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueIsBoolean(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueToBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueToBoolean(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueSetDoubleEPN2JS5ValueEd"]
            pub fn JS_ValueSetDouble(value: *mut root::JS::Value, x: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueIsDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueIsDouble(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueToDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueToDouble(value: *const root::JS::Value) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueSetInt32EPN2JS5ValueEi"]
            pub fn JS_ValueSetInt32(value: *mut root::JS::Value, x: i32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueIsInt32EPKN2JS5ValueE"]
            pub fn JS_ValueIsInt32(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueToInt32EPKN2JS5ValueE"]
            pub fn JS_ValueToInt32(value: *const root::JS::Value) -> i32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueIsNumberEPKN2JS5ValueE"]
            pub fn JS_ValueIsNumber(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueToNumberEPKN2JS5ValueE"]
            pub fn JS_ValueToNumber(value: *const root::JS::Value) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueSetNullEPN2JS5ValueE"]
            pub fn JS_ValueSetNull(value: *mut root::JS::Value);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue14JS_ValueIsNullEPKN2JS5ValueE"]
            pub fn JS_ValueIsNull(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue19JS_ValueIsUndefinedEPKN2JS5ValueE"]
            pub fn JS_ValueIsUndefined(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue22FromPropertyDescriptorEP9JSContextN2JS6HandleINS2_18PropertyDescriptorEEENS2_13MutableHandleINS2_5ValueEEE"]
            pub fn FromPropertyDescriptor(
                cx: *mut root::JSContext,
                desc_: root::JS::Handle<root::JS::PropertyDescriptor>,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue24JS_GetPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_13MutableHandleINS2_18PropertyDescriptorEEENS9_IS5_EEPb"]
            pub fn JS_GetPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                name: *const ::std::os::raw::c_char,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                holder: root::JS::MutableHandle<*mut root::JSObject>,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue31JS_GetOwnPropertyDescriptorByIdEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS2_13MutableHandleINS2_18PropertyDescriptorEEEPb"]
            pub fn JS_GetOwnPropertyDescriptorById(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue27JS_GetOwnPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_13MutableHandleINS2_18PropertyDescriptorEEEPb"]
            pub fn JS_GetOwnPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                name: *const ::std::os::raw::c_char,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue29JS_GetOwnUCPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_13MutableHandleINS2_18PropertyDescriptorEEEPb"]
            pub fn JS_GetOwnUCPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                name: *const u16,
                namelen: usize,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue28JS_GetPropertyDescriptorByIdEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS2_13MutableHandleINS2_18PropertyDescriptorEEENS9_IS5_EEPb"]
            pub fn JS_GetPropertyDescriptorById(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                holder: root::JS::MutableHandleObject,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26JS_GetUCPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_13MutableHandleINS2_18PropertyDescriptorEEENS9_IS5_EEPb"]
            pub fn JS_GetUCPropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                name: *const u16,
                namelen: usize,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                holder: root::JS::MutableHandleObject,
                isNone: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue30SetPropertyIgnoringNamedGetterEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS3_INS2_5ValueEEESA_PKNS3_INS2_18PropertyDescriptorEEERNS2_14ObjectOpResultE"]
            pub fn SetPropertyIgnoringNamedGetter(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                ownDesc: *const root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue11CreateErrorEP9JSContext9JSExnTypeN2JS6HandleIP8JSObjectEENS4_IP8JSStringEEjjP13JSErrorReportSA_NS4_INS3_5ValueEEENS3_13MutableHandleISD_EE"]
            pub fn CreateError(
                cx: *mut root::JSContext,
                type_: root::JSExnType,
                stack: root::JS::HandleObject,
                fileName: root::JS::HandleString,
                lineNumber: u32,
                columnNumber: u32,
                report: *mut root::JSErrorReport,
                message: root::JS::HandleString,
                cause: root::JS::HandleValue,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue12GetErrorTypeERKN2JS5ValueE"]
            pub fn GetErrorType(val: *const root::JS::Value) -> root::JSExnType;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17GetExceptionCauseEP8JSObjectN2JS13MutableHandleINS2_5ValueEEE"]
            pub fn GetExceptionCause(exc: *mut root::JSObject, dest: root::JS::MutableHandleValue);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue19NewEnvironmentChainEP9JSContextN2JS18SupportUnscopablesE"]
            pub fn NewEnvironmentChain(
                cx: *mut root::JSContext,
                supportUnscopables: root::JS::SupportUnscopables,
            ) -> *mut root::JS::EnvironmentChain;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue22DeleteEnvironmentChainEPN2JS16EnvironmentChainE"]
            pub fn DeleteEnvironmentChain(chain: *mut root::JS::EnvironmentChain);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue24AppendToEnvironmentChainEPN2JS16EnvironmentChainEP8JSObject"]
            pub fn AppendToEnvironmentChain(
                chain: *mut root::JS::EnvironmentChain,
                obj: *mut root::JSObject,
            ) -> bool;
        }
    }
    #[doc = " <div rustbindgen replaces=\"JSJitMethodCallArgs\"></div>"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitMethodCallArgs {
        pub argv_: *mut root::JS::Value,
        pub argc_: ::std::os::raw::c_uint,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of JSJitMethodCallArgs"][::std::mem::size_of::<JSJitMethodCallArgs>() - 16usize];
        ["Alignment of JSJitMethodCallArgs"]
            [::std::mem::align_of::<JSJitMethodCallArgs>() - 8usize];
        ["Offset of field: JSJitMethodCallArgs::argv_"]
            [::std::mem::offset_of!(JSJitMethodCallArgs, argv_) - 0usize];
        ["Offset of field: JSJitMethodCallArgs::argc_"]
            [::std::mem::offset_of!(JSJitMethodCallArgs, argc_) - 8usize];
    };
    impl JSJitMethodCallArgs {
        #[inline]
        pub fn constructing_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_constructing_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn constructing__raw(this: *const Self) -> bool {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    0usize,
                    1u8,
                ) as u8)
            }
        }
        #[inline]
        pub unsafe fn set_constructing__raw(this: *mut Self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    0usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn ignoresReturnValue_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ignoresReturnValue_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub unsafe fn ignoresReturnValue__raw(this: *const Self) -> bool {
            unsafe {
                ::std::mem::transmute(<root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                    ::std::ptr::addr_of!((*this)._bitfield_1),
                    1usize,
                    1u8,
                ) as u8)
            }
        }
        #[inline]
        pub unsafe fn set_ignoresReturnValue__raw(this: *mut Self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                <root::__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                    ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                    1usize,
                    1u8,
                    val as u64,
                )
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            constructing_: bool,
            ignoresReturnValue_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let constructing_: u8 = unsafe { ::std::mem::transmute(constructing_) };
                constructing_ as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let ignoresReturnValue_: u8 = unsafe { ::std::mem::transmute(ignoresReturnValue_) };
                ignoresReturnValue_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub type __builtin_va_list = [root::__va_list_tag; 1usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
        ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
        ["Offset of field: __va_list_tag::gp_offset"]
            [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
        ["Offset of field: __va_list_tag::fp_offset"]
            [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
        ["Offset of field: __va_list_tag::overflow_arg_area"]
            [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
        ["Offset of field: __va_list_tag::reg_save_area"]
            [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: BaseTimeDuration_open0_TimeDurationValueCalculator_close0"] [:: std :: mem :: size_of :: < root :: mozilla :: BaseTimeDuration > () - 8usize] ;
        ["Align of template specialization: BaseTimeDuration_open0_TimeDurationValueCalculator_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: BaseTimeDuration > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSFunction_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSFunction>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSFunction_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSFunction>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyKey_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyKey>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyKey_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyKey>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_StackGCVector_open1_PropertyKey_TempAllocPolicy_close1_close0"] [:: std :: mem :: size_of :: < root :: JS :: MutableHandle < root :: JS :: StackGCVector < root :: JS :: PropertyKey , root :: js :: TempAllocPolicy > > > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_StackGCVector_open1_PropertyKey_TempAllocPolicy_close1_close0"] [:: std :: mem :: align_of :: < root :: JS :: MutableHandle < root :: JS :: StackGCVector < root :: JS :: PropertyKey , root :: js :: TempAllocPolicy > > > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Opaque_open0_uint64_t_close0"]
            [::std::mem::size_of::<root::mozilla::Opaque<u64>>() - 8usize];
        ["Align of template specialization: Opaque_open0_uint64_t_close0"]
            [::std::mem::align_of::<root::mozilla::Opaque<u64>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: GenericTracerImpl_open0_CallbackTracer_close0"]
            [::std::mem::size_of::<root::js::GenericTracerImpl>() - 48usize];
        ["Align of template specialization: GenericTracerImpl_open0_CallbackTracer_close0"]
            [::std::mem::align_of::<root::js::GenericTracerImpl>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_JSONWriteFunc_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_JSONWriteFunc_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_JSONWriteFunc_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_JSONWriteFunc_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
        ["Align of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
        ["Align of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
        ["Align of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
        ["Align of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
        ["Align of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
        ["Align of template specialization: RefPtr_open0_ProgressLogger_SharedProgress_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::ProgressLogger_SharedProgress>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_JSONWriteFunc_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_JSONWriteFunc_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultHasher_open0_unsigned_int_void_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultHasher>() - 1usize];
        ["Align of template specialization: DefaultHasher_open0_unsigned_int_void_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultHasher>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > () - 1usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > () - 1usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > () - 1usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunkManager_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: DefaultDelete > () - 1usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileBufferChunk_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_ProfileChunkedBuffer_RequestedChunkRefCountedHolder_close0"] [:: std :: mem :: size_of :: < root :: RefPtr < root :: mozilla :: ProfileChunkedBuffer_RequestedChunkRefCountedHolder > > () - 8usize] ;
        ["Align of template specialization: RefPtr_open0_ProfileChunkedBuffer_RequestedChunkRefCountedHolder_close0"] [:: std :: mem :: align_of :: < root :: RefPtr < root :: mozilla :: ProfileChunkedBuffer_RequestedChunkRefCountedHolder > > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::size_of::<root::mozilla::DefaultDelete>() - 1usize];
        ["Align of template specialization: DefaultDelete_open0_ProfileChunkedBuffer_close0"]
            [::std::mem::align_of::<root::mozilla::DefaultDelete>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: TenuredHeap_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::TenuredHeap>() - 8usize];
        ["Align of template specialization: TenuredHeap_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::TenuredHeap>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: LinkedListElement_open0_PersistentRootedBase_close0"]
            [::std::mem::size_of::<root::mozilla::LinkedListElement>() - 24usize];
        ["Align of template specialization: LinkedListElement_open0_PersistentRootedBase_close0"]
            [::std::mem::align_of::<root::mozilla::LinkedListElement>() - 8usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct _bindgen_ty_74 {
        pub _address: u8,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 16usize];
        ["Align of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 16usize];
        ["Align of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 16usize];
        ["Align of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 16usize];
        ["Align of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RangedPtr_open0_Latin1Char_close0"]
            [::std::mem::size_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>() - 8usize];
        ["Align of template specialization: RangedPtr_open0_Latin1Char_close0"]
            [::std::mem::align_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RangedPtr_open0_Latin1Char_close0"]
            [::std::mem::size_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>() - 8usize];
        ["Align of template specialization: RangedPtr_open0_Latin1Char_close0"]
            [::std::mem::align_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_unsigned_char_close0"]
            [::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>() - 16usize];
        ["Align of template specialization: Range_open0_unsigned_char_close0"]
            [::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_unsigned_char_close0"]
            [::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>() - 16usize];
        ["Align of template specialization: Range_open0_unsigned_char_close0"]
            [::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RangedPtr_open0_unsigned_char_close0"]
            [::std::mem::size_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>() - 8usize];
        ["Align of template specialization: RangedPtr_open0_unsigned_char_close0"]
            [::std::mem::align_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RangedPtr_open0_unsigned_char_close0"]
            [::std::mem::size_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>() - 8usize];
        ["Align of template specialization: RangedPtr_open0_unsigned_char_close0"]
            [::std::mem::align_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u16>>() - 16usize];
        ["Align of template specialization: Range_open0_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u16>>() - 16usize];
        ["Align of template specialization: Range_open0_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RangedPtr_open0_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::RangedPtr<u16>>() - 8usize];
        ["Align of template specialization: RangedPtr_open0_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::RangedPtr<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RangedPtr_open0_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::RangedPtr<u16>>() - 8usize];
        ["Align of template specialization: RangedPtr_open0_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::RangedPtr<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RangedPtr_open0_const_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::RangedPtr<u16>>() - 8usize];
        ["Align of template specialization: RangedPtr_open0_const_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::RangedPtr<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u16>>() - 16usize];
        ["Align of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u16>>() - 16usize];
        ["Align of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u16>>() - 16usize];
        ["Align of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyKey_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyKey>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyKey_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyKey>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyKey_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyKey>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyKey_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyKey>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JSErrorNotes_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JSErrorNotes_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JSErrorNotes_Note_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JSErrorNotes_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JSErrorNotes_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Maybe_open1_Value_close1_close0"]
            [::std::mem::size_of::<u64>() - 8usize];
        ["Align of template specialization: Handle_open0_Maybe_open1_Value_close1_close0"]
            [::std::mem::align_of::<u64>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: EnumSet_open0_PropertyAttribute_unsigned_char_close0"]
            [::std::mem::size_of::<root::mozilla::EnumSet<::std::os::raw::c_uchar>>() - 1usize];
        ["Align of template specialization: EnumSet_open0_PropertyAttribute_unsigned_char_close0"] [:: std :: mem :: align_of :: < root :: mozilla :: EnumSet < :: std :: os :: raw :: c_uchar > > () - 1usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::jsid>>() - 8usize];
        ["Align of template specialization: Handle_open0_jsid_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::jsid>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: Handle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefCounted_open0_LocaleString_close0"]
            [::std::mem::size_of::<root::js::RefCounted>() - 8usize];
        ["Align of template specialization: RefCounted_open0_LocaleString_close0"]
            [::std::mem::align_of::<root::js::RefCounted>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_LocaleString_close0"]
            [::std::mem::size_of::<root::RefPtr<root::JS::LocaleString>>() - 8usize];
        ["Align of template specialization: RefPtr_open0_LocaleString_close0"]
            [::std::mem::align_of::<root::RefPtr<root::JS::LocaleString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_LocaleString_close0"]
            [::std::mem::size_of::<root::RefPtr<root::JS::LocaleString>>() - 8usize];
        ["Align of template specialization: RefPtr_open0_LocaleString_close0"]
            [::std::mem::align_of::<root::RefPtr<root::JS::LocaleString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: CheckedInt_open0_uint32_t_close0"]
            [::std::mem::size_of::<root::mozilla::CheckedInt<u32>>() - 8usize];
        ["Align of template specialization: CheckedInt_open0_uint32_t_close0"]
            [::std::mem::align_of::<root::mozilla::CheckedInt<u32>>() - 4usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::already_AddRefed<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::already_AddRefed<root::mozilla::StringBuffer>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::already_AddRefed<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::already_AddRefed<root::mozilla::StringBuffer>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::already_AddRefed<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::already_AddRefed<root::mozilla::StringBuffer>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::already_AddRefed<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::already_AddRefed<root::mozilla::StringBuffer>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::already_AddRefed<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: already_AddRefed_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::already_AddRefed<root::mozilla::StringBuffer>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u16>>() - 16usize];
        ["Align of template specialization: Range_open0_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_uint8_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u8>>() - 16usize];
        ["Align of template specialization: Range_open0_uint8_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u8>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSFunction_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 16usize];
        ["Align of template specialization: Range_open0_Latin1Char_close0"]
            [::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::size_of::<root::mozilla::Range<u16>>() - 16usize];
        ["Align of template specialization: Range_open0_const_char16_t_close0"]
            [::std::mem::align_of::<root::mozilla::Range<u16>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JobQueue_SavedJobQueue_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JobQueue_SavedJobQueue_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: DeletePolicy_open0_JobQueue_SavedJobQueue_close0"]
            [::std::mem::size_of::<root::JS::DeletePolicy>() - 1usize];
        ["Align of template specialization: DeletePolicy_open0_JobQueue_SavedJobQueue_close0"]
            [::std::mem::align_of::<root::JS::DeletePolicy>() - 1usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSString_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSString>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct IterImpl {
        pub mSegment: usize,
        pub mData: *mut ::std::os::raw::c_char,
        pub mDataEnd: *mut ::std::os::raw::c_char,
        pub mAbsoluteOffset: usize,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of IterImpl"][::std::mem::size_of::<IterImpl>() - 32usize];
        ["Alignment of IterImpl"][::std::mem::align_of::<IterImpl>() - 8usize];
        ["Offset of field: IterImpl::mSegment"]
            [::std::mem::offset_of!(IterImpl, mSegment) - 0usize];
        ["Offset of field: IterImpl::mData"][::std::mem::offset_of!(IterImpl, mData) - 8usize];
        ["Offset of field: IterImpl::mDataEnd"]
            [::std::mem::offset_of!(IterImpl, mDataEnd) - 16usize];
        ["Offset of field: IterImpl::mAbsoluteOffset"]
            [::std::mem::offset_of!(IterImpl, mAbsoluteOffset) - 24usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::size_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
        ["Align of template specialization: RefPtr_open0_StringBuffer_close0"]
            [::std::mem::align_of::<root::RefPtr<root::mozilla::StringBuffer>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: AtomicRefCounted_open0_WasmModule_close0"]
            [::std::mem::size_of::<root::js::AtomicRefCounted>() - 8usize];
        ["Align of template specialization: AtomicRefCounted_open0_WasmModule_close0"]
            [::std::mem::align_of::<root::js::AtomicRefCounted>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Value_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
        ["Align of template specialization: Handle_open0_Value_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::Value>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyKey_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyKey>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: MutableHandle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: size_of :: < u64 > () - 8usize] ;
        ["Align of template specialization: Handle_open0_Maybe_open1_PropertyDescriptor_close1_close0"] [:: std :: mem :: align_of :: < u64 > () - 8usize] ;
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: Handle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
        ["Align of template specialization: MutableHandle_open0_ptr_JSObject_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>() - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
        ["Align of template specialization: MutableHandle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyDescriptor>>()
                - 8usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::size_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
        ["Align of template specialization: Handle_open0_PropertyDescriptor_close0"]
            [::std::mem::align_of::<root::JS::Handle<root::JS::PropertyDescriptor>>() - 8usize];
    };
}
