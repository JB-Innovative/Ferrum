/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// This file is a Mako template: http://www.makotemplates.org/



use app_units::Au;
use servo_arc::{Arc, UniqueArc};
use std::{ops, ptr};
use std::{fmt, mem};

#[cfg(feature = "servo")] use euclid::SideOffsets2D;
#[cfg(feature = "gecko")] use crate::gecko_bindings::structs::{self, nsCSSPropertyID};
#[cfg(feature = "servo")] use crate::logical_geometry::LogicalMargin;
#[cfg(feature = "servo")] use crate::computed_values;
use crate::logical_geometry::WritingMode;
use malloc_size_of::{MallocSizeOf, MallocSizeOfOps};
use crate::computed_value_flags::*;
use cssparser::Parser;
use crate::media_queries::Device;
use crate::parser::ParserContext;
use crate::selector_parser::PseudoElement;
use crate::stylist::Stylist;
use style_traits::{CssStringWriter, CssWriter, KeywordsCollectFn, ParseError, SpecifiedValueInfo, StyleParseErrorKind, ToCss, TypedValue, ToTyped};
use crate::stylesheets::{CssRuleType, CssRuleTypes, Origin};
use crate::logical_geometry::{LogicalAxis, LogicalCorner, LogicalSide};
use crate::use_counters::UseCounters;
use crate::rule_tree::StrongRuleNode;
use crate::values::{
    computed,
    resolved,
    specified::{font::SystemFont, length::LineHeightBase, color::ColorSchemeFlags},
};
use std::cell::Cell;
use super::{
    PropertyDeclarationId, PropertyId, NonCustomPropertyId,
    NonCustomPropertyIdSet, PropertyFlags, SourcePropertyDeclaration,
    LonghandIdSet, VariableDeclaration, CustomDeclaration,
    WideKeywordDeclaration, NonCustomPropertyIterator,
};



/// Conversion with fewer impls than From/Into
pub trait MaybeBoxed<Out> {
    /// Convert
    fn maybe_boxed(self) -> Out;
}

impl<T> MaybeBoxed<T> for T {
    #[inline]
    fn maybe_boxed(self) -> T { self }
}

impl<T> MaybeBoxed<Box<T>> for T {
    #[inline]
    fn maybe_boxed(self) -> Box<T> { Box::new(self) }
}

macro_rules! expanded {
    ( $( $name: ident: $value: expr ),+ ) => {
        expanded!( $( $name: $value, )+ )
    };
    ( $( $name: ident: $value: expr, )+ ) => {
        Longhands {
            $(
                $name: MaybeBoxed::maybe_boxed($value),
            )+
        }
    }
}

/// A module with all the code for longhand properties.
#[allow(missing_docs)]
pub mod longhands {
    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#background-color
    pub mod background_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Color::TRANSPARENT_BLACK }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { SpecifiedValue::transparent() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Color::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundColor,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_color();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Color>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundColor)
        }
    }




    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds/#the-background-image
    pub mod background_image {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Image as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Image as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Image::None }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Image::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Image as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for background-image.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-image.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundImage,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_image();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_image::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_image(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundImage)
        }
    }




    
    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds-4/#propdef-background-position-x
    pub mod background_position_x {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::position::HorizontalPosition as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::position::HorizontalPosition as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::LengthPercentage::zero_percent() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { SpecifiedValue::initial_specified_value() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::position::HorizontalPosition as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for background-position-x.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;


            use crate::values::animated::{Animate, ToAnimatedZero, Procedure, lists};
            use crate::values::distance::{SquaredDistance, ComputeSquaredDistance};

            // FIXME(emilio): For some reason rust thinks that this alias is
            // unused, even though it's clearly used below?
            #[allow(unused)]
            type AnimatedList = <OwnedList<single_value::T> as ToAnimatedValue>::AnimatedValue;

            impl ToAnimatedZero for AnimatedList {
                fn to_animated_zero(&self) -> Result<Self, ()> { Err(()) }
            }

            impl Animate for AnimatedList {
                fn animate(
                    &self,
                    other: &Self,
                    procedure: Procedure,
                ) -> Result<Self, ()> {
                    Ok(OwnedList(
                        lists::repeatable_list::animate(&self.0, &other.0, procedure)?
                    ))
                }
            }
            impl ComputeSquaredDistance for AnimatedList {
                fn compute_squared_distance(
                    &self,
                    other: &Self,
                ) -> Result<SquaredDistance, ()> {
                    lists::repeatable_list::squared_distance(&self.0, &other.0)
                }
            }

            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-position-x.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundPositionX,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_position_x();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_position_x::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_position_x(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundPositionX)
        }
    }



    
    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds-4/#propdef-background-position-y
    pub mod background_position_y {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::position::VerticalPosition as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::position::VerticalPosition as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::LengthPercentage::zero_percent() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { SpecifiedValue::initial_specified_value() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::position::VerticalPosition as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for background-position-y.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;


            use crate::values::animated::{Animate, ToAnimatedZero, Procedure, lists};
            use crate::values::distance::{SquaredDistance, ComputeSquaredDistance};

            // FIXME(emilio): For some reason rust thinks that this alias is
            // unused, even though it's clearly used below?
            #[allow(unused)]
            type AnimatedList = <OwnedList<single_value::T> as ToAnimatedValue>::AnimatedValue;

            impl ToAnimatedZero for AnimatedList {
                fn to_animated_zero(&self) -> Result<Self, ()> { Err(()) }
            }

            impl Animate for AnimatedList {
                fn animate(
                    &self,
                    other: &Self,
                    procedure: Procedure,
                ) -> Result<Self, ()> {
                    Ok(OwnedList(
                        lists::repeatable_list::animate(&self.0, &other.0, procedure)?
                    ))
                }
            }
            impl ComputeSquaredDistance for AnimatedList {
                fn compute_squared_distance(
                    &self,
                    other: &Self,
                ) -> Result<SquaredDistance, ()> {
                    lists::repeatable_list::squared_distance(&self.0, &other.0)
                }
            }

            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-position-y.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundPositionY,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_position_y();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_position_y::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_position_y(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundPositionY)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds/#the-background-repeat
    pub mod background_repeat {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BackgroundRepeat as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BackgroundRepeat as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BackgroundRepeat::repeat() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::BackgroundRepeat::repeat() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BackgroundRepeat as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for background-repeat.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-repeat.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundRepeat,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_repeat();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_repeat::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_repeat(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundRepeat)
        }
    }





    

    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds/#the-background-attachment
    pub mod background_attachment {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Scroll,
            
            Fixed,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Scroll
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Scroll
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        }

        /// The definition of the computed value for background-attachment.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-attachment.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundAttachment,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_attachment();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_attachment::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_attachment(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundAttachment)
        }
    }





    

    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds/#the-background-clip
    pub mod background_clip {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            BorderBox,
            
            PaddingBox,
            
            ContentBox,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::BorderBox
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::BorderBox
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        }

        /// The definition of the computed value for background-clip.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-clip.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundClip,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_clip();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_clip::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_clip(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundClip)
        }
    }





    

    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds/#the-background-origin
    pub mod background_origin {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            PaddingBox,
            
            BorderBox,
            
            ContentBox,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::PaddingBox
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::PaddingBox
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        }

        /// The definition of the computed value for background-origin.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-origin.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundOrigin,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_origin();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_origin::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_origin(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundOrigin)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds/#the-background-size
    pub mod background_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BackgroundSize as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BackgroundSize as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BackgroundSize::auto() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::BackgroundSize::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BackgroundSize as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for background-size.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;


            use crate::values::animated::{Animate, ToAnimatedZero, Procedure, lists};
            use crate::values::distance::{SquaredDistance, ComputeSquaredDistance};

            // FIXME(emilio): For some reason rust thinks that this alias is
            // unused, even though it's clearly used below?
            #[allow(unused)]
            type AnimatedList = <OwnedList<single_value::T> as ToAnimatedValue>::AnimatedValue;

            impl ToAnimatedZero for AnimatedList {
                fn to_animated_zero(&self) -> Result<Self, ()> { Err(()) }
            }

            impl Animate for AnimatedList {
                fn animate(
                    &self,
                    other: &Self,
                    procedure: Procedure,
                ) -> Result<Self, ()> {
                    Ok(OwnedList(
                        lists::repeatable_list::animate(&self.0, &other.0, procedure)?
                    ))
                }
            }
            impl ComputeSquaredDistance for AnimatedList {
                fn compute_squared_distance(
                    &self,
                    other: &Self,
                ) -> Result<SquaredDistance, ()> {
                    lists::repeatable_list::squared_distance(&self.0, &other.0)
                }
            }

            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of background-size.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackgroundSize,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_background_size();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::background_size::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_background_size(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackgroundSize)
        }
    }




// https://drafts.fxtf.org/compositing/#background-blend-mode

    

    
        
    
    



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-top-color
    pub mod border_top_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Color::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderTopColor.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_top_color();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Color>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_top_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderTopColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-top-style
    pub mod border_top_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderTopStyle.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_top_style();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderStyle>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_top_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderTopStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-top-width
    pub mod border_top_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::BorderSideWidth::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderTopWidth.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_top_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderSideWidth>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_top_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderTopWidth)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-right-color
    pub mod border_right_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Color::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderRightColor.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_right_color();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Color>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_right_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderRightColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-right-style
    pub mod border_right_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderRightStyle.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_right_style();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderStyle>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_right_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderRightStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-right-width
    pub mod border_right_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::BorderSideWidth::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderRightWidth.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_right_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderSideWidth>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_right_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderRightWidth)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-bottom-color
    pub mod border_bottom_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Color::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderBottomColor.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_bottom_color();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Color>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_bottom_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBottomColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-bottom-style
    pub mod border_bottom_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderBottomStyle.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_bottom_style();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderStyle>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_bottom_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBottomStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-bottom-width
    pub mod border_bottom_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::BorderSideWidth::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderBottomWidth.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_bottom_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderSideWidth>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_bottom_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBottomWidth)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-left-color
    pub mod border_left_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Color::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderLeftColor.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_left_color();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Color>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_left_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderLeftColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-left-style
    pub mod border_left_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderLeftStyle.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_left_style();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderStyle>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_left_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderLeftStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-left-width
    pub mod border_left_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::BorderSideWidth::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderLeftWidth.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_left_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderSideWidth>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_left_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderLeftWidth)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-start-color
    pub mod border_block_start_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Color as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBlockStartColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-start-style
    pub mod border_block_start_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBlockStartStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-start-width
    pub mod border_block_start_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderSideWidth as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBlockStartWidth)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-end-color
    pub mod border_block_end_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Color as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBlockEndColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-end-style
    pub mod border_block_end_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBlockEndStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-end-width
    pub mod border_block_end_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderSideWidth as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderBlockEndWidth)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-start-color
    pub mod border_inline_start_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Color as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderInlineStartColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-start-style
    pub mod border_inline_start_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderInlineStartStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-start-width
    pub mod border_inline_start_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderSideWidth as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderInlineStartWidth)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-end-color
    pub mod border_inline_end_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Color as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderInlineEndColor)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-end-style
    pub mod border_inline_end_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::BorderStyle::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderInlineEndStyle)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-end-width
    pub mod border_inline_end_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderSideWidth as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderInlineEndWidth)
        }
    }



    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-top-left-radius
    pub mod border_top_left_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderTopLeftRadius.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_top_left_radius();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::BorderCornerRadius>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_top_left_radius(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderTopLeftRadius)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-top-right-radius
    pub mod border_top_right_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderTopRightRadius.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_top_right_radius();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::BorderCornerRadius>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_top_right_radius(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderTopRightRadius)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-bottom-right-radius
    pub mod border_bottom_right_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderBottomRightRadius.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_bottom_right_radius();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::BorderCornerRadius>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_bottom_right_radius(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderBottomRightRadius)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-bottom-left-radius
    pub mod border_bottom_left_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::BorderBottomLeftRadius.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_bottom_left_radius();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::BorderCornerRadius>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_bottom_left_radius(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderBottomLeftRadius)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-start-start-radius
    pub mod border_start_start_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderStartStartRadius)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-start-end-radius
    pub mod border_start_end_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderStartEndRadius)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-end-start-radius
    pub mod border_end_start_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderEndStartRadius)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-border-end-end-radius
    pub mod border_end_end_radius {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderCornerRadius as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderCornerRadius as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderCornerRadius::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderCornerRadius as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderEndEndRadius)
        }
    }




    

    
        
    



    

    
        
    



    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#the-background-image
    pub mod border_image_source {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Image as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Image as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Image::None }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Image::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Image as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BorderImageSource,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_image_source();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Image>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_image_source(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderImageSource)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-image-outset
    pub mod border_image_outset {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthOrNumberRect as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthOrNumberRect as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { generics::rect::Rect::all(computed::NonNegativeLengthOrNumber::zero()) }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { generics::rect::Rect::all(specified::NonNegativeLengthOrNumber::zero()) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::NonNegativeLengthOrNumberRect as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BorderImageOutset,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_border_image_outset();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let specified = Box::new(specified);
                                    let decl = PropertyDeclaration::BorderImageOutset(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_border_image_outset();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::NonNegativeLengthOrNumberRect>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_image_outset(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderImageOutset)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#the-border-image-repeat
    pub mod border_image_repeat {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderImageRepeat as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderImageRepeat as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderImageRepeat::stretch() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::BorderImageRepeat::stretch() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderImageRepeat as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BorderImageRepeat,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_image_repeat();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderImageRepeat>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_image_repeat(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderImageRepeat)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-image-width
    pub mod border_image_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderImageWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderImageWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderImageWidth::all(computed::BorderImageSideWidth::one()) }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::BorderImageWidth::all(specified::BorderImageSideWidth::one()) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderImageWidth as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BorderImageWidth,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_image_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::BorderImageWidth>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_image_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderImageWidth)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-backgrounds/#border-image-slice
    pub mod border_image_slice {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderImageSlice as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderImageSlice as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderImageSlice::hundred_percent() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::BorderImageSlice::hundred_percent() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderImageSlice as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BorderImageSlice,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_border_image_slice();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::BorderImageSlice>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_image_slice(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderImageSlice)
        }
    }



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    
        
    
    /// https://drafts.csswg.org/css-display/#propdef-display
    pub mod display {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Display as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Display as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Display::inline() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Display::inline() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Display as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Display,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_display();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Display>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_display(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Display)
        }
    }




    

    
        
    


// An internal-only property for elements in a top layer
// https://fullscreen.spec.whatwg.org/#top-layer

    

    
        
    
    /// Internal (not web-exposed)
    pub mod _servo_top_layer {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            None,
            
            Top,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::None
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::None
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ServoTopLayer,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit__servo_top_layer();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::_servo_top_layer::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set__servo_top_layer(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ServoTopLayer)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-position/#position-property
    pub mod position {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::PositionProperty as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::PositionProperty as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::PositionProperty::Static }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::PositionProperty::Static }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::PositionProperty as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Position,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_position();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::PositionProperty>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_position(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Position)
        }
    }



// Changes do not invalidate our element. We handle notify/invalidating
// elements that reference anchor-name elsewhere.

    
        
    


// Changes do not invalidate our element. We handle notify/invalidating
// any affected descendants elsewhere.

    
        
    



    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-float
    pub mod float {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Float as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Float as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Float::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Float as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Float,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_float();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Float>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_float(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Float)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css2/#propdef-clear
    pub mod clear {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Clear as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Clear as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Clear::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Clear as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Clear,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_clear();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Clear>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_clear(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Clear)
        }
    }




    
        
    
    /// https://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align
    pub mod vertical_align {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::VerticalAlign as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::VerticalAlign as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::VerticalAlign::baseline() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::VerticalAlign as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::VerticalAlign,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_vertical_align();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::VerticalAlign>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_vertical_align(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::VerticalAlign)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-inline-3/#baseline-source
    pub mod baseline_source {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BaselineSource as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BaselineSource as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BaselineSource::Auto }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BaselineSource as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BaselineSource,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_baseline_source();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BaselineSource>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_baseline_source(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BaselineSource)
        }
    }



// CSS 2.1, Section 11 - Visual effects


    

    
        
    
    /// Internal, not web-exposed,           may be standardized in the future (https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-clip-box)
    pub mod _servo_overflow_clip_box {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            PaddingBox,
            
            ContentBox,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::PaddingBox
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::PaddingBox
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ServoOverflowClipBox,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit__servo_overflow_clip_box();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::_servo_overflow_clip_box::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set__servo_overflow_clip_box(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ServoOverflowClipBox)
        }
    }



    
    
    
        
    
    /// https://drafts.csswg.org/css-overflow-3/#propdef-overflow-y
    pub mod overflow_y {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Overflow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Overflow as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Overflow::Visible }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Overflow as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::OverflowY.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_overflow_y();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Overflow>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_overflow_y(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OverflowY)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-overflow-3/#propdef-overflow-x
    pub mod overflow_x {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Overflow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Overflow as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Overflow::Visible }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Overflow as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::OverflowX.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_overflow_x();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Overflow>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_overflow_x(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OverflowX)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-overflow-3/#propdef-overflow-block
    pub mod overflow_block {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Overflow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Overflow as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Overflow::Visible }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Overflow as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OverflowBlock)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-overflow-3/#propdef-overflow-inline
    pub mod overflow_inline {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Overflow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Overflow as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Overflow::Visible }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Overflow as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OverflowInline)
        }
    }




    
        
    





    
        
    
    /// https://drafts.csswg.org/css-transforms/#propdef-transform
    pub mod transform {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Transform as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Transform as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { generics::transform::Transform::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Transform as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Transform,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transform();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Transform>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_transform(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Transform)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-transforms-2/#individual-transforms
    pub mod rotate {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Rotate as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Rotate as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { generics::transform::Rotate::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Rotate as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Rotate,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_rotate();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::Rotate>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_rotate(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::Rotate)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-transforms-2/#individual-transforms
    pub mod scale {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Scale as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Scale as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { generics::transform::Scale::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Scale as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Scale,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_scale();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::Scale>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_scale(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::Scale)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-transforms-2/#individual-transforms
    pub mod translate {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Translate as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Translate as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { generics::transform::Translate::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Translate as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Translate,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_translate();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::Translate>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_translate(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::Translate)
        }
    }



// Motion Path Module Level 1

    
        
    
    /// https://drafts.fxtf.org/motion-1/#offset-path-property
    pub mod offset_path {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::OffsetPath as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::OffsetPath as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::OffsetPath::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::OffsetPath as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::OffsetPath,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_offset_path();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::OffsetPath>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_offset_path(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OffsetPath)
        }
    }



// Motion Path Module Level 1

    
        
    


// Motion Path Module Level 1

    
        
    


// Motion Path Module Level 1

    
        
    


// Motion Path Module Level 1

    
        
    


// CSSOM View Module
// https://www.w3.org/TR/cssom-view-1/

    

    
        
    



    
        
    



    
        
    



    
        
    


    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    


// Compositing and Blending Level 1
// http://www.w3.org/TR/compositing-1/

    

    
        
    
    /// https://drafts.fxtf.org/compositing/#isolation
    pub mod isolation {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Auto,
            
            Isolate,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Auto
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Auto
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Isolation,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_isolation();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::isolation::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_isolation(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Isolation)
        }
    }




    
        
    



    
        
    



    
        
    


// CSS Basic User Interface Module Level 3
// http://dev.w3.org/csswg/css-ui

    
        
    



    
        
    
    /// https://drafts.csswg.org/css-transforms/#perspective
    pub mod perspective {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Perspective as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Perspective as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Perspective::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Perspective as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Perspective,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_perspective();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Perspective>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_perspective(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Perspective)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-transforms-2/#perspective-origin-property
    pub mod perspective_origin {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Position as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Position as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::position::Position::center() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Position as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::PerspectiveOrigin,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_perspective_origin();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let specified = Box::new(specified);
                                    let decl = PropertyDeclaration::PerspectiveOrigin(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_perspective_origin();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::Position>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_perspective_origin(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::PerspectiveOrigin)
        }
    }




    

    
        
    
    /// https://drafts.csswg.org/css-transforms/#backface-visibility-property
    pub mod backface_visibility {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Visible,
            
            Hidden,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Visible
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Visible
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackfaceVisibility,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_backface_visibility();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::backface_visibility::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_backface_visibility(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackfaceVisibility)
        }
    }




    
        
    



    
        
    
    /// https://drafts.csswg.org/css-transforms-2/#transform-style-property
    pub mod transform_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TransformStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TransformStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TransformStyle::Flat }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TransformStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TransformStyle,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transform_style();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::TransformStyle>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_transform_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TransformStyle)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-transforms/#transform-origin-property
    pub mod transform_origin {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TransformOrigin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TransformOrigin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TransformOrigin::initial_value() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TransformOrigin as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TransformOrigin,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transform_origin();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::TransformOrigin>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_transform_origin(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::TransformOrigin)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-contain/#contain-property
    pub mod contain {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Contain as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Contain as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::Contain::empty() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Contain as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Contain,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_contain();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Contain>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_contain(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Contain)
        }
    }




    
        
    



    
        
    
    /// https://drafts.csswg.org/css-contain-3/#container-type
    pub mod container_type {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ContainerType as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ContainerType as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ContainerType::NORMAL }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ContainerType as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ContainerType,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_container_type();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ContainerType>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_container_type(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ContainerType)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-contain-3/#container-name
    pub mod container_name {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ContainerName as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ContainerName as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ContainerName::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ContainerName as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ContainerName,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_container_name();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ContainerName>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_container_name(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ContainerName)
        }
    }




    
        
    


// The inherent widget type of an element, selected by specifying
// `appearance: auto`.

    
        
    



    

    
        
    



    
        
    
    /// https://drafts.csswg.org/css-will-change/#will-change
    pub mod will_change {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::WillChange as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::WillChange as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::WillChange::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::WillChange as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::WillChange,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_will_change();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::WillChange>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_will_change(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::WillChange)
        }
    }



// The spec issue for the parse_method: https://github.com/w3c/csswg-drafts/issues/4102.

    
        
    



    
        
    



    
        
    



    
        
    



    
        
    



    
        
    



    
        
    
    /// Non-standard (https://github.com/atanassov/css-zoom/ is the closest)
    pub mod zoom {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Zoom as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Zoom as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::box_::Zoom::ONE }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Zoom as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Zoom,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_zoom();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Zoom>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_zoom(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Zoom)
        }
    }



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-multicol/#propdef-column-width
    pub mod column_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::length::NonNegativeLengthOrAuto as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::length::NonNegativeLengthOrAuto as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::length::NonNegativeLengthOrAuto::auto() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::length::NonNegativeLengthOrAuto::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::length::NonNegativeLengthOrAuto as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ColumnWidth,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_column_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::length::NonNegativeLengthOrAuto>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_column_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ColumnWidth)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-multicol/#propdef-column-count
    pub mod column_count {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ColumnCount as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ColumnCount as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ColumnCount::Auto }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::ColumnCount::Auto }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ColumnCount as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ColumnCount,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_column_count();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ColumnCount>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_column_count(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ColumnCount)
        }
    }




    

    
        
    



    
        
    


// https://drafts.csswg.org/css-multicol-1/#crc

    
        
    



    

    
        
    
    /// https://drafts.csswg.org/css-multicol/#propdef-column-span
    pub mod column_span {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            None,
            
            All,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::None
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::None
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ColumnSpan,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_column_span();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::column_span::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_column_span(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ColumnSpan)
        }
    }




    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-content/#propdef-content
    pub mod content {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Content as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Content as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Content::normal() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Content::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Content as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Content,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_content();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Content>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_content(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Content)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-lists/#propdef-counter-increment
    pub mod counter_increment {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::CounterIncrement as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::CounterIncrement as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::CounterIncrement as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::CounterIncrement,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_counter_increment();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::CounterIncrement>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_counter_increment(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::CounterIncrement)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-lists-3/#propdef-counter-reset
    pub mod counter_reset {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::CounterReset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::CounterReset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::CounterReset as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::CounterReset,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_counter_reset();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::CounterReset>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_counter_reset(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::CounterReset)
        }
    }




    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-color/#transparency
    pub mod opacity {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Opacity as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Opacity as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { 1.0 }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Opacity as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Opacity,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_opacity();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Opacity>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_opacity(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Opacity)
        }
    }




    
        
    
    
    /// https://drafts.csswg.org/css-backgrounds/#box-shadow
    pub mod box_shadow {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BoxShadow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BoxShadow as T;
        }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BoxShadow as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for box-shadow.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    crate::OwnedSlice<T>;

            pub type UnderlyingOwnedList<T> =
                    crate::OwnedSlice<T>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(if_empty = "none", iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;

            impl From<ComputedList> for UnderlyingList<single_value::T> {
                #[inline]
                fn from(l: ComputedList) -> Self {
                    l.0
                }
            }
            impl From<UnderlyingList<single_value::T>> for ComputedList {
                #[inline]
                fn from(l: UnderlyingList<single_value::T>) -> Self {
                    List(l)
                }
            }

            use crate::values::animated::{Animate, ToAnimatedZero, Procedure, lists};
            use crate::values::distance::{SquaredDistance, ComputeSquaredDistance};

            // FIXME(emilio): For some reason rust thinks that this alias is
            // unused, even though it's clearly used below?
            #[allow(unused)]
            type AnimatedList = <OwnedList<single_value::T> as ToAnimatedValue>::AnimatedValue;

            impl ToAnimatedZero for AnimatedList {
                fn to_animated_zero(&self) -> Result<Self, ()> { Err(()) }
            }

            impl Animate for AnimatedList {
                fn animate(
                    &self,
                    other: &Self,
                    procedure: Procedure,
                ) -> Result<Self, ()> {
                    Ok(OwnedList(
                        lists::with_zero::animate(&self.0, &other.0, procedure)?
                    ))
                }
            }
            impl ComputeSquaredDistance for AnimatedList {
                fn compute_squared_distance(
                    &self,
                    other: &Self,
                ) -> Result<SquaredDistance, ()> {
                    lists::with_zero::squared_distance(&self.0, &other.0)
                }
            }

            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of box-shadow.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(if_empty = "none", iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                computed_value::List(Default::default())
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;

            if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
                return Ok(SpecifiedValue(Default::default()))
            }

            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BoxShadow,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_box_shadow();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::box_shadow::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_box_shadow(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BoxShadow)
        }
    }





    
        
    
    /// https://drafts.fxtf.org/css-masking/#clip-property
    pub mod clip {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ClipRectOrAuto as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ClipRectOrAuto as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ClipRectOrAuto::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::ClipRectOrAuto::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Clip,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_clip();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::ClipRectOrAuto>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_clip(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::Clip)
        }
    }




    
        
    
    
    /// https://drafts.fxtf.org/filters/#propdef-filter
    pub mod filter {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Filter as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Filter as T;
        }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Filter as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for filter.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    crate::OwnedSlice<T>;

            pub type UnderlyingOwnedList<T> =
                    crate::OwnedSlice<T>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            pub struct OwnedList<T>(
                #[css(if_empty = "none", iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;

            impl From<ComputedList> for UnderlyingList<single_value::T> {
                #[inline]
                fn from(l: ComputedList) -> Self {
                    l.0
                }
            }
            impl From<UnderlyingList<single_value::T>> for ComputedList {
                #[inline]
                fn from(l: UnderlyingList<single_value::T>) -> Self {
                    List(l)
                }
            }

            use crate::values::animated::{Animate, ToAnimatedZero, Procedure, lists};
            use crate::values::distance::{SquaredDistance, ComputeSquaredDistance};

            // FIXME(emilio): For some reason rust thinks that this alias is
            // unused, even though it's clearly used below?
            #[allow(unused)]
            type AnimatedList = <OwnedList<single_value::T> as ToAnimatedValue>::AnimatedValue;

            impl ToAnimatedZero for AnimatedList {
                fn to_animated_zero(&self) -> Result<Self, ()> { Err(()) }
            }

            impl Animate for AnimatedList {
                fn animate(
                    &self,
                    other: &Self,
                    procedure: Procedure,
                ) -> Result<Self, ()> {
                    Ok(OwnedList(
                        lists::with_zero::animate(&self.0, &other.0, procedure)?
                    ))
                }
            }
            impl ComputeSquaredDistance for AnimatedList {
                fn compute_squared_distance(
                    &self,
                    other: &Self,
                ) -> Result<SquaredDistance, ()> {
                    lists::with_zero::squared_distance(&self.0, &other.0)
                }
            }

            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of filter.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        pub struct SpecifiedValue(
            #[css(if_empty = "none", iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                computed_value::List(Default::default())
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;

            if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
                return Ok(SpecifiedValue(Default::default()))
            }

            let v = style_traits::Space::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Filter,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_filter();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::filter::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_filter(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Filter)
        }
    }





    
        
    
    
    /// https://drafts.fxtf.org/filter-effects-2/#propdef-backdrop-filter
    pub mod backdrop_filter {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Filter as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Filter as T;
        }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Filter as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for backdrop-filter.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    crate::OwnedSlice<T>;

            pub type UnderlyingOwnedList<T> =
                    crate::OwnedSlice<T>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            pub struct OwnedList<T>(
                #[css(if_empty = "none", iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;

            impl From<ComputedList> for UnderlyingList<single_value::T> {
                #[inline]
                fn from(l: ComputedList) -> Self {
                    l.0
                }
            }
            impl From<UnderlyingList<single_value::T>> for ComputedList {
                #[inline]
                fn from(l: UnderlyingList<single_value::T>) -> Self {
                    List(l)
                }
            }

            use crate::values::animated::{Animate, ToAnimatedZero, Procedure, lists};
            use crate::values::distance::{SquaredDistance, ComputeSquaredDistance};

            // FIXME(emilio): For some reason rust thinks that this alias is
            // unused, even though it's clearly used below?
            #[allow(unused)]
            type AnimatedList = <OwnedList<single_value::T> as ToAnimatedValue>::AnimatedValue;

            impl ToAnimatedZero for AnimatedList {
                fn to_animated_zero(&self) -> Result<Self, ()> { Err(()) }
            }

            impl Animate for AnimatedList {
                fn animate(
                    &self,
                    other: &Self,
                    procedure: Procedure,
                ) -> Result<Self, ()> {
                    Ok(OwnedList(
                        lists::with_zero::animate(&self.0, &other.0, procedure)?
                    ))
                }
            }
            impl ComputeSquaredDistance for AnimatedList {
                fn compute_squared_distance(
                    &self,
                    other: &Self,
                ) -> Result<SquaredDistance, ()> {
                    lists::with_zero::squared_distance(&self.0, &other.0)
                }
            }

            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of backdrop-filter.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        pub struct SpecifiedValue(
            #[css(if_empty = "none", iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                computed_value::List(Default::default())
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;

            if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
                return Ok(SpecifiedValue(Default::default()))
            }

            let v = style_traits::Space::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BackdropFilter,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_backdrop_filter();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::backdrop_filter::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_backdrop_filter(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BackdropFilter)
        }
    }





    

    
        
    
    /// https://drafts.fxtf.org/compositing/#propdef-mix-blend-mode
    pub mod mix_blend_mode {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Normal,
            
            Multiply,
            
            Screen,
            
            Overlay,
            
            Darken,
            
            Lighten,
            
            ColorDodge,
            
            ColorBurn,
            
            HardLight,
            
            SoftLight,
            
            Difference,
            
            Exclusion,
            
            Hue,
            
            Saturation,
            
            Color,
            
            Luminosity,
            
            PlusLighter,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Normal
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Normal
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::MixBlendMode,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_mix_blend_mode();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::mix_blend_mode::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_mix_blend_mode(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MixBlendMode)
        }
    }



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    
        
    
    /// https://drafts.csswg.org/css-fonts/#propdef-font-family
    pub mod font_family {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontFamily as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontFamily as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontFamily::serif() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FontFamily as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontFamily,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_family();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontFamily>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_family(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontFamily)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-fonts/#propdef-font-style
    pub mod font_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontStyle::normal() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::FontStyle::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FontStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontStyle,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_style();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontStyle>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontStyle)
        }
    }






    

    
        
    
    /// https://drafts.csswg.org/css-fonts/#propdef-font-variant-caps
    pub mod font_variant_caps {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Normal,
            
            SmallCaps,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Normal
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Normal
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontVariantCaps,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_variant_caps();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::font_variant_caps::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_variant_caps(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontVariantCaps)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-fonts/#propdef-font-weight
    pub mod font_weight {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontWeight as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontWeight as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontWeight::normal() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::FontWeight::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FontWeight as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontWeight,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_weight();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontWeight>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_weight(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontWeight)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-fonts/#propdef-font-size
    pub mod font_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontSize as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontSize as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontSize::medium() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::FontSize::medium() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::FontSize::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontSize,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_size();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_font_size();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::FontSize(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontSize>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_size(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontSize)
        }
    }




    
        
    



    
        
    
    /// https://drafts.csswg.org/css-fonts-4/#font-synthesis-weight
    pub mod font_synthesis_weight {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontSynthesis as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontSynthesis as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontSynthesis::Auto }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::FontSynthesis::Auto }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FontSynthesis as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontSynthesisWeight,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_synthesis_weight();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontSynthesis>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_synthesis_weight(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontSynthesisWeight)
        }
    }




    
        
    



    
        
    



    
        
    



    
        
    
    /// https://drafts.csswg.org/css-fonts/#propdef-font-stretch
    pub mod font_stretch {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontStretch as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontStretch as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontStretch::hundred() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::FontStretch::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FontStretch as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontStretch,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_stretch();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontStretch>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_stretch(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontStretch)
        }
    }




    

    
        
    



    
        
    



    
        
    



    

    
        
    



    
        
    



    
        
    



    

    
        
    



    
        
    



    
        
    
    /// https://drafts.csswg.org/css-fonts-4/#propdef-font-variation-settings
    pub mod font_variation_settings {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontVariationSettings as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontVariationSettings as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontVariationSettings::normal() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::FontVariationSettings::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FontVariationSettings as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontVariationSettings,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_variation_settings();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontVariationSettings>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_variation_settings(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontVariationSettings)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-fonts-3/#propdef-font-language-override
    pub mod font_language_override {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FontLanguageOverride as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FontLanguageOverride as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FontLanguageOverride::normal() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::FontLanguageOverride::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FontLanguageOverride as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FontLanguageOverride,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_font_language_override();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::FontLanguageOverride>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_font_language_override(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FontLanguageOverride)
        }
    }




    

    
        
    



    
        
    



    
        
    
    /// Internal (not web-exposed)
    pub mod _x_lang {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::XLang as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::XLang as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::XLang::get_initial_value() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::XLang as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::XLang,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset__x_lang();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::XLang>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set__x_lang(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::XLang)
        }
    }




    
        
    



    

    
        
    



    

    
        
    



    

    
        
    



    
        
    



    
        
    
    /// https://drafts.csswg.org/css2/visudet.html#propdef-line-height
    pub mod line_height {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::LineHeight as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::LineHeight as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::LineHeight::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::LineHeight as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::LineHeight,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_line_height();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_line_height();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::LineHeight(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::LineHeight>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_line_height(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::LineHeight)
        }
    }





    

    
        
    



    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



// TODO: collapse. Well, do tables first.

    

    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-visibility
    pub mod visibility {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Visible,
            
            Hidden,
            
            Collapse,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Visible
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Visible
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Visibility,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_visibility();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::visibility::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_visibility(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Visibility)
        }
    }



// CSS Writing Modes Level 3
// https://drafts.csswg.org/css-writing-modes-3

    
        
    
    /// https://drafts.csswg.org/css-writing-modes/#propdef-writing-mode
    pub mod writing_mode {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::WritingModeProperty as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::WritingModeProperty as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::WritingModeProperty::HorizontalTb }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::WritingModeProperty as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::WritingMode,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_writing_mode();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::WritingModeProperty>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_writing_mode(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::WritingMode)
        }
    }




    

    
        
    
    /// https://drafts.csswg.org/css-writing-modes/#propdef-direction
    pub mod direction {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Ltr,
            
            Rtl,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Ltr
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Ltr
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Direction,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_direction();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::direction::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_direction(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Direction)
        }
    }




    

    
        
    



    

    
        
    



    
        
    


// According to to CSS-IMAGES-3, `optimizespeed` and `optimizequality` are synonyms for `auto`
// And, firefox doesn't support `pixelated` yet (https://bugzilla.mozilla.org/show_bug.cgi?id=856337)

    
        
    
    /// https://drafts.csswg.org/css-images/#propdef-image-rendering
    pub mod image_rendering {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ImageRendering as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ImageRendering as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ImageRendering::Auto }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ImageRendering as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ImageRendering,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_image_rendering();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ImageRendering>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_image_rendering(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ImageRendering)
        }
    }




    

    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



// Section 10 - Text


    

    
        
    



    

    
        
    


// Section 11 - Painting: Filling, Stroking and Marker Symbols

    

    
        
    



    

    
        
    



    
        
    



    
        
    



    
        
    



    

    
        
    



    
        
    



    
        
    



    

    
        
    



    

    
        
    



    
        
    



    
        
    



    
        
    



    
        
    


// Section 14 - Clipping, Masking and Compositing

    
        
    



    
        
    



    
        
    



    
        
    



    
        
    



    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    

    
        
    
    /// https://drafts.csswg.org/css-tables/#propdef-border-collapse
    pub mod border_collapse {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Separate,
            
            Collapse,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Separate
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Separate
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BorderCollapse,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_border_collapse();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::border_collapse::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_border_collapse(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BorderCollapse)
        }
    }




    

    
        
    
    /// https://drafts.csswg.org/css-tables/#propdef-empty-cells
    pub mod empty_cells {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Show,
            
            Hide,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Show
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Show
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::EmptyCells,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_empty_cells();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::empty_cells::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_empty_cells(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::EmptyCells)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-tables/#propdef-caption-side
    pub mod caption_side {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::table::CaptionSide as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::table::CaptionSide as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::table::CaptionSide::Top }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::table::CaptionSide as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::CaptionSide,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_caption_side();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::table::CaptionSide>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_caption_side(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::CaptionSide)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-tables/#propdef-border-spacing
    pub mod border_spacing {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSpacing as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSpacing as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::BorderSpacing::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderSpacing as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BorderSpacing,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_border_spacing();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_border_spacing();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let specified = Box::new(specified);
                                    let decl = PropertyDeclaration::BorderSpacing(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::BorderSpacing>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_border_spacing(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::BorderSpacing)
        }
    }



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-color/#color
    pub mod color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ColorPropertyValue as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ColorPropertyValue as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { crate::color::AbsoluteColor::BLACK }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ColorPropertyValue as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Color,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_color();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ColorPropertyValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Color)
        }
    }



// CSS Text Module Level 3


    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-text-transform
    pub mod text_transform {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TextTransform as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TextTransform as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TextTransform::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TextTransform as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextTransform,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_transform();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::TextTransform>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_transform(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextTransform)
        }
    }




    

    
        
    


// TODO: Support <percentage>

    

    
        
    



    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-text-indent
    pub mod text_indent {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TextIndent as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TextIndent as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TextIndent::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TextIndent as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextIndent,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_indent();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_text_indent();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::TextIndent(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::TextIndent>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_indent(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextIndent)
        }
    }



// Also known as "word-wrap" (which is more popular because of IE), but this is
// the preferred name per CSS-TEXT 6.2.

    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-overflow-wrap
    pub mod overflow_wrap {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::OverflowWrap as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::OverflowWrap as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::OverflowWrap::Normal }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::OverflowWrap as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::OverflowWrap,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_overflow_wrap();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::OverflowWrap>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_overflow_wrap(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OverflowWrap)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-word-break
    pub mod word_break {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::WordBreak as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::WordBreak as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::WordBreak::Normal }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::WordBreak as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::WordBreak,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_word_break();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::WordBreak>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_word_break(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::WordBreak)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-text-justify
    pub mod text_justify {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TextJustify as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TextJustify as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TextJustify::Auto }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TextJustify as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextJustify,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_justify();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::TextJustify>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_justify(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextJustify)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-text-align-last
    pub mod text_align_last {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TextAlignLast as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TextAlignLast as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::text::TextAlignLast::Auto }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TextAlignLast as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextAlignLast,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_align_last();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::TextAlignLast>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_align_last(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextAlignLast)
        }
    }



// TODO make this a shorthand and implement text-align-last/text-align-all

    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-text-align
    pub mod text_align {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TextAlign as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TextAlign as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TextAlign::Start }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TextAlign as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextAlign,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_align();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::TextAlign>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_align(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextAlign)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-letter-spacing
    pub mod letter_spacing {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::LetterSpacing as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::LetterSpacing as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::LetterSpacing::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::LetterSpacing as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::LetterSpacing,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_letter_spacing();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_letter_spacing();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::LetterSpacing(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::LetterSpacing>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_letter_spacing(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::LetterSpacing)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-text/#propdef-word-spacing
    pub mod word_spacing {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::WordSpacing as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::WordSpacing as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::WordSpacing::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::WordSpacing as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::WordSpacing,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_word_spacing();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_word_spacing();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::WordSpacing(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::WordSpacing>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_word_spacing(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::WordSpacing)
        }
    }



// TODO: `white-space-collapse: discard` not yet supported

    

    
        
    
    /// https://drafts.csswg.org/css-text-4/#propdef-white-space-collapse
    pub mod white_space_collapse {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Collapse,
            
            Preserve,
            
            PreserveBreaks,
            
            BreakSpaces,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Collapse
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Collapse
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::WhiteSpaceCollapse,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_white_space_collapse();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::white_space_collapse::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_white_space_collapse(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::WhiteSpaceCollapse)
        }
    }




    
        
    



    
        
    
    
    /// https://drafts.csswg.org/css-text-decor-3/#text-shadow-property
    pub mod text_shadow {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::SimpleShadow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::SimpleShadow as T;
        }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::SimpleShadow as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for text-shadow.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    crate::ArcSlice<T>;

            pub type UnderlyingOwnedList<T> =
                    crate::OwnedSlice<T>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(if_empty = "none", iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub use self::ComputedList as List;

            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToCss, ToTyped)]
            #[css(comma)]
            pub struct ComputedList(
                #[css(if_empty = "none", iterable)]
                #[ignore_malloc_size_of = "Arc"]
                pub UnderlyingList<single_value::T>,
            );

            type ResolvedList = <OwnedList<single_value::T> as ToResolvedValue>::ResolvedValue;
            impl ToResolvedValue for ComputedList {
                type ResolvedValue = ResolvedList;

                fn to_resolved_value(self, context: &crate::values::resolved::Context) -> Self::ResolvedValue {
                    OwnedList(
                        self.0
                            .iter()
                            .cloned()
                            .map(|v| v.to_resolved_value(context))
                            .collect()
                    )
                }

                fn from_resolved_value(resolved: Self::ResolvedValue) -> Self {
                    let iter =
                        resolved.0.into_iter().map(ToResolvedValue::from_resolved_value);
                    ComputedList(UnderlyingList::from_iter(iter))
                }
            }

            impl From<ComputedList> for UnderlyingList<single_value::T> {
                #[inline]
                fn from(l: ComputedList) -> Self {
                    l.0
                }
            }
            impl From<UnderlyingList<single_value::T>> for ComputedList {
                #[inline]
                fn from(l: UnderlyingList<single_value::T>) -> Self {
                    List(l)
                }
            }

            use crate::values::animated::{Animate, ToAnimatedZero, Procedure, lists};
            use crate::values::distance::{SquaredDistance, ComputeSquaredDistance};

            // FIXME(emilio): For some reason rust thinks that this alias is
            // unused, even though it's clearly used below?
            #[allow(unused)]
            type AnimatedList = <OwnedList<single_value::T> as ToAnimatedValue>::AnimatedValue;
            impl ToAnimatedValue for ComputedList {
                type AnimatedValue = AnimatedList;

                fn to_animated_value(self, context: &crate::values::animated::Context) -> Self::AnimatedValue {
                    OwnedList(
                        self.0.iter().map(|v| v.clone().to_animated_value(context)).collect()
                    )
                }

                fn from_animated_value(animated: Self::AnimatedValue) -> Self {
                    let iter =
                        animated.0.into_iter().map(ToAnimatedValue::from_animated_value);
                    ComputedList(UnderlyingList::from_iter(iter))
                }
            }

            impl ToAnimatedZero for AnimatedList {
                fn to_animated_zero(&self) -> Result<Self, ()> { Err(()) }
            }

            impl Animate for AnimatedList {
                fn animate(
                    &self,
                    other: &Self,
                    procedure: Procedure,
                ) -> Result<Self, ()> {
                    Ok(OwnedList(
                        lists::with_zero::animate(&self.0, &other.0, procedure)?
                    ))
                }
            }
            impl ComputeSquaredDistance for AnimatedList {
                fn compute_squared_distance(
                    &self,
                    other: &Self,
                ) -> Result<SquaredDistance, ()> {
                    lists::with_zero::squared_distance(&self.0, &other.0)
                }
            }

            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of text-shadow.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(if_empty = "none", iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                computed_value::List(Default::default())
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;

            if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
                return Ok(SpecifiedValue(Default::default()))
            }

            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextShadow,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_shadow();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_text_shadow();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::TextShadow(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::text_shadow::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_shadow(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextShadow)
        }
    }





    
        
    



    
        
    



    
        
    



    
        
    



    
        
    


// CSS Compatibility
// https://compat.spec.whatwg.org

    
        
    



    
        
    



    
        
    


// CSS Ruby Layout Module Level 1
// https://drafts.csswg.org/css-ruby/

    

    
        
    



    
        
    


// CSS Writing Modes Module Level 3
// https://drafts.csswg.org/css-writing-modes-3/


    

    
        
    


// SVG 2: Section 13 - Painting: Filling, Stroking and Marker Symbols

    

    
        
    
    /// https://svgwg.org/svg2-draft/painting.html#TextRenderingProperty
    pub mod text_rendering {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Auto,
            
            Optimizespeed,
            
            Optimizelegibility,
            
            Geometricprecision,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Auto
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Auto
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextRendering,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_rendering();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::text_rendering::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_rendering(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextRendering)
        }
    }




    
        
    


// text underline offset

    
        
    


// text underline position

    
        
    


// text decoration skip ink

    
        
    


// hyphenation character

    
        
    



    
        
    



    

    
        
    



    

    
        
    
    /// https://drafts.csswg.org/css-text-4/#propdef-text-wrap-mode
    pub mod text_wrap_mode {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Wrap,
            
            Nowrap,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Wrap
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Wrap
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextWrapMode,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_text_wrap_mode();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::text_wrap_mode::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_wrap_mode(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextWrapMode)
        }
    }



// hyphenation length thresholds

    
        
    



    

    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-ui/#cursor
    pub mod cursor {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Cursor as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Cursor as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Cursor::auto() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Cursor::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Cursor as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Cursor,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_cursor();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Cursor>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_cursor(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Cursor)
        }
    }




    
        
    
    /// https://svgwg.org/svg2-draft/interact.html#PointerEventsProperty
    pub mod pointer_events {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::PointerEvents as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::PointerEvents as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::PointerEvents::Auto }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::PointerEvents as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::PointerEvents,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_pointer_events();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::PointerEvents>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_pointer_events(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PointerEvents)
        }
    }




    
        
    



    
        
    



    
        
    



    
        
    



    
        
    
    /// https://drafts.csswg.org/css-color-adjust/#color-scheme-prop
    pub mod color_scheme {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ColorScheme as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ColorScheme as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::color::ColorScheme::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ColorScheme as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ColorScheme,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_color_scheme();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ColorScheme>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_color_scheme(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ColorScheme)
        }
    }




    
        
    



    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    

    
        
    
    /// https://drafts.csswg.org/css-lists/#propdef-list-style-position
    pub mod list_style_position {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Outside,
            
            Inside,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Outside
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Outside
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ListStylePosition,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_list_style_position();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::list_style_position::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_list_style_position(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ListStylePosition)
        }
    }



// TODO(pcwalton): Implement the full set of counter styles per CSS-COUNTER-STYLES [1] 6.1:
//
//     decimal-leading-zero, armenian, upper-armenian, lower-armenian, georgian, lower-roman,
//     upper-roman
//
// [1]: http://dev.w3.org/csswg/css-counter-styles/
    
    

    
        
    
    /// https://drafts.csswg.org/css-lists/#propdef-list-style-type
    pub mod list_style_type {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Disc,
            
            None,
            
            Circle,
            
            Square,
            
            DisclosureOpen,
            
            DisclosureClosed,
            
            Decimal,
            
            LowerAlpha,
            
            UpperAlpha,
            
            ArabicIndic,
            
            Bengali,
            
            Cambodian,
            
            CjkDecimal,
            
            Devanagari,
            
            Gujarati,
            
            Gurmukhi,
            
            Kannada,
            
            Khmer,
            
            Lao,
            
            Malayalam,
            
            Mongolian,
            
            Myanmar,
            
            Oriya,
            
            Persian,
            
            Telugu,
            
            Thai,
            
            Tibetan,
            
            CjkEarthlyBranch,
            
            CjkHeavenlyStem,
            
            LowerGreek,
            
            Hiragana,
            
            HiraganaIroha,
            
            Katakana,
            
            KatakanaIroha,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Disc
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Disc
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ListStyleType,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_list_style_type();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::list_style_type::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_list_style_type(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ListStyleType)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-lists/#propdef-list-style-image
    pub mod list_style_image {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Image as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Image as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Image::None }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Image::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Image as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ListStyleImage,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_list_style_image();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Image>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_list_style_image(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ListStyleImage)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-content/#propdef-quotes
    pub mod quotes {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Quotes as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Quotes as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Quotes::get_initial_value() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Quotes as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = false;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Quotes,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Initial => {
                                context.builder.reset_quotes();
                        },
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Inherit => {
                                declaration.debug_crash("Unexpected inherit or unset for non-zoom-dependent inherited property");
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Quotes>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_quotes(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Quotes)
        }
    }



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-margin-top
    pub mod margin_top {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Margin::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MarginTop.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_margin_top();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Margin>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_margin_top(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginTop)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-margin-right
    pub mod margin_right {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Margin::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MarginRight.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_margin_right();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Margin>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_margin_right(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginRight)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-margin-bottom
    pub mod margin_bottom {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Margin::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MarginBottom.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_margin_bottom();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Margin>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_margin_bottom(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginBottom)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-margin-left
    pub mod margin_left {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Margin::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MarginLeft.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_margin_left();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Margin>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_margin_left(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginLeft)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-margin-True
    pub mod margin_block_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Margin as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginBlockStart)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-margin-True
    pub mod margin_block_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Margin as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginBlockEnd)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-margin-True
    pub mod margin_inline_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Margin as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginInlineStart)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-margin-True
    pub mod margin_inline_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Margin as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Margin as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Margin::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Margin as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MarginInlineEnd)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-overflow/#propdef-overflow-clip-margin
    pub mod overflow_clip_margin {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Length as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Length as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Length::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Length::parse_non_negative(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::OverflowClipMargin,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_overflow_clip_margin();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::OverflowClipMargin(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_overflow_clip_margin();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Length>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_overflow_clip_margin(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OverflowClipMargin)
        }
    }



    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-ui/#propdef-outline-color
    pub mod outline_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Color::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Color as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::OutlineColor,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_outline_color();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Color>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_outline_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OutlineColor)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-ui/#propdef-outline-style
    pub mod outline_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::OutlineStyle as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::OutlineStyle as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::OutlineStyle::none() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::OutlineStyle::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::OutlineStyle as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::OutlineStyle,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_outline_style();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::OutlineStyle>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_outline_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OutlineStyle)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-ui/#propdef-outline-width
    pub mod outline_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideWidth as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideWidth as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au::from_px(3) }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::BorderSideWidth::medium() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderSideWidth as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::OutlineWidth,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_outline_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderSideWidth>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_outline_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OutlineWidth)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-ui/#propdef-outline-offset
    pub mod outline_offset {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::BorderSideOffset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::BorderSideOffset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { app_units::Au(0) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::BorderSideOffset as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::OutlineOffset,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_outline_offset();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::BorderSideOffset>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_outline_offset(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::OutlineOffset)
        }
    }



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-padding-top
    pub mod padding_top {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::NonNegativeLengthPercentage::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::PaddingTop.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_padding_top();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::PaddingTop(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_padding_top();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::NonNegativeLengthPercentage>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_padding_top(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingTop)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-padding-right
    pub mod padding_right {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::NonNegativeLengthPercentage::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::PaddingRight.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_padding_right();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::PaddingRight(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_padding_right();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::NonNegativeLengthPercentage>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_padding_right(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingRight)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-padding-bottom
    pub mod padding_bottom {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::NonNegativeLengthPercentage::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::PaddingBottom.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_padding_bottom();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::PaddingBottom(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_padding_bottom();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::NonNegativeLengthPercentage>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_padding_bottom(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingBottom)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-padding-left
    pub mod padding_left {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::NonNegativeLengthPercentage::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::PaddingLeft.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_padding_left();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::PaddingLeft(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_padding_left();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::NonNegativeLengthPercentage>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_padding_left(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingLeft)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-padding-True
    pub mod padding_block_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::NonNegativeLengthPercentage as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingBlockStart)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-padding-True
    pub mod padding_block_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::NonNegativeLengthPercentage as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingBlockEnd)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-padding-True
    pub mod padding_inline_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::NonNegativeLengthPercentage as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingInlineStart)
        }
    }


    
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-padding-True
    pub mod padding_inline_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeLengthPercentage as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeLengthPercentage as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::NonNegativeLengthPercentage::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::NonNegativeLengthPercentage as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PaddingInlineEnd)
        }
    }



    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    
        
    



    
        
    



    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




// "top" / "left" / "bottom" / "right"
    
    
        
    
    /// https://www.w3.org/TR/CSS2/visuren.html#propdef-top
    pub mod top {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Inset::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::Top.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_top();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::Top(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_top();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Inset>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_top(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Top)
        }
    }


    
    
        
    
    /// https://www.w3.org/TR/CSS2/visuren.html#propdef-right
    pub mod right {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Inset::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::Right.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_right();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::Right(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_right();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Inset>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_right(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Right)
        }
    }


    
    
        
    
    /// https://www.w3.org/TR/CSS2/visuren.html#propdef-bottom
    pub mod bottom {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Inset::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::Bottom.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_bottom();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::Bottom(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_bottom();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Inset>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_bottom(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Bottom)
        }
    }


    
    
        
    
    /// https://www.w3.org/TR/CSS2/visuren.html#propdef-left
    pub mod left {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Inset::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::Left.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_left();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::Left(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_left();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Inset>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_left(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Left)
        }
    }


// inset-* logical properties, map to "top" / "left" / "bottom" / "right"
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-inset-block-start
    pub mod inset_block_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Inset as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::InsetBlockStart)
        }
    }


    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-inset-block-end
    pub mod inset_block_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Inset as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::InsetBlockEnd)
        }
    }


    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-inset-inline-start
    pub mod inset_inline_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Inset as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::InsetInlineStart)
        }
    }


    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-inset-inline-end
    pub mod inset_inline_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Inset as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Inset as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Inset::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Inset as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::InsetInlineEnd)
        }
    }




    
        
    
    /// https://www.w3.org/TR/CSS2/visuren.html#z-index
    pub mod z_index {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ZIndex as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ZIndex as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ZIndex::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ZIndex as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ZIndex,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_z_index();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ZIndex>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_z_index(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ZIndex)
        }
    }



// CSS Flexible Box Layout Module Level 1
// http://www.w3.org/TR/css3-flexbox/

// Flex container properties

    

    
        
    
    /// https://drafts.csswg.org/css-flexbox/#flex-direction-property
    pub mod flex_direction {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Row,
            
            RowReverse,
            
            Column,
            
            ColumnReverse,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Row
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Row
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FlexDirection,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_flex_direction();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::flex_direction::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_flex_direction(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FlexDirection)
        }
    }




    

    
        
    
    /// https://drafts.csswg.org/css-flexbox/#flex-wrap-property
    pub mod flex_wrap {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Nowrap,
            
            Wrap,
            
            WrapReverse,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Nowrap
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Nowrap
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FlexWrap,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_flex_wrap();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::flex_wrap::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_flex_wrap(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FlexWrap)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-align/#propdef-justify-content
    pub mod justify_content {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ContentDistribution as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ContentDistribution as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::ContentDistribution::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::ContentDistribution::parse_inline(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::JustifyContent,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_justify_content();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ContentDistribution>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_justify_content(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::JustifyContent)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-align/#propdef-align-content
    pub mod align_content {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ContentDistribution as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ContentDistribution as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::ContentDistribution::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::ContentDistribution::parse_block(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AlignContent,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_align_content();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ContentDistribution>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_align_content(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AlignContent)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-align/#propdef-align-items
    pub mod align_items {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ItemPlacement as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ItemPlacement as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::ItemPlacement::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::ItemPlacement::parse_block(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AlignItems,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_align_items();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ItemPlacement>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_align_items(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AlignItems)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-align/#propdef-justify-items
    pub mod justify_items {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::JustifyItems as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::JustifyItems as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::JustifyItems::legacy() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::JustifyItems as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::JustifyItems,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_justify_items();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::JustifyItems>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_justify_items(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::JustifyItems)
        }
    }



// Flex item properties

    
        
    
    /// https://drafts.csswg.org/css-flexbox/#flex-grow-property
    pub mod flex_grow {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeNumber as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeNumber as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { From::from(0.0) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::NonNegativeNumber as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FlexGrow,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_flex_grow();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::NonNegativeNumber>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_flex_grow(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FlexGrow)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-flexbox/#flex-shrink-property
    pub mod flex_shrink {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::NonNegativeNumber as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::NonNegativeNumber as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { From::from(1.0) }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::NonNegativeNumber as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FlexShrink,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_flex_shrink();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::NonNegativeNumber>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_flex_shrink(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::FlexShrink)
        }
    }



// https://drafts.csswg.org/css-align/#align-self-property

    
        
    
    /// https://drafts.csswg.org/css-align/#align-self-property
    pub mod align_self {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::SelfAlignment as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::SelfAlignment as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::SelfAlignment::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::SelfAlignment::parse_block(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AlignSelf,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_align_self();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::SelfAlignment>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_align_self(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AlignSelf)
        }
    }



    
        
    
    /// https://drafts.csswg.org/css-align/#justify-self-property
    pub mod justify_self {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::SelfAlignment as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::SelfAlignment as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::SelfAlignment::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::SelfAlignment::parse_inline(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::JustifySelf,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_justify_self();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::SelfAlignment>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_justify_self(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::JustifySelf)
        }
    }



// https://drafts.csswg.org/css-flexbox/#propdef-order

    
        
    
    /// https://drafts.csswg.org/css-flexbox/#order-property
    pub mod order {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Integer as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Integer as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { 0 }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Integer as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::Order,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_order();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Integer>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_order(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Order)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-flexbox/#flex-basis-property
    pub mod flex_basis {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::FlexBasis as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::FlexBasis as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::FlexBasis::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::FlexBasis as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::FlexBasis,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_flex_basis();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::FlexBasis>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_flex_basis(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::FlexBasis)
        }
    }



    
    // width, height, block-size, inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-height
    pub mod height {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Size::parse_size_for_width_or_height_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::Height.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_height();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::Height(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_height();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Size>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_height(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Height)
        }
    }


    // min-width, min-height, min-block-size, min-inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-height
    pub mod min_height {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Size::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MinHeight.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_min_height();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::MinHeight(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_min_height();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Size>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_min_height(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MinHeight)
        }
    }


    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-height
    pub mod max_height {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::MaxSize as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::MaxSize as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::MaxSize::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::MaxSize::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MaxHeight.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_max_height();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::MaxHeight(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_max_height();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::MaxSize>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_max_height(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MaxHeight)
        }
    }


    
    // width, height, block-size, inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-width
    pub mod width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Size::parse_size_for_width_or_height_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::Width.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_width();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::Width(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Size>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::Width)
        }
    }


    // min-width, min-height, min-block-size, min-inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-width
    pub mod min_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Size::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MinWidth.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_min_width();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::MinWidth(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_min_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Size>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_min_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MinWidth)
        }
    }


    
    
        
    
    /// https://drafts.csswg.org/css-box/#propdef-width
    pub mod max_width {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::MaxSize as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::MaxSize as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::MaxSize::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::MaxSize::parse_quirky(context, input, AllowQuirks::Yes)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap().logical_group(),
                LonghandId::MaxWidth.logical_group(),
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_max_width();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let decl = PropertyDeclaration::MaxWidth(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_max_width();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::MaxSize>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_max_width(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MaxWidth)
        }
    }


    
    // width, height, block-size, inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-block-size
    pub mod block_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Size::parse_size_for_width_or_height(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BlockSize)
        }
    }


    // min-width, min-height, min-block-size, min-inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-block-size
    pub mod min_block_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Size as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MinBlockSize)
        }
    }


    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-block-size
    pub mod max_block_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::MaxSize as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::MaxSize as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::MaxSize::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::MaxSize as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MaxBlockSize)
        }
    }


    
    // width, height, block-size, inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-inline-size
    pub mod inline_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Size::parse_size_for_width_or_height(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::InlineSize)
        }
    }


    // min-width, min-height, min-block-size, min-inline-size
    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-inline-size
    pub mod min_inline_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Size as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Size as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Size::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Size as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MinInlineSize)
        }
    }


    
    
        
    
    /// https://drafts.csswg.org/css-logical-props/#propdef-inline-size
    pub mod max_inline_size {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::MaxSize as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::MaxSize as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::MaxSize::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::MaxSize as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            declaration.debug_crash("Should physicalize before entering here");
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MaxInlineSize)
        }
    }




    
        
    



    
        
    
    /// https://drafts.csswg.org/css-anchor-position-1/#typedef-position-area
    pub mod position_area {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::PositionArea as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::PositionArea as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::PositionArea::none() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::PositionArea::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::PositionArea as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::PositionArea,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_position_area();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::PositionArea>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_position_area(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::PositionArea)
        }
    }




    
        
    



    
        
    



    
        
    



    

    
        
    
    /// https://drafts.csswg.org/css-ui/#propdef-box-sizing
    pub mod box_sizing {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            ContentBox,
            
            BorderBox,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::ContentBox
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::ContentBox
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::BoxSizing,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_box_sizing();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::box_sizing::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_box_sizing(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::BoxSizing)
        }
    }




    

    
        
    
    /// https://drafts.csswg.org/css-images/#propdef-object-fit
    pub mod object_fit {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Fill,
            
            Contain,
            
            Cover,
            
            None,
            
            ScaleDown,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Fill
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Fill
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ObjectFit,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_object_fit();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::object_fit::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_object_fit(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ObjectFit)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-images-3/#the-object-position
    pub mod object_position {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Position as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Position as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Position::center() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Position as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ObjectPosition,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                if !context.builder.effective_zoom_for_inheritance.is_one() {
                                    let old_zoom = context.builder.effective_zoom;
                                    context.builder.effective_zoom = context.builder.effective_zoom_for_inheritance;
                                    let computed = context.builder.inherited_style.clone_object_position();
                                    let specified = ToComputedValue::from_computed_value(&computed);
                                    let specified = Box::new(specified);
                                    let decl = PropertyDeclaration::ObjectPosition(specified);
                                    cascade_property(&decl, context);
                                    context.builder.effective_zoom = old_zoom;
                                    return;
                                }
                                context.builder.inherit_object_position();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::Position>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_object_position(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::ObjectPosition)
        }
    }



        
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-row-start
    pub mod grid_row_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridLine as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridLine as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridLine as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridRowStart,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_row_start();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridLine>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_row_start(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridRowStart)
        }
    }


        
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-row-end
    pub mod grid_row_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridLine as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridLine as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridLine as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridRowEnd,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_row_end();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridLine>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_row_end(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridRowEnd)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-auto-rows
    pub mod grid_auto_rows {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ImplicitGridTracks as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ImplicitGridTracks as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ImplicitGridTracks as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridAutoRows,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_auto_rows();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ImplicitGridTracks>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_auto_rows(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridAutoRows)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-template-rows
    pub mod grid_template_rows {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridTemplateComponent as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridTemplateComponent as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::GenericGridTemplateComponent::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridTemplateComponent as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridTemplateRows,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_template_rows();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridTemplateComponent>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_template_rows(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridTemplateRows)
        }
    }



        
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-column-start
    pub mod grid_column_start {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridLine as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridLine as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridLine as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridColumnStart,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_column_start();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridLine>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_column_start(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridColumnStart)
        }
    }


        
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-column-end
    pub mod grid_column_end {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridLine as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridLine as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridLine as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridColumnEnd,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_column_end();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridLine>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_column_end(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridColumnEnd)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-auto-columns
    pub mod grid_auto_columns {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ImplicitGridTracks as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ImplicitGridTracks as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { Default::default() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ImplicitGridTracks as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridAutoColumns,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_auto_columns();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ImplicitGridTracks>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_auto_columns(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridAutoColumns)
        }
    }



    
    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-template-columns
    pub mod grid_template_columns {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridTemplateComponent as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridTemplateComponent as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::GenericGridTemplateComponent::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridTemplateComponent as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridTemplateColumns,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_template_columns();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridTemplateComponent>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_template_columns(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridTemplateColumns)
        }
    }





    
        
    



    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-auto-flow
    pub mod grid_auto_flow {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridAutoFlow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridAutoFlow as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::GridAutoFlow::ROW }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridAutoFlow as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridAutoFlow,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_auto_flow();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridAutoFlow>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_auto_flow(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridAutoFlow)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-grid/#propdef-grid-template-areas
    pub mod grid_template_areas {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::GridTemplateAreas as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::GridTemplateAreas as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::GridTemplateAreas::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::GridTemplateAreas as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::GridTemplateAreas,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_grid_template_areas();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::GridTemplateAreas>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_grid_template_areas(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::GridTemplateAreas)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-align-3/#propdef-column-gap
    pub mod column_gap {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::length::NonNegativeLengthPercentageOrNormal as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::length::NonNegativeLengthPercentageOrNormal as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::length::NonNegativeLengthPercentageOrNormal::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::length::NonNegativeLengthPercentageOrNormal as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ColumnGap,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_column_gap();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_column_gap(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ColumnGap)
        }
    }



// no need for -moz- prefixed alias for this property

    
        
    
    /// https://drafts.csswg.org/css-align-3/#propdef-row-gap
    pub mod row_gap {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::length::NonNegativeLengthPercentageOrNormal as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::length::NonNegativeLengthPercentageOrNormal as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::length::NonNegativeLengthPercentageOrNormal::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::length::NonNegativeLengthPercentageOrNormal as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::RowGap,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_row_gap();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_row_gap(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::RowGap)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-sizing-4/#aspect-ratio
    pub mod aspect_ratio {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AspectRatio as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AspectRatio as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AspectRatio::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AspectRatio as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AspectRatio,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_aspect_ratio();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::AspectRatio>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_aspect_ratio(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AspectRatio)
        }
    }



    
    
        
    

    
    
        
    

    
    
        
    

    
    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    


// Section 14 - Gradients and Patterns


    
        
    



    
        
    


// Filter Effects Module


    
        
    



    
        
    



    
        
    


// CSS Masking Module Level 1
// https://drafts.fxtf.org/css-masking-1

    

    
        
    



    
        
    
    /// https://drafts.fxtf.org/css-masking-1/#propdef-clip-path
    pub mod clip_path {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::basic_shape::ClipPath as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::basic_shape::ClipPath as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { generics::basic_shape::ClipPath::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::basic_shape::ClipPath as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ClipPath,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_clip_path();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::basic_shape::ClipPath>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_clip_path(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ClipPath)
        }
    }




    

    
        
    
    




    
        
    
    



    
    
        
    
    


    
    
        
    
    




    

    
        
    
    




    

    
        
    
    




    
        
    
    




    

    
        
    
    




    
        
    
    
    /// https://drafts.fxtf.org/css-masking-1/#propdef-mask-image
    pub mod mask_image {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Image as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Image as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Image::None }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Image::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Image::parse_with_cors_anonymous(context, input)
        }
    
        
        }

        /// The definition of the computed value for mask-image.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of mask-image.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::MaskImage,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_mask_image();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::mask_image::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_mask_image(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::MaskImage)
        }
    }





    
        
    



    
        
    



    
        
    



    
        
    



    
        
    



    
        
    



    
        
    



    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    

    
        
    
    /// https://drafts.csswg.org/css-tables/#propdef-table-layout
    pub mod table_layout {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Auto,
            
            Fixed,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Auto
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Auto
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TableLayout,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_table_layout();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::table_layout::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_table_layout(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TableLayout)
        }
    }




    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
        
    
    /// https://drafts.csswg.org/css-ui/#propdef-text-overflow
    pub mod text_overflow {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TextOverflow as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TextOverflow as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TextOverflow::get_initial_value() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TextOverflow as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextOverflow,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_text_overflow();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<Box<crate::values::specified::TextOverflow>>()
                },
            };


                let computed = (**specified_value).to_computed_value(context);
                context.builder.set_text_overflow(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(Box::new)
                .map(PropertyDeclaration::TextOverflow)
        }
    }




    

    
        
    
    /// https://drafts.csswg.org/css-writing-modes/#propdef-unicode-bidi
    pub mod unicode_bidi {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Normal,
            
            Embed,
            
            Isolate,
            
            BidiOverride,
            
            IsolateOverride,
            
            Plaintext,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Normal
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Normal
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::UnicodeBidi,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_unicode_bidi();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::unicode_bidi::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_unicode_bidi(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::UnicodeBidi)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-text-decor/#propdef-text-decoration-line
    pub mod text_decoration_line {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TextDecorationLine as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TextDecorationLine as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { specified::TextDecorationLine::none() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::TextDecorationLine::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TextDecorationLine as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextDecorationLine,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_text_decoration_line();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::TextDecorationLine>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_decoration_line(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextDecorationLine)
        }
    }




    

    
        
    
    /// https://drafts.csswg.org/css-text-decor/#propdef-text-decoration-style
    pub mod text_decoration_style {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        pub use self::computed_value::T as SpecifiedValue;
        pub mod computed_value {
            #[cfg_attr(feature = "servo", derive(Deserialize, Hash, Serialize))]
            #[derive(Clone, Copy, Debug, Eq, FromPrimitive, MallocSizeOf, Parse, PartialEq, SpecifiedValueInfo, ToAnimatedValue, ToComputedValue, ToCss, ToResolvedValue, ToShmem, ToTyped)]
            pub enum T {
            
            Solid,
            
            Double,
            
            Dotted,
            
            Dashed,
            
            Wavy,
            
            MozNone,
            }
        }
        #[inline]
        pub fn get_initial_value() -> computed_value::T {
            computed_value::T::Solid
        }
        #[inline]
        pub fn get_initial_specified_value() -> SpecifiedValue {
            SpecifiedValue::Solid
        }
        #[inline]
        pub fn parse<'i, 't>(_context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<SpecifiedValue, ParseError<'i>> {
            SpecifiedValue::parse(input)
        }

    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextDecorationStyle,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_text_decoration_style();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::text_decoration_style::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_decoration_style(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextDecorationStyle)
        }
    }




    
        
    



    
        
    
    /// https://drafts.csswg.org/css-text-decor/#propdef-text-decoration-color
    pub mod text_decoration_color {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Color as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Color as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed_value::T::currentcolor() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Color::currentcolor() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Color as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TextDecorationColor,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_text_decoration_color();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::Color>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_text_decoration_color(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TextDecorationColor)
        }
    }




    
        
    



    
        
    


    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




// TODO spec says that UAs should not support this
// we should probably remove from gecko (https://bugzilla.mozilla.org/show_bug.cgi?id=1328331)

    

    
        
    



    

    
        
    



    
        
    



    

    
        
    


// TODO(emilio): Maybe make shadow behavior on macOS match Linux / Windows, and remove this? But
// that requires making -moz-window-input-region-margin work there...

    

    
        
    



    
        
    



    
        
    



    
        
    


// Hack to allow chrome to hide stuff only visually (without hiding it from a11y).

    
        
    


// TODO(emilio): Probably also should be hidden from content.

    
        
    





    
        
    
    
    /// https://drafts.csswg.org/css-transitions/#propdef-transition-duration
    pub mod transition_duration {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Time as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Time as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Time::zero() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Time::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            specified::Time::parse_non_negative(context, input)
        }
    
        
        }

        /// The definition of the computed value for transition-duration.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of transition-duration.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TransitionDuration,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transition_duration();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::transition_duration::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_transition_duration(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TransitionDuration)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-transitions/#propdef-transition-timing-function
    pub mod transition_timing_function {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TimingFunction as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TimingFunction as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TimingFunction::ease() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::TimingFunction::ease() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TimingFunction as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for transition-timing-function.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of transition-timing-function.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TransitionTimingFunction,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transition_timing_function();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::transition_timing_function::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_transition_timing_function(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TransitionTimingFunction)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-transitions/#propdef-transition-property
    pub mod transition_property {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TransitionProperty as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TransitionProperty as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TransitionProperty::all() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::TransitionProperty::all() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TransitionProperty as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for transition-property.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of transition-property.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[value_info(other_values = "none")]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;

            if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
                return Ok(SpecifiedValue(crate::OwnedSlice::from(vec![computed::TransitionProperty::none()])))
            }

            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TransitionProperty,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transition_property();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::transition_property::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_transition_property(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TransitionProperty)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-transitions/#propdef-transition-delay
    pub mod transition_delay {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Time as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Time as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Time::zero() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Time::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Time as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for transition-delay.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of transition-delay.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TransitionDelay,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transition_delay();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::transition_delay::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_transition_delay(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TransitionDelay)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-transitions-2/#transition-behavior-property
    pub mod transition_behavior {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TransitionBehavior as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TransitionBehavior as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TransitionBehavior::normal() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::TransitionBehavior::normal() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TransitionBehavior as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for transition-behavior.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of transition-behavior.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::TransitionBehavior,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_transition_behavior();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::transition_behavior::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_transition_behavior(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::TransitionBehavior)
        }
    }







    
        
    
    
    /// https://drafts.csswg.org/css-animations/#propdef-animation-name
    pub mod animation_name {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationName as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationName as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationName::none() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::AnimationName::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationName as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-name.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-name.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationName,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_name();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_name::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_name(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationName)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations-2/#animation-duration
    pub mod animation_duration {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationDuration as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationDuration as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationDuration::auto() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::AnimationDuration::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationDuration as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-duration.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-duration.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationDuration,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_duration();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_duration::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_duration(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationDuration)
        }
    }




// animation-timing-function is the exception to the rule for allowed_in_keyframe_block:
// https://drafts.csswg.org/css-animations/#keyframes

    
        
    
    
    /// https://drafts.csswg.org/css-transitions/#propdef-animation-timing-function
    pub mod animation_timing_function {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::TimingFunction as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::TimingFunction as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::TimingFunction::ease() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::TimingFunction::ease() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::TimingFunction as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-timing-function.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-timing-function.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationTimingFunction,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_timing_function();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_timing_function::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_timing_function(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationTimingFunction)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations/#propdef-animation-iteration-count
    pub mod animation_iteration_count {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationIterationCount as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationIterationCount as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationIterationCount::one() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::AnimationIterationCount::one() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationIterationCount as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-iteration-count.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-iteration-count.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationIterationCount,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_iteration_count();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_iteration_count::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_iteration_count(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationIterationCount)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations/#propdef-animation-direction
    pub mod animation_direction {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationDirection as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationDirection as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationDirection::Normal }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::AnimationDirection::Normal }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationDirection as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-direction.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-direction.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationDirection,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_direction();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_direction::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_direction(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationDirection)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations/#propdef-animation-play-state
    pub mod animation_play_state {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationPlayState as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationPlayState as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationPlayState::Running }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { computed::AnimationPlayState::Running }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationPlayState as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-play-state.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-play-state.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationPlayState,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_play_state();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_play_state::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_play_state(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationPlayState)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations/#propdef-animation-fill-mode
    pub mod animation_fill_mode {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationFillMode as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationFillMode as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationFillMode::None }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { computed::AnimationFillMode::None }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationFillMode as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-fill-mode.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-fill-mode.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationFillMode,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_fill_mode();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_fill_mode::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_fill_mode(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationFillMode)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations-2/#animation-composition
    pub mod animation_composition {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationComposition as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationComposition as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationComposition::Replace }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { computed::AnimationComposition::Replace }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationComposition as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-composition.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-composition.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationComposition,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_composition();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_composition::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_composition(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationComposition)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations/#propdef-animation-delay
    pub mod animation_delay {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::Time as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::Time as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::Time::zero() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::Time::zero() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::Time as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-delay.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-delay.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationDelay,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_delay();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_delay::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_delay(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationDelay)
        }
    }





    
        
    
    
    /// https://drafts.csswg.org/css-animations-2/#propdef-animation-timeline
    pub mod animation_timeline {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
        #[allow(unused_imports)]
        use smallvec::SmallVec;

        pub mod single_value {
            #[allow(unused_imports)]
            use cssparser::{Parser, BasicParseError};
            #[allow(unused_imports)]
            use crate::parser::{Parse, ParserContext};
            #[allow(unused_imports)]
            use crate::properties::ShorthandId;
            #[allow(unused_imports)]
            use selectors::parser::SelectorParseErrorKind;
            #[allow(unused_imports)]
            use style_traits::{ParseError, StyleParseErrorKind};
            #[allow(unused_imports)]
            use crate::values::computed::{Context, ToComputedValue};
            #[allow(unused_imports)]
            use crate::values::{computed, specified};
            
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::AnimationTimeline as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::AnimationTimeline as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::AnimationTimeline::auto() }
        #[inline] pub fn get_initial_specified_value() -> SpecifiedValue { specified::AnimationTimeline::auto() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::AnimationTimeline as crate::parser::Parse>::parse(context, input)
        }
    
        
        }

        /// The definition of the computed value for animation-timeline.
        pub mod computed_value {
            #[allow(unused_imports)]
            use crate::values::animated::ToAnimatedValue;
            #[allow(unused_imports)]
            use crate::values::resolved::ToResolvedValue;
            pub use super::single_value::computed_value as single_value;
            pub use self::single_value::T as SingleComputedValue;
            use smallvec::SmallVec;
            use crate::values::computed::ComputedVecIter;

            

            // FIXME(emilio): Add an OwnedNonEmptySlice type, and figure out
            // something for transition-name, which is the only remaining user
            // of NotInitial.
            pub type UnderlyingList<T> =
                    SmallVec<[T; 1]>;

            pub type UnderlyingOwnedList<T> =
                    SmallVec<[T; 1]>;


            /// The generic type defining the animated and resolved values for
            /// this property.
            ///
            /// Making this type generic allows the compiler to figure out the
            /// animated value for us, instead of having to implement it
            /// manually for every type we care about.
            #[derive(Clone, Debug, MallocSizeOf, PartialEq, ToAnimatedValue, ToResolvedValue, ToCss, ToTyped)]
            #[css(comma)]
            pub struct OwnedList<T>(
                #[css(iterable)]
                pub UnderlyingOwnedList<T>,
            );

            /// The computed value for this property.
            pub type ComputedList = OwnedList<single_value::T>;
            pub use self::OwnedList as List;



            /// The computed value, effectively a list of single values.
            pub use self::ComputedList as T;

            pub type Iter<'a, 'cx, 'cx_a> = ComputedVecIter<'a, 'cx, 'cx_a, super::single_value::SpecifiedValue>;
        }

        /// The specified value of animation-timeline.
        #[derive(Clone, Debug, MallocSizeOf, PartialEq, SpecifiedValueInfo, ToCss, ToShmem, ToTyped)]
        #[css(comma)]
        pub struct SpecifiedValue(
            #[css(iterable)]
            pub crate::OwnedSlice<single_value::SpecifiedValue>,
        );

        pub fn get_initial_value() -> computed_value::T {
                let mut v = SmallVec::new();
                v.push(single_value::get_initial_value());
                computed_value::List(v)
        }

        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            use style_traits::Separator;


            let v = style_traits::Comma::parse(input, |parser| {
                single_value::parse(context, parser)
            })?;
            Ok(SpecifiedValue(v.into()))
        }

        pub use self::single_value::SpecifiedValue as SingleSpecifiedValue;


        impl ToComputedValue for SpecifiedValue {
            type ComputedValue = computed_value::T;

            #[inline]
            fn to_computed_value(&self, context: &Context) -> computed_value::T {
                use std::iter::FromIterator;
                computed_value::List(computed_value::UnderlyingList::from_iter(
                    self.0.iter().map(|i| i.to_computed_value(context))
                ))
            }

            #[inline]
            fn from_computed_value(computed: &computed_value::T) -> Self {
                let iter = computed.0.iter().map(ToComputedValue::from_computed_value);
                SpecifiedValue(iter.collect())
            }
        }
    
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::AnimationTimeline,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_animation_timeline();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<longhands::animation_timeline::SpecifiedValue>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_animation_timeline(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::AnimationTimeline)
        }
    }





    
        
    
    




    
        
    
    




    
        
    
    




    
        
    
    




    
        
    
    




    

    
        
    



    
        
    
    /// https://drafts.csswg.org/css-view-transitions-1/#view-transition-name-prop
    pub mod view_transition_name {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ViewTransitionName as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ViewTransitionName as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ViewTransitionName::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ViewTransitionName as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ViewTransitionName,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_view_transition_name();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ViewTransitionName>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_view_transition_name(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ViewTransitionName)
        }
    }




    
        
    
    /// https://drafts.csswg.org/css-view-transitions-2/#view-transition-class-prop
    pub mod view_transition_class {
        #[allow(unused_imports)]
        use cssparser::{Parser, BasicParseError, Token};
        #[allow(unused_imports)]
        use crate::parser::{Parse, ParserContext};
        #[allow(unused_imports)]
        use crate::properties::{UnparsedValue, ShorthandId};
        #[allow(unused_imports)]
        use crate::error_reporting::ParseErrorReporter;
        #[allow(unused_imports)]
        use crate::properties::longhands;
        #[allow(unused_imports)]
        use crate::properties::{LonghandId, LonghandIdSet};
        #[allow(unused_imports)]
        use crate::properties::{CSSWideKeyword, ComputedValues, PropertyDeclaration};
        #[allow(unused_imports)]
        use crate::properties::style_structs;
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use servo_arc::Arc;
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use crate::values::computed::{Context, ToComputedValue};
        #[allow(unused_imports)]
        use crate::values::{computed, generics, specified};
        #[allow(unused_imports)]
        use crate::Atom;
        
            
        #[allow(unused_imports)]
        use app_units::Au;
        #[allow(unused_imports)]
        use crate::values::specified::AllowQuirks;
        #[allow(unused_imports)]
        use crate::Zero;
        #[allow(unused_imports)]
        use smallvec::SmallVec;
        pub use crate::values::specified::ViewTransitionClass as SpecifiedValue;
        pub mod computed_value {
            pub use crate::values::computed::ViewTransitionClass as T;
        }
        #[inline] pub fn get_initial_value() -> computed_value::T { computed::ViewTransitionClass::none() }
        #[allow(unused_variables)]
        #[inline]
        pub fn parse<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SpecifiedValue, ParseError<'i>> {
            <specified::ViewTransitionClass as crate::parser::Parse>::parse(context, input)
        }
    
        
        #[allow(unused_variables)]
        pub unsafe fn cascade_property(
            declaration: &PropertyDeclaration,
            context: &mut computed::Context,
        ) {
            context.for_non_inherited_property = true;
            debug_assert_eq!(
                declaration.id().as_longhand().unwrap(),
                LonghandId::ViewTransitionClass,
            );
            let specified_value = match *declaration {
                PropertyDeclaration::CSSWideKeyword(ref wk) => {
                    match wk.keyword {
                        CSSWideKeyword::Unset |
                        CSSWideKeyword::Initial => {
                                declaration.debug_crash("Unexpected initial or unset for non-inherited property");
                        },
                        CSSWideKeyword::Inherit => {
                                context.rule_cache_conditions.borrow_mut().set_uncacheable();
                                context.builder.inherit_view_transition_class();
                        }
                        CSSWideKeyword::RevertLayer |
                        CSSWideKeyword::Revert => {
                            declaration.debug_crash("Found revert/revert-layer not dealt with");
                        },
                    }
                    return;
                },
                #[cfg(debug_assertions)]
                PropertyDeclaration::WithVariables(..) => {
                    declaration.debug_crash("Found variables not substituted");
                    return;
                },
                _ => unsafe {
                    declaration.unchecked_value_as::<crate::values::specified::ViewTransitionClass>()
                },
            };


                let computed = specified_value.to_computed_value(context);
                context.builder.set_view_transition_class(computed)
        }

        pub fn parse_declared<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>> {
                parse(context, input)
                .map(PropertyDeclaration::ViewTransitionClass)
        }
    }



    
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    

    
        
    



    

    
        
    



    
        
    



    

    
        
    



    

    
        
    


// NOTE(heycam): Odd that the initial value is 1 yet 0 is a valid value. There
// are uses of `-moz-box-ordinal-group: 0` in the tree, too.

    
        
    


}




macro_rules! unwrap_or_initial {
    ($prop: ident) => (unwrap_or_initial!($prop, $prop));
    ($prop: ident, $expr: expr) =>
        ($expr.unwrap_or_else(|| $prop::get_initial_specified_value()));
}

/// A module with code for all the shorthand css properties, and a few
/// serialization helpers.
#[allow(missing_docs)]
pub mod shorthands {
    use cssparser::Parser;
    use crate::parser::{Parse, ParserContext};
    use style_traits::{ParseError, StyleParseErrorKind};
    use crate::values::specified;

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



// TODO: other background-* properties


    /// https://drafts.csswg.org/css-backgrounds/#the-background
    pub mod background {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub background_color:
                    longhands::background_color::SpecifiedValue
                    ,
                pub background_position_x:
                    longhands::background_position_x::SpecifiedValue
                    ,
                pub background_position_y:
                    longhands::background_position_y::SpecifiedValue
                    ,
                pub background_repeat:
                    longhands::background_repeat::SpecifiedValue
                    ,
                pub background_attachment:
                    longhands::background_attachment::SpecifiedValue
                    ,
                pub background_image:
                    longhands::background_image::SpecifiedValue
                    ,
                pub background_size:
                    longhands::background_size::SpecifiedValue
                    ,
                pub background_origin:
                    longhands::background_origin::SpecifiedValue
                    ,
                pub background_clip:
                    longhands::background_clip::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub background_color:
                    &'a longhands::background_color::SpecifiedValue,
                pub background_position_x:
                    &'a longhands::background_position_x::SpecifiedValue,
                pub background_position_y:
                    &'a longhands::background_position_y::SpecifiedValue,
                pub background_repeat:
                    &'a longhands::background_repeat::SpecifiedValue,
                pub background_attachment:
                    &'a longhands::background_attachment::SpecifiedValue,
                pub background_image:
                    &'a longhands::background_image::SpecifiedValue,
                pub background_size:
                    &'a longhands::background_size::SpecifiedValue,
                pub background_origin:
                    &'a longhands::background_origin::SpecifiedValue,
                pub background_clip:
                    &'a longhands::background_clip::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut background_color =
                        None::<&'a longhands::background_color::SpecifiedValue>;
                    let mut background_position_x =
                        None::<&'a longhands::background_position_x::SpecifiedValue>;
                    let mut background_position_y =
                        None::<&'a longhands::background_position_y::SpecifiedValue>;
                    let mut background_repeat =
                        None::<&'a longhands::background_repeat::SpecifiedValue>;
                    let mut background_attachment =
                        None::<&'a longhands::background_attachment::SpecifiedValue>;
                    let mut background_image =
                        None::<&'a longhands::background_image::SpecifiedValue>;
                    let mut background_size =
                        None::<&'a longhands::background_size::SpecifiedValue>;
                    let mut background_origin =
                        None::<&'a longhands::background_origin::SpecifiedValue>;
                    let mut background_clip =
                        None::<&'a longhands::background_clip::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BackgroundColor(ref value) => {
                                background_color = Some(value)
                            },
                            PropertyDeclaration::BackgroundPositionX(ref value) => {
                                background_position_x = Some(value)
                            },
                            PropertyDeclaration::BackgroundPositionY(ref value) => {
                                background_position_y = Some(value)
                            },
                            PropertyDeclaration::BackgroundRepeat(ref value) => {
                                background_repeat = Some(value)
                            },
                            PropertyDeclaration::BackgroundAttachment(ref value) => {
                                background_attachment = Some(value)
                            },
                            PropertyDeclaration::BackgroundImage(ref value) => {
                                background_image = Some(value)
                            },
                            PropertyDeclaration::BackgroundSize(ref value) => {
                                background_size = Some(value)
                            },
                            PropertyDeclaration::BackgroundOrigin(ref value) => {
                                background_origin = Some(value)
                            },
                            PropertyDeclaration::BackgroundClip(ref value) => {
                                background_clip = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        background_color,
                        background_position_x,
                        background_position_y,
                        background_repeat,
                        background_attachment,
                        background_image,
                        background_size,
                        background_origin,
                        background_clip,
                ) {

                    (
                        Some(background_color),
                        Some(background_position_x),
                        Some(background_position_y),
                        Some(background_repeat),
                        Some(background_attachment),
                        Some(background_image),
                        Some(background_size),
                        Some(background_origin),
                        Some(background_clip),
                    ) =>
                    Ok(LonghandsToSerialize {
                            background_color,
                            background_position_x,
                            background_position_y,
                            background_repeat,
                            background_attachment,
                            background_image,
                            background_size,
                            background_origin,
                            background_clip,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BackgroundColor(
                        longhands.background_color
                    ));
                    declarations.push(PropertyDeclaration::BackgroundPositionX(
                        longhands.background_position_x
                    ));
                    declarations.push(PropertyDeclaration::BackgroundPositionY(
                        longhands.background_position_y
                    ));
                    declarations.push(PropertyDeclaration::BackgroundRepeat(
                        longhands.background_repeat
                    ));
                    declarations.push(PropertyDeclaration::BackgroundAttachment(
                        longhands.background_attachment
                    ));
                    declarations.push(PropertyDeclaration::BackgroundImage(
                        longhands.background_image
                    ));
                    declarations.push(PropertyDeclaration::BackgroundSize(
                        longhands.background_size
                    ));
                    declarations.push(PropertyDeclaration::BackgroundOrigin(
                        longhands.background_origin
                    ));
                    declarations.push(PropertyDeclaration::BackgroundClip(
                        longhands.background_clip
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{background_position_x, background_position_y, background_repeat};
    use crate::properties::longhands::{background_attachment, background_color, background_image, background_size, background_origin};
    use crate::properties::longhands::background_clip;
    use crate::properties::longhands::background_clip::single_value::computed_value::T as Clip;
    use crate::properties::longhands::background_origin::single_value::computed_value::T as Origin;
    use crate::values::specified::{AllowQuirks, Color, Position, PositionComponent};
    use crate::parser::Parse;

    // FIXME(emilio): Should be the same type!
    impl From<background_origin::single_value::SpecifiedValue> for background_clip::single_value::SpecifiedValue {
        fn from(origin: background_origin::single_value::SpecifiedValue) ->
            background_clip::single_value::SpecifiedValue {
            match origin {
                background_origin::single_value::SpecifiedValue::ContentBox =>
                    background_clip::single_value::SpecifiedValue::ContentBox,
                background_origin::single_value::SpecifiedValue::PaddingBox =>
                    background_clip::single_value::SpecifiedValue::PaddingBox,
                background_origin::single_value::SpecifiedValue::BorderBox =>
                    background_clip::single_value::SpecifiedValue::BorderBox,
            }
        }
    }

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut background_color = None;

        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_image = Vec::with_capacity(1);
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_position_x = Vec::with_capacity(1);
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_position_y = Vec::with_capacity(1);
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_repeat = Vec::with_capacity(1);
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_size = Vec::with_capacity(1);
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_attachment = Vec::with_capacity(1);
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_origin = Vec::with_capacity(1);
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut background_clip = Vec::with_capacity(1);
        input.parse_comma_separated(|input| {
            // background-color can only be in the last element, so if it
            // is parsed anywhere before, the value is invalid.
            if background_color.is_some() {
                return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError));
            }

                let mut image = None;
                let mut position = None;
                let mut repeat = None;
                let mut size = None;
                let mut attachment = None;
                let mut origin = None;
                let mut clip = None;
            loop {
                if background_color.is_none() {
                    if let Ok(value) = input.try_parse(|i| Color::parse(context, i)) {
                        background_color = Some(value);
                        continue
                    }
                }
                if position.is_none() {
                    if let Ok(value) = input.try_parse(|input| {
                        Position::parse_three_value_quirky(context, input, AllowQuirks::No)
                    }) {
                        position = Some(value);

                        // Parse background size, if applicable.
                        size = input.try_parse(|input| {
                            input.expect_delim('/')?;
                            background_size::single_value::parse(context, input)
                        }).ok();

                        continue
                    }
                }
                    if image.is_none() {
                        if let Ok(value) = input.try_parse(|input| background_image::single_value
                                                                               ::parse(context, input)) {
                            image = Some(value);
                            continue
                        }
                    }
                    if repeat.is_none() {
                        if let Ok(value) = input.try_parse(|input| background_repeat::single_value
                                                                               ::parse(context, input)) {
                            repeat = Some(value);
                            continue
                        }
                    }
                    if attachment.is_none() {
                        if let Ok(value) = input.try_parse(|input| background_attachment::single_value
                                                                               ::parse(context, input)) {
                            attachment = Some(value);
                            continue
                        }
                    }
                    if origin.is_none() {
                        if let Ok(value) = input.try_parse(|input| background_origin::single_value
                                                                               ::parse(context, input)) {
                            origin = Some(value);
                            continue
                        }
                    }
                    if clip.is_none() {
                        if let Ok(value) = input.try_parse(|input| background_clip::single_value
                                                                               ::parse(context, input)) {
                            clip = Some(value);
                            continue
                        }
                    }
                break
            }
            if clip.is_none() {
                if let Some(origin) = origin {
                    clip = Some(background_clip::single_value::SpecifiedValue::from(origin));
                }
            }
            let mut any = false;
                any = any || image.is_some();
                any = any || position.is_some();
                any = any || repeat.is_some();
                any = any || size.is_some();
                any = any || attachment.is_some();
                any = any || origin.is_some();
                any = any || clip.is_some();
            any = any || background_color.is_some();
            if any {
                if let Some(position) = position {
                    background_position_x.push(position.horizontal);
                    background_position_y.push(position.vertical);
                } else {
                    background_position_x.push(PositionComponent::zero());
                    background_position_y.push(PositionComponent::zero());
                }
                    if let Some(bg_image) = image {
                        background_image.push(bg_image);
                    } else {
                        background_image.push(background_image::single_value
                                                                    ::get_initial_specified_value());
                    }
                    if let Some(bg_repeat) = repeat {
                        background_repeat.push(bg_repeat);
                    } else {
                        background_repeat.push(background_repeat::single_value
                                                                    ::get_initial_specified_value());
                    }
                    if let Some(bg_size) = size {
                        background_size.push(bg_size);
                    } else {
                        background_size.push(background_size::single_value
                                                                    ::get_initial_specified_value());
                    }
                    if let Some(bg_attachment) = attachment {
                        background_attachment.push(bg_attachment);
                    } else {
                        background_attachment.push(background_attachment::single_value
                                                                    ::get_initial_specified_value());
                    }
                    if let Some(bg_origin) = origin {
                        background_origin.push(bg_origin);
                    } else {
                        background_origin.push(background_origin::single_value
                                                                    ::get_initial_specified_value());
                    }
                    if let Some(bg_clip) = clip {
                        background_clip.push(bg_clip);
                    } else {
                        background_clip.push(background_clip::single_value
                                                                    ::get_initial_specified_value());
                    }
                Ok(())
            } else {
                Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
            }
        })?;

        Ok(expanded! {
             background_color: background_color.unwrap_or(Color::transparent()),
             background_image: background_image::SpecifiedValue(background_image.into()),
             background_position_x: background_position_x::SpecifiedValue(background_position_x.into()),
             background_position_y: background_position_y::SpecifiedValue(background_position_y.into()),
             background_repeat: background_repeat::SpecifiedValue(background_repeat.into()),
             background_size: background_size::SpecifiedValue(background_size.into()),
             background_attachment: background_attachment::SpecifiedValue(background_attachment.into()),
             background_origin: background_origin::SpecifiedValue(background_origin.into()),
             background_clip: background_clip::SpecifiedValue(background_clip.into()),
         })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let len = self.background_image.0.len();
            // There should be at least one declared value
            if len == 0 {
                return Ok(());
            }

            // If a value list length is differs then we don't do a shorthand serialization.
            // The exceptions to this is color which appears once only and is serialized
            // with the last item.
                if len != self.background_image.0.len() {
                    return Ok(());
                }
                if len != self.background_position_x.0.len() {
                    return Ok(());
                }
                if len != self.background_position_y.0.len() {
                    return Ok(());
                }
                if len != self.background_size.0.len() {
                    return Ok(());
                }
                if len != self.background_repeat.0.len() {
                    return Ok(());
                }
                if len != self.background_origin.0.len() {
                    return Ok(());
                }
                if len != self.background_clip.0.len() {
                    return Ok(());
                }
                if len != self.background_attachment.0.len() {
                    return Ok(());
                }

            for i in 0..len {
                    let image = &self.background_image.0[i];
                    let position_x = &self.background_position_x.0[i];
                    let position_y = &self.background_position_y.0[i];
                    let repeat = &self.background_repeat.0[i];
                    let size = &self.background_size.0[i];
                    let attachment = &self.background_attachment.0[i];
                    let origin = &self.background_origin.0[i];
                    let clip = &self.background_clip.0[i];

                if i != 0 {
                    dest.write_str(", ")?;
                }

                let mut wrote_value = false;

                if i == len - 1 {
                    if *self.background_color != background_color::get_initial_specified_value() {
                        self.background_color.to_css(dest)?;
                        wrote_value = true;
                    }
                }

                if *image != background_image::single_value::get_initial_specified_value() {
                    if wrote_value {
                        dest.write_char(' ')?;
                    }
                    image.to_css(dest)?;
                    wrote_value = true;
                }

                // Size is only valid after a position so when there is a
                // non-initial size we must also serialize position
                if *position_x != PositionComponent::zero() ||
                    *position_y != PositionComponent::zero() ||
                    *size != background_size::single_value::get_initial_specified_value()
                {
                    if wrote_value {
                        dest.write_char(' ')?;
                    }

                    Position {
                        horizontal: position_x.clone(),
                        vertical: position_y.clone()
                    }.to_css(dest)?;

                    wrote_value = true;

                    if *size != background_size::single_value::get_initial_specified_value() {
                        dest.write_str(" / ")?;
                        size.to_css(dest)?;
                    }
                }

                    if *repeat != background_repeat::single_value::get_initial_specified_value() {
                        if wrote_value {
                            dest.write_char(' ')?;
                        }
                        repeat.to_css(dest)?;
                        wrote_value = true;
                    }
                    if *attachment != background_attachment::single_value::get_initial_specified_value() {
                        if wrote_value {
                            dest.write_char(' ')?;
                        }
                        attachment.to_css(dest)?;
                        wrote_value = true;
                    }

                if *origin != Origin::PaddingBox || *clip != Clip::BorderBox {
                    if wrote_value {
                        dest.write_char(' ')?;
                    }
                    origin.to_css(dest)?;
                    if *clip != From::from(*origin) {
                        dest.write_char(' ')?;
                        clip.to_css(dest)?;
                    }

                    wrote_value = true;
                }

                if !wrote_value {
                    image.to_css(dest)?;
                }
            }

            Ok(())
        }
    }

    }




    /// https://drafts.csswg.org/css-backgrounds-4/#the-background-position
    pub mod background_position {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub background_position_x:
                    longhands::background_position_x::SpecifiedValue
                    ,
                pub background_position_y:
                    longhands::background_position_y::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub background_position_x:
                    &'a longhands::background_position_x::SpecifiedValue,
                pub background_position_y:
                    &'a longhands::background_position_y::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut background_position_x =
                        None::<&'a longhands::background_position_x::SpecifiedValue>;
                    let mut background_position_y =
                        None::<&'a longhands::background_position_y::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BackgroundPositionX(ref value) => {
                                background_position_x = Some(value)
                            },
                            PropertyDeclaration::BackgroundPositionY(ref value) => {
                                background_position_y = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        background_position_x,
                        background_position_y,
                ) {

                    (
                        Some(background_position_x),
                        Some(background_position_y),
                    ) =>
                    Ok(LonghandsToSerialize {
                            background_position_x,
                            background_position_y,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BackgroundPositionX(
                        longhands.background_position_x
                    ));
                    declarations.push(PropertyDeclaration::BackgroundPositionY(
                        longhands.background_position_y
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{background_position_x, background_position_y};
    use crate::values::specified::AllowQuirks;
    use crate::values::specified::position::Position;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        // Vec grows from 0 to 4 by default on first push().  So allocate with
        // capacity 1, so in the common case of only one item we don't way
        // overallocate, then shrink.  Note that we always push at least one
        // item if parsing succeeds.
        let mut position_x = Vec::with_capacity(1);
        let mut position_y = Vec::with_capacity(1);
        let mut any = false;

        input.parse_comma_separated(|input| {
            let value = Position::parse_three_value_quirky(context, input, AllowQuirks::Yes)?;
            position_x.push(value.horizontal);
            position_y.push(value.vertical);
            any = true;
            Ok(())
        })?;
        if !any {
            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError));
        }

        Ok(expanded! {
            background_position_x: background_position_x::SpecifiedValue(position_x.into()),
            background_position_y: background_position_y::SpecifiedValue(position_y.into()),
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let len = self.background_position_x.0.len();
            if len == 0 || len != self.background_position_y.0.len() {
                return Ok(());
            }
            for i in 0..len {
                Position {
                    horizontal: self.background_position_x.0[i].clone(),
                    vertical: self.background_position_y.0[i].clone()
                }.to_css(dest)?;

                if i < len - 1 {
                    dest.write_str(", ")?;
                }
            }
            Ok(())
        }
    }

    }


    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    
    

    /// https://drafts.csswg.org/css-backgrounds/#border-color
    pub mod border_color {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_top_color:
                    longhands::border_top_color::SpecifiedValue
                    ,
                pub border_right_color:
                    longhands::border_right_color::SpecifiedValue
                    ,
                pub border_bottom_color:
                    longhands::border_bottom_color::SpecifiedValue
                    ,
                pub border_left_color:
                    longhands::border_left_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_top_color:
                    &'a longhands::border_top_color::SpecifiedValue,
                pub border_right_color:
                    &'a longhands::border_right_color::SpecifiedValue,
                pub border_bottom_color:
                    &'a longhands::border_bottom_color::SpecifiedValue,
                pub border_left_color:
                    &'a longhands::border_left_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_top_color =
                        None::<&'a longhands::border_top_color::SpecifiedValue>;
                    let mut border_right_color =
                        None::<&'a longhands::border_right_color::SpecifiedValue>;
                    let mut border_bottom_color =
                        None::<&'a longhands::border_bottom_color::SpecifiedValue>;
                    let mut border_left_color =
                        None::<&'a longhands::border_left_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderTopColor(ref value) => {
                                border_top_color = Some(value)
                            },
                            PropertyDeclaration::BorderRightColor(ref value) => {
                                border_right_color = Some(value)
                            },
                            PropertyDeclaration::BorderBottomColor(ref value) => {
                                border_bottom_color = Some(value)
                            },
                            PropertyDeclaration::BorderLeftColor(ref value) => {
                                border_left_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_top_color,
                        border_right_color,
                        border_bottom_color,
                        border_left_color,
                ) {

                    (
                        Some(border_top_color),
                        Some(border_right_color),
                        Some(border_bottom_color),
                        Some(border_left_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_top_color,
                            border_right_color,
                            border_bottom_color,
                            border_left_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderTopColor(
                        longhands.border_top_color
                    ));
                    declarations.push(PropertyDeclaration::BorderRightColor(
                        longhands.border_right_color
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomColor(
                        longhands.border_bottom_color
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftColor(
                        longhands.border_left_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
        #[allow(unused_imports)]
        use crate::parser::Parse;
        use crate::values::generics::rect::Rect;
        #[allow(unused_imports)]
        use crate::values::specified;

        fn parse_value<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<Longhands, ParseError<'i>> {
            let rect = Rect::parse_with(context, input, |c, i| -> Result<
                crate::properties::longhands::border_top_color::SpecifiedValue,
                ParseError<'i>
            > {
                specified::Color::parse_quirky(c, i, specified::AllowQuirks::Yes)
            })?;
            Ok(expanded! {
                    border_top_color: rect.0,
                    border_right_color: rect.1,
                    border_bottom_color: rect.2,
                    border_left_color: rect.3,
            })
        }

        impl<'a> ToCss for LonghandsToSerialize<'a> {
            fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result
            where
                W: Write,
            {
                let rect = Rect::new(
                    &self.border_top_color,
                    &self.border_right_color,
                    &self.border_bottom_color,
                    &self.border_left_color,
                );
                rect.to_css(dest)
            }
        }
    
    }




    
    

    /// https://drafts.csswg.org/css-backgrounds/#border-style
    pub mod border_style {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_top_style:
                    longhands::border_top_style::SpecifiedValue
                    ,
                pub border_right_style:
                    longhands::border_right_style::SpecifiedValue
                    ,
                pub border_bottom_style:
                    longhands::border_bottom_style::SpecifiedValue
                    ,
                pub border_left_style:
                    longhands::border_left_style::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_top_style:
                    &'a longhands::border_top_style::SpecifiedValue,
                pub border_right_style:
                    &'a longhands::border_right_style::SpecifiedValue,
                pub border_bottom_style:
                    &'a longhands::border_bottom_style::SpecifiedValue,
                pub border_left_style:
                    &'a longhands::border_left_style::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_top_style =
                        None::<&'a longhands::border_top_style::SpecifiedValue>;
                    let mut border_right_style =
                        None::<&'a longhands::border_right_style::SpecifiedValue>;
                    let mut border_bottom_style =
                        None::<&'a longhands::border_bottom_style::SpecifiedValue>;
                    let mut border_left_style =
                        None::<&'a longhands::border_left_style::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderTopStyle(ref value) => {
                                border_top_style = Some(value)
                            },
                            PropertyDeclaration::BorderRightStyle(ref value) => {
                                border_right_style = Some(value)
                            },
                            PropertyDeclaration::BorderBottomStyle(ref value) => {
                                border_bottom_style = Some(value)
                            },
                            PropertyDeclaration::BorderLeftStyle(ref value) => {
                                border_left_style = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_top_style,
                        border_right_style,
                        border_bottom_style,
                        border_left_style,
                ) {

                    (
                        Some(border_top_style),
                        Some(border_right_style),
                        Some(border_bottom_style),
                        Some(border_left_style),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_top_style,
                            border_right_style,
                            border_bottom_style,
                            border_left_style,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderTopStyle(
                        longhands.border_top_style
                    ));
                    declarations.push(PropertyDeclaration::BorderRightStyle(
                        longhands.border_right_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomStyle(
                        longhands.border_bottom_style
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftStyle(
                        longhands.border_left_style
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
        #[allow(unused_imports)]
        use crate::parser::Parse;
        use crate::values::generics::rect::Rect;
        #[allow(unused_imports)]
        use crate::values::specified;

        fn parse_value<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<Longhands, ParseError<'i>> {
            let rect = Rect::parse_with(context, input, |c, i| -> Result<
                crate::properties::longhands::border_top_style::SpecifiedValue,
                ParseError<'i>
            > {
                crate::parser::Parse::parse(c, i)
            })?;
            Ok(expanded! {
                    border_top_style: rect.0,
                    border_right_style: rect.1,
                    border_bottom_style: rect.2,
                    border_left_style: rect.3,
            })
        }

        impl<'a> ToCss for LonghandsToSerialize<'a> {
            fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result
            where
                W: Write,
            {
                let rect = Rect::new(
                    &self.border_top_style,
                    &self.border_right_style,
                    &self.border_bottom_style,
                    &self.border_left_style,
                );
                rect.to_css(dest)
            }
        }
    
    }





    /// https://drafts.csswg.org/css-backgrounds/#border-width
    pub mod border_width {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_top_width:
                    longhands::border_top_width::SpecifiedValue
                    ,
                pub border_right_width:
                    longhands::border_right_width::SpecifiedValue
                    ,
                pub border_bottom_width:
                    longhands::border_bottom_width::SpecifiedValue
                    ,
                pub border_left_width:
                    longhands::border_left_width::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_top_width:
                    &'a longhands::border_top_width::SpecifiedValue,
                pub border_right_width:
                    &'a longhands::border_right_width::SpecifiedValue,
                pub border_bottom_width:
                    &'a longhands::border_bottom_width::SpecifiedValue,
                pub border_left_width:
                    &'a longhands::border_left_width::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_top_width =
                        None::<&'a longhands::border_top_width::SpecifiedValue>;
                    let mut border_right_width =
                        None::<&'a longhands::border_right_width::SpecifiedValue>;
                    let mut border_bottom_width =
                        None::<&'a longhands::border_bottom_width::SpecifiedValue>;
                    let mut border_left_width =
                        None::<&'a longhands::border_left_width::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderTopWidth(ref value) => {
                                border_top_width = Some(value)
                            },
                            PropertyDeclaration::BorderRightWidth(ref value) => {
                                border_right_width = Some(value)
                            },
                            PropertyDeclaration::BorderBottomWidth(ref value) => {
                                border_bottom_width = Some(value)
                            },
                            PropertyDeclaration::BorderLeftWidth(ref value) => {
                                border_left_width = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_top_width,
                        border_right_width,
                        border_bottom_width,
                        border_left_width,
                ) {

                    (
                        Some(border_top_width),
                        Some(border_right_width),
                        Some(border_bottom_width),
                        Some(border_left_width),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_top_width,
                            border_right_width,
                            border_bottom_width,
                            border_left_width,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderTopWidth(
                        longhands.border_top_width
                    ));
                    declarations.push(PropertyDeclaration::BorderRightWidth(
                        longhands.border_right_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomWidth(
                        longhands.border_bottom_width
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftWidth(
                        longhands.border_left_width
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::generics::rect::Rect;
    use crate::values::specified::{AllowQuirks, BorderSideWidth};

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let rect = Rect::parse_with(context, input, |_, i| {
            BorderSideWidth::parse_quirky(context, i, AllowQuirks::Yes)
        })?;
        Ok(expanded! {
            border_top_width: rect.0,
            border_right_width: rect.1,
            border_bottom_width: rect.2,
            border_left_width: rect.3,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let top = &self.border_top_width;
            let right = &self.border_right_width;
            let bottom = &self.border_bottom_width;
            let left = &self.border_left_width;
            Rect::new(top, right, bottom, left).to_css(dest)
        }
    }

    }



pub fn parse_border<'i, 't>(
    context: &ParserContext,
    input: &mut Parser<'i, 't>,
) -> Result<(specified::Color, specified::BorderStyle, specified::BorderSideWidth), ParseError<'i>> {
    use crate::values::specified::{Color, BorderStyle, BorderSideWidth};
    let _unused = context;
    let mut color = None;
    let mut style = None;
    let mut width = None;
    let mut any = false;
    loop {
        if width.is_none() {
            if let Ok(value) = input.try_parse(|i| BorderSideWidth::parse(context, i)) {
                width = Some(value);
                any = true;
            }
        }
        if style.is_none() {
            if let Ok(value) = input.try_parse(BorderStyle::parse) {
                style = Some(value);
                any = true;
                continue
            }
        }
        if color.is_none() {
            if let Ok(value) = input.try_parse(|i| Color::parse(context, i)) {
                color = Some(value);
                any = true;
                continue
            }
        }
        break
    }
    if !any {
        return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
    }
    Ok((color.unwrap_or(Color::CurrentColor), style.unwrap_or(BorderStyle::None), width.unwrap_or(BorderSideWidth::medium())))
}

    
    

    /// https://drafts.csswg.org/css-backgrounds/#border-top
    pub mod border_top {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_top_width:
                    longhands::border_top_width::SpecifiedValue
                    ,
                pub border_top_style:
                    longhands::border_top_style::SpecifiedValue
                    ,
                pub border_top_color:
                    longhands::border_top_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_top_width:
                    &'a longhands::border_top_width::SpecifiedValue,
                pub border_top_style:
                    &'a longhands::border_top_style::SpecifiedValue,
                pub border_top_color:
                    &'a longhands::border_top_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_top_width =
                        None::<&'a longhands::border_top_width::SpecifiedValue>;
                    let mut border_top_style =
                        None::<&'a longhands::border_top_style::SpecifiedValue>;
                    let mut border_top_color =
                        None::<&'a longhands::border_top_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderTopWidth(ref value) => {
                                border_top_width = Some(value)
                            },
                            PropertyDeclaration::BorderTopStyle(ref value) => {
                                border_top_style = Some(value)
                            },
                            PropertyDeclaration::BorderTopColor(ref value) => {
                                border_top_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_top_width,
                        border_top_style,
                        border_top_color,
                ) {

                    (
                        Some(border_top_width),
                        Some(border_top_style),
                        Some(border_top_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_top_width,
                            border_top_style,
                            border_top_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderTopWidth(
                        longhands.border_top_width
                    ));
                    declarations.push(PropertyDeclaration::BorderTopStyle(
                        longhands.border_top_style
                    ));
                    declarations.push(PropertyDeclaration::BorderTopColor(
                        longhands.border_top_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_top_color: color,
            border_top_style: style,
            border_top_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_top_width,
                self.border_top_style,
                self.border_top_color
            )
        }
    }

    
    }

    
    

    /// https://drafts.csswg.org/css-backgrounds/#border-right
    pub mod border_right {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_right_width:
                    longhands::border_right_width::SpecifiedValue
                    ,
                pub border_right_style:
                    longhands::border_right_style::SpecifiedValue
                    ,
                pub border_right_color:
                    longhands::border_right_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_right_width:
                    &'a longhands::border_right_width::SpecifiedValue,
                pub border_right_style:
                    &'a longhands::border_right_style::SpecifiedValue,
                pub border_right_color:
                    &'a longhands::border_right_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_right_width =
                        None::<&'a longhands::border_right_width::SpecifiedValue>;
                    let mut border_right_style =
                        None::<&'a longhands::border_right_style::SpecifiedValue>;
                    let mut border_right_color =
                        None::<&'a longhands::border_right_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderRightWidth(ref value) => {
                                border_right_width = Some(value)
                            },
                            PropertyDeclaration::BorderRightStyle(ref value) => {
                                border_right_style = Some(value)
                            },
                            PropertyDeclaration::BorderRightColor(ref value) => {
                                border_right_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_right_width,
                        border_right_style,
                        border_right_color,
                ) {

                    (
                        Some(border_right_width),
                        Some(border_right_style),
                        Some(border_right_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_right_width,
                            border_right_style,
                            border_right_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderRightWidth(
                        longhands.border_right_width
                    ));
                    declarations.push(PropertyDeclaration::BorderRightStyle(
                        longhands.border_right_style
                    ));
                    declarations.push(PropertyDeclaration::BorderRightColor(
                        longhands.border_right_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_right_color: color,
            border_right_style: style,
            border_right_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_right_width,
                self.border_right_style,
                self.border_right_color
            )
        }
    }

    
    }

    
    

    /// https://drafts.csswg.org/css-backgrounds/#border-bottom
    pub mod border_bottom {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_bottom_width:
                    longhands::border_bottom_width::SpecifiedValue
                    ,
                pub border_bottom_style:
                    longhands::border_bottom_style::SpecifiedValue
                    ,
                pub border_bottom_color:
                    longhands::border_bottom_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_bottom_width:
                    &'a longhands::border_bottom_width::SpecifiedValue,
                pub border_bottom_style:
                    &'a longhands::border_bottom_style::SpecifiedValue,
                pub border_bottom_color:
                    &'a longhands::border_bottom_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_bottom_width =
                        None::<&'a longhands::border_bottom_width::SpecifiedValue>;
                    let mut border_bottom_style =
                        None::<&'a longhands::border_bottom_style::SpecifiedValue>;
                    let mut border_bottom_color =
                        None::<&'a longhands::border_bottom_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderBottomWidth(ref value) => {
                                border_bottom_width = Some(value)
                            },
                            PropertyDeclaration::BorderBottomStyle(ref value) => {
                                border_bottom_style = Some(value)
                            },
                            PropertyDeclaration::BorderBottomColor(ref value) => {
                                border_bottom_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_bottom_width,
                        border_bottom_style,
                        border_bottom_color,
                ) {

                    (
                        Some(border_bottom_width),
                        Some(border_bottom_style),
                        Some(border_bottom_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_bottom_width,
                            border_bottom_style,
                            border_bottom_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderBottomWidth(
                        longhands.border_bottom_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomStyle(
                        longhands.border_bottom_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomColor(
                        longhands.border_bottom_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_bottom_color: color,
            border_bottom_style: style,
            border_bottom_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_bottom_width,
                self.border_bottom_style,
                self.border_bottom_color
            )
        }
    }

    
    }

    
    

    /// https://drafts.csswg.org/css-backgrounds/#border-left
    pub mod border_left {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_left_width:
                    longhands::border_left_width::SpecifiedValue
                    ,
                pub border_left_style:
                    longhands::border_left_style::SpecifiedValue
                    ,
                pub border_left_color:
                    longhands::border_left_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_left_width:
                    &'a longhands::border_left_width::SpecifiedValue,
                pub border_left_style:
                    &'a longhands::border_left_style::SpecifiedValue,
                pub border_left_color:
                    &'a longhands::border_left_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_left_width =
                        None::<&'a longhands::border_left_width::SpecifiedValue>;
                    let mut border_left_style =
                        None::<&'a longhands::border_left_style::SpecifiedValue>;
                    let mut border_left_color =
                        None::<&'a longhands::border_left_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderLeftWidth(ref value) => {
                                border_left_width = Some(value)
                            },
                            PropertyDeclaration::BorderLeftStyle(ref value) => {
                                border_left_style = Some(value)
                            },
                            PropertyDeclaration::BorderLeftColor(ref value) => {
                                border_left_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_left_width,
                        border_left_style,
                        border_left_color,
                ) {

                    (
                        Some(border_left_width),
                        Some(border_left_style),
                        Some(border_left_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_left_width,
                            border_left_style,
                            border_left_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderLeftWidth(
                        longhands.border_left_width
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftStyle(
                        longhands.border_left_style
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftColor(
                        longhands.border_left_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_left_color: color,
            border_left_style: style,
            border_left_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_left_width,
                self.border_left_style,
                self.border_left_color
            )
        }
    }

    
    }

    
    

    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-start
    pub mod border_block_start {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_block_start_width:
                    longhands::border_block_start_width::SpecifiedValue
                    ,
                pub border_block_start_style:
                    longhands::border_block_start_style::SpecifiedValue
                    ,
                pub border_block_start_color:
                    longhands::border_block_start_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_block_start_width:
                    &'a longhands::border_block_start_width::SpecifiedValue,
                pub border_block_start_style:
                    &'a longhands::border_block_start_style::SpecifiedValue,
                pub border_block_start_color:
                    &'a longhands::border_block_start_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_block_start_width =
                        None::<&'a longhands::border_block_start_width::SpecifiedValue>;
                    let mut border_block_start_style =
                        None::<&'a longhands::border_block_start_style::SpecifiedValue>;
                    let mut border_block_start_color =
                        None::<&'a longhands::border_block_start_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderBlockStartWidth(ref value) => {
                                border_block_start_width = Some(value)
                            },
                            PropertyDeclaration::BorderBlockStartStyle(ref value) => {
                                border_block_start_style = Some(value)
                            },
                            PropertyDeclaration::BorderBlockStartColor(ref value) => {
                                border_block_start_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_block_start_width,
                        border_block_start_style,
                        border_block_start_color,
                ) {

                    (
                        Some(border_block_start_width),
                        Some(border_block_start_style),
                        Some(border_block_start_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_block_start_width,
                            border_block_start_style,
                            border_block_start_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderBlockStartWidth(
                        longhands.border_block_start_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockStartStyle(
                        longhands.border_block_start_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockStartColor(
                        longhands.border_block_start_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_block_start_color: color,
            border_block_start_style: style,
            border_block_start_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_block_start_width,
                self.border_block_start_style,
                self.border_block_start_color
            )
        }
    }

    
    }

    
    

    /// https://drafts.csswg.org/css-logical-props/#propdef-border-block-end
    pub mod border_block_end {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_block_end_width:
                    longhands::border_block_end_width::SpecifiedValue
                    ,
                pub border_block_end_style:
                    longhands::border_block_end_style::SpecifiedValue
                    ,
                pub border_block_end_color:
                    longhands::border_block_end_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_block_end_width:
                    &'a longhands::border_block_end_width::SpecifiedValue,
                pub border_block_end_style:
                    &'a longhands::border_block_end_style::SpecifiedValue,
                pub border_block_end_color:
                    &'a longhands::border_block_end_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_block_end_width =
                        None::<&'a longhands::border_block_end_width::SpecifiedValue>;
                    let mut border_block_end_style =
                        None::<&'a longhands::border_block_end_style::SpecifiedValue>;
                    let mut border_block_end_color =
                        None::<&'a longhands::border_block_end_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderBlockEndWidth(ref value) => {
                                border_block_end_width = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndStyle(ref value) => {
                                border_block_end_style = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndColor(ref value) => {
                                border_block_end_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_block_end_width,
                        border_block_end_style,
                        border_block_end_color,
                ) {

                    (
                        Some(border_block_end_width),
                        Some(border_block_end_style),
                        Some(border_block_end_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_block_end_width,
                            border_block_end_style,
                            border_block_end_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderBlockEndWidth(
                        longhands.border_block_end_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndStyle(
                        longhands.border_block_end_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndColor(
                        longhands.border_block_end_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_block_end_color: color,
            border_block_end_style: style,
            border_block_end_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_block_end_width,
                self.border_block_end_style,
                self.border_block_end_color
            )
        }
    }

    
    }

    
    

    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-start
    pub mod border_inline_start {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_inline_start_width:
                    longhands::border_inline_start_width::SpecifiedValue
                    ,
                pub border_inline_start_style:
                    longhands::border_inline_start_style::SpecifiedValue
                    ,
                pub border_inline_start_color:
                    longhands::border_inline_start_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_inline_start_width:
                    &'a longhands::border_inline_start_width::SpecifiedValue,
                pub border_inline_start_style:
                    &'a longhands::border_inline_start_style::SpecifiedValue,
                pub border_inline_start_color:
                    &'a longhands::border_inline_start_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_inline_start_width =
                        None::<&'a longhands::border_inline_start_width::SpecifiedValue>;
                    let mut border_inline_start_style =
                        None::<&'a longhands::border_inline_start_style::SpecifiedValue>;
                    let mut border_inline_start_color =
                        None::<&'a longhands::border_inline_start_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderInlineStartWidth(ref value) => {
                                border_inline_start_width = Some(value)
                            },
                            PropertyDeclaration::BorderInlineStartStyle(ref value) => {
                                border_inline_start_style = Some(value)
                            },
                            PropertyDeclaration::BorderInlineStartColor(ref value) => {
                                border_inline_start_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_inline_start_width,
                        border_inline_start_style,
                        border_inline_start_color,
                ) {

                    (
                        Some(border_inline_start_width),
                        Some(border_inline_start_style),
                        Some(border_inline_start_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_inline_start_width,
                            border_inline_start_style,
                            border_inline_start_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderInlineStartWidth(
                        longhands.border_inline_start_width
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineStartStyle(
                        longhands.border_inline_start_style
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineStartColor(
                        longhands.border_inline_start_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_inline_start_color: color,
            border_inline_start_style: style,
            border_inline_start_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_inline_start_width,
                self.border_inline_start_style,
                self.border_inline_start_color
            )
        }
    }

    
    }

    
    

    /// https://drafts.csswg.org/css-logical-props/#propdef-border-inline-end
    pub mod border_inline_end {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_inline_end_width:
                    longhands::border_inline_end_width::SpecifiedValue
                    ,
                pub border_inline_end_style:
                    longhands::border_inline_end_style::SpecifiedValue
                    ,
                pub border_inline_end_color:
                    longhands::border_inline_end_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_inline_end_width:
                    &'a longhands::border_inline_end_width::SpecifiedValue,
                pub border_inline_end_style:
                    &'a longhands::border_inline_end_style::SpecifiedValue,
                pub border_inline_end_color:
                    &'a longhands::border_inline_end_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_inline_end_width =
                        None::<&'a longhands::border_inline_end_width::SpecifiedValue>;
                    let mut border_inline_end_style =
                        None::<&'a longhands::border_inline_end_style::SpecifiedValue>;
                    let mut border_inline_end_color =
                        None::<&'a longhands::border_inline_end_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderInlineEndWidth(ref value) => {
                                border_inline_end_width = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndStyle(ref value) => {
                                border_inline_end_style = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndColor(ref value) => {
                                border_inline_end_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_inline_end_width,
                        border_inline_end_style,
                        border_inline_end_color,
                ) {

                    (
                        Some(border_inline_end_width),
                        Some(border_inline_end_style),
                        Some(border_inline_end_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_inline_end_width,
                            border_inline_end_style,
                            border_inline_end_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderInlineEndWidth(
                        longhands.border_inline_end_width
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndStyle(
                        longhands.border_inline_end_style
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndColor(
                        longhands.border_inline_end_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
            border_inline_end_color: color,
            border_inline_end_style: style,
            border_inline_end_width: width
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_inline_end_width,
                self.border_inline_end_style,
                self.border_inline_end_color
            )
        }
    }

    
    }




    /// https://drafts.csswg.org/css-backgrounds/#border
    pub mod border {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        pub struct Longhands {
                pub border_top_width:
                    longhands::border_top_width::SpecifiedValue
                    ,
                pub border_top_style:
                    longhands::border_top_style::SpecifiedValue
                    ,
                pub border_top_color:
                    longhands::border_top_color::SpecifiedValue
                    ,
                pub border_right_width:
                    longhands::border_right_width::SpecifiedValue
                    ,
                pub border_right_style:
                    longhands::border_right_style::SpecifiedValue
                    ,
                pub border_right_color:
                    longhands::border_right_color::SpecifiedValue
                    ,
                pub border_bottom_width:
                    longhands::border_bottom_width::SpecifiedValue
                    ,
                pub border_bottom_style:
                    longhands::border_bottom_style::SpecifiedValue
                    ,
                pub border_bottom_color:
                    longhands::border_bottom_color::SpecifiedValue
                    ,
                pub border_left_width:
                    longhands::border_left_width::SpecifiedValue
                    ,
                pub border_left_style:
                    longhands::border_left_style::SpecifiedValue
                    ,
                pub border_left_color:
                    longhands::border_left_color::SpecifiedValue
                    ,
                pub border_image_outset:
                        Box<
                    longhands::border_image_outset::SpecifiedValue
                        >
                    ,
                pub border_image_repeat:
                    longhands::border_image_repeat::SpecifiedValue
                    ,
                pub border_image_slice:
                        Box<
                    longhands::border_image_slice::SpecifiedValue
                        >
                    ,
                pub border_image_source:
                    longhands::border_image_source::SpecifiedValue
                    ,
                pub border_image_width:
                        Box<
                    longhands::border_image_width::SpecifiedValue
                        >
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_top_width:
                    &'a longhands::border_top_width::SpecifiedValue,
                pub border_top_style:
                    &'a longhands::border_top_style::SpecifiedValue,
                pub border_top_color:
                    &'a longhands::border_top_color::SpecifiedValue,
                pub border_right_width:
                    &'a longhands::border_right_width::SpecifiedValue,
                pub border_right_style:
                    &'a longhands::border_right_style::SpecifiedValue,
                pub border_right_color:
                    &'a longhands::border_right_color::SpecifiedValue,
                pub border_bottom_width:
                    &'a longhands::border_bottom_width::SpecifiedValue,
                pub border_bottom_style:
                    &'a longhands::border_bottom_style::SpecifiedValue,
                pub border_bottom_color:
                    &'a longhands::border_bottom_color::SpecifiedValue,
                pub border_left_width:
                    &'a longhands::border_left_width::SpecifiedValue,
                pub border_left_style:
                    &'a longhands::border_left_style::SpecifiedValue,
                pub border_left_color:
                    &'a longhands::border_left_color::SpecifiedValue,
                pub border_image_outset:
                    &'a longhands::border_image_outset::SpecifiedValue,
                pub border_image_repeat:
                    &'a longhands::border_image_repeat::SpecifiedValue,
                pub border_image_slice:
                    &'a longhands::border_image_slice::SpecifiedValue,
                pub border_image_source:
                    &'a longhands::border_image_source::SpecifiedValue,
                pub border_image_width:
                    &'a longhands::border_image_width::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_top_width =
                        None::<&'a longhands::border_top_width::SpecifiedValue>;
                    let mut border_top_style =
                        None::<&'a longhands::border_top_style::SpecifiedValue>;
                    let mut border_top_color =
                        None::<&'a longhands::border_top_color::SpecifiedValue>;
                    let mut border_right_width =
                        None::<&'a longhands::border_right_width::SpecifiedValue>;
                    let mut border_right_style =
                        None::<&'a longhands::border_right_style::SpecifiedValue>;
                    let mut border_right_color =
                        None::<&'a longhands::border_right_color::SpecifiedValue>;
                    let mut border_bottom_width =
                        None::<&'a longhands::border_bottom_width::SpecifiedValue>;
                    let mut border_bottom_style =
                        None::<&'a longhands::border_bottom_style::SpecifiedValue>;
                    let mut border_bottom_color =
                        None::<&'a longhands::border_bottom_color::SpecifiedValue>;
                    let mut border_left_width =
                        None::<&'a longhands::border_left_width::SpecifiedValue>;
                    let mut border_left_style =
                        None::<&'a longhands::border_left_style::SpecifiedValue>;
                    let mut border_left_color =
                        None::<&'a longhands::border_left_color::SpecifiedValue>;
                    let mut border_image_outset =
                        None::<&'a longhands::border_image_outset::SpecifiedValue>;
                    let mut border_image_repeat =
                        None::<&'a longhands::border_image_repeat::SpecifiedValue>;
                    let mut border_image_slice =
                        None::<&'a longhands::border_image_slice::SpecifiedValue>;
                    let mut border_image_source =
                        None::<&'a longhands::border_image_source::SpecifiedValue>;
                    let mut border_image_width =
                        None::<&'a longhands::border_image_width::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderTopWidth(ref value) => {
                                border_top_width = Some(value)
                            },
                            PropertyDeclaration::BorderTopStyle(ref value) => {
                                border_top_style = Some(value)
                            },
                            PropertyDeclaration::BorderTopColor(ref value) => {
                                border_top_color = Some(value)
                            },
                            PropertyDeclaration::BorderRightWidth(ref value) => {
                                border_right_width = Some(value)
                            },
                            PropertyDeclaration::BorderRightStyle(ref value) => {
                                border_right_style = Some(value)
                            },
                            PropertyDeclaration::BorderRightColor(ref value) => {
                                border_right_color = Some(value)
                            },
                            PropertyDeclaration::BorderBottomWidth(ref value) => {
                                border_bottom_width = Some(value)
                            },
                            PropertyDeclaration::BorderBottomStyle(ref value) => {
                                border_bottom_style = Some(value)
                            },
                            PropertyDeclaration::BorderBottomColor(ref value) => {
                                border_bottom_color = Some(value)
                            },
                            PropertyDeclaration::BorderLeftWidth(ref value) => {
                                border_left_width = Some(value)
                            },
                            PropertyDeclaration::BorderLeftStyle(ref value) => {
                                border_left_style = Some(value)
                            },
                            PropertyDeclaration::BorderLeftColor(ref value) => {
                                border_left_color = Some(value)
                            },
                            PropertyDeclaration::BorderImageOutset(ref value) => {
                                border_image_outset = Some(value)
                            },
                            PropertyDeclaration::BorderImageRepeat(ref value) => {
                                border_image_repeat = Some(value)
                            },
                            PropertyDeclaration::BorderImageSlice(ref value) => {
                                border_image_slice = Some(value)
                            },
                            PropertyDeclaration::BorderImageSource(ref value) => {
                                border_image_source = Some(value)
                            },
                            PropertyDeclaration::BorderImageWidth(ref value) => {
                                border_image_width = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_top_width,
                        border_top_style,
                        border_top_color,
                        border_right_width,
                        border_right_style,
                        border_right_color,
                        border_bottom_width,
                        border_bottom_style,
                        border_bottom_color,
                        border_left_width,
                        border_left_style,
                        border_left_color,
                        border_image_outset,
                        border_image_repeat,
                        border_image_slice,
                        border_image_source,
                        border_image_width,
                ) {

                    (
                        Some(border_top_width),
                        Some(border_top_style),
                        Some(border_top_color),
                        Some(border_right_width),
                        Some(border_right_style),
                        Some(border_right_color),
                        Some(border_bottom_width),
                        Some(border_bottom_style),
                        Some(border_bottom_color),
                        Some(border_left_width),
                        Some(border_left_style),
                        Some(border_left_color),
                        Some(border_image_outset),
                        Some(border_image_repeat),
                        Some(border_image_slice),
                        Some(border_image_source),
                        Some(border_image_width),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_top_width,
                            border_top_style,
                            border_top_color,
                            border_right_width,
                            border_right_style,
                            border_right_color,
                            border_bottom_width,
                            border_bottom_style,
                            border_bottom_color,
                            border_left_width,
                            border_left_style,
                            border_left_color,
                            border_image_outset,
                            border_image_repeat,
                            border_image_slice,
                            border_image_source,
                            border_image_width,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderTopWidth(
                        longhands.border_top_width
                    ));
                    declarations.push(PropertyDeclaration::BorderTopStyle(
                        longhands.border_top_style
                    ));
                    declarations.push(PropertyDeclaration::BorderTopColor(
                        longhands.border_top_color
                    ));
                    declarations.push(PropertyDeclaration::BorderRightWidth(
                        longhands.border_right_width
                    ));
                    declarations.push(PropertyDeclaration::BorderRightStyle(
                        longhands.border_right_style
                    ));
                    declarations.push(PropertyDeclaration::BorderRightColor(
                        longhands.border_right_color
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomWidth(
                        longhands.border_bottom_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomStyle(
                        longhands.border_bottom_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomColor(
                        longhands.border_bottom_color
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftWidth(
                        longhands.border_left_width
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftStyle(
                        longhands.border_left_style
                    ));
                    declarations.push(PropertyDeclaration::BorderLeftColor(
                        longhands.border_left_color
                    ));
                    declarations.push(PropertyDeclaration::BorderImageOutset(
                        longhands.border_image_outset
                    ));
                    declarations.push(PropertyDeclaration::BorderImageRepeat(
                        longhands.border_image_repeat
                    ));
                    declarations.push(PropertyDeclaration::BorderImageSlice(
                        longhands.border_image_slice
                    ));
                    declarations.push(PropertyDeclaration::BorderImageSource(
                        longhands.border_image_source
                    ));
                    declarations.push(PropertyDeclaration::BorderImageWidth(
                        longhands.border_image_width
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        use crate::properties::longhands::{border_image_outset, border_image_repeat, border_image_slice};
        use crate::properties::longhands::{border_image_source, border_image_width};

        let (color, style, width) = super::parse_border(context, input)?;
        Ok(expanded! {
                border_top_color: color.clone(),
                border_top_style: style,
                border_top_width: width.clone(),
                border_right_color: color.clone(),
                border_right_style: style,
                border_right_width: width.clone(),
                border_bottom_color: color.clone(),
                border_bottom_style: style,
                border_bottom_width: width.clone(),
                border_left_color: color.clone(),
                border_left_style: style,
                border_left_width: width.clone(),

            // The border shorthand resets border-image to its initial value.
            // See https://drafts.csswg.org/css-backgrounds-3/#the-border-shorthands
                border_image_outset: border_image_outset::get_initial_specified_value(),
                border_image_repeat: border_image_repeat::get_initial_specified_value(),
                border_image_slice: border_image_slice::get_initial_specified_value(),
                border_image_source: border_image_source::get_initial_specified_value(),
                border_image_width: border_image_width::get_initial_specified_value(),
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            use crate::properties::longhands;

            // If any of the border-image longhands differ from their initial specified values we should not
            // invoke serialize_directional_border(), so there is no point in continuing on to compute all_equal.
                if *self.border_image_outset != longhands::border_image_outset::get_initial_specified_value() {
                    return Ok(());
                }
                if *self.border_image_repeat != longhands::border_image_repeat::get_initial_specified_value() {
                    return Ok(());
                }
                if *self.border_image_slice != longhands::border_image_slice::get_initial_specified_value() {
                    return Ok(());
                }
                if *self.border_image_source != longhands::border_image_source::get_initial_specified_value() {
                    return Ok(());
                }
                if *self.border_image_width != longhands::border_image_width::get_initial_specified_value() {
                    return Ok(());
                }

            let all_equal = {
                  let border_top_width = self.border_top_width;
                  let border_top_style = self.border_top_style;
                  let border_top_color = self.border_top_color;
                  let border_right_width = self.border_right_width;
                  let border_right_style = self.border_right_style;
                  let border_right_color = self.border_right_color;
                  let border_bottom_width = self.border_bottom_width;
                  let border_bottom_style = self.border_bottom_style;
                  let border_bottom_color = self.border_bottom_color;
                  let border_left_width = self.border_left_width;
                  let border_left_style = self.border_left_style;
                  let border_left_color = self.border_left_color;

                border_top_width == border_right_width &&
                border_right_width == border_bottom_width &&
                border_bottom_width == border_left_width &&

                border_top_style == border_right_style &&
                border_right_style == border_bottom_style &&
                border_bottom_style == border_left_style &&

                border_top_color == border_right_color &&
                border_right_color == border_bottom_color &&
                border_bottom_color == border_left_color
            };

            // If all longhands are all present, then all sides should be the same,
            // so we can just one set of color/style/width
            if !all_equal {
                return Ok(())
            }
            crate::values::specified::border::serialize_directional_border(
                dest,
                self.border_left_width,
                self.border_left_style,
                self.border_left_color
            )
        }
    }

    // Just use the same as border-left. The border shorthand can't accept
    // any value that the sub-shorthand couldn't.
    
    impl SpecifiedValueInfo for Longhands {
        const SUPPORTED_TYPES: u8 = <crate::properties::shorthands::border_left::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES;
        fn collect_completion_keywords(f: KeywordsCollectFn) {
            <crate::properties::shorthands::border_left::Longhands as SpecifiedValueInfo>::collect_completion_keywords(f);
        }
    }

    }




    /// https://drafts.csswg.org/css-backgrounds/#border-radius
    pub mod border_radius {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_top_left_radius:
                        Box<
                    longhands::border_top_left_radius::SpecifiedValue
                        >
                    ,
                pub border_top_right_radius:
                        Box<
                    longhands::border_top_right_radius::SpecifiedValue
                        >
                    ,
                pub border_bottom_right_radius:
                        Box<
                    longhands::border_bottom_right_radius::SpecifiedValue
                        >
                    ,
                pub border_bottom_left_radius:
                        Box<
                    longhands::border_bottom_left_radius::SpecifiedValue
                        >
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_top_left_radius:
                    &'a longhands::border_top_left_radius::SpecifiedValue,
                pub border_top_right_radius:
                    &'a longhands::border_top_right_radius::SpecifiedValue,
                pub border_bottom_right_radius:
                    &'a longhands::border_bottom_right_radius::SpecifiedValue,
                pub border_bottom_left_radius:
                    &'a longhands::border_bottom_left_radius::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_top_left_radius =
                        None::<&'a longhands::border_top_left_radius::SpecifiedValue>;
                    let mut border_top_right_radius =
                        None::<&'a longhands::border_top_right_radius::SpecifiedValue>;
                    let mut border_bottom_right_radius =
                        None::<&'a longhands::border_bottom_right_radius::SpecifiedValue>;
                    let mut border_bottom_left_radius =
                        None::<&'a longhands::border_bottom_left_radius::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderTopLeftRadius(ref value) => {
                                border_top_left_radius = Some(value)
                            },
                            PropertyDeclaration::BorderTopRightRadius(ref value) => {
                                border_top_right_radius = Some(value)
                            },
                            PropertyDeclaration::BorderBottomRightRadius(ref value) => {
                                border_bottom_right_radius = Some(value)
                            },
                            PropertyDeclaration::BorderBottomLeftRadius(ref value) => {
                                border_bottom_left_radius = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_top_left_radius,
                        border_top_right_radius,
                        border_bottom_right_radius,
                        border_bottom_left_radius,
                ) {

                    (
                        Some(border_top_left_radius),
                        Some(border_top_right_radius),
                        Some(border_bottom_right_radius),
                        Some(border_bottom_left_radius),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_top_left_radius,
                            border_top_right_radius,
                            border_bottom_right_radius,
                            border_bottom_left_radius,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderTopLeftRadius(
                        longhands.border_top_left_radius
                    ));
                    declarations.push(PropertyDeclaration::BorderTopRightRadius(
                        longhands.border_top_right_radius
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomRightRadius(
                        longhands.border_bottom_right_radius
                    ));
                    declarations.push(PropertyDeclaration::BorderBottomLeftRadius(
                        longhands.border_bottom_left_radius
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::generics::rect::Rect;
    use crate::values::generics::border::BorderCornerRadius;
    use crate::values::specified::border::BorderRadius;
    use crate::parser::Parse;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let radii = BorderRadius::parse(context, input)?;
        Ok(expanded! {
            border_top_left_radius: radii.top_left,
            border_top_right_radius: radii.top_right,
            border_bottom_right_radius: radii.bottom_right,
            border_bottom_left_radius: radii.bottom_left,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let LonghandsToSerialize {
                border_top_left_radius: &BorderCornerRadius(ref tl),
                border_top_right_radius: &BorderCornerRadius(ref tr),
                border_bottom_right_radius: &BorderCornerRadius(ref br),
                border_bottom_left_radius: &BorderCornerRadius(ref bl),
            } = *self;


            let widths = Rect::new(tl.width(), tr.width(), br.width(), bl.width());
            let heights = Rect::new(tl.height(), tr.height(), br.height(), bl.height());

            BorderRadius::serialize_rects(widths, heights, dest)
        }
    }

    }




    /// https://drafts.csswg.org/css-backgrounds-3/#border-image
    pub mod border_image {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_image_outset:
                        Box<
                    longhands::border_image_outset::SpecifiedValue
                        >
                    ,
                pub border_image_repeat:
                    longhands::border_image_repeat::SpecifiedValue
                    ,
                pub border_image_slice:
                        Box<
                    longhands::border_image_slice::SpecifiedValue
                        >
                    ,
                pub border_image_source:
                    longhands::border_image_source::SpecifiedValue
                    ,
                pub border_image_width:
                        Box<
                    longhands::border_image_width::SpecifiedValue
                        >
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_image_outset:
                    &'a longhands::border_image_outset::SpecifiedValue,
                pub border_image_repeat:
                    &'a longhands::border_image_repeat::SpecifiedValue,
                pub border_image_slice:
                    &'a longhands::border_image_slice::SpecifiedValue,
                pub border_image_source:
                    &'a longhands::border_image_source::SpecifiedValue,
                pub border_image_width:
                    &'a longhands::border_image_width::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_image_outset =
                        None::<&'a longhands::border_image_outset::SpecifiedValue>;
                    let mut border_image_repeat =
                        None::<&'a longhands::border_image_repeat::SpecifiedValue>;
                    let mut border_image_slice =
                        None::<&'a longhands::border_image_slice::SpecifiedValue>;
                    let mut border_image_source =
                        None::<&'a longhands::border_image_source::SpecifiedValue>;
                    let mut border_image_width =
                        None::<&'a longhands::border_image_width::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderImageOutset(ref value) => {
                                border_image_outset = Some(value)
                            },
                            PropertyDeclaration::BorderImageRepeat(ref value) => {
                                border_image_repeat = Some(value)
                            },
                            PropertyDeclaration::BorderImageSlice(ref value) => {
                                border_image_slice = Some(value)
                            },
                            PropertyDeclaration::BorderImageSource(ref value) => {
                                border_image_source = Some(value)
                            },
                            PropertyDeclaration::BorderImageWidth(ref value) => {
                                border_image_width = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_image_outset,
                        border_image_repeat,
                        border_image_slice,
                        border_image_source,
                        border_image_width,
                ) {

                    (
                        Some(border_image_outset),
                        Some(border_image_repeat),
                        Some(border_image_slice),
                        Some(border_image_source),
                        Some(border_image_width),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_image_outset,
                            border_image_repeat,
                            border_image_slice,
                            border_image_source,
                            border_image_width,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderImageOutset(
                        longhands.border_image_outset
                    ));
                    declarations.push(PropertyDeclaration::BorderImageRepeat(
                        longhands.border_image_repeat
                    ));
                    declarations.push(PropertyDeclaration::BorderImageSlice(
                        longhands.border_image_slice
                    ));
                    declarations.push(PropertyDeclaration::BorderImageSource(
                        longhands.border_image_source
                    ));
                    declarations.push(PropertyDeclaration::BorderImageWidth(
                        longhands.border_image_width
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{border_image_outset, border_image_repeat, border_image_slice};
    use crate::properties::longhands::{border_image_source, border_image_width};

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut outset = border_image_outset::get_initial_specified_value();
        let mut repeat = border_image_repeat::get_initial_specified_value();
        let mut slice = border_image_slice::get_initial_specified_value();
        let mut source = border_image_source::get_initial_specified_value();
        let mut width = border_image_width::get_initial_specified_value();
        let mut any = false;
        let mut parsed_slice = false;
        let mut parsed_source = false;
        let mut parsed_repeat = false;
        loop {
            if !parsed_slice {
                if let Ok(value) = input.try_parse(|input| border_image_slice::parse(context, input)) {
                    parsed_slice = true;
                    any = true;
                    slice = value;
                    // Parse border image width and outset, if applicable.
                    let maybe_width_outset: Result<_, ParseError> = input.try_parse(|input| {
                        input.expect_delim('/')?;

                        // Parse border image width, if applicable.
                        let w = input.try_parse(|input| border_image_width::parse(context, input)).ok();

                        // Parse border image outset if applicable.
                        let o = input.try_parse(|input| {
                            input.expect_delim('/')?;
                            border_image_outset::parse(context, input)
                        }).ok();
                        if w.is_none() && o.is_none() {
                            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
                        }
                        Ok((w, o))
                    });
                    if let Ok((w, o)) = maybe_width_outset {
                        if let Some(w) = w {
                            width = w;
                        }
                        if let Some(o) = o {
                            outset = o;
                        }
                    }
                    continue;
                }
            }
                if !parsed_source {
                    if let Ok(value) = input.try_parse(|input| border_image_source::parse(context, input)) {
                        source = value;
                        parsed_source = true;
                        any = true;
                        continue
                    }
                }
                if !parsed_repeat {
                    if let Ok(value) = input.try_parse(|input| border_image_repeat::parse(context, input)) {
                        repeat = value;
                        parsed_repeat = true;
                        any = true;
                        continue
                    }
                }
            break
        }
        if !any {
            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        }
        Ok(expanded! {
                border_image_outset: outset,
                border_image_repeat: repeat,
                border_image_slice: slice,
                border_image_source: source,
                border_image_width: width,
         })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let mut has_any = false;
            let has_source = *self.border_image_source != border_image_source::get_initial_specified_value();
            has_any = has_any || has_source;
            let has_slice = *self.border_image_slice != border_image_slice::get_initial_specified_value();
            has_any = has_any || has_slice;
            let has_outset = *self.border_image_outset != border_image_outset::get_initial_specified_value();
            has_any = has_any || has_outset;
            let has_width = *self.border_image_width != border_image_width::get_initial_specified_value();
            has_any = has_any || has_width;
            let has_repeat = *self.border_image_repeat != border_image_repeat::get_initial_specified_value();
            has_any = has_any || has_repeat;
            if has_source || !has_any {
                self.border_image_source.to_css(dest)?;
                if !has_any {
                    return Ok(());
                }
            }
            let needs_slice = has_slice || has_width || has_outset;
            if needs_slice {
                if has_source {
                    dest.write_char(' ')?;
                }
                self.border_image_slice.to_css(dest)?;
                if has_width || has_outset {
                    dest.write_str(" /")?;
                    if has_width {
                        dest.write_char(' ')?;
                        self.border_image_width.to_css(dest)?;
                    }
                    if has_outset {
                        dest.write_str(" / ")?;
                        self.border_image_outset.to_css(dest)?;
                    }
                }
            }
            if has_repeat {
                if has_source || needs_slice {
                    dest.write_char(' ')?;
                }
                self.border_image_repeat.to_css(dest)?;
            }
            Ok(())
        }
    }

    }


        
        

    /// https://drafts.csswg.org/css-logical/#propdef-border-block-width
    pub mod border_block_width {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_block_start_width:
                    longhands::border_block_start_width::SpecifiedValue
                    ,
                pub border_block_end_width:
                    longhands::border_block_end_width::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_block_start_width:
                    &'a longhands::border_block_start_width::SpecifiedValue,
                pub border_block_end_width:
                    &'a longhands::border_block_end_width::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_block_start_width =
                        None::<&'a longhands::border_block_start_width::SpecifiedValue>;
                    let mut border_block_end_width =
                        None::<&'a longhands::border_block_end_width::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderBlockStartWidth(ref value) => {
                                border_block_start_width = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndWidth(ref value) => {
                                border_block_end_width = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_block_start_width,
                        border_block_end_width,
                ) {

                    (
                        Some(border_block_start_width),
                        Some(border_block_end_width),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_block_start_width,
                            border_block_end_width,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderBlockStartWidth(
                        longhands.border_block_start_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndWidth(
                        longhands.border_block_end_width
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

            use crate::properties::longhands::border_block_start_width;
            pub fn parse_value<'i, 't>(
                context: &ParserContext,
                input: &mut Parser<'i, 't>,
            ) -> Result<Longhands, ParseError<'i>> {
                let start_value = border_block_start_width::parse(context, input)?;
                let end_value =
                    input.try_parse(|input| border_block_start_width::parse(context, input))
                        .unwrap_or_else(|_| start_value.clone());

                Ok(expanded! {
                    border_block_start_width: start_value,
                    border_block_end_width: end_value,
                })
            }

            impl<'a> ToCss for LonghandsToSerialize<'a>  {
                fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                    self.border_block_start_width.to_css(dest)?;

                    if self.border_block_end_width != self.border_block_start_width {
                        dest.write_char(' ')?;
                        self.border_block_end_width.to_css(dest)?;
                    }

                    Ok(())
                }
            }
        
    }

        
        

    /// https://drafts.csswg.org/css-logical/#propdef-border-block-style
    pub mod border_block_style {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_block_start_style:
                    longhands::border_block_start_style::SpecifiedValue
                    ,
                pub border_block_end_style:
                    longhands::border_block_end_style::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_block_start_style:
                    &'a longhands::border_block_start_style::SpecifiedValue,
                pub border_block_end_style:
                    &'a longhands::border_block_end_style::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_block_start_style =
                        None::<&'a longhands::border_block_start_style::SpecifiedValue>;
                    let mut border_block_end_style =
                        None::<&'a longhands::border_block_end_style::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderBlockStartStyle(ref value) => {
                                border_block_start_style = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndStyle(ref value) => {
                                border_block_end_style = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_block_start_style,
                        border_block_end_style,
                ) {

                    (
                        Some(border_block_start_style),
                        Some(border_block_end_style),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_block_start_style,
                            border_block_end_style,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderBlockStartStyle(
                        longhands.border_block_start_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndStyle(
                        longhands.border_block_end_style
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

            use crate::properties::longhands::border_block_start_style;
            pub fn parse_value<'i, 't>(
                context: &ParserContext,
                input: &mut Parser<'i, 't>,
            ) -> Result<Longhands, ParseError<'i>> {
                let start_value = border_block_start_style::parse(context, input)?;
                let end_value =
                    input.try_parse(|input| border_block_start_style::parse(context, input))
                        .unwrap_or_else(|_| start_value.clone());

                Ok(expanded! {
                    border_block_start_style: start_value,
                    border_block_end_style: end_value,
                })
            }

            impl<'a> ToCss for LonghandsToSerialize<'a>  {
                fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                    self.border_block_start_style.to_css(dest)?;

                    if self.border_block_end_style != self.border_block_start_style {
                        dest.write_char(' ')?;
                        self.border_block_end_style.to_css(dest)?;
                    }

                    Ok(())
                }
            }
        
    }

        
        

    /// https://drafts.csswg.org/css-logical/#propdef-border-block-color
    pub mod border_block_color {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_block_start_color:
                    longhands::border_block_start_color::SpecifiedValue
                    ,
                pub border_block_end_color:
                    longhands::border_block_end_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_block_start_color:
                    &'a longhands::border_block_start_color::SpecifiedValue,
                pub border_block_end_color:
                    &'a longhands::border_block_end_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_block_start_color =
                        None::<&'a longhands::border_block_start_color::SpecifiedValue>;
                    let mut border_block_end_color =
                        None::<&'a longhands::border_block_end_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderBlockStartColor(ref value) => {
                                border_block_start_color = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndColor(ref value) => {
                                border_block_end_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_block_start_color,
                        border_block_end_color,
                ) {

                    (
                        Some(border_block_start_color),
                        Some(border_block_end_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_block_start_color,
                            border_block_end_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderBlockStartColor(
                        longhands.border_block_start_color
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndColor(
                        longhands.border_block_end_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

            use crate::properties::longhands::border_block_start_color;
            pub fn parse_value<'i, 't>(
                context: &ParserContext,
                input: &mut Parser<'i, 't>,
            ) -> Result<Longhands, ParseError<'i>> {
                let start_value = border_block_start_color::parse(context, input)?;
                let end_value =
                    input.try_parse(|input| border_block_start_color::parse(context, input))
                        .unwrap_or_else(|_| start_value.clone());

                Ok(expanded! {
                    border_block_start_color: start_value,
                    border_block_end_color: end_value,
                })
            }

            impl<'a> ToCss for LonghandsToSerialize<'a>  {
                fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                    self.border_block_start_color.to_css(dest)?;

                    if self.border_block_end_color != self.border_block_start_color {
                        dest.write_char(' ')?;
                        self.border_block_end_color.to_css(dest)?;
                    }

                    Ok(())
                }
            }
        
    }

        
        

    /// https://drafts.csswg.org/css-logical/#propdef-border-inline-width
    pub mod border_inline_width {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_inline_start_width:
                    longhands::border_inline_start_width::SpecifiedValue
                    ,
                pub border_inline_end_width:
                    longhands::border_inline_end_width::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_inline_start_width:
                    &'a longhands::border_inline_start_width::SpecifiedValue,
                pub border_inline_end_width:
                    &'a longhands::border_inline_end_width::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_inline_start_width =
                        None::<&'a longhands::border_inline_start_width::SpecifiedValue>;
                    let mut border_inline_end_width =
                        None::<&'a longhands::border_inline_end_width::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderInlineStartWidth(ref value) => {
                                border_inline_start_width = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndWidth(ref value) => {
                                border_inline_end_width = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_inline_start_width,
                        border_inline_end_width,
                ) {

                    (
                        Some(border_inline_start_width),
                        Some(border_inline_end_width),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_inline_start_width,
                            border_inline_end_width,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderInlineStartWidth(
                        longhands.border_inline_start_width
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndWidth(
                        longhands.border_inline_end_width
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

            use crate::properties::longhands::border_inline_start_width;
            pub fn parse_value<'i, 't>(
                context: &ParserContext,
                input: &mut Parser<'i, 't>,
            ) -> Result<Longhands, ParseError<'i>> {
                let start_value = border_inline_start_width::parse(context, input)?;
                let end_value =
                    input.try_parse(|input| border_inline_start_width::parse(context, input))
                        .unwrap_or_else(|_| start_value.clone());

                Ok(expanded! {
                    border_inline_start_width: start_value,
                    border_inline_end_width: end_value,
                })
            }

            impl<'a> ToCss for LonghandsToSerialize<'a>  {
                fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                    self.border_inline_start_width.to_css(dest)?;

                    if self.border_inline_end_width != self.border_inline_start_width {
                        dest.write_char(' ')?;
                        self.border_inline_end_width.to_css(dest)?;
                    }

                    Ok(())
                }
            }
        
    }

        
        

    /// https://drafts.csswg.org/css-logical/#propdef-border-inline-style
    pub mod border_inline_style {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_inline_start_style:
                    longhands::border_inline_start_style::SpecifiedValue
                    ,
                pub border_inline_end_style:
                    longhands::border_inline_end_style::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_inline_start_style:
                    &'a longhands::border_inline_start_style::SpecifiedValue,
                pub border_inline_end_style:
                    &'a longhands::border_inline_end_style::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_inline_start_style =
                        None::<&'a longhands::border_inline_start_style::SpecifiedValue>;
                    let mut border_inline_end_style =
                        None::<&'a longhands::border_inline_end_style::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderInlineStartStyle(ref value) => {
                                border_inline_start_style = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndStyle(ref value) => {
                                border_inline_end_style = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_inline_start_style,
                        border_inline_end_style,
                ) {

                    (
                        Some(border_inline_start_style),
                        Some(border_inline_end_style),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_inline_start_style,
                            border_inline_end_style,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderInlineStartStyle(
                        longhands.border_inline_start_style
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndStyle(
                        longhands.border_inline_end_style
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

            use crate::properties::longhands::border_inline_start_style;
            pub fn parse_value<'i, 't>(
                context: &ParserContext,
                input: &mut Parser<'i, 't>,
            ) -> Result<Longhands, ParseError<'i>> {
                let start_value = border_inline_start_style::parse(context, input)?;
                let end_value =
                    input.try_parse(|input| border_inline_start_style::parse(context, input))
                        .unwrap_or_else(|_| start_value.clone());

                Ok(expanded! {
                    border_inline_start_style: start_value,
                    border_inline_end_style: end_value,
                })
            }

            impl<'a> ToCss for LonghandsToSerialize<'a>  {
                fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                    self.border_inline_start_style.to_css(dest)?;

                    if self.border_inline_end_style != self.border_inline_start_style {
                        dest.write_char(' ')?;
                        self.border_inline_end_style.to_css(dest)?;
                    }

                    Ok(())
                }
            }
        
    }

        
        

    /// https://drafts.csswg.org/css-logical/#propdef-border-inline-color
    pub mod border_inline_color {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_inline_start_color:
                    longhands::border_inline_start_color::SpecifiedValue
                    ,
                pub border_inline_end_color:
                    longhands::border_inline_end_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_inline_start_color:
                    &'a longhands::border_inline_start_color::SpecifiedValue,
                pub border_inline_end_color:
                    &'a longhands::border_inline_end_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_inline_start_color =
                        None::<&'a longhands::border_inline_start_color::SpecifiedValue>;
                    let mut border_inline_end_color =
                        None::<&'a longhands::border_inline_end_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderInlineStartColor(ref value) => {
                                border_inline_start_color = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndColor(ref value) => {
                                border_inline_end_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_inline_start_color,
                        border_inline_end_color,
                ) {

                    (
                        Some(border_inline_start_color),
                        Some(border_inline_end_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_inline_start_color,
                            border_inline_end_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderInlineStartColor(
                        longhands.border_inline_start_color
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndColor(
                        longhands.border_inline_end_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

            use crate::properties::longhands::border_inline_start_color;
            pub fn parse_value<'i, 't>(
                context: &ParserContext,
                input: &mut Parser<'i, 't>,
            ) -> Result<Longhands, ParseError<'i>> {
                let start_value = border_inline_start_color::parse(context, input)?;
                let end_value =
                    input.try_parse(|input| border_inline_start_color::parse(context, input))
                        .unwrap_or_else(|_| start_value.clone());

                Ok(expanded! {
                    border_inline_start_color: start_value,
                    border_inline_end_color: end_value,
                })
            }

            impl<'a> ToCss for LonghandsToSerialize<'a>  {
                fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                    self.border_inline_start_color.to_css(dest)?;

                    if self.border_inline_end_color != self.border_inline_start_color {
                        dest.write_char(' ')?;
                        self.border_inline_end_color.to_css(dest)?;
                    }

                    Ok(())
                }
            }
        
    }


    
    

    /// https://drafts.csswg.org/css-logical/#propdef-border-block
    pub mod border_block {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_block_start_width:
                    longhands::border_block_start_width::SpecifiedValue
                    ,
                pub border_block_end_width:
                    longhands::border_block_end_width::SpecifiedValue
                    ,
                pub border_block_start_style:
                    longhands::border_block_start_style::SpecifiedValue
                    ,
                pub border_block_end_style:
                    longhands::border_block_end_style::SpecifiedValue
                    ,
                pub border_block_start_color:
                    longhands::border_block_start_color::SpecifiedValue
                    ,
                pub border_block_end_color:
                    longhands::border_block_end_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_block_start_width:
                    &'a longhands::border_block_start_width::SpecifiedValue,
                pub border_block_end_width:
                    &'a longhands::border_block_end_width::SpecifiedValue,
                pub border_block_start_style:
                    &'a longhands::border_block_start_style::SpecifiedValue,
                pub border_block_end_style:
                    &'a longhands::border_block_end_style::SpecifiedValue,
                pub border_block_start_color:
                    &'a longhands::border_block_start_color::SpecifiedValue,
                pub border_block_end_color:
                    &'a longhands::border_block_end_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_block_start_width =
                        None::<&'a longhands::border_block_start_width::SpecifiedValue>;
                    let mut border_block_end_width =
                        None::<&'a longhands::border_block_end_width::SpecifiedValue>;
                    let mut border_block_start_style =
                        None::<&'a longhands::border_block_start_style::SpecifiedValue>;
                    let mut border_block_end_style =
                        None::<&'a longhands::border_block_end_style::SpecifiedValue>;
                    let mut border_block_start_color =
                        None::<&'a longhands::border_block_start_color::SpecifiedValue>;
                    let mut border_block_end_color =
                        None::<&'a longhands::border_block_end_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderBlockStartWidth(ref value) => {
                                border_block_start_width = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndWidth(ref value) => {
                                border_block_end_width = Some(value)
                            },
                            PropertyDeclaration::BorderBlockStartStyle(ref value) => {
                                border_block_start_style = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndStyle(ref value) => {
                                border_block_end_style = Some(value)
                            },
                            PropertyDeclaration::BorderBlockStartColor(ref value) => {
                                border_block_start_color = Some(value)
                            },
                            PropertyDeclaration::BorderBlockEndColor(ref value) => {
                                border_block_end_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_block_start_width,
                        border_block_end_width,
                        border_block_start_style,
                        border_block_end_style,
                        border_block_start_color,
                        border_block_end_color,
                ) {

                    (
                        Some(border_block_start_width),
                        Some(border_block_end_width),
                        Some(border_block_start_style),
                        Some(border_block_end_style),
                        Some(border_block_start_color),
                        Some(border_block_end_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_block_start_width,
                            border_block_end_width,
                            border_block_start_style,
                            border_block_end_style,
                            border_block_start_color,
                            border_block_end_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderBlockStartWidth(
                        longhands.border_block_start_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndWidth(
                        longhands.border_block_end_width
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockStartStyle(
                        longhands.border_block_start_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndStyle(
                        longhands.border_block_end_style
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockStartColor(
                        longhands.border_block_start_color
                    ));
                    declarations.push(PropertyDeclaration::BorderBlockEndColor(
                        longhands.border_block_end_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

        use crate::properties::shorthands::border_block_start;
        pub fn parse_value<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<Longhands, ParseError<'i>> {
            let start_value = border_block_start::parse_value(context, input)?;
            Ok(expanded! {
                border_block_start_width: start_value.border_block_start_width.clone(),
                border_block_end_width: start_value.border_block_start_width,
                border_block_start_style: start_value.border_block_start_style.clone(),
                border_block_end_style: start_value.border_block_start_style,
                border_block_start_color: start_value.border_block_start_color.clone(),
                border_block_end_color: start_value.border_block_start_color,
            })
        }

        impl<'a> ToCss for LonghandsToSerialize<'a>  {
            fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                crate::values::specified::border::serialize_directional_border(
                    dest,
                    self.border_block_start_width,
                    self.border_block_start_style,
                    self.border_block_start_color
                )
            }
        }
    
    }

    
    

    /// https://drafts.csswg.org/css-logical/#propdef-border-inline
    pub mod border_inline {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub border_inline_start_width:
                    longhands::border_inline_start_width::SpecifiedValue
                    ,
                pub border_inline_end_width:
                    longhands::border_inline_end_width::SpecifiedValue
                    ,
                pub border_inline_start_style:
                    longhands::border_inline_start_style::SpecifiedValue
                    ,
                pub border_inline_end_style:
                    longhands::border_inline_end_style::SpecifiedValue
                    ,
                pub border_inline_start_color:
                    longhands::border_inline_start_color::SpecifiedValue
                    ,
                pub border_inline_end_color:
                    longhands::border_inline_end_color::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub border_inline_start_width:
                    &'a longhands::border_inline_start_width::SpecifiedValue,
                pub border_inline_end_width:
                    &'a longhands::border_inline_end_width::SpecifiedValue,
                pub border_inline_start_style:
                    &'a longhands::border_inline_start_style::SpecifiedValue,
                pub border_inline_end_style:
                    &'a longhands::border_inline_end_style::SpecifiedValue,
                pub border_inline_start_color:
                    &'a longhands::border_inline_start_color::SpecifiedValue,
                pub border_inline_end_color:
                    &'a longhands::border_inline_end_color::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut border_inline_start_width =
                        None::<&'a longhands::border_inline_start_width::SpecifiedValue>;
                    let mut border_inline_end_width =
                        None::<&'a longhands::border_inline_end_width::SpecifiedValue>;
                    let mut border_inline_start_style =
                        None::<&'a longhands::border_inline_start_style::SpecifiedValue>;
                    let mut border_inline_end_style =
                        None::<&'a longhands::border_inline_end_style::SpecifiedValue>;
                    let mut border_inline_start_color =
                        None::<&'a longhands::border_inline_start_color::SpecifiedValue>;
                    let mut border_inline_end_color =
                        None::<&'a longhands::border_inline_end_color::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::BorderInlineStartWidth(ref value) => {
                                border_inline_start_width = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndWidth(ref value) => {
                                border_inline_end_width = Some(value)
                            },
                            PropertyDeclaration::BorderInlineStartStyle(ref value) => {
                                border_inline_start_style = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndStyle(ref value) => {
                                border_inline_end_style = Some(value)
                            },
                            PropertyDeclaration::BorderInlineStartColor(ref value) => {
                                border_inline_start_color = Some(value)
                            },
                            PropertyDeclaration::BorderInlineEndColor(ref value) => {
                                border_inline_end_color = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        border_inline_start_width,
                        border_inline_end_width,
                        border_inline_start_style,
                        border_inline_end_style,
                        border_inline_start_color,
                        border_inline_end_color,
                ) {

                    (
                        Some(border_inline_start_width),
                        Some(border_inline_end_width),
                        Some(border_inline_start_style),
                        Some(border_inline_end_style),
                        Some(border_inline_start_color),
                        Some(border_inline_end_color),
                    ) =>
                    Ok(LonghandsToSerialize {
                            border_inline_start_width,
                            border_inline_end_width,
                            border_inline_start_style,
                            border_inline_end_style,
                            border_inline_start_color,
                            border_inline_end_color,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::BorderInlineStartWidth(
                        longhands.border_inline_start_width
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndWidth(
                        longhands.border_inline_end_width
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineStartStyle(
                        longhands.border_inline_start_style
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndStyle(
                        longhands.border_inline_end_style
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineStartColor(
                        longhands.border_inline_start_color
                    ));
                    declarations.push(PropertyDeclaration::BorderInlineEndColor(
                        longhands.border_inline_end_color
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        

        use crate::properties::shorthands::border_inline_start;
        pub fn parse_value<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<Longhands, ParseError<'i>> {
            let start_value = border_inline_start::parse_value(context, input)?;
            Ok(expanded! {
                border_inline_start_width: start_value.border_inline_start_width.clone(),
                border_inline_end_width: start_value.border_inline_start_width,
                border_inline_start_style: start_value.border_inline_start_style.clone(),
                border_inline_end_style: start_value.border_inline_start_style,
                border_inline_start_color: start_value.border_inline_start_color.clone(),
                border_inline_end_color: start_value.border_inline_start_color,
            })
        }

        impl<'a> ToCss for LonghandsToSerialize<'a>  {
            fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
                crate::values::specified::border::serialize_directional_border(
                    dest,
                    self.border_inline_start_width,
                    self.border_inline_start_style,
                    self.border_inline_start_color
                )
            }
        }
    
    }


    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */






    /// https://drafts.csswg.org/css-overflow/#propdef-overflow
    pub mod overflow {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub overflow_x:
                    longhands::overflow_x::SpecifiedValue
                    ,
                pub overflow_y:
                    longhands::overflow_y::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub overflow_x:
                    &'a longhands::overflow_x::SpecifiedValue,
                pub overflow_y:
                    &'a longhands::overflow_y::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut overflow_x =
                        None::<&'a longhands::overflow_x::SpecifiedValue>;
                    let mut overflow_y =
                        None::<&'a longhands::overflow_y::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::OverflowX(ref value) => {
                                overflow_x = Some(value)
                            },
                            PropertyDeclaration::OverflowY(ref value) => {
                                overflow_y = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        overflow_x,
                        overflow_y,
                ) {

                    (
                        Some(overflow_x),
                        Some(overflow_y),
                    ) =>
                    Ok(LonghandsToSerialize {
                            overflow_x,
                            overflow_y,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::OverflowX(
                        longhands.overflow_x
                    ));
                    declarations.push(PropertyDeclaration::OverflowY(
                        longhands.overflow_y
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    #[allow(unused_imports)]
    use crate::parser::Parse;
    #[allow(unused_imports)]
    use crate::values::specified;

    fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let parse_one = |c: &ParserContext, input: &mut Parser<'i, 't>| -> Result<
            crate::properties::longhands::overflow_x::SpecifiedValue,
            ParseError<'i>
        > {
            crate::parser::Parse::parse(c, input)
        };

        let first = parse_one(context, input)?;
        let second =
            input.try_parse(|input| parse_one(context, input)).unwrap_or_else(|_| first.clone());
        Ok(expanded! {
            overflow_x: first,
            overflow_y: second,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let first = &self.overflow_x;
            let second = &self.overflow_y;

            first.to_css(dest)?;
            if first != second {
                dest.write_char(' ')?;
                second.to_css(dest)?;
            }
            Ok(())
        }
    }

    }





























    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    /// https://drafts.csswg.org/css-multicol/#propdef-columns
    pub mod columns {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub column_width:
                    longhands::column_width::SpecifiedValue
                    ,
                pub column_count:
                    longhands::column_count::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub column_width:
                    &'a longhands::column_width::SpecifiedValue,
                pub column_count:
                    &'a longhands::column_count::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut column_width =
                        None::<&'a longhands::column_width::SpecifiedValue>;
                    let mut column_count =
                        None::<&'a longhands::column_count::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::ColumnWidth(ref value) => {
                                column_width = Some(value)
                            },
                            PropertyDeclaration::ColumnCount(ref value) => {
                                column_count = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        column_width,
                        column_count,
                ) {

                    (
                        Some(column_width),
                        Some(column_count),
                    ) =>
                    Ok(LonghandsToSerialize {
                            column_width,
                            column_count,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::ColumnWidth(
                        longhands.column_width
                    ));
                    declarations.push(PropertyDeclaration::ColumnCount(
                        longhands.column_count
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{column_count, column_width};

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut column_count = None;
        let mut column_width = None;
        let mut autos = 0;

        loop {
            if input.try_parse(|input| input.expect_ident_matching("auto")).is_ok() {
                // Leave the options to None, 'auto' is the initial value.
                autos += 1;
                continue
            }

            if column_count.is_none() {
                if let Ok(value) = input.try_parse(|input| column_count::parse(context, input)) {
                    column_count = Some(value);
                    continue
                }
            }

            if column_width.is_none() {
                if let Ok(value) = input.try_parse(|input| column_width::parse(context, input)) {
                    column_width = Some(value);
                    continue
                }
            }

            break
        }

        let values = autos + column_count.iter().len() + column_width.iter().len();
        if values == 0 || values > 2 {
            Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        } else {
            Ok(expanded! {
                column_count: unwrap_or_initial!(column_count),
                column_width: unwrap_or_initial!(column_width),
            })
        }
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            if self.column_width.is_auto() {
                return self.column_count.to_css(dest)
            }
            self.column_width.to_css(dest)?;
            if !self.column_count.is_auto() {
                dest.write_char(' ')?;
                self.column_count.to_css(dest)?;
            }
            Ok(())
        }
    }

    }






    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */






    /// https://drafts.csswg.org/css-fonts-3/#propdef-font
    pub mod font {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        pub struct Longhands {
                pub font_style:
                    longhands::font_style::SpecifiedValue
                    ,
                pub font_variant_caps:
                    longhands::font_variant_caps::SpecifiedValue
                    ,
                pub font_weight:
                    longhands::font_weight::SpecifiedValue
                    ,
                pub font_stretch:
                    longhands::font_stretch::SpecifiedValue
                    ,
                pub font_size:
                    longhands::font_size::SpecifiedValue
                    ,
                pub line_height:
                    longhands::line_height::SpecifiedValue
                    ,
                pub font_family:
                    longhands::font_family::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub font_style:
                    &'a longhands::font_style::SpecifiedValue,
                pub font_variant_caps:
                    &'a longhands::font_variant_caps::SpecifiedValue,
                pub font_weight:
                    &'a longhands::font_weight::SpecifiedValue,
                pub font_stretch:
                    &'a longhands::font_stretch::SpecifiedValue,
                pub font_size:
                    &'a longhands::font_size::SpecifiedValue,
                pub line_height:
                    &'a longhands::line_height::SpecifiedValue,
                pub font_family:
                    &'a longhands::font_family::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut font_style =
                        None::<&'a longhands::font_style::SpecifiedValue>;
                    let mut font_variant_caps =
                        None::<&'a longhands::font_variant_caps::SpecifiedValue>;
                    let mut font_weight =
                        None::<&'a longhands::font_weight::SpecifiedValue>;
                    let mut font_stretch =
                        None::<&'a longhands::font_stretch::SpecifiedValue>;
                    let mut font_size =
                        None::<&'a longhands::font_size::SpecifiedValue>;
                    let mut line_height =
                        None::<&'a longhands::line_height::SpecifiedValue>;
                    let mut font_family =
                        None::<&'a longhands::font_family::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::FontStyle(ref value) => {
                                font_style = Some(value)
                            },
                            PropertyDeclaration::FontVariantCaps(ref value) => {
                                font_variant_caps = Some(value)
                            },
                            PropertyDeclaration::FontWeight(ref value) => {
                                font_weight = Some(value)
                            },
                            PropertyDeclaration::FontStretch(ref value) => {
                                font_stretch = Some(value)
                            },
                            PropertyDeclaration::FontSize(ref value) => {
                                font_size = Some(value)
                            },
                            PropertyDeclaration::LineHeight(ref value) => {
                                line_height = Some(value)
                            },
                            PropertyDeclaration::FontFamily(ref value) => {
                                font_family = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        font_style,
                        font_variant_caps,
                        font_weight,
                        font_stretch,
                        font_size,
                        line_height,
                        font_family,
                ) {

                    (
                        Some(font_style),
                        Some(font_variant_caps),
                        Some(font_weight),
                        Some(font_stretch),
                        Some(font_size),
                        Some(line_height),
                        Some(font_family),
                    ) =>
                    Ok(LonghandsToSerialize {
                            font_style,
                            font_variant_caps,
                            font_weight,
                            font_stretch,
                            font_size,
                            line_height,
                            font_family,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::FontStyle(
                        longhands.font_style
                    ));
                    declarations.push(PropertyDeclaration::FontVariantCaps(
                        longhands.font_variant_caps
                    ));
                    declarations.push(PropertyDeclaration::FontWeight(
                        longhands.font_weight
                    ));
                    declarations.push(PropertyDeclaration::FontStretch(
                        longhands.font_stretch
                    ));
                    declarations.push(PropertyDeclaration::FontSize(
                        longhands.font_size
                    ));
                    declarations.push(PropertyDeclaration::LineHeight(
                        longhands.line_height
                    ));
                    declarations.push(PropertyDeclaration::FontFamily(
                        longhands.font_family
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::computed_values::font_variant_caps::T::SmallCaps;
    use crate::parser::Parse;
    use crate::properties::longhands::{font_family, font_style, font_weight, font_stretch};
    #[cfg(feature = "gecko")]
    use crate::properties::longhands::font_size;
    use crate::properties::longhands::font_variant_caps;
    use crate::values::specified::font::LineHeight;
    use crate::values::specified::{FontSize, FontWeight};
    use crate::values::specified::font::{FontStretch, FontStretchKeyword};
    #[cfg(feature = "gecko")]
    use crate::values::specified::font::SystemFont;

    
    use self::font_family::SpecifiedValue as FontFamily;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut nb_normals = 0;
        let mut style = None;
        let mut variant_caps = None;
        let mut weight = None;
        let mut stretch = None;
        let size;
        loop {
            // Special-case 'normal' because it is valid in each of
            // font-style, font-weight, font-variant and font-stretch.
            // Leaves the values to None, 'normal' is the initial value for each of them.
            if input.try_parse(|input| input.expect_ident_matching("normal")).is_ok() {
                nb_normals += 1;
                continue;
            }
            if style.is_none() {
                if let Ok(value) = input.try_parse(|input| font_style::parse(context, input)) {
                    style = Some(value);
                    continue
                }
            }
            if weight.is_none() {
                if let Ok(value) = input.try_parse(|input| font_weight::parse(context, input)) {
                    weight = Some(value);
                    continue
                }
            }
            if variant_caps.is_none() {
                // The only variant-caps value allowed is small-caps (from CSS2); the added values
                // defined by CSS Fonts 3 and later are not accepted.
                // https://www.w3.org/TR/css-fonts-4/#font-prop
                if input.try_parse(|input| input.expect_ident_matching("small-caps")).is_ok() {
                    variant_caps = Some(SmallCaps);
                    continue
                }
            }
            if stretch.is_none() {
                if let Ok(value) = input.try_parse(FontStretchKeyword::parse) {
                    stretch = Some(FontStretch::Keyword(value));
                    continue
                }
            }
            size = Some(FontSize::parse(context, input)?);
            break
        }

        let size = match size {
            Some(s) => s,
            None => {
                return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
            }
        };

        let line_height = if input.try_parse(|input| input.expect_delim('/')).is_ok() {
            Some(LineHeight::parse(context, input)?)
        } else {
            None
        };

        #[inline]
        fn count<T>(opt: &Option<T>) -> u8 {
            if opt.is_some() { 1 } else { 0 }
        }

        if (count(&style) + count(&weight) + count(&variant_caps) + count(&stretch) + nb_normals) > 4 {
            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        }

        let family = FontFamily::parse(context, input)?;
        Ok(expanded! {
                font_style: unwrap_or_initial!(font_style, style),
                font_weight: unwrap_or_initial!(font_weight, weight),
                font_stretch: unwrap_or_initial!(font_stretch, stretch),
                font_variant_caps: unwrap_or_initial!(font_variant_caps, variant_caps),
            font_size: size,
            line_height: line_height.unwrap_or(LineHeight::normal()),
            font_family: family,
        })
    }


    impl<'a> ToCss for LonghandsToSerialize<'a> {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {


            // Only font-stretch keywords are allowed as part as the font
            // shorthand.
            let font_stretch = match *self.font_stretch {
                FontStretch::Keyword(kw) => kw,
                FontStretch::Stretch(percentage) => {
                    match FontStretchKeyword::from_percentage(percentage.0.get()) {
                        Some(kw) => kw,
                        None => return Ok(()),
                    }
                }
                FontStretch::System(..) => return Ok(()),
            };

            // The only variant-caps value allowed in the shorthand is small-caps (from CSS2);
            // the added values defined by CSS Fonts 3 and later are not supported.
            // https://www.w3.org/TR/css-fonts-4/#font-prop
            if self.font_variant_caps != &font_variant_caps::get_initial_specified_value() &&
                *self.font_variant_caps != SmallCaps {
                return Ok(());
            }

                if self.font_style != &font_style::get_initial_specified_value() {
                    self.font_style.to_css(dest)?;
                    dest.write_char(' ')?;
                }
                if self.font_variant_caps != &font_variant_caps::get_initial_specified_value() {
                    self.font_variant_caps.to_css(dest)?;
                    dest.write_char(' ')?;
                }

            // The initial specified font-weight value of 'normal' computes as a number (400),
            // not to the keyword, so we need to check for that as well in order to properly
            // serialize the computed style.
            if self.font_weight != &FontWeight::normal() &&
               self.font_weight != &FontWeight::from_gecko_keyword(400)  {
                self.font_weight.to_css(dest)?;
                dest.write_char(' ')?;
            }

            if font_stretch != FontStretchKeyword::Normal {
                font_stretch.to_css(dest)?;
                dest.write_char(' ')?;
            }

            self.font_size.to_css(dest)?;

            if *self.line_height != LineHeight::normal() {
                dest.write_str(" / ")?;
                self.line_height.to_css(dest)?;
            }

            dest.write_char(' ')?;
            self.font_family.to_css(dest)?;

            Ok(())
        }
    }

    impl<'a> LonghandsToSerialize<'a> {
    }

    
    impl SpecifiedValueInfo for Longhands {
        const SUPPORTED_TYPES: u8 = 0
            | <longhands::font_style::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES
            | <longhands::font_weight::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES
            | <longhands::font_stretch::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES
            | <longhands::font_variant_caps::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES
            | <longhands::font_size::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES
            | <longhands::font_family::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES
            ;

        fn collect_completion_keywords(f: KeywordsCollectFn) {
            <longhands::font_style::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords(f);
            <longhands::font_weight::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords(f);
            <longhands::font_stretch::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords(f);
            <longhands::font_variant_caps::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords(f);
            <longhands::font_size::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords(f);
            <longhands::font_family::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords(f);
        }
    }

    }




    /// https://drafts.csswg.org/css-fonts-3/#propdef-font-variant
    pub mod font_variant {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub font_variant_caps:
                    longhands::font_variant_caps::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub font_variant_caps:
                    &'a longhands::font_variant_caps::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut font_variant_caps =
                        None::<&'a longhands::font_variant_caps::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::FontVariantCaps(ref value) => {
                                font_variant_caps = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        font_variant_caps,
                ) {

                    (
                        Some(font_variant_caps),
                    ) =>
                    Ok(LonghandsToSerialize {
                            font_variant_caps,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::FontVariantCaps(
                        longhands.font_variant_caps
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    

    use crate::properties::longhands::font_variant_caps;
    #[allow(unused_imports)]
    use crate::values::specified::FontVariantLigatures;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut caps = None;

        if input.try_parse(|input| input.expect_ident_matching("normal")).is_ok() {
            // Leave the values to None, 'normal' is the initial value for all the sub properties.
        } else if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
            // The 'none' value sets 'font-variant-ligatures' to 'none' and resets all other sub properties
            // to their initial value.
        } else {
            let mut has_custom_value: bool = false;
            loop {
                if input.try_parse(|input| input.expect_ident_matching("normal")).is_ok() ||
                   input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
                    return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
                }
                if caps.is_none() {
                    if let Ok(value) = input.try_parse(|i| font_variant_caps::parse(context, i)) {
                        has_custom_value = true;
                        caps = Some(value);
                        continue
                    }
                }

                break
            }

            if !has_custom_value {
                return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
            }
        }

        Ok(expanded! {
            font_variant_caps: unwrap_or_initial!(font_variant_caps, caps),
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        #[allow(unused_assignments)]
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {

            let has_none_ligatures =
                false;

            const TOTAL_SUBPROPS: usize = 1;
            let mut nb_normals = 0;
            {
                let value = self.font_variant_caps;
                if value == &font_variant_caps::get_initial_specified_value() {
                   nb_normals += 1;
                }
            }


            if nb_normals > 0 && nb_normals == TOTAL_SUBPROPS {
                dest.write_str("normal")?;
            } else if has_none_ligatures {
                if nb_normals == TOTAL_SUBPROPS - 1 {
                    // Serialize to 'none' if 'font-variant-ligatures' is set to 'none' and all other
                    // font feature properties are reset to their initial value.
                    dest.write_str("none")?;
                } else {
                    return Ok(())
                }
            } else {
                let mut has_any = false;
                {
                    let value = self.font_variant_caps;
                    if value != &font_variant_caps::get_initial_specified_value() {
                        if has_any {
                            dest.write_char(' ')?;
                        }
                        has_any = true;
                        value.to_css(dest)?;
                    }
                }
            }

            Ok(())
        }
    }

    }






    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */







    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */













    /// https://www.w3.org/TR/css-text-4/#white-space-property
    pub mod white_space {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        pub struct Longhands {
                pub text_wrap_mode:
                    longhands::text_wrap_mode::SpecifiedValue
                    ,
                pub white_space_collapse:
                    longhands::white_space_collapse::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub text_wrap_mode:
                    &'a longhands::text_wrap_mode::SpecifiedValue,
                pub white_space_collapse:
                    &'a longhands::white_space_collapse::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut text_wrap_mode =
                        None::<&'a longhands::text_wrap_mode::SpecifiedValue>;
                    let mut white_space_collapse =
                        None::<&'a longhands::white_space_collapse::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::TextWrapMode(ref value) => {
                                text_wrap_mode = Some(value)
                            },
                            PropertyDeclaration::WhiteSpaceCollapse(ref value) => {
                                white_space_collapse = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        text_wrap_mode,
                        white_space_collapse,
                ) {

                    (
                        Some(text_wrap_mode),
                        Some(white_space_collapse),
                    ) =>
                    Ok(LonghandsToSerialize {
                            text_wrap_mode,
                            white_space_collapse,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::TextWrapMode(
                        longhands.text_wrap_mode
                    ));
                    declarations.push(PropertyDeclaration::WhiteSpaceCollapse(
                        longhands.white_space_collapse
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{text_wrap_mode, white_space_collapse};

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        use white_space_collapse::computed_value::T as Collapse;
        use text_wrap_mode::computed_value::T as Wrap;

        fn parse_special_shorthands<'i, 't>(input: &mut Parser<'i, 't>) -> Result<Longhands, ParseError<'i>> {
            let (mode, collapse) = try_match_ident_ignore_ascii_case! { input,
                "normal" => (Wrap::Wrap, Collapse::Collapse),
                "pre" => (Wrap::Nowrap, Collapse::Preserve),
                "pre-wrap" => (Wrap::Wrap, Collapse::Preserve),
                "pre-line" => (Wrap::Wrap, Collapse::PreserveBreaks),
            };
            Ok(expanded! {
                text_wrap_mode: mode,
                white_space_collapse: collapse,
            })
        }

        if let Ok(result) = input.try_parse(parse_special_shorthands) {
            return Ok(result);
        }

        let mut wrap = None;
        let mut collapse = None;

        loop {
            if wrap.is_none() {
                if let Ok(value) = input.try_parse(|input| text_wrap_mode::parse(context, input)) {
                    wrap = Some(value);
                    continue
                }
            }
            if collapse.is_none() {
                if let Ok(value) = input.try_parse(|input| white_space_collapse::parse(context, input)) {
                    collapse = Some(value);
                    continue
                }
            }
            break
        }

        if wrap.is_some() || collapse.is_some() {
            Ok(expanded! {
                text_wrap_mode: unwrap_or_initial!(text_wrap_mode, wrap),
                white_space_collapse: unwrap_or_initial!(white_space_collapse, collapse),
            })
        } else {
            Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        }
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            use white_space_collapse::computed_value::T as Collapse;
            use text_wrap_mode::computed_value::T as Wrap;

            match *self.text_wrap_mode {
                Wrap::Wrap => {
                    match *self.white_space_collapse {
                        Collapse::Collapse => return dest.write_str("normal"),
                        Collapse::Preserve => return dest.write_str("pre-wrap"),
                        Collapse::PreserveBreaks => return dest.write_str("pre-line"),
                        _ => (),
                    }
                },
                Wrap::Nowrap => {
                    if let Collapse::Preserve = *self.white_space_collapse {
                        return dest.write_str("pre");
                    }
                },
            }

            let mut has_value = false;
            if *self.white_space_collapse != Collapse::Collapse {
                self.white_space_collapse.to_css(dest)?;
                has_value = true;
            }

            if *self.text_wrap_mode != Wrap::Wrap {
                if has_value {
                    dest.write_char(' ')?;
                }
                self.text_wrap_mode.to_css(dest)?;
            }

            Ok(())
        }
    }

    impl SpecifiedValueInfo for Longhands {
        fn collect_completion_keywords(f: KeywordsCollectFn) {
            // Collect keywords from our longhands.
            text_wrap_mode::SpecifiedValue::collect_completion_keywords(f);
            white_space_collapse::SpecifiedValue::collect_completion_keywords(f);

            // Add the special values supported only by the shorthand
            // (see parse_special_shorthands() above).
            f(&["normal", "pre", "pre-wrap", "pre-line"])
        }
    }

    }


// CSS Compatibility
// https://compat.spec.whatwg.org/




    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    /// https://drafts.csswg.org/css-lists/#propdef-list-style
    pub mod list_style {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub list_style_position:
                    longhands::list_style_position::SpecifiedValue
                    ,
                pub list_style_image:
                    longhands::list_style_image::SpecifiedValue
                    ,
                pub list_style_type:
                    longhands::list_style_type::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub list_style_position:
                    &'a longhands::list_style_position::SpecifiedValue,
                pub list_style_image:
                    &'a longhands::list_style_image::SpecifiedValue,
                pub list_style_type:
                    &'a longhands::list_style_type::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut list_style_position =
                        None::<&'a longhands::list_style_position::SpecifiedValue>;
                    let mut list_style_image =
                        None::<&'a longhands::list_style_image::SpecifiedValue>;
                    let mut list_style_type =
                        None::<&'a longhands::list_style_type::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::ListStylePosition(ref value) => {
                                list_style_position = Some(value)
                            },
                            PropertyDeclaration::ListStyleImage(ref value) => {
                                list_style_image = Some(value)
                            },
                            PropertyDeclaration::ListStyleType(ref value) => {
                                list_style_type = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        list_style_position,
                        list_style_image,
                        list_style_type,
                ) {

                    (
                        Some(list_style_position),
                        Some(list_style_image),
                        Some(list_style_type),
                    ) =>
                    Ok(LonghandsToSerialize {
                            list_style_position,
                            list_style_image,
                            list_style_type,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::ListStylePosition(
                        longhands.list_style_position
                    ));
                    declarations.push(PropertyDeclaration::ListStyleImage(
                        longhands.list_style_image
                    ));
                    declarations.push(PropertyDeclaration::ListStyleType(
                        longhands.list_style_type
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{list_style_image, list_style_position, list_style_type};
    use crate::values::specified::Image;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        // `none` is ambiguous until we've finished parsing the shorthands, so we count the number
        // of times we see it.
        let mut nones = 0u8;
        let (mut image, mut position, mut list_style_type, mut any) = (None, None, None, false);
        loop {
            if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
                nones = nones + 1;
                if nones > 2 {
                    return Err(input.new_custom_error(SelectorParseErrorKind::UnexpectedIdent("none".into())))
                }
                any = true;
                continue
            }

            if image.is_none() {
                if let Ok(value) = input.try_parse(|input| list_style_image::parse(context, input)) {
                    image = Some(value);
                    any = true;
                    continue
                }
            }

            if position.is_none() {
                if let Ok(value) = input.try_parse(|input| list_style_position::parse(context, input)) {
                    position = Some(value);
                    any = true;
                    continue
                }
            }

            // list-style-type must be checked the last, because it accepts
            // arbitrary identifier for custom counter style, and thus may
            // affect values of list-style-position.
            if list_style_type.is_none() {
                if let Ok(value) = input.try_parse(|input| list_style_type::parse(context, input)) {
                    list_style_type = Some(value);
                    any = true;
                    continue
                }
            }
            break
        }

        let position = unwrap_or_initial!(list_style_position, position);

        // If there are two `none`s, then we can't have a type or image; if there is one `none`,
        // then we can't have both a type *and* an image; if there is no `none` then we're fine as
        // long as we parsed something.
        use self::list_style_type::SpecifiedValue as ListStyleType;
        match (any, nones, list_style_type, image) {
            (true, 2, None, None) => {
                Ok(expanded! {
                    list_style_position: position,
                    list_style_image: Image::None,
                    list_style_type: ListStyleType::none(),
                })
            }
            (true, 1, None, Some(image)) => {
                Ok(expanded! {
                    list_style_position: position,
                    list_style_image: image,
                    list_style_type: ListStyleType::none(),
                })
            }
            (true, 1, Some(list_style_type), None) => {
                Ok(expanded! {
                    list_style_position: position,
                    list_style_image: Image::None,
                    list_style_type: list_style_type,
                })
            }
            (true, 1, None, None) => {
                Ok(expanded! {
                    list_style_position: position,
                    list_style_image: Image::None,
                    list_style_type: ListStyleType::none(),
                })
            }
            (true, 0, list_style_type, image) => {
                Ok(expanded! {
                    list_style_position: position,
                    list_style_image: unwrap_or_initial!(list_style_image, image),
                    list_style_type: unwrap_or_initial!(list_style_type),
                })
            }
            _ => Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError)),
        }
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            use longhands::list_style_position::SpecifiedValue as ListStylePosition;
            use longhands::list_style_type::SpecifiedValue as ListStyleType;
            use longhands::list_style_image::SpecifiedValue as ListStyleImage;
            let mut have_one_non_initial_value = false;
            let position_is_initial = self.list_style_position == &ListStylePosition::Outside;
            if !position_is_initial {
                self.list_style_position.to_css(dest)?;
                have_one_non_initial_value = true;
            }
            if self.list_style_image != &ListStyleImage::None {
                if have_one_non_initial_value {
                    dest.write_char(' ')?;
                }
                self.list_style_image.to_css(dest)?;
                have_one_non_initial_value = true;
            }
            if self.list_style_type != &ListStyleType::disc() {
                if have_one_non_initial_value {
                    dest.write_char(' ')?;
                }
                self.list_style_type.to_css(dest)?;
                have_one_non_initial_value = true;
            }
            if !have_one_non_initial_value {
                self.list_style_position.to_css(dest)?;
            }
            Ok(())
        }
    }

    }


    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    
    

    /// https://drafts.csswg.org/css-box/#propdef-margin
    pub mod margin {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub margin_top:
                    longhands::margin_top::SpecifiedValue
                    ,
                pub margin_right:
                    longhands::margin_right::SpecifiedValue
                    ,
                pub margin_bottom:
                    longhands::margin_bottom::SpecifiedValue
                    ,
                pub margin_left:
                    longhands::margin_left::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub margin_top:
                    &'a longhands::margin_top::SpecifiedValue,
                pub margin_right:
                    &'a longhands::margin_right::SpecifiedValue,
                pub margin_bottom:
                    &'a longhands::margin_bottom::SpecifiedValue,
                pub margin_left:
                    &'a longhands::margin_left::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut margin_top =
                        None::<&'a longhands::margin_top::SpecifiedValue>;
                    let mut margin_right =
                        None::<&'a longhands::margin_right::SpecifiedValue>;
                    let mut margin_bottom =
                        None::<&'a longhands::margin_bottom::SpecifiedValue>;
                    let mut margin_left =
                        None::<&'a longhands::margin_left::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::MarginTop(ref value) => {
                                margin_top = Some(value)
                            },
                            PropertyDeclaration::MarginRight(ref value) => {
                                margin_right = Some(value)
                            },
                            PropertyDeclaration::MarginBottom(ref value) => {
                                margin_bottom = Some(value)
                            },
                            PropertyDeclaration::MarginLeft(ref value) => {
                                margin_left = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        margin_top,
                        margin_right,
                        margin_bottom,
                        margin_left,
                ) {

                    (
                        Some(margin_top),
                        Some(margin_right),
                        Some(margin_bottom),
                        Some(margin_left),
                    ) =>
                    Ok(LonghandsToSerialize {
                            margin_top,
                            margin_right,
                            margin_bottom,
                            margin_left,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::MarginTop(
                        longhands.margin_top
                    ));
                    declarations.push(PropertyDeclaration::MarginRight(
                        longhands.margin_right
                    ));
                    declarations.push(PropertyDeclaration::MarginBottom(
                        longhands.margin_bottom
                    ));
                    declarations.push(PropertyDeclaration::MarginLeft(
                        longhands.margin_left
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
        #[allow(unused_imports)]
        use crate::parser::Parse;
        use crate::values::generics::rect::Rect;
        #[allow(unused_imports)]
        use crate::values::specified;

        fn parse_value<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<Longhands, ParseError<'i>> {
            let rect = Rect::parse_with(context, input, |c, i| -> Result<
                crate::properties::longhands::margin_top::SpecifiedValue,
                ParseError<'i>
            > {
                specified::Margin::parse_quirky(c, i, specified::AllowQuirks::Yes)
            })?;
            Ok(expanded! {
                    margin_top: rect.0,
                    margin_right: rect.1,
                    margin_bottom: rect.2,
                    margin_left: rect.3,
            })
        }

        impl<'a> ToCss for LonghandsToSerialize<'a> {
            fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result
            where
                W: Write,
            {
                let rect = Rect::new(
                    &self.margin_top,
                    &self.margin_right,
                    &self.margin_bottom,
                    &self.margin_left,
                );
                rect.to_css(dest)
            }
        }
    
    }






    /// https://drafts.csswg.org/css-logical/#propdef-margin-block
    pub mod margin_block {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub margin_block_start:
                    longhands::margin_block_start::SpecifiedValue
                    ,
                pub margin_block_end:
                    longhands::margin_block_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub margin_block_start:
                    &'a longhands::margin_block_start::SpecifiedValue,
                pub margin_block_end:
                    &'a longhands::margin_block_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut margin_block_start =
                        None::<&'a longhands::margin_block_start::SpecifiedValue>;
                    let mut margin_block_end =
                        None::<&'a longhands::margin_block_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::MarginBlockStart(ref value) => {
                                margin_block_start = Some(value)
                            },
                            PropertyDeclaration::MarginBlockEnd(ref value) => {
                                margin_block_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        margin_block_start,
                        margin_block_end,
                ) {

                    (
                        Some(margin_block_start),
                        Some(margin_block_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            margin_block_start,
                            margin_block_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::MarginBlockStart(
                        longhands.margin_block_start
                    ));
                    declarations.push(PropertyDeclaration::MarginBlockEnd(
                        longhands.margin_block_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    #[allow(unused_imports)]
    use crate::parser::Parse;
    #[allow(unused_imports)]
    use crate::values::specified;

    fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let parse_one = |c: &ParserContext, input: &mut Parser<'i, 't>| -> Result<
            crate::properties::longhands::margin_block_start::SpecifiedValue,
            ParseError<'i>
        > {
            specified::Margin::parse(c, input)
        };

        let first = parse_one(context, input)?;
        let second =
            input.try_parse(|input| parse_one(context, input)).unwrap_or_else(|_| first.clone());
        Ok(expanded! {
            margin_block_start: first,
            margin_block_end: second,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let first = &self.margin_block_start;
            let second = &self.margin_block_end;

            first.to_css(dest)?;
            if first != second {
                dest.write_char(' ')?;
                second.to_css(dest)?;
            }
            Ok(())
        }
    }

    }






    /// https://drafts.csswg.org/css-logical/#propdef-margin-inline
    pub mod margin_inline {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub margin_inline_start:
                    longhands::margin_inline_start::SpecifiedValue
                    ,
                pub margin_inline_end:
                    longhands::margin_inline_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub margin_inline_start:
                    &'a longhands::margin_inline_start::SpecifiedValue,
                pub margin_inline_end:
                    &'a longhands::margin_inline_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut margin_inline_start =
                        None::<&'a longhands::margin_inline_start::SpecifiedValue>;
                    let mut margin_inline_end =
                        None::<&'a longhands::margin_inline_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::MarginInlineStart(ref value) => {
                                margin_inline_start = Some(value)
                            },
                            PropertyDeclaration::MarginInlineEnd(ref value) => {
                                margin_inline_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        margin_inline_start,
                        margin_inline_end,
                ) {

                    (
                        Some(margin_inline_start),
                        Some(margin_inline_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            margin_inline_start,
                            margin_inline_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::MarginInlineStart(
                        longhands.margin_inline_start
                    ));
                    declarations.push(PropertyDeclaration::MarginInlineEnd(
                        longhands.margin_inline_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    #[allow(unused_imports)]
    use crate::parser::Parse;
    #[allow(unused_imports)]
    use crate::values::specified;

    fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let parse_one = |c: &ParserContext, input: &mut Parser<'i, 't>| -> Result<
            crate::properties::longhands::margin_inline_start::SpecifiedValue,
            ParseError<'i>
        > {
            specified::Margin::parse(c, input)
        };

        let first = parse_one(context, input)?;
        let second =
            input.try_parse(|input| parse_one(context, input)).unwrap_or_else(|_| first.clone());
        Ok(expanded! {
            margin_inline_start: first,
            margin_inline_end: second,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let first = &self.margin_inline_start;
            let second = &self.margin_inline_end;

            first.to_css(dest)?;
            if first != second {
                dest.write_char(' ')?;
                second.to_css(dest)?;
            }
            Ok(())
        }
    }

    }




    
    
















    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    /// https://drafts.csswg.org/css-ui/#propdef-outline
    pub mod outline {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub outline_color:
                    longhands::outline_color::SpecifiedValue
                    ,
                pub outline_style:
                    longhands::outline_style::SpecifiedValue
                    ,
                pub outline_width:
                    longhands::outline_width::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub outline_color:
                    &'a longhands::outline_color::SpecifiedValue,
                pub outline_style:
                    &'a longhands::outline_style::SpecifiedValue,
                pub outline_width:
                    &'a longhands::outline_width::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut outline_color =
                        None::<&'a longhands::outline_color::SpecifiedValue>;
                    let mut outline_style =
                        None::<&'a longhands::outline_style::SpecifiedValue>;
                    let mut outline_width =
                        None::<&'a longhands::outline_width::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::OutlineColor(ref value) => {
                                outline_color = Some(value)
                            },
                            PropertyDeclaration::OutlineStyle(ref value) => {
                                outline_style = Some(value)
                            },
                            PropertyDeclaration::OutlineWidth(ref value) => {
                                outline_width = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        outline_color,
                        outline_style,
                        outline_width,
                ) {

                    (
                        Some(outline_color),
                        Some(outline_style),
                        Some(outline_width),
                    ) =>
                    Ok(LonghandsToSerialize {
                            outline_color,
                            outline_style,
                            outline_width,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::OutlineColor(
                        longhands.outline_color
                    ));
                    declarations.push(PropertyDeclaration::OutlineStyle(
                        longhands.outline_style
                    ));
                    declarations.push(PropertyDeclaration::OutlineWidth(
                        longhands.outline_width
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{outline_color, outline_width, outline_style};
    use crate::values::specified;
    use crate::parser::Parse;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let _unused = context;
        let mut color = None;
        let mut style = None;
        let mut width = None;
        let mut any = false;
        loop {
            if color.is_none() {
                if let Ok(value) = input.try_parse(|i| specified::Color::parse(context, i)) {
                    color = Some(value);
                    any = true;
                    continue
                }
            }
            if style.is_none() {
                if let Ok(value) = input.try_parse(|input| outline_style::parse(context, input)) {
                    style = Some(value);
                    any = true;
                    continue
                }
            }
            if width.is_none() {
                if let Ok(value) = input.try_parse(|input| outline_width::parse(context, input)) {
                    width = Some(value);
                    any = true;
                    continue
                }
            }
            break
        }
        if any {
            Ok(expanded! {
                outline_color: unwrap_or_initial!(outline_color, color),
                outline_style: unwrap_or_initial!(outline_style, style),
                outline_width: unwrap_or_initial!(outline_width, width),
            })
        } else {
            Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        }
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let mut wrote_value = false;

                if *self.outline_color != outline_color::get_initial_specified_value() {
                    if wrote_value {
                        dest.write_char(' ')?;
                    }
                    self.outline_color.to_css(dest)?;
                    wrote_value = true;
                }
                if *self.outline_style != outline_style::get_initial_specified_value() {
                    if wrote_value {
                        dest.write_char(' ')?;
                    }
                    self.outline_style.to_css(dest)?;
                    wrote_value = true;
                }
                if *self.outline_width != outline_width::get_initial_specified_value() {
                    if wrote_value {
                        dest.write_char(' ')?;
                    }
                    self.outline_width.to_css(dest)?;
                    wrote_value = true;
                }

            if !wrote_value {
                self.outline_style.to_css(dest)?;
            }

            Ok(())
        }
    }

    }


    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




    
    

    /// https://drafts.csswg.org/css-box-3/#propdef-padding
    pub mod padding {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub padding_top:
                    longhands::padding_top::SpecifiedValue
                    ,
                pub padding_right:
                    longhands::padding_right::SpecifiedValue
                    ,
                pub padding_bottom:
                    longhands::padding_bottom::SpecifiedValue
                    ,
                pub padding_left:
                    longhands::padding_left::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub padding_top:
                    &'a longhands::padding_top::SpecifiedValue,
                pub padding_right:
                    &'a longhands::padding_right::SpecifiedValue,
                pub padding_bottom:
                    &'a longhands::padding_bottom::SpecifiedValue,
                pub padding_left:
                    &'a longhands::padding_left::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut padding_top =
                        None::<&'a longhands::padding_top::SpecifiedValue>;
                    let mut padding_right =
                        None::<&'a longhands::padding_right::SpecifiedValue>;
                    let mut padding_bottom =
                        None::<&'a longhands::padding_bottom::SpecifiedValue>;
                    let mut padding_left =
                        None::<&'a longhands::padding_left::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::PaddingTop(ref value) => {
                                padding_top = Some(value)
                            },
                            PropertyDeclaration::PaddingRight(ref value) => {
                                padding_right = Some(value)
                            },
                            PropertyDeclaration::PaddingBottom(ref value) => {
                                padding_bottom = Some(value)
                            },
                            PropertyDeclaration::PaddingLeft(ref value) => {
                                padding_left = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        padding_top,
                        padding_right,
                        padding_bottom,
                        padding_left,
                ) {

                    (
                        Some(padding_top),
                        Some(padding_right),
                        Some(padding_bottom),
                        Some(padding_left),
                    ) =>
                    Ok(LonghandsToSerialize {
                            padding_top,
                            padding_right,
                            padding_bottom,
                            padding_left,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::PaddingTop(
                        longhands.padding_top
                    ));
                    declarations.push(PropertyDeclaration::PaddingRight(
                        longhands.padding_right
                    ));
                    declarations.push(PropertyDeclaration::PaddingBottom(
                        longhands.padding_bottom
                    ));
                    declarations.push(PropertyDeclaration::PaddingLeft(
                        longhands.padding_left
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
        #[allow(unused_imports)]
        use crate::parser::Parse;
        use crate::values::generics::rect::Rect;
        #[allow(unused_imports)]
        use crate::values::specified;

        fn parse_value<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<Longhands, ParseError<'i>> {
            let rect = Rect::parse_with(context, input, |c, i| -> Result<
                crate::properties::longhands::padding_top::SpecifiedValue,
                ParseError<'i>
            > {
                specified::NonNegativeLengthPercentage::parse_quirky(c, i, specified::AllowQuirks::Yes)
            })?;
            Ok(expanded! {
                    padding_top: rect.0,
                    padding_right: rect.1,
                    padding_bottom: rect.2,
                    padding_left: rect.3,
            })
        }

        impl<'a> ToCss for LonghandsToSerialize<'a> {
            fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result
            where
                W: Write,
            {
                let rect = Rect::new(
                    &self.padding_top,
                    &self.padding_right,
                    &self.padding_bottom,
                    &self.padding_left,
                );
                rect.to_css(dest)
            }
        }
    
    }






    /// https://drafts.csswg.org/css-logical/#propdef-padding-block
    pub mod padding_block {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub padding_block_start:
                    longhands::padding_block_start::SpecifiedValue
                    ,
                pub padding_block_end:
                    longhands::padding_block_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub padding_block_start:
                    &'a longhands::padding_block_start::SpecifiedValue,
                pub padding_block_end:
                    &'a longhands::padding_block_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut padding_block_start =
                        None::<&'a longhands::padding_block_start::SpecifiedValue>;
                    let mut padding_block_end =
                        None::<&'a longhands::padding_block_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::PaddingBlockStart(ref value) => {
                                padding_block_start = Some(value)
                            },
                            PropertyDeclaration::PaddingBlockEnd(ref value) => {
                                padding_block_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        padding_block_start,
                        padding_block_end,
                ) {

                    (
                        Some(padding_block_start),
                        Some(padding_block_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            padding_block_start,
                            padding_block_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::PaddingBlockStart(
                        longhands.padding_block_start
                    ));
                    declarations.push(PropertyDeclaration::PaddingBlockEnd(
                        longhands.padding_block_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    #[allow(unused_imports)]
    use crate::parser::Parse;
    #[allow(unused_imports)]
    use crate::values::specified;

    fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let parse_one = |c: &ParserContext, input: &mut Parser<'i, 't>| -> Result<
            crate::properties::longhands::padding_block_start::SpecifiedValue,
            ParseError<'i>
        > {
            specified::NonNegativeLengthPercentage::parse(c, input)
        };

        let first = parse_one(context, input)?;
        let second =
            input.try_parse(|input| parse_one(context, input)).unwrap_or_else(|_| first.clone());
        Ok(expanded! {
            padding_block_start: first,
            padding_block_end: second,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let first = &self.padding_block_start;
            let second = &self.padding_block_end;

            first.to_css(dest)?;
            if first != second {
                dest.write_char(' ')?;
                second.to_css(dest)?;
            }
            Ok(())
        }
    }

    }






    /// https://drafts.csswg.org/css-logical/#propdef-padding-inline
    pub mod padding_inline {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub padding_inline_start:
                    longhands::padding_inline_start::SpecifiedValue
                    ,
                pub padding_inline_end:
                    longhands::padding_inline_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub padding_inline_start:
                    &'a longhands::padding_inline_start::SpecifiedValue,
                pub padding_inline_end:
                    &'a longhands::padding_inline_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut padding_inline_start =
                        None::<&'a longhands::padding_inline_start::SpecifiedValue>;
                    let mut padding_inline_end =
                        None::<&'a longhands::padding_inline_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::PaddingInlineStart(ref value) => {
                                padding_inline_start = Some(value)
                            },
                            PropertyDeclaration::PaddingInlineEnd(ref value) => {
                                padding_inline_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        padding_inline_start,
                        padding_inline_end,
                ) {

                    (
                        Some(padding_inline_start),
                        Some(padding_inline_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            padding_inline_start,
                            padding_inline_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::PaddingInlineStart(
                        longhands.padding_inline_start
                    ));
                    declarations.push(PropertyDeclaration::PaddingInlineEnd(
                        longhands.padding_inline_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    #[allow(unused_imports)]
    use crate::parser::Parse;
    #[allow(unused_imports)]
    use crate::values::specified;

    fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let parse_one = |c: &ParserContext, input: &mut Parser<'i, 't>| -> Result<
            crate::properties::longhands::padding_inline_start::SpecifiedValue,
            ParseError<'i>
        > {
            specified::NonNegativeLengthPercentage::parse(c, input)
        };

        let first = parse_one(context, input)?;
        let second =
            input.try_parse(|input| parse_one(context, input)).unwrap_or_else(|_| first.clone());
        Ok(expanded! {
            padding_inline_start: first,
            padding_inline_end: second,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let first = &self.padding_inline_start;
            let second = &self.padding_inline_end;

            first.to_css(dest)?;
            if first != second {
                dest.write_char(' ')?;
                second.to_css(dest)?;
            }
            Ok(())
        }
    }

    }




    
    
















    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */






    /// https://drafts.csswg.org/css-flexbox/#flex-flow-property
    pub mod flex_flow {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub flex_direction:
                    longhands::flex_direction::SpecifiedValue
                    ,
                pub flex_wrap:
                    longhands::flex_wrap::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub flex_direction:
                    &'a longhands::flex_direction::SpecifiedValue,
                pub flex_wrap:
                    &'a longhands::flex_wrap::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut flex_direction =
                        None::<&'a longhands::flex_direction::SpecifiedValue>;
                    let mut flex_wrap =
                        None::<&'a longhands::flex_wrap::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::FlexDirection(ref value) => {
                                flex_direction = Some(value)
                            },
                            PropertyDeclaration::FlexWrap(ref value) => {
                                flex_wrap = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        flex_direction,
                        flex_wrap,
                ) {

                    (
                        Some(flex_direction),
                        Some(flex_wrap),
                    ) =>
                    Ok(LonghandsToSerialize {
                            flex_direction,
                            flex_wrap,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::FlexDirection(
                        longhands.flex_direction
                    ));
                    declarations.push(PropertyDeclaration::FlexWrap(
                        longhands.flex_wrap
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{flex_direction, flex_wrap};

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut direction = None;
        let mut wrap = None;
        loop {
            if direction.is_none() {
                if let Ok(value) = input.try_parse(|input| flex_direction::parse(context, input)) {
                    direction = Some(value);
                    continue
                }
            }
            if wrap.is_none() {
                if let Ok(value) = input.try_parse(|input| flex_wrap::parse(context, input)) {
                    wrap = Some(value);
                    continue
                }
            }
            break
        }

        if direction.is_none() && wrap.is_none() {
            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        }
        Ok(expanded! {
            flex_direction: unwrap_or_initial!(flex_direction, direction),
            flex_wrap: unwrap_or_initial!(flex_wrap, wrap),
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            if *self.flex_direction == flex_direction::get_initial_specified_value() &&
               *self.flex_wrap != flex_wrap::get_initial_specified_value() {
                return self.flex_wrap.to_css(dest)
            }
            self.flex_direction.to_css(dest)?;
            if *self.flex_wrap != flex_wrap::get_initial_specified_value() {
                dest.write_char(' ')?;
                self.flex_wrap.to_css(dest)?;
            }
            Ok(())
        }
    }

    }




    /// https://drafts.csswg.org/css-flexbox/#flex-property
    pub mod flex {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub flex_grow:
                    longhands::flex_grow::SpecifiedValue
                    ,
                pub flex_shrink:
                    longhands::flex_shrink::SpecifiedValue
                    ,
                pub flex_basis:
                        Box<
                    longhands::flex_basis::SpecifiedValue
                        >
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        #[derive(ToCss)]
        pub struct LonghandsToSerialize<'a> {
                pub flex_grow:
                    &'a longhands::flex_grow::SpecifiedValue,
                pub flex_shrink:
                    &'a longhands::flex_shrink::SpecifiedValue,
                pub flex_basis:
                    &'a longhands::flex_basis::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut flex_grow =
                        None::<&'a longhands::flex_grow::SpecifiedValue>;
                    let mut flex_shrink =
                        None::<&'a longhands::flex_shrink::SpecifiedValue>;
                    let mut flex_basis =
                        None::<&'a longhands::flex_basis::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::FlexGrow(ref value) => {
                                flex_grow = Some(value)
                            },
                            PropertyDeclaration::FlexShrink(ref value) => {
                                flex_shrink = Some(value)
                            },
                            PropertyDeclaration::FlexBasis(ref value) => {
                                flex_basis = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        flex_grow,
                        flex_shrink,
                        flex_basis,
                ) {

                    (
                        Some(flex_grow),
                        Some(flex_shrink),
                        Some(flex_basis),
                    ) =>
                    Ok(LonghandsToSerialize {
                            flex_grow,
                            flex_shrink,
                            flex_basis,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::FlexGrow(
                        longhands.flex_grow
                    ));
                    declarations.push(PropertyDeclaration::FlexShrink(
                        longhands.flex_shrink
                    ));
                    declarations.push(PropertyDeclaration::FlexBasis(
                        longhands.flex_basis
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::parser::Parse;
    use crate::values::specified::NonNegativeNumber;
    use crate::properties::longhands::flex_basis::SpecifiedValue as FlexBasis;

    fn parse_flexibility<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<(NonNegativeNumber, Option<NonNegativeNumber>),ParseError<'i>> {
        let grow = NonNegativeNumber::parse(context, input)?;
        let shrink = input.try_parse(|i| NonNegativeNumber::parse(context, i)).ok();
        Ok((grow, shrink))
    }

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut grow = None;
        let mut shrink = None;
        let mut basis = None;

        if input.try_parse(|input| input.expect_ident_matching("none")).is_ok() {
            return Ok(expanded! {
                flex_grow: NonNegativeNumber::new(0.0),
                flex_shrink: NonNegativeNumber::new(0.0),
                flex_basis: FlexBasis::auto(),
            })
        }
        loop {
            if grow.is_none() {
                if let Ok((flex_grow, flex_shrink)) = input.try_parse(|i| parse_flexibility(context, i)) {
                    grow = Some(flex_grow);
                    shrink = flex_shrink;
                    continue
                }
            }
            if basis.is_none() {
                if let Ok(value) = input.try_parse(|input| FlexBasis::parse(context, input)) {
                    basis = Some(value);
                    continue
                }
            }
            break
        }

        if grow.is_none() && basis.is_none() {
            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        }
        Ok(expanded! {
            flex_grow: grow.unwrap_or(NonNegativeNumber::new(1.0)),
            flex_shrink: shrink.unwrap_or(NonNegativeNumber::new(1.0)),
            // Per spec, this should be SpecifiedValue::zero(), but all
            // browsers currently agree on using `0%`. This is a spec
            // change which hasn't been adopted by browsers:
            // https://github.com/w3c/csswg-drafts/commit/2c446befdf0f686217905bdd7c92409f6bd3921b
            flex_basis: basis.unwrap_or(FlexBasis::zero_percent()),
        })
    }

    }




    /// https://drafts.csswg.org/css-align-3/#gap-shorthand
    pub mod gap {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub row_gap:
                    longhands::row_gap::SpecifiedValue
                    ,
                pub column_gap:
                    longhands::column_gap::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub row_gap:
                    &'a longhands::row_gap::SpecifiedValue,
                pub column_gap:
                    &'a longhands::column_gap::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut row_gap =
                        None::<&'a longhands::row_gap::SpecifiedValue>;
                    let mut column_gap =
                        None::<&'a longhands::column_gap::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::RowGap(ref value) => {
                                row_gap = Some(value)
                            },
                            PropertyDeclaration::ColumnGap(ref value) => {
                                column_gap = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        row_gap,
                        column_gap,
                ) {

                    (
                        Some(row_gap),
                        Some(column_gap),
                    ) =>
                    Ok(LonghandsToSerialize {
                            row_gap,
                            column_gap,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::RowGap(
                        longhands.row_gap
                    ));
                    declarations.push(PropertyDeclaration::ColumnGap(
                        longhands.column_gap
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
  use crate::properties::longhands::{row_gap, column_gap};

  pub fn parse_value<'i, 't>(context: &ParserContext, input: &mut Parser<'i, 't>)
                             -> Result<Longhands, ParseError<'i>> {
      let r_gap = row_gap::parse(context, input)?;
      let c_gap = input.try_parse(|input| column_gap::parse(context, input)).unwrap_or(r_gap.clone());

      Ok(expanded! {
        row_gap: r_gap,
        column_gap: c_gap,
      })
  }

  impl<'a> ToCss for LonghandsToSerialize<'a>  {
      fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
          if self.row_gap == self.column_gap {
            self.row_gap.to_css(dest)
          } else {
            self.row_gap.to_css(dest)?;
            dest.write_char(' ')?;
            self.column_gap.to_css(dest)
          }
      }
  }


    }




    /// https://drafts.csswg.org/css-grid/#propdef-grid-row
    pub mod grid_row {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub grid_row_start:
                    longhands::grid_row_start::SpecifiedValue
                    ,
                pub grid_row_end:
                    longhands::grid_row_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub grid_row_start:
                    &'a longhands::grid_row_start::SpecifiedValue,
                pub grid_row_end:
                    &'a longhands::grid_row_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut grid_row_start =
                        None::<&'a longhands::grid_row_start::SpecifiedValue>;
                    let mut grid_row_end =
                        None::<&'a longhands::grid_row_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::GridRowStart(ref value) => {
                                grid_row_start = Some(value)
                            },
                            PropertyDeclaration::GridRowEnd(ref value) => {
                                grid_row_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        grid_row_start,
                        grid_row_end,
                ) {

                    (
                        Some(grid_row_start),
                        Some(grid_row_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            grid_row_start,
                            grid_row_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::GridRowStart(
                        longhands.grid_row_start
                    ));
                    declarations.push(PropertyDeclaration::GridRowEnd(
                        longhands.grid_row_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::specified::GridLine;
    use crate::parser::Parse;
    use crate::Zero;

    // NOTE: Since both the shorthands have the same code, we should (re-)use code from one to implement
    // the other. This might not be a big deal for now, but we should consider looking into this in the future
    // to limit the amount of code generated.
    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let start = input.try_parse(|i| GridLine::parse(context, i))?;
        let end = if input.try_parse(|i| i.expect_delim('/')).is_ok() {
            GridLine::parse(context, input)?
        } else {
            let mut line = GridLine::auto();
            if start.line_num.is_zero() && !start.is_span {
                line.ident = start.ident.clone(); // ident from start value should be taken
            }

            line
        };

        Ok(expanded! {
            grid_row_start: start,
            grid_row_end: end,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        // Return the shortest possible serialization of the `grid-row-[start/end]` values.
        // This function exploits the opportunities to omit the end value per this spec text:
        //
        // https://drafts.csswg.org/css-grid/#propdef-grid-column
        // "When the second value is omitted, if the first value is a <custom-ident>,
        // the grid-row-end/grid-column-end longhand is also set to that <custom-ident>;
        // otherwise, it is set to auto."
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            self.grid_row_start.to_css(dest)?;
            if self.grid_row_start.can_omit(self.grid_row_end) {
                return Ok(());  // the end value is redundant
            }
            dest.write_str(" / ")?;
            self.grid_row_end.to_css(dest)
        }
    }

    }



    /// https://drafts.csswg.org/css-grid/#propdef-grid-column
    pub mod grid_column {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub grid_column_start:
                    longhands::grid_column_start::SpecifiedValue
                    ,
                pub grid_column_end:
                    longhands::grid_column_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub grid_column_start:
                    &'a longhands::grid_column_start::SpecifiedValue,
                pub grid_column_end:
                    &'a longhands::grid_column_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut grid_column_start =
                        None::<&'a longhands::grid_column_start::SpecifiedValue>;
                    let mut grid_column_end =
                        None::<&'a longhands::grid_column_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::GridColumnStart(ref value) => {
                                grid_column_start = Some(value)
                            },
                            PropertyDeclaration::GridColumnEnd(ref value) => {
                                grid_column_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        grid_column_start,
                        grid_column_end,
                ) {

                    (
                        Some(grid_column_start),
                        Some(grid_column_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            grid_column_start,
                            grid_column_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::GridColumnStart(
                        longhands.grid_column_start
                    ));
                    declarations.push(PropertyDeclaration::GridColumnEnd(
                        longhands.grid_column_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::specified::GridLine;
    use crate::parser::Parse;
    use crate::Zero;

    // NOTE: Since both the shorthands have the same code, we should (re-)use code from one to implement
    // the other. This might not be a big deal for now, but we should consider looking into this in the future
    // to limit the amount of code generated.
    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let start = input.try_parse(|i| GridLine::parse(context, i))?;
        let end = if input.try_parse(|i| i.expect_delim('/')).is_ok() {
            GridLine::parse(context, input)?
        } else {
            let mut line = GridLine::auto();
            if start.line_num.is_zero() && !start.is_span {
                line.ident = start.ident.clone(); // ident from start value should be taken
            }

            line
        };

        Ok(expanded! {
            grid_column_start: start,
            grid_column_end: end,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        // Return the shortest possible serialization of the `grid-column-[start/end]` values.
        // This function exploits the opportunities to omit the end value per this spec text:
        //
        // https://drafts.csswg.org/css-grid/#propdef-grid-column
        // "When the second value is omitted, if the first value is a <custom-ident>,
        // the grid-row-end/grid-column-end longhand is also set to that <custom-ident>;
        // otherwise, it is set to auto."
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            self.grid_column_start.to_css(dest)?;
            if self.grid_column_start.can_omit(self.grid_column_end) {
                return Ok(());  // the end value is redundant
            }
            dest.write_str(" / ")?;
            self.grid_column_end.to_css(dest)
        }
    }

    }




    /// https://drafts.csswg.org/css-grid/#propdef-grid-area
    pub mod grid_area {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub grid_row_start:
                    longhands::grid_row_start::SpecifiedValue
                    ,
                pub grid_row_end:
                    longhands::grid_row_end::SpecifiedValue
                    ,
                pub grid_column_start:
                    longhands::grid_column_start::SpecifiedValue
                    ,
                pub grid_column_end:
                    longhands::grid_column_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub grid_row_start:
                    &'a longhands::grid_row_start::SpecifiedValue,
                pub grid_row_end:
                    &'a longhands::grid_row_end::SpecifiedValue,
                pub grid_column_start:
                    &'a longhands::grid_column_start::SpecifiedValue,
                pub grid_column_end:
                    &'a longhands::grid_column_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut grid_row_start =
                        None::<&'a longhands::grid_row_start::SpecifiedValue>;
                    let mut grid_row_end =
                        None::<&'a longhands::grid_row_end::SpecifiedValue>;
                    let mut grid_column_start =
                        None::<&'a longhands::grid_column_start::SpecifiedValue>;
                    let mut grid_column_end =
                        None::<&'a longhands::grid_column_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::GridRowStart(ref value) => {
                                grid_row_start = Some(value)
                            },
                            PropertyDeclaration::GridRowEnd(ref value) => {
                                grid_row_end = Some(value)
                            },
                            PropertyDeclaration::GridColumnStart(ref value) => {
                                grid_column_start = Some(value)
                            },
                            PropertyDeclaration::GridColumnEnd(ref value) => {
                                grid_column_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        grid_row_start,
                        grid_row_end,
                        grid_column_start,
                        grid_column_end,
                ) {

                    (
                        Some(grid_row_start),
                        Some(grid_row_end),
                        Some(grid_column_start),
                        Some(grid_column_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            grid_row_start,
                            grid_row_end,
                            grid_column_start,
                            grid_column_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::GridRowStart(
                        longhands.grid_row_start
                    ));
                    declarations.push(PropertyDeclaration::GridRowEnd(
                        longhands.grid_row_end
                    ));
                    declarations.push(PropertyDeclaration::GridColumnStart(
                        longhands.grid_column_start
                    ));
                    declarations.push(PropertyDeclaration::GridColumnEnd(
                        longhands.grid_column_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::specified::GridLine;
    use crate::parser::Parse;
    use crate::Zero;

    // The code is the same as `grid-{row,column}` except that this can have four values at most.
    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        fn line_with_ident_from(other: &GridLine) -> GridLine {
            let mut this = GridLine::auto();
            if other.line_num.is_zero() && !other.is_span {
                this.ident = other.ident.clone();
            }

            this
        }

        let row_start = input.try_parse(|i| GridLine::parse(context, i))?;
        let (column_start, row_end, column_end) = if input.try_parse(|i| i.expect_delim('/')).is_ok() {
            let column_start = GridLine::parse(context, input)?;
            let (row_end, column_end) = if input.try_parse(|i| i.expect_delim('/')).is_ok() {
                let row_end = GridLine::parse(context, input)?;
                let column_end = if input.try_parse(|i| i.expect_delim('/')).is_ok() {
                    GridLine::parse(context, input)?
                } else {        // grid-column-end has not been given
                    line_with_ident_from(&column_start)
                };

                (row_end, column_end)
            } else {        // grid-row-start and grid-column-start has been given
                let row_end = line_with_ident_from(&row_start);
                let column_end = line_with_ident_from(&column_start);
                (row_end, column_end)
            };

            (column_start, row_end, column_end)
        } else {        // only grid-row-start is given
            let line = line_with_ident_from(&row_start);
            (line.clone(), line.clone(), line)
        };

        Ok(expanded! {
            grid_row_start: row_start,
            grid_row_end: row_end,
            grid_column_start: column_start,
            grid_column_end: column_end,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        // Return the shortest possible serialization of the `grid-[column/row]-[start/end]` values.
        // This function exploits the opportunities to omit trailing values per this spec text:
        //
        // https://drafts.csswg.org/css-grid/#propdef-grid-area
        // "If four <grid-line> values are specified, grid-row-start is set to the first value,
        // grid-column-start is set to the second value, grid-row-end is set to the third value,
        // and grid-column-end is set to the fourth value.
        //
        // When grid-column-end is omitted, if grid-column-start is a <custom-ident>,
        // grid-column-end is set to that <custom-ident>; otherwise, it is set to auto.
        //
        // When grid-row-end is omitted, if grid-row-start is a <custom-ident>, grid-row-end is
        // set to that <custom-ident>; otherwise, it is set to auto.
        //
        // When grid-column-start is omitted, if grid-row-start is a <custom-ident>, all four
        // longhands are set to that value. Otherwise, it is set to auto."
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            self.grid_row_start.to_css(dest)?;
            let mut trailing_values = 3;
            if self.grid_column_start.can_omit(self.grid_column_end) {
                trailing_values -= 1;
                if self.grid_row_start.can_omit(self.grid_row_end) {
                    trailing_values -= 1;
                    if self.grid_row_start.can_omit(self.grid_column_start) {
                        trailing_values -= 1;
                    }
                }
            }
            let values = [&self.grid_column_start, &self.grid_row_end, &self.grid_column_end];
            for value in values.iter().take(trailing_values) {
                dest.write_str(" / ")?;
                value.to_css(dest)?;
            }
            Ok(())
        }
    }

    }




    /// https://drafts.csswg.org/css-grid/#propdef-grid-template
    pub mod grid_template {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub grid_template_rows:
                    longhands::grid_template_rows::SpecifiedValue
                    ,
                pub grid_template_columns:
                    longhands::grid_template_columns::SpecifiedValue
                    ,
                pub grid_template_areas:
                    longhands::grid_template_areas::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub grid_template_rows:
                    &'a longhands::grid_template_rows::SpecifiedValue,
                pub grid_template_columns:
                    &'a longhands::grid_template_columns::SpecifiedValue,
                pub grid_template_areas:
                    &'a longhands::grid_template_areas::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut grid_template_rows =
                        None::<&'a longhands::grid_template_rows::SpecifiedValue>;
                    let mut grid_template_columns =
                        None::<&'a longhands::grid_template_columns::SpecifiedValue>;
                    let mut grid_template_areas =
                        None::<&'a longhands::grid_template_areas::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::GridTemplateRows(ref value) => {
                                grid_template_rows = Some(value)
                            },
                            PropertyDeclaration::GridTemplateColumns(ref value) => {
                                grid_template_columns = Some(value)
                            },
                            PropertyDeclaration::GridTemplateAreas(ref value) => {
                                grid_template_areas = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        grid_template_rows,
                        grid_template_columns,
                        grid_template_areas,
                ) {

                    (
                        Some(grid_template_rows),
                        Some(grid_template_columns),
                        Some(grid_template_areas),
                    ) =>
                    Ok(LonghandsToSerialize {
                            grid_template_rows,
                            grid_template_columns,
                            grid_template_areas,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::GridTemplateRows(
                        longhands.grid_template_rows
                    ));
                    declarations.push(PropertyDeclaration::GridTemplateColumns(
                        longhands.grid_template_columns
                    ));
                    declarations.push(PropertyDeclaration::GridTemplateAreas(
                        longhands.grid_template_areas
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::parser::Parse;
    use servo_arc::Arc;
    use crate::values::generics::grid::{TrackSize, TrackList};
    use crate::values::generics::grid::{TrackListValue, concat_serialize_idents};
    use crate::values::specified::{GridTemplateComponent, GenericGridTemplateComponent};
    use crate::values::specified::grid::parse_line_names;
    use crate::values::specified::position::{GridTemplateAreas, TemplateAreasParser, TemplateAreasArc};

    /// Parsing for `<grid-template>` shorthand (also used by `grid` shorthand).
    pub fn parse_grid_template<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<(GridTemplateComponent, GridTemplateComponent, GridTemplateAreas), ParseError<'i>> {
        // Other shorthand sub properties also parse the `none` keyword and this shorthand
        // should know after this keyword there is nothing to parse. Otherwise it gets
        // confused and rejects the sub properties that contains `none`.
        
            if let Ok(x) = input.try_parse(|i| {
                if i.try_parse(|i| i.expect_ident_matching("none")).is_ok() {
                    if !i.is_exhausted() {
                        return Err(());
                    }
                    return Ok((GenericGridTemplateComponent::None, GenericGridTemplateComponent::None, GridTemplateAreas::None));
                }
                Err(())
            }) {
                return Ok(x);
            }

        let first_line_names = input.try_parse(parse_line_names).unwrap_or_default();
        let mut areas_parser = TemplateAreasParser::default();
        if areas_parser.try_parse_string(input).is_ok() {
            let mut values = vec![];
            let mut line_names = vec![];
            line_names.push(first_line_names);
            loop {
                let size = input.try_parse(|i| TrackSize::parse(context, i)).unwrap_or_default();
                values.push(TrackListValue::TrackSize(size));
                let mut names = input.try_parse(parse_line_names).unwrap_or_default();
                let more_names = input.try_parse(parse_line_names);

                match areas_parser.try_parse_string(input) {
                    Ok(()) => {
                        if let Ok(v) = more_names {
                            // We got `[names] [more_names] "string"` - merge the two name lists.
                            let mut names_vec = names.into_vec();
                            names_vec.extend(v.into_iter());
                            names = names_vec.into();
                        }
                        line_names.push(names);
                    },
                    Err(e) => {
                        if more_names.is_ok() {
                            // We've parsed `"string" [names] [more_names]` but then failed to parse another `"string"`.
                            // The grammar doesn't allow two trailing `<line-names>` so this is an invalid value.
                            return Err(e);
                        }
                        // only the named area determines whether we should bail out
                        line_names.push(names);
                        break
                    },
                };
            }

            if line_names.len() == values.len() {
                // should be one longer than track sizes
                line_names.push(Default::default());
            }

            let template_areas = areas_parser.finish()
                .map_err(|()| input.new_custom_error(StyleParseErrorKind::UnspecifiedError))?;
            let template_rows = TrackList {
                values: values.into(),
                line_names: line_names.into(),
                auto_repeat_index: std::usize::MAX,
            };

            let template_cols = if input.try_parse(|i| i.expect_delim('/')).is_ok() {
                let value = GridTemplateComponent::parse_without_none(context, input)?;
                if let GenericGridTemplateComponent::TrackList(ref list) = value {
                    if !list.is_explicit() {
                        return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
                    }
                }

                value
            } else {
                GridTemplateComponent::default()
            };

            Ok((
                GenericGridTemplateComponent::TrackList(Box::new(template_rows)),
                template_cols,
                GridTemplateAreas::Areas(TemplateAreasArc(Arc::new(template_areas)))
            ))
        } else {
            let mut template_rows = GridTemplateComponent::parse(context, input)?;
            if let GenericGridTemplateComponent::TrackList(ref mut list) = template_rows {
                // Fist line names are parsed already and it shouldn't be parsed again.
                // If line names are not empty, that means given property value is not acceptable
                if list.line_names[0].is_empty() {
                    list.line_names[0] = first_line_names;      // won't panic
                } else {
                    return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError));
                }
            }

            input.expect_delim('/')?;
            Ok((template_rows, GridTemplateComponent::parse(context, input)?, GridTemplateAreas::None))
        }
    }

    #[inline]
    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (rows, columns, areas) = parse_grid_template(context, input)?;
        Ok(expanded! {
            grid_template_rows: rows,
            grid_template_columns: columns,
            grid_template_areas: areas,
        })
    }

    /// Serialization for `<grid-template>` shorthand (also used by `grid` shorthand).
    pub fn serialize_grid_template<W>(
        template_rows: &GridTemplateComponent,
        template_columns: &GridTemplateComponent,
        template_areas: &GridTemplateAreas,
        dest: &mut CssWriter<W>,
    ) -> fmt::Result
    where
        W: Write {
        match *template_areas {
            GridTemplateAreas::None => {
                if template_rows.is_initial() && template_columns.is_initial() {
                    return GridTemplateComponent::default().to_css(dest);
                }
                template_rows.to_css(dest)?;
                dest.write_str(" / ")?;
                template_columns.to_css(dest)
            },
            GridTemplateAreas::Areas(ref areas) => {
                // The length of template-area and template-rows values should be equal.
                if areas.0.strings.len() != template_rows.track_list_len() {
                    return Ok(());
                }

                let track_list = match *template_rows {
                    GenericGridTemplateComponent::TrackList(ref list) => {
                        // We should fail if there is a `repeat` function.
                        // `grid` and `grid-template` shorthands doesn't accept
                        // that. Only longhand accepts.
                        if !list.is_explicit() {
                            return Ok(());
                        }
                        list
                    },
                    // Others template components shouldn't exist with normal shorthand values.
                    // But if we need to serialize a group of longhand sub-properties for
                    // the shorthand, we should be able to return empty string instead of crashing.
                    _ => return Ok(()),
                };

                // We need to check some values that longhand accepts but shorthands don't.
                match *template_columns {
                    // We should fail if there is a `repeat` function. `grid` and
                    // `grid-template` shorthands doesn't accept that. Only longhand accepts that.
                    GenericGridTemplateComponent::TrackList(ref list) => {
                        if !list.is_explicit() {
                            return Ok(());
                        }
                    },
                    // Also the shorthands don't accept subgrids unlike longhand.
                    // We should fail without an error here.
                    GenericGridTemplateComponent::Subgrid(_) => {
                        return Ok(());
                    },
                    _ => {},
                }

                let mut names_iter = track_list.line_names.iter();
                for (((i, string), names), value) in areas.0.strings.iter().enumerate()
                                                                  .zip(&mut names_iter)
                                                                  .zip(track_list.values.iter()) {
                    if i > 0 {
                        dest.write_char(' ')?;
                    }

                    if !names.is_empty() {
                        concat_serialize_idents("[", "] ", names, " ", dest)?;
                    }

                    string.to_css(dest)?;

                    // If the track size is the initial value then it's redundant here.
                    if !value.is_initial() {
                        dest.write_char(' ')?;
                        value.to_css(dest)?;
                    }
                }

                if let Some(names) = names_iter.next() {
                    concat_serialize_idents(" [", "]", names, " ", dest)?;
                }

                if let GenericGridTemplateComponent::TrackList(ref list) = *template_columns {
                    dest.write_str(" / ")?;
                    list.to_css(dest)?;
                }

                Ok(())
            },
        }
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        #[inline]
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            serialize_grid_template(
                self.grid_template_rows,
                self.grid_template_columns,
                self.grid_template_areas,
                dest
            )
        }
    }

    }




    /// https://drafts.csswg.org/css-grid/#propdef-grid
    pub mod grid {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub grid_template_rows:
                    longhands::grid_template_rows::SpecifiedValue
                    ,
                pub grid_template_columns:
                    longhands::grid_template_columns::SpecifiedValue
                    ,
                pub grid_template_areas:
                    longhands::grid_template_areas::SpecifiedValue
                    ,
                pub grid_auto_rows:
                    longhands::grid_auto_rows::SpecifiedValue
                    ,
                pub grid_auto_columns:
                    longhands::grid_auto_columns::SpecifiedValue
                    ,
                pub grid_auto_flow:
                    longhands::grid_auto_flow::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub grid_template_rows:
                    &'a longhands::grid_template_rows::SpecifiedValue,
                pub grid_template_columns:
                    &'a longhands::grid_template_columns::SpecifiedValue,
                pub grid_template_areas:
                    &'a longhands::grid_template_areas::SpecifiedValue,
                pub grid_auto_rows:
                    &'a longhands::grid_auto_rows::SpecifiedValue,
                pub grid_auto_columns:
                    &'a longhands::grid_auto_columns::SpecifiedValue,
                pub grid_auto_flow:
                    &'a longhands::grid_auto_flow::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut grid_template_rows =
                        None::<&'a longhands::grid_template_rows::SpecifiedValue>;
                    let mut grid_template_columns =
                        None::<&'a longhands::grid_template_columns::SpecifiedValue>;
                    let mut grid_template_areas =
                        None::<&'a longhands::grid_template_areas::SpecifiedValue>;
                    let mut grid_auto_rows =
                        None::<&'a longhands::grid_auto_rows::SpecifiedValue>;
                    let mut grid_auto_columns =
                        None::<&'a longhands::grid_auto_columns::SpecifiedValue>;
                    let mut grid_auto_flow =
                        None::<&'a longhands::grid_auto_flow::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::GridTemplateRows(ref value) => {
                                grid_template_rows = Some(value)
                            },
                            PropertyDeclaration::GridTemplateColumns(ref value) => {
                                grid_template_columns = Some(value)
                            },
                            PropertyDeclaration::GridTemplateAreas(ref value) => {
                                grid_template_areas = Some(value)
                            },
                            PropertyDeclaration::GridAutoRows(ref value) => {
                                grid_auto_rows = Some(value)
                            },
                            PropertyDeclaration::GridAutoColumns(ref value) => {
                                grid_auto_columns = Some(value)
                            },
                            PropertyDeclaration::GridAutoFlow(ref value) => {
                                grid_auto_flow = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        grid_template_rows,
                        grid_template_columns,
                        grid_template_areas,
                        grid_auto_rows,
                        grid_auto_columns,
                        grid_auto_flow,
                ) {

                    (
                        Some(grid_template_rows),
                        Some(grid_template_columns),
                        Some(grid_template_areas),
                        Some(grid_auto_rows),
                        Some(grid_auto_columns),
                        Some(grid_auto_flow),
                    ) =>
                    Ok(LonghandsToSerialize {
                            grid_template_rows,
                            grid_template_columns,
                            grid_template_areas,
                            grid_auto_rows,
                            grid_auto_columns,
                            grid_auto_flow,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::GridTemplateRows(
                        longhands.grid_template_rows
                    ));
                    declarations.push(PropertyDeclaration::GridTemplateColumns(
                        longhands.grid_template_columns
                    ));
                    declarations.push(PropertyDeclaration::GridTemplateAreas(
                        longhands.grid_template_areas
                    ));
                    declarations.push(PropertyDeclaration::GridAutoRows(
                        longhands.grid_auto_rows
                    ));
                    declarations.push(PropertyDeclaration::GridAutoColumns(
                        longhands.grid_auto_columns
                    ));
                    declarations.push(PropertyDeclaration::GridAutoFlow(
                        longhands.grid_auto_flow
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::parser::Parse;
    use crate::properties::longhands::{grid_auto_columns, grid_auto_rows, grid_auto_flow};
    use crate::values::generics::grid::GridTemplateComponent;
    use crate::values::specified::{GenericGridTemplateComponent, ImplicitGridTracks};
    use crate::values::specified::position::{GridAutoFlow, GridTemplateAreas};

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let mut temp_rows = GridTemplateComponent::default();
        let mut temp_cols = GridTemplateComponent::default();
        let mut temp_areas = GridTemplateAreas::None;
        let mut auto_rows = ImplicitGridTracks::default();
        let mut auto_cols = ImplicitGridTracks::default();
        let mut flow = grid_auto_flow::get_initial_value();

        fn parse_auto_flow<'i, 't>(
            input: &mut Parser<'i, 't>,
            is_row: bool,
        ) -> Result<GridAutoFlow, ParseError<'i>> {
            let mut track = None;
            let mut dense = GridAutoFlow::empty();

            for _ in 0..2 {
                if input.try_parse(|i| i.expect_ident_matching("auto-flow")).is_ok() {
                    track = if is_row {
                        Some(GridAutoFlow::ROW)
                    } else {
                        Some(GridAutoFlow::COLUMN)
                    };
                } else if input.try_parse(|i| i.expect_ident_matching("dense")).is_ok() {
                    dense = GridAutoFlow::DENSE
                } else {
                    break
                }
            }

            if track.is_some() {
                Ok(track.unwrap() | dense)
            } else {
                Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
            }
        }

        if let Ok((rows, cols, areas)) = input.try_parse(|i| super::grid_template::parse_grid_template(context, i)) {
            temp_rows = rows;
            temp_cols = cols;
            temp_areas = areas;
        } else if let Ok(rows) = input.try_parse(|i| GridTemplateComponent::parse(context, i)) {
            temp_rows = rows;
            input.expect_delim('/')?;
            flow = parse_auto_flow(input, false)?;
            auto_cols = input.try_parse(|i| grid_auto_columns::parse(context, i)).unwrap_or_default();
        } else {
            flow = parse_auto_flow(input, true)?;
            auto_rows = input.try_parse(|i| grid_auto_rows::parse(context, i)).unwrap_or_default();
            input.expect_delim('/')?;
            temp_cols = GridTemplateComponent::parse(context, input)?;
        }

        Ok(expanded! {
            grid_template_rows: temp_rows,
            grid_template_columns: temp_cols,
            grid_template_areas: temp_areas,
            grid_auto_rows: auto_rows,
            grid_auto_columns: auto_cols,
            grid_auto_flow: flow,
        })
    }

    impl<'a> LonghandsToSerialize<'a> {
        /// Returns true if other sub properties except template-{rows,columns} are initial.
        fn is_grid_template(&self) -> bool {
            self.grid_auto_rows.is_initial() &&
            self.grid_auto_columns.is_initial() &&
            *self.grid_auto_flow == grid_auto_flow::get_initial_value()
        }
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            if self.is_grid_template() {
                return super::grid_template::serialize_grid_template(
                    self.grid_template_rows,
                    self.grid_template_columns,
                    self.grid_template_areas,
                    dest
                );
            }

            if *self.grid_template_areas != GridTemplateAreas::None {
                // No other syntax can set the template areas, so fail to
                // serialize.
                return Ok(());
            }

            if self.grid_auto_flow.contains(GridAutoFlow::COLUMN) {
                // It should fail to serialize if other branch of the if condition's values are set.
                if !self.grid_auto_rows.is_initial() ||
                    !self.grid_template_columns.is_initial() {
                    return Ok(());
                }

                // It should fail to serialize if template-rows value is not Explicit.
                if let GenericGridTemplateComponent::TrackList(ref list) = *self.grid_template_rows {
                    if !list.is_explicit() {
                        return Ok(());
                    }
                }

                self.grid_template_rows.to_css(dest)?;
                dest.write_str(" / auto-flow")?;
                if self.grid_auto_flow.contains(GridAutoFlow::DENSE) {
                    dest.write_str(" dense")?;
                }

                if !self.grid_auto_columns.is_initial() {
                    dest.write_char(' ')?;
                    self.grid_auto_columns.to_css(dest)?;
                }

                return Ok(());
            }

            // It should fail to serialize if other branch of the if condition's values are set.
            if !self.grid_auto_columns.is_initial() ||
                !self.grid_template_rows.is_initial() {
                return Ok(());
            }

            // It should fail to serialize if template-column value is not Explicit.
            if let GenericGridTemplateComponent::TrackList(ref list) = *self.grid_template_columns {
                if !list.is_explicit() {
                    return Ok(());
                }
            }

            dest.write_str("auto-flow")?;
            if self.grid_auto_flow.contains(GridAutoFlow::DENSE) {
                dest.write_str(" dense")?;
            }

            if !self.grid_auto_rows.is_initial() {
                dest.write_char(' ')?;
                self.grid_auto_rows.to_css(dest)?;
            }

            dest.write_str(" / ")?;
            self.grid_template_columns.to_css(dest)?;
            Ok(())
        }
    }

    }




    /// https://drafts.csswg.org/css-align/#propdef-place-content
    pub mod place_content {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub align_content:
                    longhands::align_content::SpecifiedValue
                    ,
                pub justify_content:
                    longhands::justify_content::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub align_content:
                    &'a longhands::align_content::SpecifiedValue,
                pub justify_content:
                    &'a longhands::justify_content::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut align_content =
                        None::<&'a longhands::align_content::SpecifiedValue>;
                    let mut justify_content =
                        None::<&'a longhands::justify_content::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::AlignContent(ref value) => {
                                align_content = Some(value)
                            },
                            PropertyDeclaration::JustifyContent(ref value) => {
                                justify_content = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        align_content,
                        justify_content,
                ) {

                    (
                        Some(align_content),
                        Some(justify_content),
                    ) =>
                    Ok(LonghandsToSerialize {
                            align_content,
                            justify_content,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::AlignContent(
                        longhands.align_content
                    ));
                    declarations.push(PropertyDeclaration::JustifyContent(
                        longhands.justify_content
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::specified::align::ContentDistribution;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let align_content = ContentDistribution::parse_block(context, input)?;
        let justify_content = input.try_parse(|input| ContentDistribution::parse_inline(context, input));

        let justify_content = match justify_content {
            Ok(v) => v,
            Err(..) => {
                // https://drafts.csswg.org/css-align-3/#place-content:
                //
                //   The second value is assigned to justify-content; if
                //   omitted, it is copied from the first value, unless that
                //   value is a <baseline-position> in which case it is
                //   defaulted to start.
                //
                if !align_content.is_baseline_position() {
                    align_content
                } else {
                    ContentDistribution::start()
                }
            }
        };

        Ok(expanded! {
            align_content: align_content,
            justify_content: justify_content,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            self.align_content.to_css(dest)?;
            if self.align_content != self.justify_content {
                dest.write_char(' ')?;
                self.justify_content.to_css(dest)?;
            }
            Ok(())
        }
    }

    }




    /// https://drafts.csswg.org/css-align/#place-self-property
    pub mod place_self {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub align_self:
                    longhands::align_self::SpecifiedValue
                    ,
                pub justify_self:
                    longhands::justify_self::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub align_self:
                    &'a longhands::align_self::SpecifiedValue,
                pub justify_self:
                    &'a longhands::justify_self::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut align_self =
                        None::<&'a longhands::align_self::SpecifiedValue>;
                    let mut justify_self =
                        None::<&'a longhands::justify_self::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::AlignSelf(ref value) => {
                                align_self = Some(value)
                            },
                            PropertyDeclaration::JustifySelf(ref value) => {
                                justify_self = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        align_self,
                        justify_self,
                ) {

                    (
                        Some(align_self),
                        Some(justify_self),
                    ) =>
                    Ok(LonghandsToSerialize {
                            align_self,
                            justify_self,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::AlignSelf(
                        longhands.align_self
                    ));
                    declarations.push(PropertyDeclaration::JustifySelf(
                        longhands.justify_self
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::specified::align::SelfAlignment;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let align = SelfAlignment::parse_block(context, input)?;
        let justify = input.try_parse(|input| SelfAlignment::parse_inline(context, input));

        let justify = match justify {
            Ok(v) => v,
            Err(..) => {
                debug_assert!(align.is_valid_on_both_axes());
                align
            }
        };

        Ok(expanded! {
            align_self: align,
            justify_self: justify,
        })
    }
    impl<'a> ToCss for LonghandsToSerialize<'a> {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            self.align_self.to_css(dest)?;
            if self.align_self != self.justify_self {
                dest.write_char(' ')?;
                self.justify_self.to_css(dest)?;
            }
            Ok(())
        }
    }

    }




    /// https://drafts.csswg.org/css-align/#place-items-property
    pub mod place_items {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub align_items:
                    longhands::align_items::SpecifiedValue
                    ,
                pub justify_items:
                    longhands::justify_items::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub align_items:
                    &'a longhands::align_items::SpecifiedValue,
                pub justify_items:
                    &'a longhands::justify_items::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut align_items =
                        None::<&'a longhands::align_items::SpecifiedValue>;
                    let mut justify_items =
                        None::<&'a longhands::justify_items::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::AlignItems(ref value) => {
                                align_items = Some(value)
                            },
                            PropertyDeclaration::JustifyItems(ref value) => {
                                justify_items = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        align_items,
                        justify_items,
                ) {

                    (
                        Some(align_items),
                        Some(justify_items),
                    ) =>
                    Ok(LonghandsToSerialize {
                            align_items,
                            justify_items,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::AlignItems(
                        longhands.align_items
                    ));
                    declarations.push(PropertyDeclaration::JustifyItems(
                        longhands.justify_items
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::values::specified::align::{ItemPlacement, JustifyItems};

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let align = ItemPlacement::parse_block(context, input)?;
        let justify =
            input.try_parse(|input| ItemPlacement::parse_inline(context, input))
                 .unwrap_or_else(|_| align.clone());

        Ok(expanded! {
            align_items: align,
            justify_items: JustifyItems(justify),
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a> {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            self.align_items.to_css(dest)?;
            if *self.align_items != self.justify_items.0 {
                dest.write_char(' ')?;
                self.justify_items.to_css(dest)?;
            }
            Ok(())
        }
    }

    }






// See https://github.com/w3c/csswg-drafts/issues/3525 for the quirks stuff.

    
    

    /// https://drafts.csswg.org/css-logical/#propdef-inset
    pub mod inset {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub top:
                    longhands::top::SpecifiedValue
                    ,
                pub right:
                    longhands::right::SpecifiedValue
                    ,
                pub bottom:
                    longhands::bottom::SpecifiedValue
                    ,
                pub left:
                    longhands::left::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub top:
                    &'a longhands::top::SpecifiedValue,
                pub right:
                    &'a longhands::right::SpecifiedValue,
                pub bottom:
                    &'a longhands::bottom::SpecifiedValue,
                pub left:
                    &'a longhands::left::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut top =
                        None::<&'a longhands::top::SpecifiedValue>;
                    let mut right =
                        None::<&'a longhands::right::SpecifiedValue>;
                    let mut bottom =
                        None::<&'a longhands::bottom::SpecifiedValue>;
                    let mut left =
                        None::<&'a longhands::left::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::Top(ref value) => {
                                top = Some(value)
                            },
                            PropertyDeclaration::Right(ref value) => {
                                right = Some(value)
                            },
                            PropertyDeclaration::Bottom(ref value) => {
                                bottom = Some(value)
                            },
                            PropertyDeclaration::Left(ref value) => {
                                left = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        top,
                        right,
                        bottom,
                        left,
                ) {

                    (
                        Some(top),
                        Some(right),
                        Some(bottom),
                        Some(left),
                    ) =>
                    Ok(LonghandsToSerialize {
                            top,
                            right,
                            bottom,
                            left,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::Top(
                        longhands.top
                    ));
                    declarations.push(PropertyDeclaration::Right(
                        longhands.right
                    ));
                    declarations.push(PropertyDeclaration::Bottom(
                        longhands.bottom
                    ));
                    declarations.push(PropertyDeclaration::Left(
                        longhands.left
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
        #[allow(unused_imports)]
        use crate::parser::Parse;
        use crate::values::generics::rect::Rect;
        #[allow(unused_imports)]
        use crate::values::specified;

        fn parse_value<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<Longhands, ParseError<'i>> {
            let rect = Rect::parse_with(context, input, |c, i| -> Result<
                crate::properties::longhands::top::SpecifiedValue,
                ParseError<'i>
            > {
                specified::Inset::parse(c, i)
            })?;
            Ok(expanded! {
                    top: rect.0,
                    right: rect.1,
                    bottom: rect.2,
                    left: rect.3,
            })
        }

        impl<'a> ToCss for LonghandsToSerialize<'a> {
            fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result
            where
                W: Write,
            {
                let rect = Rect::new(
                    &self.top,
                    &self.right,
                    &self.bottom,
                    &self.left,
                );
                rect.to_css(dest)
            }
        }
    
    }






    /// https://drafts.csswg.org/css-logical/#propdef-inset-block
    pub mod inset_block {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub inset_block_start:
                    longhands::inset_block_start::SpecifiedValue
                    ,
                pub inset_block_end:
                    longhands::inset_block_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub inset_block_start:
                    &'a longhands::inset_block_start::SpecifiedValue,
                pub inset_block_end:
                    &'a longhands::inset_block_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut inset_block_start =
                        None::<&'a longhands::inset_block_start::SpecifiedValue>;
                    let mut inset_block_end =
                        None::<&'a longhands::inset_block_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::InsetBlockStart(ref value) => {
                                inset_block_start = Some(value)
                            },
                            PropertyDeclaration::InsetBlockEnd(ref value) => {
                                inset_block_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        inset_block_start,
                        inset_block_end,
                ) {

                    (
                        Some(inset_block_start),
                        Some(inset_block_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            inset_block_start,
                            inset_block_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::InsetBlockStart(
                        longhands.inset_block_start
                    ));
                    declarations.push(PropertyDeclaration::InsetBlockEnd(
                        longhands.inset_block_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    #[allow(unused_imports)]
    use crate::parser::Parse;
    #[allow(unused_imports)]
    use crate::values::specified;

    fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let parse_one = |c: &ParserContext, input: &mut Parser<'i, 't>| -> Result<
            crate::properties::longhands::inset_block_start::SpecifiedValue,
            ParseError<'i>
        > {
            specified::Inset::parse(c, input)
        };

        let first = parse_one(context, input)?;
        let second =
            input.try_parse(|input| parse_one(context, input)).unwrap_or_else(|_| first.clone());
        Ok(expanded! {
            inset_block_start: first,
            inset_block_end: second,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let first = &self.inset_block_start;
            let second = &self.inset_block_end;

            first.to_css(dest)?;
            if first != second {
                dest.write_char(' ')?;
                second.to_css(dest)?;
            }
            Ok(())
        }
    }

    }






    /// https://drafts.csswg.org/css-logical/#propdef-inset-inline
    pub mod inset_inline {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub inset_inline_start:
                    longhands::inset_inline_start::SpecifiedValue
                    ,
                pub inset_inline_end:
                    longhands::inset_inline_end::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub inset_inline_start:
                    &'a longhands::inset_inline_start::SpecifiedValue,
                pub inset_inline_end:
                    &'a longhands::inset_inline_end::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut inset_inline_start =
                        None::<&'a longhands::inset_inline_start::SpecifiedValue>;
                    let mut inset_inline_end =
                        None::<&'a longhands::inset_inline_end::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::InsetInlineStart(ref value) => {
                                inset_inline_start = Some(value)
                            },
                            PropertyDeclaration::InsetInlineEnd(ref value) => {
                                inset_inline_end = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        inset_inline_start,
                        inset_inline_end,
                ) {

                    (
                        Some(inset_inline_start),
                        Some(inset_inline_end),
                    ) =>
                    Ok(LonghandsToSerialize {
                            inset_inline_start,
                            inset_inline_end,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::InsetInlineStart(
                        longhands.inset_inline_start
                    ));
                    declarations.push(PropertyDeclaration::InsetInlineEnd(
                        longhands.inset_inline_end
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    #[allow(unused_imports)]
    use crate::parser::Parse;
    #[allow(unused_imports)]
    use crate::values::specified;

    fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let parse_one = |c: &ParserContext, input: &mut Parser<'i, 't>| -> Result<
            crate::properties::longhands::inset_inline_start::SpecifiedValue,
            ParseError<'i>
        > {
            specified::Inset::parse(c, input)
        };

        let first = parse_one(context, input)?;
        let second =
            input.try_parse(|input| parse_one(context, input)).unwrap_or_else(|_| first.clone());
        Ok(expanded! {
            inset_inline_start: first,
            inset_inline_end: second,
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            let first = &self.inset_inline_start;
            let second = &self.inset_inline_end;

            first.to_css(dest)?;
            if first != second {
                dest.write_char(' ')?;
                second.to_css(dest)?;
            }
            Ok(())
        }
    }

    }









    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */











    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





    /// https://drafts.csswg.org/css-text-decor/#propdef-text-decoration
    pub mod text_decoration {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub text_decoration_color:
                    longhands::text_decoration_color::SpecifiedValue
                    ,
                pub text_decoration_line:
                    longhands::text_decoration_line::SpecifiedValue
                    ,
                pub text_decoration_style:
                    longhands::text_decoration_style::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub text_decoration_color:
                    &'a longhands::text_decoration_color::SpecifiedValue,
                pub text_decoration_line:
                    &'a longhands::text_decoration_line::SpecifiedValue,
                pub text_decoration_style:
                    &'a longhands::text_decoration_style::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut text_decoration_color =
                        None::<&'a longhands::text_decoration_color::SpecifiedValue>;
                    let mut text_decoration_line =
                        None::<&'a longhands::text_decoration_line::SpecifiedValue>;
                    let mut text_decoration_style =
                        None::<&'a longhands::text_decoration_style::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::TextDecorationColor(ref value) => {
                                text_decoration_color = Some(value)
                            },
                            PropertyDeclaration::TextDecorationLine(ref value) => {
                                text_decoration_line = Some(value)
                            },
                            PropertyDeclaration::TextDecorationStyle(ref value) => {
                                text_decoration_style = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        text_decoration_color,
                        text_decoration_line,
                        text_decoration_style,
                ) {

                    (
                        Some(text_decoration_color),
                        Some(text_decoration_line),
                        Some(text_decoration_style),
                    ) =>
                    Ok(LonghandsToSerialize {
                            text_decoration_color,
                            text_decoration_line,
                            text_decoration_style,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::TextDecorationColor(
                        longhands.text_decoration_color
                    ));
                    declarations.push(PropertyDeclaration::TextDecorationLine(
                        longhands.text_decoration_line
                    ));
                    declarations.push(PropertyDeclaration::TextDecorationStyle(
                        longhands.text_decoration_style
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::properties::longhands::{text_decoration_color, text_decoration_line, text_decoration_style};


    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        let (mut line, mut style, mut color, mut any) = (None, None, None, false);

        loop {
            macro_rules! parse_component {
                ($value:ident, $module:ident) => (
                    if $value.is_none() {
                        if let Ok(value) = input.try_parse(|input| $module::parse(context, input)) {
                            $value = Some(value);
                            any = true;
                            continue;
                        }
                    }
                )
            }

            parse_component!(line, text_decoration_line);
            parse_component!(style, text_decoration_style);
            parse_component!(color, text_decoration_color);


            break;
        }

        if !any {
            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError));
        }

        Ok(expanded! {
            text_decoration_line: unwrap_or_initial!(text_decoration_line, line),
            text_decoration_style: unwrap_or_initial!(text_decoration_style, style),
            text_decoration_color: unwrap_or_initial!(text_decoration_color, color),

        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        #[allow(unused)]
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            use crate::values::specified::TextDecorationLine;
            use crate::values::specified::Color;

            let (is_solid_style, is_current_color) =
            (
                *self.text_decoration_style == text_decoration_style::SpecifiedValue::Solid,
                *self.text_decoration_color == Color::CurrentColor,
            );

                let is_auto_thickness = true;


            let mut has_value = false;
            let is_none = *self.text_decoration_line == TextDecorationLine::none();
            if (is_solid_style && is_current_color && is_auto_thickness) || !is_none {
                self.text_decoration_line.to_css(dest)?;
                has_value = true;
            }


            if !is_solid_style {
                if has_value {
                    dest.write_char(' ')?;
                }
                self.text_decoration_style.to_css(dest)?;
                has_value = true;
            }

            if !is_current_color {
                if has_value {
                    dest.write_char(' ')?;
                }
                self.text_decoration_color.to_css(dest)?;
                has_value = true;
            }

            Ok(())
        }
    }

    }


    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



macro_rules! try_parse_one {
    ($context: expr, $input: expr, $var: ident, $prop_module: ident) => {
        if $var.is_none() {
            if let Ok(value) = $input.try_parse(|i| {
                $prop_module::single_value::parse($context, i)
            }) {
                $var = Some(value);
                continue;
            }
        }
    };
}



    /// https://drafts.csswg.org/css-transitions/#propdef-transition
    pub mod transition {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub transition_property:
                    longhands::transition_property::SpecifiedValue
                    ,
                pub transition_duration:
                    longhands::transition_duration::SpecifiedValue
                    ,
                pub transition_timing_function:
                    longhands::transition_timing_function::SpecifiedValue
                    ,
                pub transition_delay:
                    longhands::transition_delay::SpecifiedValue
                    ,
                pub transition_behavior:
                    longhands::transition_behavior::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub transition_property:
                    &'a longhands::transition_property::SpecifiedValue,
                pub transition_duration:
                    &'a longhands::transition_duration::SpecifiedValue,
                pub transition_timing_function:
                    &'a longhands::transition_timing_function::SpecifiedValue,
                pub transition_delay:
                    &'a longhands::transition_delay::SpecifiedValue,
                pub transition_behavior:
                    &'a longhands::transition_behavior::SpecifiedValue,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut transition_property =
                        None::<&'a longhands::transition_property::SpecifiedValue>;
                    let mut transition_duration =
                        None::<&'a longhands::transition_duration::SpecifiedValue>;
                    let mut transition_timing_function =
                        None::<&'a longhands::transition_timing_function::SpecifiedValue>;
                    let mut transition_delay =
                        None::<&'a longhands::transition_delay::SpecifiedValue>;
                    let mut transition_behavior =
                        None::<&'a longhands::transition_behavior::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::TransitionProperty(ref value) => {
                                transition_property = Some(value)
                            },
                            PropertyDeclaration::TransitionDuration(ref value) => {
                                transition_duration = Some(value)
                            },
                            PropertyDeclaration::TransitionTimingFunction(ref value) => {
                                transition_timing_function = Some(value)
                            },
                            PropertyDeclaration::TransitionDelay(ref value) => {
                                transition_delay = Some(value)
                            },
                            PropertyDeclaration::TransitionBehavior(ref value) => {
                                transition_behavior = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        transition_property,
                        transition_duration,
                        transition_timing_function,
                        transition_delay,
                        transition_behavior,
                ) {

                    (
                        Some(transition_property),
                        Some(transition_duration),
                        Some(transition_timing_function),
                        Some(transition_delay),
                        Some(transition_behavior),
                    ) =>
                    Ok(LonghandsToSerialize {
                            transition_property,
                            transition_duration,
                            transition_timing_function,
                            transition_delay,
                            transition_behavior,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::TransitionProperty(
                        longhands.transition_property
                    ));
                    declarations.push(PropertyDeclaration::TransitionDuration(
                        longhands.transition_duration
                    ));
                    declarations.push(PropertyDeclaration::TransitionTimingFunction(
                        longhands.transition_timing_function
                    ));
                    declarations.push(PropertyDeclaration::TransitionDelay(
                        longhands.transition_delay
                    ));
                    declarations.push(PropertyDeclaration::TransitionBehavior(
                        longhands.transition_behavior
                    ));
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    use crate::parser::Parse;
    use crate::properties::longhands::transition_delay;
    use crate::properties::longhands::transition_duration;
    use crate::properties::longhands::transition_property;
    use crate::properties::longhands::transition_timing_function;
    use crate::properties::longhands::transition_behavior;
    use crate::values::specified::TransitionProperty;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        struct SingleTransition {
            transition_property: transition_property::SingleSpecifiedValue,
            transition_duration: transition_duration::SingleSpecifiedValue,
            transition_timing_function: transition_timing_function::SingleSpecifiedValue,
            transition_delay: transition_delay::SingleSpecifiedValue,
            transition_behavior: transition_behavior::SingleSpecifiedValue,
        }

        fn parse_one_transition<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
            first: bool,
        ) -> Result<SingleTransition,ParseError<'i>> {
            let mut property = None;
            let mut duration = None;
            let mut timing_function = None;
            let mut delay = None;
            let mut behavior = None;

            let mut parsed = 0;
            loop {
                parsed += 1;

                try_parse_one!(context, input, duration, transition_duration);
                try_parse_one!(context, input, timing_function, transition_timing_function);
                try_parse_one!(context, input, delay, transition_delay);
                try_parse_one!(context, input, behavior, transition_behavior);
                // Must check 'transition-property' after 'transition-timing-function' since
                // 'transition-property' accepts any keyword.
                if property.is_none() {
                    if let Ok(value) = input.try_parse(|i| TransitionProperty::parse(context, i)) {
                        property = Some(value);
                        continue;
                    }

                    // 'none' is not a valid value for <single-transition-property>,
                    // so it's only acceptable as the first item.
                    if first && input.try_parse(|i| i.expect_ident_matching("none")).is_ok() {
                        property = Some(TransitionProperty::none());
                        continue;
                    }
                }

                parsed -= 1;
                break
            }

            if parsed != 0 {
                Ok(SingleTransition {
                    transition_property: property.unwrap_or_else(transition_property::single_value
                                                                                 ::get_initial_specified_value),
                    transition_duration: duration.unwrap_or_else(transition_duration::single_value
                                                                                 ::get_initial_specified_value),
                    transition_timing_function: timing_function.unwrap_or_else(transition_timing_function::single_value
                                                                                 ::get_initial_specified_value),
                    transition_delay: delay.unwrap_or_else(transition_delay::single_value
                                                                                 ::get_initial_specified_value),
                    transition_behavior: behavior.unwrap_or_else(transition_behavior::single_value
                                                                                 ::get_initial_specified_value),
                })
            } else {
                Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
            }
        }

        let mut propertys = Vec::new();
        let mut durations = Vec::new();
        let mut timing_functions = Vec::new();
        let mut delays = Vec::new();
        let mut behaviors = Vec::new();

        let mut first = true;
        let mut has_transition_property_none = false;
        let results = input.parse_comma_separated(|i| {
            if has_transition_property_none {
                // If you specify transition-property: none, multiple items are invalid.
                return Err(i.new_custom_error(StyleParseErrorKind::UnspecifiedError))
            }
            let transition = parse_one_transition(context, i, first)?;
            first = false;
            has_transition_property_none = transition.transition_property.is_none();
            Ok(transition)
        })?;
        for result in results {
            propertys.push(result.transition_property);
            durations.push(result.transition_duration);
            timing_functions.push(result.transition_timing_function);
            delays.push(result.transition_delay);
            behaviors.push(result.transition_behavior);
        }

        Ok(expanded! {
            transition_property: transition_property::SpecifiedValue(propertys.into()),
            transition_duration: transition_duration::SpecifiedValue(durations.into()),
            transition_timing_function: transition_timing_function::SpecifiedValue(timing_functions.into()),
            transition_delay: transition_delay::SpecifiedValue(delays.into()),
            transition_behavior: transition_behavior::SpecifiedValue(behaviors.into()),
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            use crate::Zero;
            use style_traits::values::SequenceWriter;

            let property_len = self.transition_property.0.len();

            // There are two cases that we can do shorthand serialization:
            // * when all value lists have the same length, or
            // * when transition-property is none, and other value lists have exactly one item.
            if property_len == 0 {
                    if self.transition_duration.0.len() != 1 {
                        return Ok(());
                    }
                    if self.transition_delay.0.len() != 1 {
                        return Ok(());
                    }
                    if self.transition_timing_function.0.len() != 1 {
                        return Ok(());
                    }

                if self.transition_behavior.0.len() != 1 {
                    return Ok(());
                }
            } else {
                    if self.transition_duration.0.len() != property_len {
                        return Ok(());
                    }
                    if self.transition_delay.0.len() != property_len {
                        return Ok(());
                    }
                    if self.transition_timing_function.0.len() != property_len {
                        return Ok(());
                    }

                if self.transition_behavior.0.len() != property_len {
                    return Ok(());
                }
            }

            // Representative length.
            let len = self.transition_duration.0.len();

            for i in 0..len {
                if i != 0 {
                    dest.write_str(", ")?;
                }

                let has_duration = !self.transition_duration.0[i].is_zero();
                let has_timing = !self.transition_timing_function.0[i].is_ease();
                let has_delay = !self.transition_delay.0[i].is_zero();
                let has_behavior = !self.transition_behavior.0[i].is_normal();
                let has_any = has_duration || has_timing || has_delay || has_behavior;

                let mut writer = SequenceWriter::new(dest, " ");

                if property_len == 0 {
                    writer.raw_item("none")?;
                } else if !self.transition_property.0[i].is_all() || !has_any {
                    writer.item(&self.transition_property.0[i])?;
                }

                // In order to avoid ambiguity, we have to serialize duration if we have delay.
                if has_duration || has_delay {
                    writer.item(&self.transition_duration.0[i])?;
                }

                if has_timing {
                    writer.item(&self.transition_timing_function.0[i])?;
                }

                if has_delay {
                    writer.item(&self.transition_delay.0[i])?;
                }

                if has_behavior {
                    writer.item(&self.transition_behavior.0[i])?;
                }
            }
            Ok(())
        }
    }

    }




    /// https://drafts.csswg.org/css-animations/#propdef-animation
    pub mod animation {
        use cssparser::Parser;
        use crate::parser::ParserContext;
        use crate::properties::{PropertyDeclaration, SourcePropertyDeclaration, MaybeBoxed, longhands};
        #[allow(unused_imports)]
        use selectors::parser::SelectorParseErrorKind;
        #[allow(unused_imports)]
        use std::fmt::{self, Write};
        #[allow(unused_imports)]
        use style_traits::{ParseError, StyleParseErrorKind};
        #[allow(unused_imports)]
        use style_traits::{CssWriter, KeywordsCollectFn, SpecifiedValueInfo, ToCss};

        #[derive(SpecifiedValueInfo)]
        pub struct Longhands {
                pub animation_name:
                    longhands::animation_name::SpecifiedValue
                    ,
                pub animation_duration:
                    longhands::animation_duration::SpecifiedValue
                    ,
                pub animation_timing_function:
                    longhands::animation_timing_function::SpecifiedValue
                    ,
                pub animation_delay:
                    longhands::animation_delay::SpecifiedValue
                    ,
                pub animation_iteration_count:
                    longhands::animation_iteration_count::SpecifiedValue
                    ,
                pub animation_direction:
                    longhands::animation_direction::SpecifiedValue
                    ,
                pub animation_fill_mode:
                    longhands::animation_fill_mode::SpecifiedValue
                    ,
                pub animation_play_state:
                    longhands::animation_play_state::SpecifiedValue
                    ,
                pub animation_timeline:
                    longhands::animation_timeline::SpecifiedValue
                    ,
        }

        /// Represents a serializable set of all of the longhand properties that
        /// correspond to a shorthand.
        pub struct LonghandsToSerialize<'a> {
                pub animation_name:
                    &'a longhands::animation_name::SpecifiedValue,
                pub animation_duration:
                    &'a longhands::animation_duration::SpecifiedValue,
                pub animation_timing_function:
                    &'a longhands::animation_timing_function::SpecifiedValue,
                pub animation_delay:
                    &'a longhands::animation_delay::SpecifiedValue,
                pub animation_iteration_count:
                    &'a longhands::animation_iteration_count::SpecifiedValue,
                pub animation_direction:
                    &'a longhands::animation_direction::SpecifiedValue,
                pub animation_fill_mode:
                    &'a longhands::animation_fill_mode::SpecifiedValue,
                pub animation_play_state:
                    &'a longhands::animation_play_state::SpecifiedValue,
                pub animation_timeline:
                    Option<
                    &'a longhands::animation_timeline::SpecifiedValue,
                    >,
        }

        impl<'a> LonghandsToSerialize<'a> {
            /// Tries to get a serializable set of longhands given a set of
            /// property declarations.
            pub fn from_iter(iter: impl Iterator<Item = &'a PropertyDeclaration>) -> Result<Self, ()> {
                // Define all of the expected variables that correspond to the shorthand
                    let mut animation_name =
                        None::<&'a longhands::animation_name::SpecifiedValue>;
                    let mut animation_duration =
                        None::<&'a longhands::animation_duration::SpecifiedValue>;
                    let mut animation_timing_function =
                        None::<&'a longhands::animation_timing_function::SpecifiedValue>;
                    let mut animation_delay =
                        None::<&'a longhands::animation_delay::SpecifiedValue>;
                    let mut animation_iteration_count =
                        None::<&'a longhands::animation_iteration_count::SpecifiedValue>;
                    let mut animation_direction =
                        None::<&'a longhands::animation_direction::SpecifiedValue>;
                    let mut animation_fill_mode =
                        None::<&'a longhands::animation_fill_mode::SpecifiedValue>;
                    let mut animation_play_state =
                        None::<&'a longhands::animation_play_state::SpecifiedValue>;
                    let mut animation_timeline =
                        None::<&'a longhands::animation_timeline::SpecifiedValue>;

                // Attempt to assign the incoming declarations to the expected variables
                for declaration in iter {
                    match *declaration {
                            PropertyDeclaration::AnimationName(ref value) => {
                                animation_name = Some(value)
                            },
                            PropertyDeclaration::AnimationDuration(ref value) => {
                                animation_duration = Some(value)
                            },
                            PropertyDeclaration::AnimationTimingFunction(ref value) => {
                                animation_timing_function = Some(value)
                            },
                            PropertyDeclaration::AnimationDelay(ref value) => {
                                animation_delay = Some(value)
                            },
                            PropertyDeclaration::AnimationIterationCount(ref value) => {
                                animation_iteration_count = Some(value)
                            },
                            PropertyDeclaration::AnimationDirection(ref value) => {
                                animation_direction = Some(value)
                            },
                            PropertyDeclaration::AnimationFillMode(ref value) => {
                                animation_fill_mode = Some(value)
                            },
                            PropertyDeclaration::AnimationPlayState(ref value) => {
                                animation_play_state = Some(value)
                            },
                            PropertyDeclaration::AnimationTimeline(ref value) => {
                                animation_timeline = Some(value)
                            },
                        _ => {}
                    };
                }

                // If any of the expected variables are missing, return an error
                match (
                        animation_name,
                        animation_duration,
                        animation_timing_function,
                        animation_delay,
                        animation_iteration_count,
                        animation_direction,
                        animation_fill_mode,
                        animation_play_state,
                        animation_timeline,
                ) {

                    (
                        Some(animation_name),
                        Some(animation_duration),
                        Some(animation_timing_function),
                        Some(animation_delay),
                        Some(animation_iteration_count),
                        Some(animation_direction),
                        Some(animation_fill_mode),
                        Some(animation_play_state),
                        animation_timeline,
                    ) =>
                    Ok(LonghandsToSerialize {
                            animation_name,
                            animation_duration,
                            animation_timing_function,
                            animation_delay,
                            animation_iteration_count,
                            animation_direction,
                            animation_fill_mode,
                            animation_play_state,
                            animation_timeline,
                    }),
                    _ => Err(())
                }
            }
        }

        /// Parse the given shorthand and fill the result into the
        /// `declarations` vector.
        pub fn parse_into<'i, 't>(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>> {
            #[allow(unused_imports)]
            use crate::properties::{NonCustomPropertyId, LonghandId};
            input.parse_entirely(|input| parse_value(context, input)).map(|longhands| {
                    declarations.push(PropertyDeclaration::AnimationName(
                        longhands.animation_name
                    ));
                    declarations.push(PropertyDeclaration::AnimationDuration(
                        longhands.animation_duration
                    ));
                    declarations.push(PropertyDeclaration::AnimationTimingFunction(
                        longhands.animation_timing_function
                    ));
                    declarations.push(PropertyDeclaration::AnimationDelay(
                        longhands.animation_delay
                    ));
                    declarations.push(PropertyDeclaration::AnimationIterationCount(
                        longhands.animation_iteration_count
                    ));
                    declarations.push(PropertyDeclaration::AnimationDirection(
                        longhands.animation_direction
                    ));
                    declarations.push(PropertyDeclaration::AnimationFillMode(
                        longhands.animation_fill_mode
                    ));
                    declarations.push(PropertyDeclaration::AnimationPlayState(
                        longhands.animation_play_state
                    ));
                if NonCustomPropertyId::from(LonghandId::AnimationTimeline)
                    .allowed_in_ignoring_rule_type(context) {
                    declarations.push(PropertyDeclaration::AnimationTimeline(
                        longhands.animation_timeline
                    ));
                }
            })
        }

        /// Try to serialize a given shorthand to a string.
        pub fn to_css(declarations: &[&PropertyDeclaration], dest: &mut style_traits::CssStringWriter) -> fmt::Result {
            match LonghandsToSerialize::from_iter(declarations.iter().cloned()) {
                Ok(longhands) => longhands.to_css(&mut CssWriter::new(dest)),
                Err(_) => Ok(())
            }
        }

        
    
    use crate::properties::longhands::animation_name;
    use crate::properties::longhands::animation_duration;
    use crate::properties::longhands::animation_timing_function;
    use crate::properties::longhands::animation_delay;
    use crate::properties::longhands::animation_iteration_count;
    use crate::properties::longhands::animation_direction;
    use crate::properties::longhands::animation_fill_mode;
    use crate::properties::longhands::animation_play_state;
    use crate::properties::longhands::animation_timeline;

    pub fn parse_value<'i, 't>(
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<Longhands, ParseError<'i>> {
        struct SingleAnimation {
            animation_name: animation_name::SingleSpecifiedValue,
            animation_duration: animation_duration::SingleSpecifiedValue,
            animation_timing_function: animation_timing_function::SingleSpecifiedValue,
            animation_delay: animation_delay::SingleSpecifiedValue,
            animation_iteration_count: animation_iteration_count::SingleSpecifiedValue,
            animation_direction: animation_direction::SingleSpecifiedValue,
            animation_fill_mode: animation_fill_mode::SingleSpecifiedValue,
            animation_play_state: animation_play_state::SingleSpecifiedValue,
        }

        fn parse_one_animation<'i, 't>(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<SingleAnimation, ParseError<'i>> {
            let mut name = None;
            let mut duration = None;
            let mut timing_function = None;
            let mut delay = None;
            let mut iteration_count = None;
            let mut direction = None;
            let mut fill_mode = None;
            let mut play_state = None;

            let mut parsed = 0;
            // NB: Name must be the last one here so that keywords valid for other
            // longhands are not interpreted as names.
            //
            // Also, duration must be before delay, see
            // https://drafts.csswg.org/css-animations/#typedef-single-animation
            loop {
                parsed += 1;
                try_parse_one!(context, input, duration, animation_duration);
                try_parse_one!(context, input, timing_function, animation_timing_function);
                try_parse_one!(context, input, delay, animation_delay);
                try_parse_one!(context, input, iteration_count, animation_iteration_count);
                try_parse_one!(context, input, direction, animation_direction);
                try_parse_one!(context, input, fill_mode, animation_fill_mode);
                try_parse_one!(context, input, play_state, animation_play_state);
                try_parse_one!(context, input, name, animation_name);

                // Note: per spec issue discussion, all animation longhands not defined in
                // Animations 1 are defined as reset-only sub-properties for now.
                // https://github.com/w3c/csswg-drafts/issues/6946#issuecomment-1233190360
                //
                // FIXME: Bug 1824261. We should revisit this when the spec gets updated with the
                // new syntax.
                // https://github.com/w3c/csswg-drafts/issues/6946

                parsed -= 1;
                break
            }

            // If nothing is parsed, this is an invalid entry.
            if parsed == 0 {
                Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
            } else {
                Ok(SingleAnimation {
                    animation_name: name.unwrap_or_else(animation_name::single_value
                                                              ::get_initial_specified_value),
                    animation_duration: duration.unwrap_or_else(animation_duration::single_value
                                                              ::get_initial_specified_value),
                    animation_timing_function: timing_function.unwrap_or_else(animation_timing_function::single_value
                                                              ::get_initial_specified_value),
                    animation_delay: delay.unwrap_or_else(animation_delay::single_value
                                                              ::get_initial_specified_value),
                    animation_iteration_count: iteration_count.unwrap_or_else(animation_iteration_count::single_value
                                                              ::get_initial_specified_value),
                    animation_direction: direction.unwrap_or_else(animation_direction::single_value
                                                              ::get_initial_specified_value),
                    animation_fill_mode: fill_mode.unwrap_or_else(animation_fill_mode::single_value
                                                              ::get_initial_specified_value),
                    animation_play_state: play_state.unwrap_or_else(animation_play_state::single_value
                                                              ::get_initial_specified_value),
                })
            }
        }

        let mut names = vec![];
        let mut durations = vec![];
        let mut timing_functions = vec![];
        let mut delays = vec![];
        let mut iteration_counts = vec![];
        let mut directions = vec![];
        let mut fill_modes = vec![];
        let mut play_states = vec![];

        let results = input.parse_comma_separated(|i| parse_one_animation(context, i))?;
        for result in results.into_iter() {
            names.push(result.animation_name);
            durations.push(result.animation_duration);
            timing_functions.push(result.animation_timing_function);
            delays.push(result.animation_delay);
            iteration_counts.push(result.animation_iteration_count);
            directions.push(result.animation_direction);
            fill_modes.push(result.animation_fill_mode);
            play_states.push(result.animation_play_state);
        }

        Ok(expanded! {
            animation_name: animation_name::SpecifiedValue(names.into()),
            animation_duration: animation_duration::SpecifiedValue(durations.into()),
            animation_timing_function: animation_timing_function::SpecifiedValue(timing_functions.into()),
            animation_delay: animation_delay::SpecifiedValue(delays.into()),
            animation_iteration_count: animation_iteration_count::SpecifiedValue(iteration_counts.into()),
            animation_direction: animation_direction::SpecifiedValue(directions.into()),
            animation_fill_mode: animation_fill_mode::SpecifiedValue(fill_modes.into()),
            animation_play_state: animation_play_state::SpecifiedValue(play_states.into()),
            // FIXME: Bug 1824261. animation-timeline is reset-only for now.
            animation_timeline: animation_timeline::SpecifiedValue(
                vec![animation_timeline::single_value::get_initial_specified_value()].into()
            ),
        })
    }

    impl<'a> ToCss for LonghandsToSerialize<'a>  {
        fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result where W: fmt::Write {
            use crate::values::specified::easing::TimingFunction;
            use crate::values::specified::{
                AnimationDirection, AnimationFillMode, AnimationPlayState,
            };
            use crate::Zero;
            use style_traits::values::SequenceWriter;

            let len = self.animation_name.0.len();
            // There should be at least one declared value
            if len == 0 {
                return Ok(());
            }

            // If any value list length is differs then we don't do a shorthand serialization
            // either.
                if len != self.animation_duration.0.len() {
                    return Ok(())
                }
                if len != self.animation_timing_function.0.len() {
                    return Ok(())
                }
                if len != self.animation_delay.0.len() {
                    return Ok(())
                }
                if len != self.animation_iteration_count.0.len() {
                    return Ok(())
                }
                if len != self.animation_direction.0.len() {
                    return Ok(())
                }
                if len != self.animation_fill_mode.0.len() {
                    return Ok(())
                }
                if len != self.animation_play_state.0.len() {
                    return Ok(())
                }

            // FIXME: Bug 1824261. We don't serialize this shorthand if the animation-timeline is
            // speficied, per the wpt update: https://github.com/web-platform-tests/wpt/pull/38848.
            if self.animation_timeline.map_or(false, |v| v.0.len() != 1 || !v.0[0].is_auto()) {
                return Ok(());
            }

            for i in 0..len {
                if i != 0 {
                    dest.write_str(", ")?;
                }

                // We follow the order of this syntax:
                // <single-animation> =
                //   <animation-duration> ||
                //   <easing-function> ||
                //   <animation-delay> ||
                //   <single-animation-iteration-count> ||
                //   <single-animation-direction> ||
                //   <single-animation-fill-mode> ||
                //   <single-animation-play-state> ||
                //   [ none | <keyframes-name> ] ||
                //   <single-animation-timeline>
                //
                // https://drafts.csswg.org/css-animations-2/#animation-shorthand
                //
                // Note: animation-timeline is not serialized for now because it is always the
                // initial value in this loop. Therefore, animation-duration is always resolved as
                // 0s if it is auto because animation-timeline is the initial value, i.e.
                // time-driven animations. In conclusion, we don't serialize animation-duration if
                // it is auto (for specified value) or if it is 0s (for resolved value).
                // https://drafts.csswg.org/css-animations-2/#animation-duration
                let has_duration = !self.animation_duration.0[i].is_auto()
                    && !self.animation_duration.0[i].is_zero();
                let has_timing_function = !self.animation_timing_function.0[i].is_ease();
                let has_delay = !self.animation_delay.0[i].is_zero();
                let has_iteration_count = !self.animation_iteration_count.0[i].is_one();
                let has_direction =
                    !matches!(self.animation_direction.0[i], AnimationDirection::Normal);
                let has_fill_mode =
                    !matches!(self.animation_fill_mode.0[i], AnimationFillMode::None);
                let has_play_state =
                    !matches!(self.animation_play_state.0[i], AnimationPlayState::Running);
                let animation_name = &self.animation_name.0[i];
                let has_name = !animation_name.is_none();

                let mut writer = SequenceWriter::new(dest, " ");

                // To avoid ambiguity, we have to serialize duration if duration is initial
                // but delay is not. (In other words, it's ambiguous if we serialize delay only.)
                if has_duration || has_delay {
                    writer.item(&self.animation_duration.0[i])?;
                }

                if has_timing_function || TimingFunction::match_keywords(animation_name) {
                    writer.item(&self.animation_timing_function.0[i])?;
                }

                // For animation-delay and animation-iteration-count.
                if has_delay {
                    writer.item(&self.animation_delay.0[i])?;
                }
                if has_iteration_count {
                    writer.item(&self.animation_iteration_count.0[i])?;
                }

                if has_direction || AnimationDirection::match_keywords(animation_name) {
                    writer.item(&self.animation_direction.0[i])?;
                }

                if has_fill_mode || AnimationFillMode::match_keywords(animation_name) {
                    writer.item(&self.animation_fill_mode.0[i])?;
                }

                if has_play_state || AnimationPlayState::match_keywords(animation_name) {
                    writer.item(&self.animation_play_state.0[i])?;
                }

                // If all values are initial, we must serialize animation-name.
                let has_any = {
                    has_duration
                        || has_timing_function
                        || has_delay
                        || has_iteration_count
                        || has_direction
                        || has_fill_mode
                        || has_play_state
                };
                if has_name || !has_any {
                    writer.item(animation_name)?;
                }
            }
            Ok(())
        }
    }

    }






// Note: view-timeline shorthand doesn't take view-timeline-inset into account.




    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


    // We didn't define the 'all' shorthand using the regular helpers:shorthand
    // mechanism, since it causes some very large types to be generated.
    //
    // Also, make sure logical properties appear before its physical
    // counter-parts, in order to prevent bugs like:
    //
    //   https://bugzilla.mozilla.org/show_bug.cgi?id=1410028
    //
    // FIXME(emilio): Adopt the resolution from:
    //
    //   https://github.com/w3c/csswg-drafts/issues/1898
    //
    // when there is one, whatever that is.
    
}



// WARNING: It is *really* important for the variants of `LonghandId`
// and `PropertyDeclaration` to be defined in the exact same order,
// with the exception of `CSSWideKeyword`, `WithVariables` and `Custom`,
// which don't exist in `LonghandId`.



/// Servo's representation for a property declaration.
#[derive(ToShmem)]
#[repr(u16)]
pub enum PropertyDeclaration {
    /// `align-items`
    AlignItems(crate::values::specified::ItemPlacement),
    /// `aspect-ratio`
    AspectRatio(crate::values::specified::AspectRatio),
    /// `backface-visibility`
    BackfaceVisibility(longhands::backface_visibility::SpecifiedValue),
    /// `baseline-source`
    BaselineSource(crate::values::specified::BaselineSource),
    /// `border-collapse`
    BorderCollapse(longhands::border_collapse::SpecifiedValue),
    /// `border-image-repeat`
    BorderImageRepeat(crate::values::specified::BorderImageRepeat),
    /// `box-sizing`
    BoxSizing(longhands::box_sizing::SpecifiedValue),
    /// `caption-side`
    CaptionSide(crate::values::specified::table::CaptionSide),
    /// `clear`
    Clear(crate::values::specified::Clear),
    /// `column-count`
    ColumnCount(crate::values::specified::ColumnCount),
    /// `column-span`
    ColumnSpan(longhands::column_span::SpecifiedValue),
    /// `contain`
    Contain(crate::values::specified::Contain),
    /// `container-type`
    ContainerType(crate::values::specified::ContainerType),
    /// `direction`
    Direction(longhands::direction::SpecifiedValue),
    /// `display`
    Display(crate::values::specified::Display),
    /// `empty-cells`
    EmptyCells(longhands::empty_cells::SpecifiedValue),
    /// `flex-direction`
    FlexDirection(longhands::flex_direction::SpecifiedValue),
    /// `flex-wrap`
    FlexWrap(longhands::flex_wrap::SpecifiedValue),
    /// `float`
    Float(crate::values::specified::Float),
    /// `font-language-override`
    FontLanguageOverride(crate::values::specified::FontLanguageOverride),
    /// `font-stretch`
    FontStretch(crate::values::specified::FontStretch),
    /// `font-style`
    FontStyle(crate::values::specified::FontStyle),
    /// `font-synthesis-weight`
    FontSynthesisWeight(crate::values::specified::FontSynthesis),
    /// `font-variant-caps`
    FontVariantCaps(longhands::font_variant_caps::SpecifiedValue),
    /// `font-weight`
    FontWeight(crate::values::specified::FontWeight),
    /// `grid-auto-flow`
    GridAutoFlow(crate::values::specified::GridAutoFlow),
    /// `image-rendering`
    ImageRendering(crate::values::specified::ImageRendering),
    /// `isolation`
    Isolation(longhands::isolation::SpecifiedValue),
    /// `justify-items`
    JustifyItems(crate::values::specified::JustifyItems),
    /// `list-style-position`
    ListStylePosition(longhands::list_style_position::SpecifiedValue),
    /// `list-style-type`
    ListStyleType(longhands::list_style_type::SpecifiedValue),
    /// `mix-blend-mode`
    MixBlendMode(longhands::mix_blend_mode::SpecifiedValue),
    /// `object-fit`
    ObjectFit(longhands::object_fit::SpecifiedValue),
    /// `opacity`
    Opacity(crate::values::specified::Opacity),
    /// `order`
    Order(crate::values::specified::Integer),
    /// `outline-style`
    OutlineStyle(crate::values::specified::OutlineStyle),
    /// `overflow-wrap`
    OverflowWrap(crate::values::specified::OverflowWrap),
    /// `pointer-events`
    PointerEvents(crate::values::specified::PointerEvents),
    /// `position`
    Position(crate::values::specified::PositionProperty),
    /// `position-area`
    PositionArea(crate::values::specified::PositionArea),
    /// `-servo-overflow-clip-box`
    ServoOverflowClipBox(longhands::_servo_overflow_clip_box::SpecifiedValue),
    /// `-servo-top-layer`
    ServoTopLayer(longhands::_servo_top_layer::SpecifiedValue),
    /// `table-layout`
    TableLayout(longhands::table_layout::SpecifiedValue),
    /// `text-align`
    TextAlign(crate::values::specified::TextAlign),
    /// `text-align-last`
    TextAlignLast(crate::values::specified::TextAlignLast),
    /// `text-decoration-line`
    TextDecorationLine(crate::values::specified::TextDecorationLine),
    /// `text-decoration-style`
    TextDecorationStyle(longhands::text_decoration_style::SpecifiedValue),
    /// `text-justify`
    TextJustify(crate::values::specified::TextJustify),
    /// `text-rendering`
    TextRendering(longhands::text_rendering::SpecifiedValue),
    /// `text-transform`
    TextTransform(crate::values::specified::TextTransform),
    /// `text-wrap-mode`
    TextWrapMode(longhands::text_wrap_mode::SpecifiedValue),
    /// `transform-style`
    TransformStyle(crate::values::specified::TransformStyle),
    /// `unicode-bidi`
    UnicodeBidi(longhands::unicode_bidi::SpecifiedValue),
    /// `visibility`
    Visibility(longhands::visibility::SpecifiedValue),
    /// `white-space-collapse`
    WhiteSpaceCollapse(longhands::white_space_collapse::SpecifiedValue),
    /// `word-break`
    WordBreak(crate::values::specified::WordBreak),
    /// `writing-mode`
    WritingMode(crate::values::specified::WritingModeProperty),
    /// `z-index`
    ZIndex(crate::values::specified::ZIndex),
    /// `zoom`
    Zoom(crate::values::specified::Zoom),
    /// `align-content`
    AlignContent(crate::values::specified::ContentDistribution),
    /// `justify-content`
    JustifyContent(crate::values::specified::ContentDistribution),
    /// `flex-grow`
    FlexGrow(crate::values::specified::NonNegativeNumber),
    /// `flex-shrink`
    FlexShrink(crate::values::specified::NonNegativeNumber),
    /// `align-self`
    AlignSelf(crate::values::specified::SelfAlignment),
    /// `justify-self`
    JustifySelf(crate::values::specified::SelfAlignment),
    /// `overflow-block`
    OverflowBlock(crate::values::specified::Overflow),
    /// `overflow-inline`
    OverflowInline(crate::values::specified::Overflow),
    /// `overflow-x`
    OverflowX(crate::values::specified::Overflow),
    /// `overflow-y`
    OverflowY(crate::values::specified::Overflow),
    /// `border-block-end-style`
    BorderBlockEndStyle(crate::values::specified::BorderStyle),
    /// `border-block-start-style`
    BorderBlockStartStyle(crate::values::specified::BorderStyle),
    /// `border-bottom-style`
    BorderBottomStyle(crate::values::specified::BorderStyle),
    /// `border-inline-end-style`
    BorderInlineEndStyle(crate::values::specified::BorderStyle),
    /// `border-inline-start-style`
    BorderInlineStartStyle(crate::values::specified::BorderStyle),
    /// `border-left-style`
    BorderLeftStyle(crate::values::specified::BorderStyle),
    /// `border-right-style`
    BorderRightStyle(crate::values::specified::BorderStyle),
    /// `border-top-style`
    BorderTopStyle(crate::values::specified::BorderStyle),
    /// `animation-composition`
    AnimationComposition(longhands::animation_composition::SpecifiedValue),
    /// `animation-delay`
    AnimationDelay(longhands::animation_delay::SpecifiedValue),
    /// `animation-direction`
    AnimationDirection(longhands::animation_direction::SpecifiedValue),
    /// `animation-duration`
    AnimationDuration(longhands::animation_duration::SpecifiedValue),
    /// `animation-fill-mode`
    AnimationFillMode(longhands::animation_fill_mode::SpecifiedValue),
    /// `animation-iteration-count`
    AnimationIterationCount(longhands::animation_iteration_count::SpecifiedValue),
    /// `animation-name`
    AnimationName(longhands::animation_name::SpecifiedValue),
    /// `animation-play-state`
    AnimationPlayState(longhands::animation_play_state::SpecifiedValue),
    /// `animation-timeline`
    AnimationTimeline(longhands::animation_timeline::SpecifiedValue),
    /// `animation-timing-function`
    AnimationTimingFunction(longhands::animation_timing_function::SpecifiedValue),
    /// `backdrop-filter`
    BackdropFilter(longhands::backdrop_filter::SpecifiedValue),
    /// `background-attachment`
    BackgroundAttachment(longhands::background_attachment::SpecifiedValue),
    /// `background-clip`
    BackgroundClip(longhands::background_clip::SpecifiedValue),
    /// `background-image`
    BackgroundImage(longhands::background_image::SpecifiedValue),
    /// `background-origin`
    BackgroundOrigin(longhands::background_origin::SpecifiedValue),
    /// `background-position-x`
    BackgroundPositionX(longhands::background_position_x::SpecifiedValue),
    /// `background-position-y`
    BackgroundPositionY(longhands::background_position_y::SpecifiedValue),
    /// `background-repeat`
    BackgroundRepeat(longhands::background_repeat::SpecifiedValue),
    /// `background-size`
    BackgroundSize(longhands::background_size::SpecifiedValue),
    /// `border-image-outset`
    BorderImageOutset(Box<crate::values::specified::NonNegativeLengthOrNumberRect>),
    /// `border-image-slice`
    BorderImageSlice(Box<crate::values::specified::BorderImageSlice>),
    /// `border-image-width`
    BorderImageWidth(Box<crate::values::specified::BorderImageWidth>),
    /// `border-spacing`
    BorderSpacing(Box<crate::values::specified::BorderSpacing>),
    /// `box-shadow`
    BoxShadow(longhands::box_shadow::SpecifiedValue),
    /// `clip`
    Clip(Box<crate::values::specified::ClipRectOrAuto>),
    /// `clip-path`
    ClipPath(crate::values::specified::basic_shape::ClipPath),
    /// `color`
    Color(crate::values::specified::ColorPropertyValue),
    /// `color-scheme`
    ColorScheme(crate::values::specified::ColorScheme),
    /// `column-width`
    ColumnWidth(crate::values::specified::length::NonNegativeLengthOrAuto),
    /// `container-name`
    ContainerName(crate::values::specified::ContainerName),
    /// `content`
    Content(crate::values::specified::Content),
    /// `counter-increment`
    CounterIncrement(crate::values::specified::CounterIncrement),
    /// `counter-reset`
    CounterReset(crate::values::specified::CounterReset),
    /// `cursor`
    Cursor(crate::values::specified::Cursor),
    /// `filter`
    Filter(longhands::filter::SpecifiedValue),
    /// `flex-basis`
    FlexBasis(Box<crate::values::specified::FlexBasis>),
    /// `font-family`
    FontFamily(crate::values::specified::FontFamily),
    /// `font-size`
    FontSize(crate::values::specified::FontSize),
    /// `font-variation-settings`
    FontVariationSettings(crate::values::specified::FontVariationSettings),
    /// `grid-template-areas`
    GridTemplateAreas(crate::values::specified::GridTemplateAreas),
    /// `letter-spacing`
    LetterSpacing(crate::values::specified::LetterSpacing),
    /// `line-height`
    LineHeight(crate::values::specified::LineHeight),
    /// `mask-image`
    MaskImage(longhands::mask_image::SpecifiedValue),
    /// `offset-path`
    OffsetPath(crate::values::specified::OffsetPath),
    /// `outline-offset`
    OutlineOffset(crate::values::specified::BorderSideOffset),
    /// `overflow-clip-margin`
    OverflowClipMargin(crate::values::specified::Length),
    /// `perspective`
    Perspective(crate::values::specified::Perspective),
    /// `quotes`
    Quotes(crate::values::specified::Quotes),
    /// `rotate`
    Rotate(Box<crate::values::specified::Rotate>),
    /// `scale`
    Scale(Box<crate::values::specified::Scale>),
    /// `text-indent`
    TextIndent(crate::values::specified::TextIndent),
    /// `text-overflow`
    TextOverflow(Box<crate::values::specified::TextOverflow>),
    /// `text-shadow`
    TextShadow(longhands::text_shadow::SpecifiedValue),
    /// `transform`
    Transform(crate::values::specified::Transform),
    /// `transform-origin`
    TransformOrigin(Box<crate::values::specified::TransformOrigin>),
    /// `transition-behavior`
    TransitionBehavior(longhands::transition_behavior::SpecifiedValue),
    /// `transition-delay`
    TransitionDelay(longhands::transition_delay::SpecifiedValue),
    /// `transition-duration`
    TransitionDuration(longhands::transition_duration::SpecifiedValue),
    /// `transition-property`
    TransitionProperty(longhands::transition_property::SpecifiedValue),
    /// `transition-timing-function`
    TransitionTimingFunction(longhands::transition_timing_function::SpecifiedValue),
    /// `translate`
    Translate(Box<crate::values::specified::Translate>),
    /// `vertical-align`
    VerticalAlign(crate::values::specified::VerticalAlign),
    /// `view-transition-class`
    ViewTransitionClass(crate::values::specified::ViewTransitionClass),
    /// `view-transition-name`
    ViewTransitionName(crate::values::specified::ViewTransitionName),
    /// `will-change`
    WillChange(crate::values::specified::WillChange),
    /// `word-spacing`
    WordSpacing(crate::values::specified::WordSpacing),
    /// `-x-lang`
    XLang(crate::values::specified::XLang),
    /// `object-position`
    ObjectPosition(Box<crate::values::specified::Position>),
    /// `perspective-origin`
    PerspectiveOrigin(Box<crate::values::specified::Position>),
    /// `grid-template-columns`
    GridTemplateColumns(crate::values::specified::GridTemplateComponent),
    /// `grid-template-rows`
    GridTemplateRows(crate::values::specified::GridTemplateComponent),
    /// `border-image-source`
    BorderImageSource(crate::values::specified::Image),
    /// `list-style-image`
    ListStyleImage(crate::values::specified::Image),
    /// `grid-auto-columns`
    GridAutoColumns(crate::values::specified::ImplicitGridTracks),
    /// `grid-auto-rows`
    GridAutoRows(crate::values::specified::ImplicitGridTracks),
    /// `column-gap`
    ColumnGap(crate::values::specified::length::NonNegativeLengthPercentageOrNormal),
    /// `row-gap`
    RowGap(crate::values::specified::length::NonNegativeLengthPercentageOrNormal),
    /// `grid-column-end`
    GridColumnEnd(crate::values::specified::GridLine),
    /// `grid-column-start`
    GridColumnStart(crate::values::specified::GridLine),
    /// `grid-row-end`
    GridRowEnd(crate::values::specified::GridLine),
    /// `grid-row-start`
    GridRowStart(crate::values::specified::GridLine),
    /// `max-block-size`
    MaxBlockSize(crate::values::specified::MaxSize),
    /// `max-height`
    MaxHeight(crate::values::specified::MaxSize),
    /// `max-inline-size`
    MaxInlineSize(crate::values::specified::MaxSize),
    /// `max-width`
    MaxWidth(crate::values::specified::MaxSize),
    /// `border-bottom-left-radius`
    BorderBottomLeftRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `border-bottom-right-radius`
    BorderBottomRightRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `border-end-end-radius`
    BorderEndEndRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `border-end-start-radius`
    BorderEndStartRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `border-start-end-radius`
    BorderStartEndRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `border-start-start-radius`
    BorderStartStartRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `border-top-left-radius`
    BorderTopLeftRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `border-top-right-radius`
    BorderTopRightRadius(Box<crate::values::specified::BorderCornerRadius>),
    /// `bottom`
    Bottom(crate::values::specified::Inset),
    /// `inset-block-end`
    InsetBlockEnd(crate::values::specified::Inset),
    /// `inset-block-start`
    InsetBlockStart(crate::values::specified::Inset),
    /// `inset-inline-end`
    InsetInlineEnd(crate::values::specified::Inset),
    /// `inset-inline-start`
    InsetInlineStart(crate::values::specified::Inset),
    /// `left`
    Left(crate::values::specified::Inset),
    /// `right`
    Right(crate::values::specified::Inset),
    /// `top`
    Top(crate::values::specified::Inset),
    /// `margin-block-end`
    MarginBlockEnd(crate::values::specified::Margin),
    /// `margin-block-start`
    MarginBlockStart(crate::values::specified::Margin),
    /// `margin-bottom`
    MarginBottom(crate::values::specified::Margin),
    /// `margin-inline-end`
    MarginInlineEnd(crate::values::specified::Margin),
    /// `margin-inline-start`
    MarginInlineStart(crate::values::specified::Margin),
    /// `margin-left`
    MarginLeft(crate::values::specified::Margin),
    /// `margin-right`
    MarginRight(crate::values::specified::Margin),
    /// `margin-top`
    MarginTop(crate::values::specified::Margin),
    /// `padding-block-end`
    PaddingBlockEnd(crate::values::specified::NonNegativeLengthPercentage),
    /// `padding-block-start`
    PaddingBlockStart(crate::values::specified::NonNegativeLengthPercentage),
    /// `padding-bottom`
    PaddingBottom(crate::values::specified::NonNegativeLengthPercentage),
    /// `padding-inline-end`
    PaddingInlineEnd(crate::values::specified::NonNegativeLengthPercentage),
    /// `padding-inline-start`
    PaddingInlineStart(crate::values::specified::NonNegativeLengthPercentage),
    /// `padding-left`
    PaddingLeft(crate::values::specified::NonNegativeLengthPercentage),
    /// `padding-right`
    PaddingRight(crate::values::specified::NonNegativeLengthPercentage),
    /// `padding-top`
    PaddingTop(crate::values::specified::NonNegativeLengthPercentage),
    /// `block-size`
    BlockSize(crate::values::specified::Size),
    /// `height`
    Height(crate::values::specified::Size),
    /// `inline-size`
    InlineSize(crate::values::specified::Size),
    /// `min-block-size`
    MinBlockSize(crate::values::specified::Size),
    /// `min-height`
    MinHeight(crate::values::specified::Size),
    /// `min-inline-size`
    MinInlineSize(crate::values::specified::Size),
    /// `min-width`
    MinWidth(crate::values::specified::Size),
    /// `width`
    Width(crate::values::specified::Size),
    /// `border-block-end-width`
    BorderBlockEndWidth(crate::values::specified::BorderSideWidth),
    /// `border-block-start-width`
    BorderBlockStartWidth(crate::values::specified::BorderSideWidth),
    /// `border-bottom-width`
    BorderBottomWidth(crate::values::specified::BorderSideWidth),
    /// `border-inline-end-width`
    BorderInlineEndWidth(crate::values::specified::BorderSideWidth),
    /// `border-inline-start-width`
    BorderInlineStartWidth(crate::values::specified::BorderSideWidth),
    /// `border-left-width`
    BorderLeftWidth(crate::values::specified::BorderSideWidth),
    /// `border-right-width`
    BorderRightWidth(crate::values::specified::BorderSideWidth),
    /// `border-top-width`
    BorderTopWidth(crate::values::specified::BorderSideWidth),
    /// `outline-width`
    OutlineWidth(crate::values::specified::BorderSideWidth),
    /// `background-color`
    BackgroundColor(crate::values::specified::Color),
    /// `border-block-end-color`
    BorderBlockEndColor(crate::values::specified::Color),
    /// `border-block-start-color`
    BorderBlockStartColor(crate::values::specified::Color),
    /// `border-bottom-color`
    BorderBottomColor(crate::values::specified::Color),
    /// `border-inline-end-color`
    BorderInlineEndColor(crate::values::specified::Color),
    /// `border-inline-start-color`
    BorderInlineStartColor(crate::values::specified::Color),
    /// `border-left-color`
    BorderLeftColor(crate::values::specified::Color),
    /// `border-right-color`
    BorderRightColor(crate::values::specified::Color),
    /// `border-top-color`
    BorderTopColor(crate::values::specified::Color),
    /// `outline-color`
    OutlineColor(crate::values::specified::Color),
    /// `text-decoration-color`
    TextDecorationColor(crate::values::specified::Color),
    /// A CSS-wide keyword.
    CSSWideKeyword(WideKeywordDeclaration),
    /// An unparsed declaration.
    WithVariables(VariableDeclaration),
    /// A custom property declaration.
    Custom(CustomDeclaration),
}

// There's one of these for each parsed declaration so it better be small.
size_of_test!(PropertyDeclaration, 32);

#[repr(C)]
struct PropertyDeclarationVariantRepr<T> {
    tag: u16,
    value: T
}

impl Clone for PropertyDeclaration {
    #[inline]
    fn clone(&self) -> Self {
        use self::PropertyDeclaration::*;

        

        let self_tag = unsafe {
            (*(self as *const _ as *const PropertyDeclarationVariantRepr<()>)).tag
        };
        if self_tag <= LonghandId::BorderTopStyle as u16 {
            #[derive(Clone, Copy)]
            #[repr(u16)]
            enum CopyVariants {
                _AlignItems(crate::values::specified::ItemPlacement),
                _AspectRatio(crate::values::specified::AspectRatio),
                _BackfaceVisibility(longhands::backface_visibility::SpecifiedValue),
                _BaselineSource(crate::values::specified::BaselineSource),
                _BorderCollapse(longhands::border_collapse::SpecifiedValue),
                _BorderImageRepeat(crate::values::specified::BorderImageRepeat),
                _BoxSizing(longhands::box_sizing::SpecifiedValue),
                _CaptionSide(crate::values::specified::table::CaptionSide),
                _Clear(crate::values::specified::Clear),
                _ColumnCount(crate::values::specified::ColumnCount),
                _ColumnSpan(longhands::column_span::SpecifiedValue),
                _Contain(crate::values::specified::Contain),
                _ContainerType(crate::values::specified::ContainerType),
                _Direction(longhands::direction::SpecifiedValue),
                _Display(crate::values::specified::Display),
                _EmptyCells(longhands::empty_cells::SpecifiedValue),
                _FlexDirection(longhands::flex_direction::SpecifiedValue),
                _FlexWrap(longhands::flex_wrap::SpecifiedValue),
                _Float(crate::values::specified::Float),
                _FontLanguageOverride(crate::values::specified::FontLanguageOverride),
                _FontStretch(crate::values::specified::FontStretch),
                _FontStyle(crate::values::specified::FontStyle),
                _FontSynthesisWeight(crate::values::specified::FontSynthesis),
                _FontVariantCaps(longhands::font_variant_caps::SpecifiedValue),
                _FontWeight(crate::values::specified::FontWeight),
                _GridAutoFlow(crate::values::specified::GridAutoFlow),
                _ImageRendering(crate::values::specified::ImageRendering),
                _Isolation(longhands::isolation::SpecifiedValue),
                _JustifyItems(crate::values::specified::JustifyItems),
                _ListStylePosition(longhands::list_style_position::SpecifiedValue),
                _ListStyleType(longhands::list_style_type::SpecifiedValue),
                _MixBlendMode(longhands::mix_blend_mode::SpecifiedValue),
                _ObjectFit(longhands::object_fit::SpecifiedValue),
                _Opacity(crate::values::specified::Opacity),
                _Order(crate::values::specified::Integer),
                _OutlineStyle(crate::values::specified::OutlineStyle),
                _OverflowWrap(crate::values::specified::OverflowWrap),
                _PointerEvents(crate::values::specified::PointerEvents),
                _Position(crate::values::specified::PositionProperty),
                _PositionArea(crate::values::specified::PositionArea),
                _ServoOverflowClipBox(longhands::_servo_overflow_clip_box::SpecifiedValue),
                _ServoTopLayer(longhands::_servo_top_layer::SpecifiedValue),
                _TableLayout(longhands::table_layout::SpecifiedValue),
                _TextAlign(crate::values::specified::TextAlign),
                _TextAlignLast(crate::values::specified::TextAlignLast),
                _TextDecorationLine(crate::values::specified::TextDecorationLine),
                _TextDecorationStyle(longhands::text_decoration_style::SpecifiedValue),
                _TextJustify(crate::values::specified::TextJustify),
                _TextRendering(longhands::text_rendering::SpecifiedValue),
                _TextTransform(crate::values::specified::TextTransform),
                _TextWrapMode(longhands::text_wrap_mode::SpecifiedValue),
                _TransformStyle(crate::values::specified::TransformStyle),
                _UnicodeBidi(longhands::unicode_bidi::SpecifiedValue),
                _Visibility(longhands::visibility::SpecifiedValue),
                _WhiteSpaceCollapse(longhands::white_space_collapse::SpecifiedValue),
                _WordBreak(crate::values::specified::WordBreak),
                _WritingMode(crate::values::specified::WritingModeProperty),
                _ZIndex(crate::values::specified::ZIndex),
                _Zoom(crate::values::specified::Zoom),
                _AlignContent(crate::values::specified::ContentDistribution),
                _JustifyContent(crate::values::specified::ContentDistribution),
                _FlexGrow(crate::values::specified::NonNegativeNumber),
                _FlexShrink(crate::values::specified::NonNegativeNumber),
                _AlignSelf(crate::values::specified::SelfAlignment),
                _JustifySelf(crate::values::specified::SelfAlignment),
                _OverflowBlock(crate::values::specified::Overflow),
                _OverflowInline(crate::values::specified::Overflow),
                _OverflowX(crate::values::specified::Overflow),
                _OverflowY(crate::values::specified::Overflow),
                _BorderBlockEndStyle(crate::values::specified::BorderStyle),
                _BorderBlockStartStyle(crate::values::specified::BorderStyle),
                _BorderBottomStyle(crate::values::specified::BorderStyle),
                _BorderInlineEndStyle(crate::values::specified::BorderStyle),
                _BorderInlineStartStyle(crate::values::specified::BorderStyle),
                _BorderLeftStyle(crate::values::specified::BorderStyle),
                _BorderRightStyle(crate::values::specified::BorderStyle),
                _BorderTopStyle(crate::values::specified::BorderStyle),
            }

            unsafe {
                let mut out = mem::MaybeUninit::uninit();
                ptr::write(
                    out.as_mut_ptr() as *mut CopyVariants,
                    *(self as *const _ as *const CopyVariants),
                );
                return out.assume_init();
            }
        }

        // This function ensures that all properties not handled above
        // do not have a specified value implements Copy. If you hit
        // compile error here, you may want to add the type name into
        // Longhand.specified_is_copy in data.py.
        fn _static_assert_others_are_not_copy() {
            struct Helper<T>(T);
            trait AssertCopy { fn assert() {} }
            trait AssertNotCopy { fn assert() {} }
            impl<T: Copy> AssertCopy for Helper<T> {}
            impl AssertNotCopy for Helper<Box<crate::values::specified::BorderCornerRadius>> {}
            Helper::<Box<crate::values::specified::BorderCornerRadius>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::BorderImageSlice>> {}
            Helper::<Box<crate::values::specified::BorderImageSlice>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::BorderImageWidth>> {}
            Helper::<Box<crate::values::specified::BorderImageWidth>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::BorderSpacing>> {}
            Helper::<Box<crate::values::specified::BorderSpacing>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::ClipRectOrAuto>> {}
            Helper::<Box<crate::values::specified::ClipRectOrAuto>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::FlexBasis>> {}
            Helper::<Box<crate::values::specified::FlexBasis>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::NonNegativeLengthOrNumberRect>> {}
            Helper::<Box<crate::values::specified::NonNegativeLengthOrNumberRect>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::Position>> {}
            Helper::<Box<crate::values::specified::Position>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::Rotate>> {}
            Helper::<Box<crate::values::specified::Rotate>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::Scale>> {}
            Helper::<Box<crate::values::specified::Scale>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::TextOverflow>> {}
            Helper::<Box<crate::values::specified::TextOverflow>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::TransformOrigin>> {}
            Helper::<Box<crate::values::specified::TransformOrigin>>::assert();
            impl AssertNotCopy for Helper<Box<crate::values::specified::Translate>> {}
            Helper::<Box<crate::values::specified::Translate>>::assert();
            impl AssertNotCopy for Helper<CustomDeclaration> {}
            Helper::<CustomDeclaration>::assert();
            impl AssertNotCopy for Helper<VariableDeclaration> {}
            Helper::<VariableDeclaration>::assert();
            impl AssertNotCopy for Helper<WideKeywordDeclaration> {}
            Helper::<WideKeywordDeclaration>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::BorderSideOffset> {}
            Helper::<crate::values::specified::BorderSideOffset>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::BorderSideWidth> {}
            Helper::<crate::values::specified::BorderSideWidth>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Color> {}
            Helper::<crate::values::specified::Color>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::ColorPropertyValue> {}
            Helper::<crate::values::specified::ColorPropertyValue>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::ColorScheme> {}
            Helper::<crate::values::specified::ColorScheme>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::ContainerName> {}
            Helper::<crate::values::specified::ContainerName>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Content> {}
            Helper::<crate::values::specified::Content>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::CounterIncrement> {}
            Helper::<crate::values::specified::CounterIncrement>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::CounterReset> {}
            Helper::<crate::values::specified::CounterReset>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Cursor> {}
            Helper::<crate::values::specified::Cursor>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::FontFamily> {}
            Helper::<crate::values::specified::FontFamily>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::FontSize> {}
            Helper::<crate::values::specified::FontSize>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::FontVariationSettings> {}
            Helper::<crate::values::specified::FontVariationSettings>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::GridLine> {}
            Helper::<crate::values::specified::GridLine>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::GridTemplateAreas> {}
            Helper::<crate::values::specified::GridTemplateAreas>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::GridTemplateComponent> {}
            Helper::<crate::values::specified::GridTemplateComponent>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Image> {}
            Helper::<crate::values::specified::Image>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::ImplicitGridTracks> {}
            Helper::<crate::values::specified::ImplicitGridTracks>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Inset> {}
            Helper::<crate::values::specified::Inset>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Length> {}
            Helper::<crate::values::specified::Length>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::LetterSpacing> {}
            Helper::<crate::values::specified::LetterSpacing>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::LineHeight> {}
            Helper::<crate::values::specified::LineHeight>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Margin> {}
            Helper::<crate::values::specified::Margin>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::MaxSize> {}
            Helper::<crate::values::specified::MaxSize>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::NonNegativeLengthPercentage> {}
            Helper::<crate::values::specified::NonNegativeLengthPercentage>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::OffsetPath> {}
            Helper::<crate::values::specified::OffsetPath>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Perspective> {}
            Helper::<crate::values::specified::Perspective>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Quotes> {}
            Helper::<crate::values::specified::Quotes>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Size> {}
            Helper::<crate::values::specified::Size>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::TextIndent> {}
            Helper::<crate::values::specified::TextIndent>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::Transform> {}
            Helper::<crate::values::specified::Transform>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::VerticalAlign> {}
            Helper::<crate::values::specified::VerticalAlign>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::ViewTransitionClass> {}
            Helper::<crate::values::specified::ViewTransitionClass>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::ViewTransitionName> {}
            Helper::<crate::values::specified::ViewTransitionName>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::WillChange> {}
            Helper::<crate::values::specified::WillChange>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::WordSpacing> {}
            Helper::<crate::values::specified::WordSpacing>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::XLang> {}
            Helper::<crate::values::specified::XLang>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::basic_shape::ClipPath> {}
            Helper::<crate::values::specified::basic_shape::ClipPath>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::length::NonNegativeLengthOrAuto> {}
            Helper::<crate::values::specified::length::NonNegativeLengthOrAuto>::assert();
            impl AssertNotCopy for Helper<crate::values::specified::length::NonNegativeLengthPercentageOrNormal> {}
            Helper::<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>::assert();
            impl AssertNotCopy for Helper<longhands::animation_composition::SpecifiedValue> {}
            Helper::<longhands::animation_composition::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_delay::SpecifiedValue> {}
            Helper::<longhands::animation_delay::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_direction::SpecifiedValue> {}
            Helper::<longhands::animation_direction::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_duration::SpecifiedValue> {}
            Helper::<longhands::animation_duration::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_fill_mode::SpecifiedValue> {}
            Helper::<longhands::animation_fill_mode::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_iteration_count::SpecifiedValue> {}
            Helper::<longhands::animation_iteration_count::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_name::SpecifiedValue> {}
            Helper::<longhands::animation_name::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_play_state::SpecifiedValue> {}
            Helper::<longhands::animation_play_state::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_timeline::SpecifiedValue> {}
            Helper::<longhands::animation_timeline::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::animation_timing_function::SpecifiedValue> {}
            Helper::<longhands::animation_timing_function::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::backdrop_filter::SpecifiedValue> {}
            Helper::<longhands::backdrop_filter::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_attachment::SpecifiedValue> {}
            Helper::<longhands::background_attachment::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_clip::SpecifiedValue> {}
            Helper::<longhands::background_clip::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_image::SpecifiedValue> {}
            Helper::<longhands::background_image::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_origin::SpecifiedValue> {}
            Helper::<longhands::background_origin::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_position_x::SpecifiedValue> {}
            Helper::<longhands::background_position_x::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_position_y::SpecifiedValue> {}
            Helper::<longhands::background_position_y::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_repeat::SpecifiedValue> {}
            Helper::<longhands::background_repeat::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::background_size::SpecifiedValue> {}
            Helper::<longhands::background_size::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::box_shadow::SpecifiedValue> {}
            Helper::<longhands::box_shadow::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::filter::SpecifiedValue> {}
            Helper::<longhands::filter::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::mask_image::SpecifiedValue> {}
            Helper::<longhands::mask_image::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::text_shadow::SpecifiedValue> {}
            Helper::<longhands::text_shadow::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::transition_behavior::SpecifiedValue> {}
            Helper::<longhands::transition_behavior::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::transition_delay::SpecifiedValue> {}
            Helper::<longhands::transition_delay::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::transition_duration::SpecifiedValue> {}
            Helper::<longhands::transition_duration::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::transition_property::SpecifiedValue> {}
            Helper::<longhands::transition_property::SpecifiedValue>::assert();
            impl AssertNotCopy for Helper<longhands::transition_timing_function::SpecifiedValue> {}
            Helper::<longhands::transition_timing_function::SpecifiedValue>::assert();
        }

        match *self {
            AlignItems(..) |
AspectRatio(..) |
BackfaceVisibility(..) |
BaselineSource(..) |
BorderCollapse(..) |
BorderImageRepeat(..) |
BoxSizing(..) |
CaptionSide(..) |
Clear(..) |
ColumnCount(..) |
ColumnSpan(..) |
Contain(..) |
ContainerType(..) |
Direction(..) |
Display(..) |
EmptyCells(..) |
FlexDirection(..) |
FlexWrap(..) |
Float(..) |
FontLanguageOverride(..) |
FontStretch(..) |
FontStyle(..) |
FontSynthesisWeight(..) |
FontVariantCaps(..) |
FontWeight(..) |
GridAutoFlow(..) |
ImageRendering(..) |
Isolation(..) |
JustifyItems(..) |
ListStylePosition(..) |
ListStyleType(..) |
MixBlendMode(..) |
ObjectFit(..) |
Opacity(..) |
Order(..) |
OutlineStyle(..) |
OverflowWrap(..) |
PointerEvents(..) |
Position(..) |
PositionArea(..) |
ServoOverflowClipBox(..) |
ServoTopLayer(..) |
TableLayout(..) |
TextAlign(..) |
TextAlignLast(..) |
TextDecorationLine(..) |
TextDecorationStyle(..) |
TextJustify(..) |
TextRendering(..) |
TextTransform(..) |
TextWrapMode(..) |
TransformStyle(..) |
UnicodeBidi(..) |
Visibility(..) |
WhiteSpaceCollapse(..) |
WordBreak(..) |
WritingMode(..) |
ZIndex(..) |
Zoom(..) |
AlignContent(..) |
JustifyContent(..) |
FlexGrow(..) |
FlexShrink(..) |
AlignSelf(..) |
JustifySelf(..) |
OverflowBlock(..) |
OverflowInline(..) |
OverflowX(..) |
OverflowY(..) |
BorderBlockEndStyle(..) |
BorderBlockStartStyle(..) |
BorderBottomStyle(..) |
BorderInlineEndStyle(..) |
BorderInlineStartStyle(..) |
BorderLeftStyle(..) |
BorderRightStyle(..) |
BorderTopStyle(..) => {
                unsafe { debug_unreachable!() }
            }
            
            AnimationComposition(ref value) => {
                AnimationComposition(value.clone())
            }
            
            AnimationDelay(ref value) => {
                AnimationDelay(value.clone())
            }
            
            AnimationDirection(ref value) => {
                AnimationDirection(value.clone())
            }
            
            AnimationDuration(ref value) => {
                AnimationDuration(value.clone())
            }
            
            AnimationFillMode(ref value) => {
                AnimationFillMode(value.clone())
            }
            
            AnimationIterationCount(ref value) => {
                AnimationIterationCount(value.clone())
            }
            
            AnimationName(ref value) => {
                AnimationName(value.clone())
            }
            
            AnimationPlayState(ref value) => {
                AnimationPlayState(value.clone())
            }
            
            AnimationTimeline(ref value) => {
                AnimationTimeline(value.clone())
            }
            
            AnimationTimingFunction(ref value) => {
                AnimationTimingFunction(value.clone())
            }
            
            BackdropFilter(ref value) => {
                BackdropFilter(value.clone())
            }
            
            BackgroundAttachment(ref value) => {
                BackgroundAttachment(value.clone())
            }
            
            BackgroundClip(ref value) => {
                BackgroundClip(value.clone())
            }
            
            BackgroundImage(ref value) => {
                BackgroundImage(value.clone())
            }
            
            BackgroundOrigin(ref value) => {
                BackgroundOrigin(value.clone())
            }
            
            BackgroundPositionX(ref value) => {
                BackgroundPositionX(value.clone())
            }
            
            BackgroundPositionY(ref value) => {
                BackgroundPositionY(value.clone())
            }
            
            BackgroundRepeat(ref value) => {
                BackgroundRepeat(value.clone())
            }
            
            BackgroundSize(ref value) => {
                BackgroundSize(value.clone())
            }
            
            BorderImageOutset(ref value) => {
                BorderImageOutset(value.clone())
            }
            
            BorderImageSlice(ref value) => {
                BorderImageSlice(value.clone())
            }
            
            BorderImageWidth(ref value) => {
                BorderImageWidth(value.clone())
            }
            
            BorderSpacing(ref value) => {
                BorderSpacing(value.clone())
            }
            
            BoxShadow(ref value) => {
                BoxShadow(value.clone())
            }
            
            Clip(ref value) => {
                Clip(value.clone())
            }
            
            ClipPath(ref value) => {
                ClipPath(value.clone())
            }
            
            Color(ref value) => {
                Color(value.clone())
            }
            
            ColorScheme(ref value) => {
                ColorScheme(value.clone())
            }
            
            ColumnWidth(ref value) => {
                ColumnWidth(value.clone())
            }
            
            ContainerName(ref value) => {
                ContainerName(value.clone())
            }
            
            Content(ref value) => {
                Content(value.clone())
            }
            
            CounterIncrement(ref value) => {
                CounterIncrement(value.clone())
            }
            
            CounterReset(ref value) => {
                CounterReset(value.clone())
            }
            
            Cursor(ref value) => {
                Cursor(value.clone())
            }
            
            Filter(ref value) => {
                Filter(value.clone())
            }
            
            FlexBasis(ref value) => {
                FlexBasis(value.clone())
            }
            
            FontFamily(ref value) => {
                FontFamily(value.clone())
            }
            
            FontSize(ref value) => {
                FontSize(value.clone())
            }
            
            FontVariationSettings(ref value) => {
                FontVariationSettings(value.clone())
            }
            
            GridTemplateAreas(ref value) => {
                GridTemplateAreas(value.clone())
            }
            
            LetterSpacing(ref value) => {
                LetterSpacing(value.clone())
            }
            
            LineHeight(ref value) => {
                LineHeight(value.clone())
            }
            
            MaskImage(ref value) => {
                MaskImage(value.clone())
            }
            
            OffsetPath(ref value) => {
                OffsetPath(value.clone())
            }
            
            OutlineOffset(ref value) => {
                OutlineOffset(value.clone())
            }
            
            OverflowClipMargin(ref value) => {
                OverflowClipMargin(value.clone())
            }
            
            Perspective(ref value) => {
                Perspective(value.clone())
            }
            
            Quotes(ref value) => {
                Quotes(value.clone())
            }
            
            Rotate(ref value) => {
                Rotate(value.clone())
            }
            
            Scale(ref value) => {
                Scale(value.clone())
            }
            
            TextIndent(ref value) => {
                TextIndent(value.clone())
            }
            
            TextOverflow(ref value) => {
                TextOverflow(value.clone())
            }
            
            TextShadow(ref value) => {
                TextShadow(value.clone())
            }
            
            Transform(ref value) => {
                Transform(value.clone())
            }
            
            TransformOrigin(ref value) => {
                TransformOrigin(value.clone())
            }
            
            TransitionBehavior(ref value) => {
                TransitionBehavior(value.clone())
            }
            
            TransitionDelay(ref value) => {
                TransitionDelay(value.clone())
            }
            
            TransitionDuration(ref value) => {
                TransitionDuration(value.clone())
            }
            
            TransitionProperty(ref value) => {
                TransitionProperty(value.clone())
            }
            
            TransitionTimingFunction(ref value) => {
                TransitionTimingFunction(value.clone())
            }
            
            Translate(ref value) => {
                Translate(value.clone())
            }
            
            VerticalAlign(ref value) => {
                VerticalAlign(value.clone())
            }
            
            ViewTransitionClass(ref value) => {
                ViewTransitionClass(value.clone())
            }
            
            ViewTransitionName(ref value) => {
                ViewTransitionName(value.clone())
            }
            
            WillChange(ref value) => {
                WillChange(value.clone())
            }
            
            WordSpacing(ref value) => {
                WordSpacing(value.clone())
            }
            
            XLang(ref value) => {
                XLang(value.clone())
            }
            
            ObjectPosition(ref value) |
PerspectiveOrigin(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<Box<crate::values::specified::Position>>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridTemplateColumns(ref value) |
GridTemplateRows(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::GridTemplateComponent>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderImageSource(ref value) |
ListStyleImage(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Image>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridAutoColumns(ref value) |
GridAutoRows(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::ImplicitGridTracks>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            ColumnGap(ref value) |
RowGap(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridColumnEnd(ref value) |
GridColumnStart(ref value) |
GridRowEnd(ref value) |
GridRowStart(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::GridLine>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            MaxBlockSize(ref value) |
MaxHeight(ref value) |
MaxInlineSize(ref value) |
MaxWidth(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::MaxSize>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderBottomLeftRadius(ref value) |
BorderBottomRightRadius(ref value) |
BorderEndEndRadius(ref value) |
BorderEndStartRadius(ref value) |
BorderStartEndRadius(ref value) |
BorderStartStartRadius(ref value) |
BorderTopLeftRadius(ref value) |
BorderTopRightRadius(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderCornerRadius>>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            Bottom(ref value) |
InsetBlockEnd(ref value) |
InsetBlockStart(ref value) |
InsetInlineEnd(ref value) |
InsetInlineStart(ref value) |
Left(ref value) |
Right(ref value) |
Top(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Inset>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            MarginBlockEnd(ref value) |
MarginBlockStart(ref value) |
MarginBottom(ref value) |
MarginInlineEnd(ref value) |
MarginInlineStart(ref value) |
MarginLeft(ref value) |
MarginRight(ref value) |
MarginTop(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Margin>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            PaddingBlockEnd(ref value) |
PaddingBlockStart(ref value) |
PaddingBottom(ref value) |
PaddingInlineEnd(ref value) |
PaddingInlineStart(ref value) |
PaddingLeft(ref value) |
PaddingRight(ref value) |
PaddingTop(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeLengthPercentage>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BlockSize(ref value) |
Height(ref value) |
InlineSize(ref value) |
MinBlockSize(ref value) |
MinHeight(ref value) |
MinInlineSize(ref value) |
MinWidth(ref value) |
Width(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Size>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderBlockEndWidth(ref value) |
BorderBlockStartWidth(ref value) |
BorderBottomWidth(ref value) |
BorderInlineEndWidth(ref value) |
BorderInlineStartWidth(ref value) |
BorderLeftWidth(ref value) |
BorderRightWidth(ref value) |
BorderTopWidth(ref value) |
OutlineWidth(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::BorderSideWidth>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BackgroundColor(ref value) |
BorderBlockEndColor(ref value) |
BorderBlockStartColor(ref value) |
BorderBottomColor(ref value) |
BorderInlineEndColor(ref value) |
BorderInlineStartColor(ref value) |
BorderLeftColor(ref value) |
BorderRightColor(ref value) |
BorderTopColor(ref value) |
OutlineColor(ref value) |
TextDecorationColor(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Color>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            CSSWideKeyword(ref value) => {
                CSSWideKeyword(value.clone())
            }
            
            WithVariables(ref value) => {
                WithVariables(value.clone())
            }
            
            Custom(ref value) => {
                Custom(value.clone())
            }
        }
    }
}

impl PartialEq for PropertyDeclaration {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        use self::PropertyDeclaration::*;

        unsafe {
            let this_repr =
                &*(self as *const _ as *const PropertyDeclarationVariantRepr<()>);
            let other_repr =
                &*(other as *const _ as *const PropertyDeclarationVariantRepr<()>);
            if this_repr.tag != other_repr.tag {
                return false;
            }
            match *self {
                AlignItems(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ItemPlacement>);
                    *this == other_repr.value
                }
                AspectRatio(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::AspectRatio>);
                    *this == other_repr.value
                }
                BackfaceVisibility(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::backface_visibility::SpecifiedValue>);
                    *this == other_repr.value
                }
                BaselineSource(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BaselineSource>);
                    *this == other_repr.value
                }
                BorderCollapse(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::border_collapse::SpecifiedValue>);
                    *this == other_repr.value
                }
                BorderImageRepeat(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderImageRepeat>);
                    *this == other_repr.value
                }
                BoxSizing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::box_sizing::SpecifiedValue>);
                    *this == other_repr.value
                }
                CaptionSide(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::table::CaptionSide>);
                    *this == other_repr.value
                }
                Clear(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Clear>);
                    *this == other_repr.value
                }
                ColumnCount(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ColumnCount>);
                    *this == other_repr.value
                }
                ColumnSpan(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::column_span::SpecifiedValue>);
                    *this == other_repr.value
                }
                Contain(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Contain>);
                    *this == other_repr.value
                }
                ContainerType(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ContainerType>);
                    *this == other_repr.value
                }
                Direction(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::direction::SpecifiedValue>);
                    *this == other_repr.value
                }
                Display(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Display>);
                    *this == other_repr.value
                }
                EmptyCells(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::empty_cells::SpecifiedValue>);
                    *this == other_repr.value
                }
                FlexDirection(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::flex_direction::SpecifiedValue>);
                    *this == other_repr.value
                }
                FlexWrap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::flex_wrap::SpecifiedValue>);
                    *this == other_repr.value
                }
                Float(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Float>);
                    *this == other_repr.value
                }
                FontLanguageOverride(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontLanguageOverride>);
                    *this == other_repr.value
                }
                FontStretch(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontStretch>);
                    *this == other_repr.value
                }
                FontStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontStyle>);
                    *this == other_repr.value
                }
                FontSynthesisWeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontSynthesis>);
                    *this == other_repr.value
                }
                FontVariantCaps(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::font_variant_caps::SpecifiedValue>);
                    *this == other_repr.value
                }
                FontWeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontWeight>);
                    *this == other_repr.value
                }
                GridAutoFlow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridAutoFlow>);
                    *this == other_repr.value
                }
                ImageRendering(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ImageRendering>);
                    *this == other_repr.value
                }
                Isolation(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::isolation::SpecifiedValue>);
                    *this == other_repr.value
                }
                JustifyItems(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::JustifyItems>);
                    *this == other_repr.value
                }
                ListStylePosition(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::list_style_position::SpecifiedValue>);
                    *this == other_repr.value
                }
                ListStyleType(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::list_style_type::SpecifiedValue>);
                    *this == other_repr.value
                }
                MixBlendMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::mix_blend_mode::SpecifiedValue>);
                    *this == other_repr.value
                }
                ObjectFit(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::object_fit::SpecifiedValue>);
                    *this == other_repr.value
                }
                Opacity(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Opacity>);
                    *this == other_repr.value
                }
                Order(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Integer>);
                    *this == other_repr.value
                }
                OutlineStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::OutlineStyle>);
                    *this == other_repr.value
                }
                OverflowWrap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::OverflowWrap>);
                    *this == other_repr.value
                }
                PointerEvents(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::PointerEvents>);
                    *this == other_repr.value
                }
                Position(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::PositionProperty>);
                    *this == other_repr.value
                }
                PositionArea(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::PositionArea>);
                    *this == other_repr.value
                }
                ServoOverflowClipBox(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::_servo_overflow_clip_box::SpecifiedValue>);
                    *this == other_repr.value
                }
                ServoTopLayer(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::_servo_top_layer::SpecifiedValue>);
                    *this == other_repr.value
                }
                TableLayout(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::table_layout::SpecifiedValue>);
                    *this == other_repr.value
                }
                TextAlign(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextAlign>);
                    *this == other_repr.value
                }
                TextAlignLast(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextAlignLast>);
                    *this == other_repr.value
                }
                TextDecorationLine(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextDecorationLine>);
                    *this == other_repr.value
                }
                TextDecorationStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_decoration_style::SpecifiedValue>);
                    *this == other_repr.value
                }
                TextJustify(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextJustify>);
                    *this == other_repr.value
                }
                TextRendering(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_rendering::SpecifiedValue>);
                    *this == other_repr.value
                }
                TextTransform(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextTransform>);
                    *this == other_repr.value
                }
                TextWrapMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_wrap_mode::SpecifiedValue>);
                    *this == other_repr.value
                }
                TransformStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TransformStyle>);
                    *this == other_repr.value
                }
                UnicodeBidi(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::unicode_bidi::SpecifiedValue>);
                    *this == other_repr.value
                }
                Visibility(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::visibility::SpecifiedValue>);
                    *this == other_repr.value
                }
                WhiteSpaceCollapse(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::white_space_collapse::SpecifiedValue>);
                    *this == other_repr.value
                }
                WordBreak(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::WordBreak>);
                    *this == other_repr.value
                }
                WritingMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::WritingModeProperty>);
                    *this == other_repr.value
                }
                ZIndex(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ZIndex>);
                    *this == other_repr.value
                }
                Zoom(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Zoom>);
                    *this == other_repr.value
                }
                AlignContent(ref this) |
JustifyContent(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ContentDistribution>);
                    *this == other_repr.value
                }
                FlexGrow(ref this) |
FlexShrink(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeNumber>);
                    *this == other_repr.value
                }
                AlignSelf(ref this) |
JustifySelf(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::SelfAlignment>);
                    *this == other_repr.value
                }
                OverflowBlock(ref this) |
OverflowInline(ref this) |
OverflowX(ref this) |
OverflowY(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Overflow>);
                    *this == other_repr.value
                }
                BorderBlockEndStyle(ref this) |
BorderBlockStartStyle(ref this) |
BorderBottomStyle(ref this) |
BorderInlineEndStyle(ref this) |
BorderInlineStartStyle(ref this) |
BorderLeftStyle(ref this) |
BorderRightStyle(ref this) |
BorderTopStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderStyle>);
                    *this == other_repr.value
                }
                AnimationComposition(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_composition::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationDelay(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_delay::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationDirection(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_direction::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationDuration(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_duration::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationFillMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_fill_mode::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationIterationCount(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_iteration_count::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationName(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_name::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationPlayState(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_play_state::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationTimeline(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_timeline::SpecifiedValue>);
                    *this == other_repr.value
                }
                AnimationTimingFunction(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::animation_timing_function::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackdropFilter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::backdrop_filter::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundAttachment(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_attachment::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundClip(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_clip::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_image::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_origin::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundPositionX(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_position_x::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundPositionY(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_position_y::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundRepeat(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_repeat::SpecifiedValue>);
                    *this == other_repr.value
                }
                BackgroundSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_size::SpecifiedValue>);
                    *this == other_repr.value
                }
                BorderImageOutset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::NonNegativeLengthOrNumberRect>>);
                    *this == other_repr.value
                }
                BorderImageSlice(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderImageSlice>>);
                    *this == other_repr.value
                }
                BorderImageWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderImageWidth>>);
                    *this == other_repr.value
                }
                BorderSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderSpacing>>);
                    *this == other_repr.value
                }
                BoxShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::box_shadow::SpecifiedValue>);
                    *this == other_repr.value
                }
                Clip(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::ClipRectOrAuto>>);
                    *this == other_repr.value
                }
                ClipPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::basic_shape::ClipPath>);
                    *this == other_repr.value
                }
                Color(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ColorPropertyValue>);
                    *this == other_repr.value
                }
                ColorScheme(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ColorScheme>);
                    *this == other_repr.value
                }
                ColumnWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::length::NonNegativeLengthOrAuto>);
                    *this == other_repr.value
                }
                ContainerName(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ContainerName>);
                    *this == other_repr.value
                }
                Content(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Content>);
                    *this == other_repr.value
                }
                CounterIncrement(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::CounterIncrement>);
                    *this == other_repr.value
                }
                CounterReset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::CounterReset>);
                    *this == other_repr.value
                }
                Cursor(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Cursor>);
                    *this == other_repr.value
                }
                Filter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::filter::SpecifiedValue>);
                    *this == other_repr.value
                }
                FlexBasis(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::FlexBasis>>);
                    *this == other_repr.value
                }
                FontFamily(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontFamily>);
                    *this == other_repr.value
                }
                FontSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontSize>);
                    *this == other_repr.value
                }
                FontVariationSettings(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontVariationSettings>);
                    *this == other_repr.value
                }
                GridTemplateAreas(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridTemplateAreas>);
                    *this == other_repr.value
                }
                LetterSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::LetterSpacing>);
                    *this == other_repr.value
                }
                LineHeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::LineHeight>);
                    *this == other_repr.value
                }
                MaskImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::mask_image::SpecifiedValue>);
                    *this == other_repr.value
                }
                OffsetPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::OffsetPath>);
                    *this == other_repr.value
                }
                OutlineOffset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderSideOffset>);
                    *this == other_repr.value
                }
                OverflowClipMargin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Length>);
                    *this == other_repr.value
                }
                Perspective(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Perspective>);
                    *this == other_repr.value
                }
                Quotes(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Quotes>);
                    *this == other_repr.value
                }
                Rotate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Rotate>>);
                    *this == other_repr.value
                }
                Scale(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Scale>>);
                    *this == other_repr.value
                }
                TextIndent(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextIndent>);
                    *this == other_repr.value
                }
                TextOverflow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::TextOverflow>>);
                    *this == other_repr.value
                }
                TextShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_shadow::SpecifiedValue>);
                    *this == other_repr.value
                }
                Transform(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Transform>);
                    *this == other_repr.value
                }
                TransformOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::TransformOrigin>>);
                    *this == other_repr.value
                }
                TransitionBehavior(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::transition_behavior::SpecifiedValue>);
                    *this == other_repr.value
                }
                TransitionDelay(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::transition_delay::SpecifiedValue>);
                    *this == other_repr.value
                }
                TransitionDuration(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::transition_duration::SpecifiedValue>);
                    *this == other_repr.value
                }
                TransitionProperty(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::transition_property::SpecifiedValue>);
                    *this == other_repr.value
                }
                TransitionTimingFunction(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<longhands::transition_timing_function::SpecifiedValue>);
                    *this == other_repr.value
                }
                Translate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Translate>>);
                    *this == other_repr.value
                }
                VerticalAlign(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::VerticalAlign>);
                    *this == other_repr.value
                }
                ViewTransitionClass(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ViewTransitionClass>);
                    *this == other_repr.value
                }
                ViewTransitionName(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ViewTransitionName>);
                    *this == other_repr.value
                }
                WillChange(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::WillChange>);
                    *this == other_repr.value
                }
                WordSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::WordSpacing>);
                    *this == other_repr.value
                }
                XLang(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::XLang>);
                    *this == other_repr.value
                }
                ObjectPosition(ref this) |
PerspectiveOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Position>>);
                    *this == other_repr.value
                }
                GridTemplateColumns(ref this) |
GridTemplateRows(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridTemplateComponent>);
                    *this == other_repr.value
                }
                BorderImageSource(ref this) |
ListStyleImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Image>);
                    *this == other_repr.value
                }
                GridAutoColumns(ref this) |
GridAutoRows(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ImplicitGridTracks>);
                    *this == other_repr.value
                }
                ColumnGap(ref this) |
RowGap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>);
                    *this == other_repr.value
                }
                GridColumnEnd(ref this) |
GridColumnStart(ref this) |
GridRowEnd(ref this) |
GridRowStart(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridLine>);
                    *this == other_repr.value
                }
                MaxBlockSize(ref this) |
MaxHeight(ref this) |
MaxInlineSize(ref this) |
MaxWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::MaxSize>);
                    *this == other_repr.value
                }
                BorderBottomLeftRadius(ref this) |
BorderBottomRightRadius(ref this) |
BorderEndEndRadius(ref this) |
BorderEndStartRadius(ref this) |
BorderStartEndRadius(ref this) |
BorderStartStartRadius(ref this) |
BorderTopLeftRadius(ref this) |
BorderTopRightRadius(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderCornerRadius>>);
                    *this == other_repr.value
                }
                Bottom(ref this) |
InsetBlockEnd(ref this) |
InsetBlockStart(ref this) |
InsetInlineEnd(ref this) |
InsetInlineStart(ref this) |
Left(ref this) |
Right(ref this) |
Top(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Inset>);
                    *this == other_repr.value
                }
                MarginBlockEnd(ref this) |
MarginBlockStart(ref this) |
MarginBottom(ref this) |
MarginInlineEnd(ref this) |
MarginInlineStart(ref this) |
MarginLeft(ref this) |
MarginRight(ref this) |
MarginTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Margin>);
                    *this == other_repr.value
                }
                PaddingBlockEnd(ref this) |
PaddingBlockStart(ref this) |
PaddingBottom(ref this) |
PaddingInlineEnd(ref this) |
PaddingInlineStart(ref this) |
PaddingLeft(ref this) |
PaddingRight(ref this) |
PaddingTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeLengthPercentage>);
                    *this == other_repr.value
                }
                BlockSize(ref this) |
Height(ref this) |
InlineSize(ref this) |
MinBlockSize(ref this) |
MinHeight(ref this) |
MinInlineSize(ref this) |
MinWidth(ref this) |
Width(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Size>);
                    *this == other_repr.value
                }
                BorderBlockEndWidth(ref this) |
BorderBlockStartWidth(ref this) |
BorderBottomWidth(ref this) |
BorderInlineEndWidth(ref this) |
BorderInlineStartWidth(ref this) |
BorderLeftWidth(ref this) |
BorderRightWidth(ref this) |
BorderTopWidth(ref this) |
OutlineWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderSideWidth>);
                    *this == other_repr.value
                }
                BackgroundColor(ref this) |
BorderBlockEndColor(ref this) |
BorderBlockStartColor(ref this) |
BorderBottomColor(ref this) |
BorderInlineEndColor(ref this) |
BorderInlineStartColor(ref this) |
BorderLeftColor(ref this) |
BorderRightColor(ref this) |
BorderTopColor(ref this) |
OutlineColor(ref this) |
TextDecorationColor(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Color>);
                    *this == other_repr.value
                }
                CSSWideKeyword(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<WideKeywordDeclaration>);
                    *this == other_repr.value
                }
                WithVariables(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<VariableDeclaration>);
                    *this == other_repr.value
                }
                Custom(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const PropertyDeclarationVariantRepr<CustomDeclaration>);
                    *this == other_repr.value
                }
            }
        }
    }
}

impl MallocSizeOf for PropertyDeclaration {
    #[inline]
    fn size_of(&self, ops: &mut MallocSizeOfOps) -> usize {
        use self::PropertyDeclaration::*;

        match *self {
            AlignItems(ref value) => {
                value.size_of(ops)
            }
            AspectRatio(ref value) => {
                value.size_of(ops)
            }
            BackfaceVisibility(ref value) => {
                value.size_of(ops)
            }
            BaselineSource(ref value) => {
                value.size_of(ops)
            }
            BorderCollapse(ref value) => {
                value.size_of(ops)
            }
            BorderImageRepeat(ref value) => {
                value.size_of(ops)
            }
            BoxSizing(ref value) => {
                value.size_of(ops)
            }
            CaptionSide(ref value) => {
                value.size_of(ops)
            }
            Clear(ref value) => {
                value.size_of(ops)
            }
            ColumnCount(ref value) => {
                value.size_of(ops)
            }
            ColumnSpan(ref value) => {
                value.size_of(ops)
            }
            Contain(ref value) => {
                value.size_of(ops)
            }
            ContainerType(ref value) => {
                value.size_of(ops)
            }
            Direction(ref value) => {
                value.size_of(ops)
            }
            Display(ref value) => {
                value.size_of(ops)
            }
            EmptyCells(ref value) => {
                value.size_of(ops)
            }
            FlexDirection(ref value) => {
                value.size_of(ops)
            }
            FlexWrap(ref value) => {
                value.size_of(ops)
            }
            Float(ref value) => {
                value.size_of(ops)
            }
            FontLanguageOverride(ref value) => {
                value.size_of(ops)
            }
            FontStretch(ref value) => {
                value.size_of(ops)
            }
            FontStyle(ref value) => {
                value.size_of(ops)
            }
            FontSynthesisWeight(ref value) => {
                value.size_of(ops)
            }
            FontVariantCaps(ref value) => {
                value.size_of(ops)
            }
            FontWeight(ref value) => {
                value.size_of(ops)
            }
            GridAutoFlow(ref value) => {
                value.size_of(ops)
            }
            ImageRendering(ref value) => {
                value.size_of(ops)
            }
            Isolation(ref value) => {
                value.size_of(ops)
            }
            JustifyItems(ref value) => {
                value.size_of(ops)
            }
            ListStylePosition(ref value) => {
                value.size_of(ops)
            }
            ListStyleType(ref value) => {
                value.size_of(ops)
            }
            MixBlendMode(ref value) => {
                value.size_of(ops)
            }
            ObjectFit(ref value) => {
                value.size_of(ops)
            }
            Opacity(ref value) => {
                value.size_of(ops)
            }
            Order(ref value) => {
                value.size_of(ops)
            }
            OutlineStyle(ref value) => {
                value.size_of(ops)
            }
            OverflowWrap(ref value) => {
                value.size_of(ops)
            }
            PointerEvents(ref value) => {
                value.size_of(ops)
            }
            Position(ref value) => {
                value.size_of(ops)
            }
            PositionArea(ref value) => {
                value.size_of(ops)
            }
            ServoOverflowClipBox(ref value) => {
                value.size_of(ops)
            }
            ServoTopLayer(ref value) => {
                value.size_of(ops)
            }
            TableLayout(ref value) => {
                value.size_of(ops)
            }
            TextAlign(ref value) => {
                value.size_of(ops)
            }
            TextAlignLast(ref value) => {
                value.size_of(ops)
            }
            TextDecorationLine(ref value) => {
                value.size_of(ops)
            }
            TextDecorationStyle(ref value) => {
                value.size_of(ops)
            }
            TextJustify(ref value) => {
                value.size_of(ops)
            }
            TextRendering(ref value) => {
                value.size_of(ops)
            }
            TextTransform(ref value) => {
                value.size_of(ops)
            }
            TextWrapMode(ref value) => {
                value.size_of(ops)
            }
            TransformStyle(ref value) => {
                value.size_of(ops)
            }
            UnicodeBidi(ref value) => {
                value.size_of(ops)
            }
            Visibility(ref value) => {
                value.size_of(ops)
            }
            WhiteSpaceCollapse(ref value) => {
                value.size_of(ops)
            }
            WordBreak(ref value) => {
                value.size_of(ops)
            }
            WritingMode(ref value) => {
                value.size_of(ops)
            }
            ZIndex(ref value) => {
                value.size_of(ops)
            }
            Zoom(ref value) => {
                value.size_of(ops)
            }
            AlignContent(ref value) | JustifyContent(ref value) => {
                value.size_of(ops)
            }
            FlexGrow(ref value) | FlexShrink(ref value) => {
                value.size_of(ops)
            }
            AlignSelf(ref value) | JustifySelf(ref value) => {
                value.size_of(ops)
            }
            OverflowBlock(ref value) | OverflowInline(ref value) | OverflowX(ref value) | OverflowY(ref value) => {
                value.size_of(ops)
            }
            BorderBlockEndStyle(ref value) | BorderBlockStartStyle(ref value) | BorderBottomStyle(ref value) | BorderInlineEndStyle(ref value) | BorderInlineStartStyle(ref value) | BorderLeftStyle(ref value) | BorderRightStyle(ref value) | BorderTopStyle(ref value) => {
                value.size_of(ops)
            }
            AnimationComposition(ref value) => {
                value.size_of(ops)
            }
            AnimationDelay(ref value) => {
                value.size_of(ops)
            }
            AnimationDirection(ref value) => {
                value.size_of(ops)
            }
            AnimationDuration(ref value) => {
                value.size_of(ops)
            }
            AnimationFillMode(ref value) => {
                value.size_of(ops)
            }
            AnimationIterationCount(ref value) => {
                value.size_of(ops)
            }
            AnimationName(ref value) => {
                value.size_of(ops)
            }
            AnimationPlayState(ref value) => {
                value.size_of(ops)
            }
            AnimationTimeline(ref value) => {
                value.size_of(ops)
            }
            AnimationTimingFunction(ref value) => {
                value.size_of(ops)
            }
            BackdropFilter(ref value) => {
                value.size_of(ops)
            }
            BackgroundAttachment(ref value) => {
                value.size_of(ops)
            }
            BackgroundClip(ref value) => {
                value.size_of(ops)
            }
            BackgroundImage(ref value) => {
                value.size_of(ops)
            }
            BackgroundOrigin(ref value) => {
                value.size_of(ops)
            }
            BackgroundPositionX(ref value) => {
                value.size_of(ops)
            }
            BackgroundPositionY(ref value) => {
                value.size_of(ops)
            }
            BackgroundRepeat(ref value) => {
                value.size_of(ops)
            }
            BackgroundSize(ref value) => {
                value.size_of(ops)
            }
            BorderImageOutset(ref value) => {
                value.size_of(ops)
            }
            BorderImageSlice(ref value) => {
                value.size_of(ops)
            }
            BorderImageWidth(ref value) => {
                value.size_of(ops)
            }
            BorderSpacing(ref value) => {
                value.size_of(ops)
            }
            BoxShadow(ref value) => {
                value.size_of(ops)
            }
            Clip(ref value) => {
                value.size_of(ops)
            }
            ClipPath(ref value) => {
                value.size_of(ops)
            }
            Color(ref value) => {
                value.size_of(ops)
            }
            ColorScheme(ref value) => {
                value.size_of(ops)
            }
            ColumnWidth(ref value) => {
                value.size_of(ops)
            }
            ContainerName(ref value) => {
                value.size_of(ops)
            }
            Content(ref value) => {
                value.size_of(ops)
            }
            CounterIncrement(ref value) => {
                value.size_of(ops)
            }
            CounterReset(ref value) => {
                value.size_of(ops)
            }
            Cursor(ref value) => {
                value.size_of(ops)
            }
            Filter(ref value) => {
                value.size_of(ops)
            }
            FlexBasis(ref value) => {
                value.size_of(ops)
            }
            FontFamily(ref value) => {
                value.size_of(ops)
            }
            FontSize(ref value) => {
                value.size_of(ops)
            }
            FontVariationSettings(ref value) => {
                value.size_of(ops)
            }
            GridTemplateAreas(ref value) => {
                value.size_of(ops)
            }
            LetterSpacing(ref value) => {
                value.size_of(ops)
            }
            LineHeight(ref value) => {
                value.size_of(ops)
            }
            MaskImage(ref value) => {
                value.size_of(ops)
            }
            OffsetPath(ref value) => {
                value.size_of(ops)
            }
            OutlineOffset(ref value) => {
                value.size_of(ops)
            }
            OverflowClipMargin(ref value) => {
                value.size_of(ops)
            }
            Perspective(ref value) => {
                value.size_of(ops)
            }
            Quotes(ref value) => {
                value.size_of(ops)
            }
            Rotate(ref value) => {
                value.size_of(ops)
            }
            Scale(ref value) => {
                value.size_of(ops)
            }
            TextIndent(ref value) => {
                value.size_of(ops)
            }
            TextOverflow(ref value) => {
                value.size_of(ops)
            }
            TextShadow(ref value) => {
                value.size_of(ops)
            }
            Transform(ref value) => {
                value.size_of(ops)
            }
            TransformOrigin(ref value) => {
                value.size_of(ops)
            }
            TransitionBehavior(ref value) => {
                value.size_of(ops)
            }
            TransitionDelay(ref value) => {
                value.size_of(ops)
            }
            TransitionDuration(ref value) => {
                value.size_of(ops)
            }
            TransitionProperty(ref value) => {
                value.size_of(ops)
            }
            TransitionTimingFunction(ref value) => {
                value.size_of(ops)
            }
            Translate(ref value) => {
                value.size_of(ops)
            }
            VerticalAlign(ref value) => {
                value.size_of(ops)
            }
            ViewTransitionClass(ref value) => {
                value.size_of(ops)
            }
            ViewTransitionName(ref value) => {
                value.size_of(ops)
            }
            WillChange(ref value) => {
                value.size_of(ops)
            }
            WordSpacing(ref value) => {
                value.size_of(ops)
            }
            XLang(ref value) => {
                value.size_of(ops)
            }
            ObjectPosition(ref value) | PerspectiveOrigin(ref value) => {
                value.size_of(ops)
            }
            GridTemplateColumns(ref value) | GridTemplateRows(ref value) => {
                value.size_of(ops)
            }
            BorderImageSource(ref value) | ListStyleImage(ref value) => {
                value.size_of(ops)
            }
            GridAutoColumns(ref value) | GridAutoRows(ref value) => {
                value.size_of(ops)
            }
            ColumnGap(ref value) | RowGap(ref value) => {
                value.size_of(ops)
            }
            GridColumnEnd(ref value) | GridColumnStart(ref value) | GridRowEnd(ref value) | GridRowStart(ref value) => {
                value.size_of(ops)
            }
            MaxBlockSize(ref value) | MaxHeight(ref value) | MaxInlineSize(ref value) | MaxWidth(ref value) => {
                value.size_of(ops)
            }
            BorderBottomLeftRadius(ref value) | BorderBottomRightRadius(ref value) | BorderEndEndRadius(ref value) | BorderEndStartRadius(ref value) | BorderStartEndRadius(ref value) | BorderStartStartRadius(ref value) | BorderTopLeftRadius(ref value) | BorderTopRightRadius(ref value) => {
                value.size_of(ops)
            }
            Bottom(ref value) | InsetBlockEnd(ref value) | InsetBlockStart(ref value) | InsetInlineEnd(ref value) | InsetInlineStart(ref value) | Left(ref value) | Right(ref value) | Top(ref value) => {
                value.size_of(ops)
            }
            MarginBlockEnd(ref value) | MarginBlockStart(ref value) | MarginBottom(ref value) | MarginInlineEnd(ref value) | MarginInlineStart(ref value) | MarginLeft(ref value) | MarginRight(ref value) | MarginTop(ref value) => {
                value.size_of(ops)
            }
            PaddingBlockEnd(ref value) | PaddingBlockStart(ref value) | PaddingBottom(ref value) | PaddingInlineEnd(ref value) | PaddingInlineStart(ref value) | PaddingLeft(ref value) | PaddingRight(ref value) | PaddingTop(ref value) => {
                value.size_of(ops)
            }
            BlockSize(ref value) | Height(ref value) | InlineSize(ref value) | MinBlockSize(ref value) | MinHeight(ref value) | MinInlineSize(ref value) | MinWidth(ref value) | Width(ref value) => {
                value.size_of(ops)
            }
            BorderBlockEndWidth(ref value) | BorderBlockStartWidth(ref value) | BorderBottomWidth(ref value) | BorderInlineEndWidth(ref value) | BorderInlineStartWidth(ref value) | BorderLeftWidth(ref value) | BorderRightWidth(ref value) | BorderTopWidth(ref value) | OutlineWidth(ref value) => {
                value.size_of(ops)
            }
            BackgroundColor(ref value) | BorderBlockEndColor(ref value) | BorderBlockStartColor(ref value) | BorderBottomColor(ref value) | BorderInlineEndColor(ref value) | BorderInlineStartColor(ref value) | BorderLeftColor(ref value) | BorderRightColor(ref value) | BorderTopColor(ref value) | OutlineColor(ref value) | TextDecorationColor(ref value) => {
                value.size_of(ops)
            }
            CSSWideKeyword(ref value) => {
                value.size_of(ops)
            }
            WithVariables(ref value) => {
                value.size_of(ops)
            }
            Custom(ref value) => {
                value.size_of(ops)
            }
        }
    }
}


impl PropertyDeclaration {
    /// Returns the given value for this declaration as a particular type.
    /// It's the caller's responsibility to guarantee that the longhand id has the right specified
    /// value representation.
    pub(crate) unsafe fn unchecked_value_as<T>(&self) -> &T {
        &(*(self as *const _ as *const PropertyDeclarationVariantRepr<T>)).value
    }

    /// Dumps the property declaration before crashing.
    #[cold]
    #[cfg(debug_assertions)]
    pub(crate) fn debug_crash(&self, reason: &str) {
        panic!("{}: {:?}", reason, self);
    }
    #[cfg(not(debug_assertions))]
    #[inline(always)]
    pub(crate) fn debug_crash(&self, _reason: &str) {}

    /// Returns whether this is a variant of the Longhand(Value) type, rather
    /// than one of the special variants in extra_variants.
    fn is_longhand_value(&self) -> bool {
        match *self {
            PropertyDeclaration::CSSWideKeyword(..) => false,
            PropertyDeclaration::WithVariables(..) => false,
            PropertyDeclaration::Custom(..) => false,
            _ => true,
        }
    }

    /// Like the method on ToCss, but without the type parameter to avoid
    /// accidentally monomorphizing this large function multiple times for
    /// different writers.
    pub fn to_css(&self, dest: &mut CssStringWriter) -> fmt::Result {
        use self::PropertyDeclaration::*;

        let mut dest = CssWriter::new(dest);
        match *self {
            AlignItems(ref value) => {
                value.to_css(&mut dest)
            }
            AspectRatio(ref value) => {
                value.to_css(&mut dest)
            }
            BackfaceVisibility(ref value) => {
                value.to_css(&mut dest)
            }
            BaselineSource(ref value) => {
                value.to_css(&mut dest)
            }
            BorderCollapse(ref value) => {
                value.to_css(&mut dest)
            }
            BorderImageRepeat(ref value) => {
                value.to_css(&mut dest)
            }
            BoxSizing(ref value) => {
                value.to_css(&mut dest)
            }
            CaptionSide(ref value) => {
                value.to_css(&mut dest)
            }
            Clear(ref value) => {
                value.to_css(&mut dest)
            }
            ColumnCount(ref value) => {
                value.to_css(&mut dest)
            }
            ColumnSpan(ref value) => {
                value.to_css(&mut dest)
            }
            Contain(ref value) => {
                value.to_css(&mut dest)
            }
            ContainerType(ref value) => {
                value.to_css(&mut dest)
            }
            Direction(ref value) => {
                value.to_css(&mut dest)
            }
            Display(ref value) => {
                value.to_css(&mut dest)
            }
            EmptyCells(ref value) => {
                value.to_css(&mut dest)
            }
            FlexDirection(ref value) => {
                value.to_css(&mut dest)
            }
            FlexWrap(ref value) => {
                value.to_css(&mut dest)
            }
            Float(ref value) => {
                value.to_css(&mut dest)
            }
            FontLanguageOverride(ref value) => {
                value.to_css(&mut dest)
            }
            FontStretch(ref value) => {
                value.to_css(&mut dest)
            }
            FontStyle(ref value) => {
                value.to_css(&mut dest)
            }
            FontSynthesisWeight(ref value) => {
                value.to_css(&mut dest)
            }
            FontVariantCaps(ref value) => {
                value.to_css(&mut dest)
            }
            FontWeight(ref value) => {
                value.to_css(&mut dest)
            }
            GridAutoFlow(ref value) => {
                value.to_css(&mut dest)
            }
            ImageRendering(ref value) => {
                value.to_css(&mut dest)
            }
            Isolation(ref value) => {
                value.to_css(&mut dest)
            }
            JustifyItems(ref value) => {
                value.to_css(&mut dest)
            }
            ListStylePosition(ref value) => {
                value.to_css(&mut dest)
            }
            ListStyleType(ref value) => {
                value.to_css(&mut dest)
            }
            MixBlendMode(ref value) => {
                value.to_css(&mut dest)
            }
            ObjectFit(ref value) => {
                value.to_css(&mut dest)
            }
            Opacity(ref value) => {
                value.to_css(&mut dest)
            }
            Order(ref value) => {
                value.to_css(&mut dest)
            }
            OutlineStyle(ref value) => {
                value.to_css(&mut dest)
            }
            OverflowWrap(ref value) => {
                value.to_css(&mut dest)
            }
            PointerEvents(ref value) => {
                value.to_css(&mut dest)
            }
            Position(ref value) => {
                value.to_css(&mut dest)
            }
            PositionArea(ref value) => {
                value.to_css(&mut dest)
            }
            ServoOverflowClipBox(ref value) => {
                value.to_css(&mut dest)
            }
            ServoTopLayer(ref value) => {
                value.to_css(&mut dest)
            }
            TableLayout(ref value) => {
                value.to_css(&mut dest)
            }
            TextAlign(ref value) => {
                value.to_css(&mut dest)
            }
            TextAlignLast(ref value) => {
                value.to_css(&mut dest)
            }
            TextDecorationLine(ref value) => {
                value.to_css(&mut dest)
            }
            TextDecorationStyle(ref value) => {
                value.to_css(&mut dest)
            }
            TextJustify(ref value) => {
                value.to_css(&mut dest)
            }
            TextRendering(ref value) => {
                value.to_css(&mut dest)
            }
            TextTransform(ref value) => {
                value.to_css(&mut dest)
            }
            TextWrapMode(ref value) => {
                value.to_css(&mut dest)
            }
            TransformStyle(ref value) => {
                value.to_css(&mut dest)
            }
            UnicodeBidi(ref value) => {
                value.to_css(&mut dest)
            }
            Visibility(ref value) => {
                value.to_css(&mut dest)
            }
            WhiteSpaceCollapse(ref value) => {
                value.to_css(&mut dest)
            }
            WordBreak(ref value) => {
                value.to_css(&mut dest)
            }
            WritingMode(ref value) => {
                value.to_css(&mut dest)
            }
            ZIndex(ref value) => {
                value.to_css(&mut dest)
            }
            Zoom(ref value) => {
                value.to_css(&mut dest)
            }
            AlignContent(ref value) | JustifyContent(ref value) => {
                value.to_css(&mut dest)
            }
            FlexGrow(ref value) | FlexShrink(ref value) => {
                value.to_css(&mut dest)
            }
            AlignSelf(ref value) | JustifySelf(ref value) => {
                value.to_css(&mut dest)
            }
            OverflowBlock(ref value) | OverflowInline(ref value) | OverflowX(ref value) | OverflowY(ref value) => {
                value.to_css(&mut dest)
            }
            BorderBlockEndStyle(ref value) | BorderBlockStartStyle(ref value) | BorderBottomStyle(ref value) | BorderInlineEndStyle(ref value) | BorderInlineStartStyle(ref value) | BorderLeftStyle(ref value) | BorderRightStyle(ref value) | BorderTopStyle(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationComposition(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationDelay(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationDirection(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationDuration(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationFillMode(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationIterationCount(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationName(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationPlayState(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationTimeline(ref value) => {
                value.to_css(&mut dest)
            }
            AnimationTimingFunction(ref value) => {
                value.to_css(&mut dest)
            }
            BackdropFilter(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundAttachment(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundClip(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundImage(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundOrigin(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundPositionX(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundPositionY(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundRepeat(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundSize(ref value) => {
                value.to_css(&mut dest)
            }
            BorderImageOutset(ref value) => {
                value.to_css(&mut dest)
            }
            BorderImageSlice(ref value) => {
                value.to_css(&mut dest)
            }
            BorderImageWidth(ref value) => {
                value.to_css(&mut dest)
            }
            BorderSpacing(ref value) => {
                value.to_css(&mut dest)
            }
            BoxShadow(ref value) => {
                value.to_css(&mut dest)
            }
            Clip(ref value) => {
                value.to_css(&mut dest)
            }
            ClipPath(ref value) => {
                value.to_css(&mut dest)
            }
            Color(ref value) => {
                value.to_css(&mut dest)
            }
            ColorScheme(ref value) => {
                value.to_css(&mut dest)
            }
            ColumnWidth(ref value) => {
                value.to_css(&mut dest)
            }
            ContainerName(ref value) => {
                value.to_css(&mut dest)
            }
            Content(ref value) => {
                value.to_css(&mut dest)
            }
            CounterIncrement(ref value) => {
                value.to_css(&mut dest)
            }
            CounterReset(ref value) => {
                value.to_css(&mut dest)
            }
            Cursor(ref value) => {
                value.to_css(&mut dest)
            }
            Filter(ref value) => {
                value.to_css(&mut dest)
            }
            FlexBasis(ref value) => {
                value.to_css(&mut dest)
            }
            FontFamily(ref value) => {
                value.to_css(&mut dest)
            }
            FontSize(ref value) => {
                value.to_css(&mut dest)
            }
            FontVariationSettings(ref value) => {
                value.to_css(&mut dest)
            }
            GridTemplateAreas(ref value) => {
                value.to_css(&mut dest)
            }
            LetterSpacing(ref value) => {
                value.to_css(&mut dest)
            }
            LineHeight(ref value) => {
                value.to_css(&mut dest)
            }
            MaskImage(ref value) => {
                value.to_css(&mut dest)
            }
            OffsetPath(ref value) => {
                value.to_css(&mut dest)
            }
            OutlineOffset(ref value) => {
                value.to_css(&mut dest)
            }
            OverflowClipMargin(ref value) => {
                value.to_css(&mut dest)
            }
            Perspective(ref value) => {
                value.to_css(&mut dest)
            }
            Quotes(ref value) => {
                value.to_css(&mut dest)
            }
            Rotate(ref value) => {
                value.to_css(&mut dest)
            }
            Scale(ref value) => {
                value.to_css(&mut dest)
            }
            TextIndent(ref value) => {
                value.to_css(&mut dest)
            }
            TextOverflow(ref value) => {
                value.to_css(&mut dest)
            }
            TextShadow(ref value) => {
                value.to_css(&mut dest)
            }
            Transform(ref value) => {
                value.to_css(&mut dest)
            }
            TransformOrigin(ref value) => {
                value.to_css(&mut dest)
            }
            TransitionBehavior(ref value) => {
                value.to_css(&mut dest)
            }
            TransitionDelay(ref value) => {
                value.to_css(&mut dest)
            }
            TransitionDuration(ref value) => {
                value.to_css(&mut dest)
            }
            TransitionProperty(ref value) => {
                value.to_css(&mut dest)
            }
            TransitionTimingFunction(ref value) => {
                value.to_css(&mut dest)
            }
            Translate(ref value) => {
                value.to_css(&mut dest)
            }
            VerticalAlign(ref value) => {
                value.to_css(&mut dest)
            }
            ViewTransitionClass(ref value) => {
                value.to_css(&mut dest)
            }
            ViewTransitionName(ref value) => {
                value.to_css(&mut dest)
            }
            WillChange(ref value) => {
                value.to_css(&mut dest)
            }
            WordSpacing(ref value) => {
                value.to_css(&mut dest)
            }
            XLang(ref value) => {
                value.to_css(&mut dest)
            }
            ObjectPosition(ref value) | PerspectiveOrigin(ref value) => {
                value.to_css(&mut dest)
            }
            GridTemplateColumns(ref value) | GridTemplateRows(ref value) => {
                value.to_css(&mut dest)
            }
            BorderImageSource(ref value) | ListStyleImage(ref value) => {
                value.to_css(&mut dest)
            }
            GridAutoColumns(ref value) | GridAutoRows(ref value) => {
                value.to_css(&mut dest)
            }
            ColumnGap(ref value) | RowGap(ref value) => {
                value.to_css(&mut dest)
            }
            GridColumnEnd(ref value) | GridColumnStart(ref value) | GridRowEnd(ref value) | GridRowStart(ref value) => {
                value.to_css(&mut dest)
            }
            MaxBlockSize(ref value) | MaxHeight(ref value) | MaxInlineSize(ref value) | MaxWidth(ref value) => {
                value.to_css(&mut dest)
            }
            BorderBottomLeftRadius(ref value) | BorderBottomRightRadius(ref value) | BorderEndEndRadius(ref value) | BorderEndStartRadius(ref value) | BorderStartEndRadius(ref value) | BorderStartStartRadius(ref value) | BorderTopLeftRadius(ref value) | BorderTopRightRadius(ref value) => {
                value.to_css(&mut dest)
            }
            Bottom(ref value) | InsetBlockEnd(ref value) | InsetBlockStart(ref value) | InsetInlineEnd(ref value) | InsetInlineStart(ref value) | Left(ref value) | Right(ref value) | Top(ref value) => {
                value.to_css(&mut dest)
            }
            MarginBlockEnd(ref value) | MarginBlockStart(ref value) | MarginBottom(ref value) | MarginInlineEnd(ref value) | MarginInlineStart(ref value) | MarginLeft(ref value) | MarginRight(ref value) | MarginTop(ref value) => {
                value.to_css(&mut dest)
            }
            PaddingBlockEnd(ref value) | PaddingBlockStart(ref value) | PaddingBottom(ref value) | PaddingInlineEnd(ref value) | PaddingInlineStart(ref value) | PaddingLeft(ref value) | PaddingRight(ref value) | PaddingTop(ref value) => {
                value.to_css(&mut dest)
            }
            BlockSize(ref value) | Height(ref value) | InlineSize(ref value) | MinBlockSize(ref value) | MinHeight(ref value) | MinInlineSize(ref value) | MinWidth(ref value) | Width(ref value) => {
                value.to_css(&mut dest)
            }
            BorderBlockEndWidth(ref value) | BorderBlockStartWidth(ref value) | BorderBottomWidth(ref value) | BorderInlineEndWidth(ref value) | BorderInlineStartWidth(ref value) | BorderLeftWidth(ref value) | BorderRightWidth(ref value) | BorderTopWidth(ref value) | OutlineWidth(ref value) => {
                value.to_css(&mut dest)
            }
            BackgroundColor(ref value) | BorderBlockEndColor(ref value) | BorderBlockStartColor(ref value) | BorderBottomColor(ref value) | BorderInlineEndColor(ref value) | BorderInlineStartColor(ref value) | BorderLeftColor(ref value) | BorderRightColor(ref value) | BorderTopColor(ref value) | OutlineColor(ref value) | TextDecorationColor(ref value) => {
                value.to_css(&mut dest)
            }
            CSSWideKeyword(ref value) => {
                value.to_css(&mut dest)
            }
            WithVariables(ref value) => {
                value.to_css(&mut dest)
            }
            Custom(ref value) => {
                value.to_css(&mut dest)
            }
        }
    }

    /// Like the method on ToTyped.
    pub fn to_typed(&self) -> Option<TypedValue> {
        use self::PropertyDeclaration::*;

        match *self {
            AlignItems(ref value) => {
                value.to_typed()
            }
            AspectRatio(ref value) => {
                value.to_typed()
            }
            BackfaceVisibility(ref value) => {
                value.to_typed()
            }
            BaselineSource(ref value) => {
                value.to_typed()
            }
            BorderCollapse(ref value) => {
                value.to_typed()
            }
            BorderImageRepeat(ref value) => {
                value.to_typed()
            }
            BoxSizing(ref value) => {
                value.to_typed()
            }
            CaptionSide(ref value) => {
                value.to_typed()
            }
            Clear(ref value) => {
                value.to_typed()
            }
            ColumnCount(ref value) => {
                value.to_typed()
            }
            ColumnSpan(ref value) => {
                value.to_typed()
            }
            Contain(ref value) => {
                value.to_typed()
            }
            ContainerType(ref value) => {
                value.to_typed()
            }
            Direction(ref value) => {
                value.to_typed()
            }
            Display(ref value) => {
                value.to_typed()
            }
            EmptyCells(ref value) => {
                value.to_typed()
            }
            FlexDirection(ref value) => {
                value.to_typed()
            }
            FlexWrap(ref value) => {
                value.to_typed()
            }
            Float(ref value) => {
                value.to_typed()
            }
            FontLanguageOverride(ref value) => {
                value.to_typed()
            }
            FontStretch(ref value) => {
                value.to_typed()
            }
            FontStyle(ref value) => {
                value.to_typed()
            }
            FontSynthesisWeight(ref value) => {
                value.to_typed()
            }
            FontVariantCaps(ref value) => {
                value.to_typed()
            }
            FontWeight(ref value) => {
                value.to_typed()
            }
            GridAutoFlow(ref value) => {
                value.to_typed()
            }
            ImageRendering(ref value) => {
                value.to_typed()
            }
            Isolation(ref value) => {
                value.to_typed()
            }
            JustifyItems(ref value) => {
                value.to_typed()
            }
            ListStylePosition(ref value) => {
                value.to_typed()
            }
            ListStyleType(ref value) => {
                value.to_typed()
            }
            MixBlendMode(ref value) => {
                value.to_typed()
            }
            ObjectFit(ref value) => {
                value.to_typed()
            }
            Opacity(ref value) => {
                value.to_typed()
            }
            Order(ref value) => {
                value.to_typed()
            }
            OutlineStyle(ref value) => {
                value.to_typed()
            }
            OverflowWrap(ref value) => {
                value.to_typed()
            }
            PointerEvents(ref value) => {
                value.to_typed()
            }
            Position(ref value) => {
                value.to_typed()
            }
            PositionArea(ref value) => {
                value.to_typed()
            }
            ServoOverflowClipBox(ref value) => {
                value.to_typed()
            }
            ServoTopLayer(ref value) => {
                value.to_typed()
            }
            TableLayout(ref value) => {
                value.to_typed()
            }
            TextAlign(ref value) => {
                value.to_typed()
            }
            TextAlignLast(ref value) => {
                value.to_typed()
            }
            TextDecorationLine(ref value) => {
                value.to_typed()
            }
            TextDecorationStyle(ref value) => {
                value.to_typed()
            }
            TextJustify(ref value) => {
                value.to_typed()
            }
            TextRendering(ref value) => {
                value.to_typed()
            }
            TextTransform(ref value) => {
                value.to_typed()
            }
            TextWrapMode(ref value) => {
                value.to_typed()
            }
            TransformStyle(ref value) => {
                value.to_typed()
            }
            UnicodeBidi(ref value) => {
                value.to_typed()
            }
            Visibility(ref value) => {
                value.to_typed()
            }
            WhiteSpaceCollapse(ref value) => {
                value.to_typed()
            }
            WordBreak(ref value) => {
                value.to_typed()
            }
            WritingMode(ref value) => {
                value.to_typed()
            }
            ZIndex(ref value) => {
                value.to_typed()
            }
            Zoom(ref value) => {
                value.to_typed()
            }
            AlignContent(ref value) | JustifyContent(ref value) => {
                value.to_typed()
            }
            FlexGrow(ref value) | FlexShrink(ref value) => {
                value.to_typed()
            }
            AlignSelf(ref value) | JustifySelf(ref value) => {
                value.to_typed()
            }
            OverflowBlock(ref value) | OverflowInline(ref value) | OverflowX(ref value) | OverflowY(ref value) => {
                value.to_typed()
            }
            BorderBlockEndStyle(ref value) | BorderBlockStartStyle(ref value) | BorderBottomStyle(ref value) | BorderInlineEndStyle(ref value) | BorderInlineStartStyle(ref value) | BorderLeftStyle(ref value) | BorderRightStyle(ref value) | BorderTopStyle(ref value) => {
                value.to_typed()
            }
            AnimationComposition(ref value) => {
                value.to_typed()
            }
            AnimationDelay(ref value) => {
                value.to_typed()
            }
            AnimationDirection(ref value) => {
                value.to_typed()
            }
            AnimationDuration(ref value) => {
                value.to_typed()
            }
            AnimationFillMode(ref value) => {
                value.to_typed()
            }
            AnimationIterationCount(ref value) => {
                value.to_typed()
            }
            AnimationName(ref value) => {
                value.to_typed()
            }
            AnimationPlayState(ref value) => {
                value.to_typed()
            }
            AnimationTimeline(ref value) => {
                value.to_typed()
            }
            AnimationTimingFunction(ref value) => {
                value.to_typed()
            }
            BackdropFilter(ref value) => {
                value.to_typed()
            }
            BackgroundAttachment(ref value) => {
                value.to_typed()
            }
            BackgroundClip(ref value) => {
                value.to_typed()
            }
            BackgroundImage(ref value) => {
                value.to_typed()
            }
            BackgroundOrigin(ref value) => {
                value.to_typed()
            }
            BackgroundPositionX(ref value) => {
                value.to_typed()
            }
            BackgroundPositionY(ref value) => {
                value.to_typed()
            }
            BackgroundRepeat(ref value) => {
                value.to_typed()
            }
            BackgroundSize(ref value) => {
                value.to_typed()
            }
            BorderImageOutset(ref value) => {
                value.to_typed()
            }
            BorderImageSlice(ref value) => {
                value.to_typed()
            }
            BorderImageWidth(ref value) => {
                value.to_typed()
            }
            BorderSpacing(ref value) => {
                value.to_typed()
            }
            BoxShadow(ref value) => {
                value.to_typed()
            }
            Clip(ref value) => {
                value.to_typed()
            }
            ClipPath(ref value) => {
                value.to_typed()
            }
            Color(ref value) => {
                value.to_typed()
            }
            ColorScheme(ref value) => {
                value.to_typed()
            }
            ColumnWidth(ref value) => {
                value.to_typed()
            }
            ContainerName(ref value) => {
                value.to_typed()
            }
            Content(ref value) => {
                value.to_typed()
            }
            CounterIncrement(ref value) => {
                value.to_typed()
            }
            CounterReset(ref value) => {
                value.to_typed()
            }
            Cursor(ref value) => {
                value.to_typed()
            }
            Filter(ref value) => {
                value.to_typed()
            }
            FlexBasis(ref value) => {
                value.to_typed()
            }
            FontFamily(ref value) => {
                value.to_typed()
            }
            FontSize(ref value) => {
                value.to_typed()
            }
            FontVariationSettings(ref value) => {
                value.to_typed()
            }
            GridTemplateAreas(ref value) => {
                value.to_typed()
            }
            LetterSpacing(ref value) => {
                value.to_typed()
            }
            LineHeight(ref value) => {
                value.to_typed()
            }
            MaskImage(ref value) => {
                value.to_typed()
            }
            OffsetPath(ref value) => {
                value.to_typed()
            }
            OutlineOffset(ref value) => {
                value.to_typed()
            }
            OverflowClipMargin(ref value) => {
                value.to_typed()
            }
            Perspective(ref value) => {
                value.to_typed()
            }
            Quotes(ref value) => {
                value.to_typed()
            }
            Rotate(ref value) => {
                value.to_typed()
            }
            Scale(ref value) => {
                value.to_typed()
            }
            TextIndent(ref value) => {
                value.to_typed()
            }
            TextOverflow(ref value) => {
                value.to_typed()
            }
            TextShadow(ref value) => {
                value.to_typed()
            }
            Transform(ref value) => {
                value.to_typed()
            }
            TransformOrigin(ref value) => {
                value.to_typed()
            }
            TransitionBehavior(ref value) => {
                value.to_typed()
            }
            TransitionDelay(ref value) => {
                value.to_typed()
            }
            TransitionDuration(ref value) => {
                value.to_typed()
            }
            TransitionProperty(ref value) => {
                value.to_typed()
            }
            TransitionTimingFunction(ref value) => {
                value.to_typed()
            }
            Translate(ref value) => {
                value.to_typed()
            }
            VerticalAlign(ref value) => {
                value.to_typed()
            }
            ViewTransitionClass(ref value) => {
                value.to_typed()
            }
            ViewTransitionName(ref value) => {
                value.to_typed()
            }
            WillChange(ref value) => {
                value.to_typed()
            }
            WordSpacing(ref value) => {
                value.to_typed()
            }
            XLang(ref value) => {
                value.to_typed()
            }
            ObjectPosition(ref value) | PerspectiveOrigin(ref value) => {
                value.to_typed()
            }
            GridTemplateColumns(ref value) | GridTemplateRows(ref value) => {
                value.to_typed()
            }
            BorderImageSource(ref value) | ListStyleImage(ref value) => {
                value.to_typed()
            }
            GridAutoColumns(ref value) | GridAutoRows(ref value) => {
                value.to_typed()
            }
            ColumnGap(ref value) | RowGap(ref value) => {
                value.to_typed()
            }
            GridColumnEnd(ref value) | GridColumnStart(ref value) | GridRowEnd(ref value) | GridRowStart(ref value) => {
                value.to_typed()
            }
            MaxBlockSize(ref value) | MaxHeight(ref value) | MaxInlineSize(ref value) | MaxWidth(ref value) => {
                value.to_typed()
            }
            BorderBottomLeftRadius(ref value) | BorderBottomRightRadius(ref value) | BorderEndEndRadius(ref value) | BorderEndStartRadius(ref value) | BorderStartEndRadius(ref value) | BorderStartStartRadius(ref value) | BorderTopLeftRadius(ref value) | BorderTopRightRadius(ref value) => {
                value.to_typed()
            }
            Bottom(ref value) | InsetBlockEnd(ref value) | InsetBlockStart(ref value) | InsetInlineEnd(ref value) | InsetInlineStart(ref value) | Left(ref value) | Right(ref value) | Top(ref value) => {
                value.to_typed()
            }
            MarginBlockEnd(ref value) | MarginBlockStart(ref value) | MarginBottom(ref value) | MarginInlineEnd(ref value) | MarginInlineStart(ref value) | MarginLeft(ref value) | MarginRight(ref value) | MarginTop(ref value) => {
                value.to_typed()
            }
            PaddingBlockEnd(ref value) | PaddingBlockStart(ref value) | PaddingBottom(ref value) | PaddingInlineEnd(ref value) | PaddingInlineStart(ref value) | PaddingLeft(ref value) | PaddingRight(ref value) | PaddingTop(ref value) => {
                value.to_typed()
            }
            BlockSize(ref value) | Height(ref value) | InlineSize(ref value) | MinBlockSize(ref value) | MinHeight(ref value) | MinInlineSize(ref value) | MinWidth(ref value) | Width(ref value) => {
                value.to_typed()
            }
            BorderBlockEndWidth(ref value) | BorderBlockStartWidth(ref value) | BorderBottomWidth(ref value) | BorderInlineEndWidth(ref value) | BorderInlineStartWidth(ref value) | BorderLeftWidth(ref value) | BorderRightWidth(ref value) | BorderTopWidth(ref value) | OutlineWidth(ref value) => {
                value.to_typed()
            }
            BackgroundColor(ref value) | BorderBlockEndColor(ref value) | BorderBlockStartColor(ref value) | BorderBottomColor(ref value) | BorderInlineEndColor(ref value) | BorderInlineStartColor(ref value) | BorderLeftColor(ref value) | BorderRightColor(ref value) | BorderTopColor(ref value) | OutlineColor(ref value) | TextDecorationColor(ref value) => {
                value.to_typed()
            }
            CSSWideKeyword(ref value) => {
                value.to_typed()
            }
            WithVariables(ref value) => {
                value.to_typed()
            }
            Custom(ref value) => {
                value.to_typed()
            }
        }
    }

    /// Returns the color value of a given property, for high-contrast-mode tweaks.
    pub(super) fn color_value(&self) -> Option<&crate::values::specified::Color> {
        
static COLOR_PROPERTIES: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff80000]
};

        
        let id = self.id().as_longhand()?;
        if !COLOR_PROPERTIES.contains(id) || !self.is_longhand_value() {
            return None;
        }
        let repr = self as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Color>;
        Some(unsafe { &(*repr).value })
    }
}

/// A module with all the code related to animated properties.
///
/// This needs to be "included" by mako at least after all longhand modules,
/// given they populate the global data.
pub mod animated_properties {
    /* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





#[cfg(feature = "gecko")] use crate::gecko_bindings::structs::nsCSSPropertyID;
use crate::properties::{
    longhands::{
        self, visibility::computed_value::T as Visibility,
    },
    CSSWideKeyword, LonghandId, NonCustomPropertyIterator,
    PropertyDeclaration, PropertyDeclarationId,
};
#[cfg(feature = "gecko")] use crate::properties::{
    longhands::content_visibility::computed_value::T as ContentVisibility,
    NonCustomPropertyId,
};
use std::ptr;
use std::mem;
use rustc_hash::FxHashMap;
use super::ComputedValues;
use crate::properties::OwnedPropertyDeclarationId;
use crate::values::animated::{Animate, Procedure, ToAnimatedValue, ToAnimatedZero};
use crate::values::animated::effects::AnimatedFilter;
#[cfg(feature = "gecko")] use crate::values::computed::TransitionProperty;
use crate::values::computed::{ClipRect, Context};
use crate::values::computed::ToComputedValue;
use crate::values::distance::{ComputeSquaredDistance, SquaredDistance};
use crate::values::generics::effects::Filter;
use void::{self, Void};
use crate::properties_and_values::value::CustomAnimatedValue;

/// Convert nsCSSPropertyID to TransitionProperty
#[cfg(feature = "gecko")]
#[allow(non_upper_case_globals)]
impl From<nsCSSPropertyID> for TransitionProperty {
    fn from(property: nsCSSPropertyID) -> TransitionProperty {
        TransitionProperty::NonCustom(NonCustomPropertyId::from_nscsspropertyid(property).unwrap())
    }
}

/// A collection of AnimationValue that were composed on an element.
/// This HashMap stores the values that are the last AnimationValue to be
/// composed for each TransitionProperty.
pub type AnimationValueMap = FxHashMap<OwnedPropertyDeclarationId, AnimationValue>;

/// An enum to represent a single computed value belonging to an animated
/// property in order to be interpolated with another one. When interpolating,
/// both values need to belong to the same property.
#[derive(Debug, MallocSizeOf)]
#[repr(u16)]
pub enum AnimationValue {
    /// `align-items`
    AlignItems(<crate::values::specified::ItemPlacement as ToComputedValue>::ComputedValue),
    /// `aspect-ratio`
    AspectRatio(<<crate::values::specified::AspectRatio as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `backface-visibility`
    BackfaceVisibility(<longhands::backface_visibility::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `baseline-source`
    BaselineSource(<crate::values::specified::BaselineSource as ToComputedValue>::ComputedValue),
    /// `border-collapse`
    BorderCollapse(<longhands::border_collapse::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `border-image-repeat`
    BorderImageRepeat(<crate::values::specified::BorderImageRepeat as ToComputedValue>::ComputedValue),
    /// `box-sizing`
    BoxSizing(<longhands::box_sizing::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `caption-side`
    CaptionSide(<crate::values::specified::table::CaptionSide as ToComputedValue>::ComputedValue),
    /// `clear`
    Clear(<crate::values::specified::Clear as ToComputedValue>::ComputedValue),
    /// `column-count`
    ColumnCount(<<crate::values::specified::ColumnCount as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `column-span`
    ColumnSpan(<longhands::column_span::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `contain`
    Contain(Void),
    /// `container-type`
    ContainerType(Void),
    /// `direction`
    Direction(Void),
    /// `display`
    Display(<crate::values::specified::Display as ToComputedValue>::ComputedValue),
    /// `empty-cells`
    EmptyCells(<longhands::empty_cells::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `flex-direction`
    FlexDirection(<longhands::flex_direction::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `flex-wrap`
    FlexWrap(<longhands::flex_wrap::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `float`
    Float(<crate::values::specified::Float as ToComputedValue>::ComputedValue),
    /// `font-language-override`
    FontLanguageOverride(<crate::values::specified::FontLanguageOverride as ToComputedValue>::ComputedValue),
    /// `font-stretch`
    FontStretch(<<crate::values::specified::FontStretch as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `font-style`
    FontStyle(<<crate::values::specified::FontStyle as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `font-synthesis-weight`
    FontSynthesisWeight(<crate::values::specified::FontSynthesis as ToComputedValue>::ComputedValue),
    /// `font-variant-caps`
    FontVariantCaps(<longhands::font_variant_caps::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `font-weight`
    FontWeight(<<crate::values::specified::FontWeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `grid-auto-flow`
    GridAutoFlow(<crate::values::specified::GridAutoFlow as ToComputedValue>::ComputedValue),
    /// `image-rendering`
    ImageRendering(<crate::values::specified::ImageRendering as ToComputedValue>::ComputedValue),
    /// `isolation`
    Isolation(<longhands::isolation::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `justify-items`
    JustifyItems(<crate::values::specified::JustifyItems as ToComputedValue>::ComputedValue),
    /// `list-style-position`
    ListStylePosition(<longhands::list_style_position::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `list-style-type`
    ListStyleType(<longhands::list_style_type::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `mix-blend-mode`
    MixBlendMode(<longhands::mix_blend_mode::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `object-fit`
    ObjectFit(<longhands::object_fit::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `opacity`
    Opacity(<<crate::values::specified::Opacity as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `order`
    Order(<<crate::values::specified::Integer as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `outline-style`
    OutlineStyle(<crate::values::specified::OutlineStyle as ToComputedValue>::ComputedValue),
    /// `overflow-wrap`
    OverflowWrap(<crate::values::specified::OverflowWrap as ToComputedValue>::ComputedValue),
    /// `pointer-events`
    PointerEvents(<crate::values::specified::PointerEvents as ToComputedValue>::ComputedValue),
    /// `position`
    Position(<crate::values::specified::PositionProperty as ToComputedValue>::ComputedValue),
    /// `position-area`
    PositionArea(<crate::values::specified::PositionArea as ToComputedValue>::ComputedValue),
    /// `-servo-overflow-clip-box`
    ServoOverflowClipBox(Void),
    /// `-servo-top-layer`
    ServoTopLayer(Void),
    /// `table-layout`
    TableLayout(<longhands::table_layout::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `text-align`
    TextAlign(<crate::values::specified::TextAlign as ToComputedValue>::ComputedValue),
    /// `text-align-last`
    TextAlignLast(<crate::values::specified::TextAlignLast as ToComputedValue>::ComputedValue),
    /// `text-decoration-line`
    TextDecorationLine(<crate::values::specified::TextDecorationLine as ToComputedValue>::ComputedValue),
    /// `text-decoration-style`
    TextDecorationStyle(<longhands::text_decoration_style::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `text-justify`
    TextJustify(<crate::values::specified::TextJustify as ToComputedValue>::ComputedValue),
    /// `text-rendering`
    TextRendering(<longhands::text_rendering::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `text-transform`
    TextTransform(<crate::values::specified::TextTransform as ToComputedValue>::ComputedValue),
    /// `text-wrap-mode`
    TextWrapMode(<longhands::text_wrap_mode::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `transform-style`
    TransformStyle(<crate::values::specified::TransformStyle as ToComputedValue>::ComputedValue),
    /// `unicode-bidi`
    UnicodeBidi(Void),
    /// `visibility`
    Visibility(<<longhands::visibility::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `white-space-collapse`
    WhiteSpaceCollapse(<longhands::white_space_collapse::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `word-break`
    WordBreak(<crate::values::specified::WordBreak as ToComputedValue>::ComputedValue),
    /// `writing-mode`
    WritingMode(Void),
    /// `z-index`
    ZIndex(<<crate::values::specified::ZIndex as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `zoom`
    Zoom(<<crate::values::specified::Zoom as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `align-content`
    AlignContent(<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue),
    /// `justify-content`
    JustifyContent(<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue),
    /// `flex-grow`
    FlexGrow(<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `flex-shrink`
    FlexShrink(<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `align-self`
    AlignSelf(<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue),
    /// `justify-self`
    JustifySelf(<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue),
    /// `overflow-block`
    OverflowBlock(Void),
    /// `overflow-inline`
    OverflowInline(Void),
    /// `overflow-x`
    OverflowX(<crate::values::specified::Overflow as ToComputedValue>::ComputedValue),
    /// `overflow-y`
    OverflowY(<crate::values::specified::Overflow as ToComputedValue>::ComputedValue),
    /// `border-block-end-style`
    BorderBlockEndStyle(Void),
    /// `border-block-start-style`
    BorderBlockStartStyle(Void),
    /// `border-bottom-style`
    BorderBottomStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
    /// `border-inline-end-style`
    BorderInlineEndStyle(Void),
    /// `border-inline-start-style`
    BorderInlineStartStyle(Void),
    /// `border-left-style`
    BorderLeftStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
    /// `border-right-style`
    BorderRightStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
    /// `border-top-style`
    BorderTopStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
    /// `animation-composition`
    AnimationComposition(Void),
    /// `animation-delay`
    AnimationDelay(Void),
    /// `animation-direction`
    AnimationDirection(Void),
    /// `animation-duration`
    AnimationDuration(Void),
    /// `animation-fill-mode`
    AnimationFillMode(Void),
    /// `animation-iteration-count`
    AnimationIterationCount(Void),
    /// `animation-name`
    AnimationName(Void),
    /// `animation-play-state`
    AnimationPlayState(Void),
    /// `animation-timeline`
    AnimationTimeline(Void),
    /// `animation-timing-function`
    AnimationTimingFunction(Void),
    /// `backdrop-filter`
    BackdropFilter(<<longhands::backdrop_filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `background-attachment`
    BackgroundAttachment(<longhands::background_attachment::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `background-clip`
    BackgroundClip(<longhands::background_clip::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `background-image`
    BackgroundImage(<longhands::background_image::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `background-origin`
    BackgroundOrigin(<longhands::background_origin::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `background-position-x`
    BackgroundPositionX(<<longhands::background_position_x::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `background-position-y`
    BackgroundPositionY(<<longhands::background_position_y::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `background-repeat`
    BackgroundRepeat(<longhands::background_repeat::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `background-size`
    BackgroundSize(<<longhands::background_size::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-image-outset`
    BorderImageOutset(<<crate::values::specified::NonNegativeLengthOrNumberRect as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-image-slice`
    BorderImageSlice(<<crate::values::specified::BorderImageSlice as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-image-width`
    BorderImageWidth(<<crate::values::specified::BorderImageWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-spacing`
    BorderSpacing(<<crate::values::specified::BorderSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `box-shadow`
    BoxShadow(<<longhands::box_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `clip`
    Clip(<<crate::values::specified::ClipRectOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `clip-path`
    ClipPath(<<crate::values::specified::basic_shape::ClipPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `color`
    Color(<<crate::values::specified::ColorPropertyValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `color-scheme`
    ColorScheme(<crate::values::specified::ColorScheme as ToComputedValue>::ComputedValue),
    /// `column-width`
    ColumnWidth(<<crate::values::specified::length::NonNegativeLengthOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `container-name`
    ContainerName(Void),
    /// `content`
    Content(<crate::values::specified::Content as ToComputedValue>::ComputedValue),
    /// `counter-increment`
    CounterIncrement(<crate::values::specified::CounterIncrement as ToComputedValue>::ComputedValue),
    /// `counter-reset`
    CounterReset(<crate::values::specified::CounterReset as ToComputedValue>::ComputedValue),
    /// `cursor`
    Cursor(<crate::values::specified::Cursor as ToComputedValue>::ComputedValue),
    /// `filter`
    Filter(<<longhands::filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `flex-basis`
    FlexBasis(<<crate::values::specified::FlexBasis as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `font-family`
    FontFamily(<crate::values::specified::FontFamily as ToComputedValue>::ComputedValue),
    /// `font-size`
    FontSize(<<crate::values::specified::FontSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `font-variation-settings`
    FontVariationSettings(<<crate::values::specified::FontVariationSettings as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `grid-template-areas`
    GridTemplateAreas(<crate::values::specified::GridTemplateAreas as ToComputedValue>::ComputedValue),
    /// `letter-spacing`
    LetterSpacing(<<crate::values::specified::LetterSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `line-height`
    LineHeight(<<crate::values::specified::LineHeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `mask-image`
    MaskImage(<longhands::mask_image::SpecifiedValue as ToComputedValue>::ComputedValue),
    /// `offset-path`
    OffsetPath(<<crate::values::specified::OffsetPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `outline-offset`
    OutlineOffset(<<crate::values::specified::BorderSideOffset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `overflow-clip-margin`
    OverflowClipMargin(<<crate::values::specified::Length as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `perspective`
    Perspective(<<crate::values::specified::Perspective as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `quotes`
    Quotes(<crate::values::specified::Quotes as ToComputedValue>::ComputedValue),
    /// `rotate`
    Rotate(<<crate::values::specified::Rotate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `scale`
    Scale(<<crate::values::specified::Scale as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `text-indent`
    TextIndent(<<crate::values::specified::TextIndent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `text-overflow`
    TextOverflow(<crate::values::specified::TextOverflow as ToComputedValue>::ComputedValue),
    /// `text-shadow`
    TextShadow(<<longhands::text_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `transform`
    Transform(<<crate::values::specified::Transform as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `transform-origin`
    TransformOrigin(<<crate::values::specified::TransformOrigin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `transition-behavior`
    TransitionBehavior(Void),
    /// `transition-delay`
    TransitionDelay(Void),
    /// `transition-duration`
    TransitionDuration(Void),
    /// `transition-property`
    TransitionProperty(Void),
    /// `transition-timing-function`
    TransitionTimingFunction(Void),
    /// `translate`
    Translate(<<crate::values::specified::Translate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `vertical-align`
    VerticalAlign(<<crate::values::specified::VerticalAlign as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `view-transition-class`
    ViewTransitionClass(<crate::values::specified::ViewTransitionClass as ToComputedValue>::ComputedValue),
    /// `view-transition-name`
    ViewTransitionName(<crate::values::specified::ViewTransitionName as ToComputedValue>::ComputedValue),
    /// `will-change`
    WillChange(Void),
    /// `word-spacing`
    WordSpacing(<<crate::values::specified::WordSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `-x-lang`
    XLang(Void),
    /// `object-position`
    ObjectPosition(<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `perspective-origin`
    PerspectiveOrigin(<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `grid-template-columns`
    GridTemplateColumns(<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `grid-template-rows`
    GridTemplateRows(<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-image-source`
    BorderImageSource(<crate::values::specified::Image as ToComputedValue>::ComputedValue),
    /// `list-style-image`
    ListStyleImage(<crate::values::specified::Image as ToComputedValue>::ComputedValue),
    /// `grid-auto-columns`
    GridAutoColumns(<crate::values::specified::ImplicitGridTracks as ToComputedValue>::ComputedValue),
    /// `grid-auto-rows`
    GridAutoRows(<crate::values::specified::ImplicitGridTracks as ToComputedValue>::ComputedValue),
    /// `column-gap`
    ColumnGap(<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `row-gap`
    RowGap(<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `grid-column-end`
    GridColumnEnd(<crate::values::specified::GridLine as ToComputedValue>::ComputedValue),
    /// `grid-column-start`
    GridColumnStart(<crate::values::specified::GridLine as ToComputedValue>::ComputedValue),
    /// `grid-row-end`
    GridRowEnd(<crate::values::specified::GridLine as ToComputedValue>::ComputedValue),
    /// `grid-row-start`
    GridRowStart(<crate::values::specified::GridLine as ToComputedValue>::ComputedValue),
    /// `max-block-size`
    MaxBlockSize(Void),
    /// `max-height`
    MaxHeight(<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `max-inline-size`
    MaxInlineSize(Void),
    /// `max-width`
    MaxWidth(<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-bottom-left-radius`
    BorderBottomLeftRadius(<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-bottom-right-radius`
    BorderBottomRightRadius(<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-end-end-radius`
    BorderEndEndRadius(Void),
    /// `border-end-start-radius`
    BorderEndStartRadius(Void),
    /// `border-start-end-radius`
    BorderStartEndRadius(Void),
    /// `border-start-start-radius`
    BorderStartStartRadius(Void),
    /// `border-top-left-radius`
    BorderTopLeftRadius(<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-top-right-radius`
    BorderTopRightRadius(<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `bottom`
    Bottom(<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `inset-block-end`
    InsetBlockEnd(Void),
    /// `inset-block-start`
    InsetBlockStart(Void),
    /// `inset-inline-end`
    InsetInlineEnd(Void),
    /// `inset-inline-start`
    InsetInlineStart(Void),
    /// `left`
    Left(<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `right`
    Right(<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `top`
    Top(<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `margin-block-end`
    MarginBlockEnd(Void),
    /// `margin-block-start`
    MarginBlockStart(Void),
    /// `margin-bottom`
    MarginBottom(<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `margin-inline-end`
    MarginInlineEnd(Void),
    /// `margin-inline-start`
    MarginInlineStart(Void),
    /// `margin-left`
    MarginLeft(<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `margin-right`
    MarginRight(<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `margin-top`
    MarginTop(<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `padding-block-end`
    PaddingBlockEnd(Void),
    /// `padding-block-start`
    PaddingBlockStart(Void),
    /// `padding-bottom`
    PaddingBottom(<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `padding-inline-end`
    PaddingInlineEnd(Void),
    /// `padding-inline-start`
    PaddingInlineStart(Void),
    /// `padding-left`
    PaddingLeft(<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `padding-right`
    PaddingRight(<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `padding-top`
    PaddingTop(<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `block-size`
    BlockSize(Void),
    /// `height`
    Height(<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `inline-size`
    InlineSize(Void),
    /// `min-block-size`
    MinBlockSize(Void),
    /// `min-height`
    MinHeight(<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `min-inline-size`
    MinInlineSize(Void),
    /// `min-width`
    MinWidth(<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `width`
    Width(<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-block-end-width`
    BorderBlockEndWidth(Void),
    /// `border-block-start-width`
    BorderBlockStartWidth(Void),
    /// `border-bottom-width`
    BorderBottomWidth(<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-inline-end-width`
    BorderInlineEndWidth(Void),
    /// `border-inline-start-width`
    BorderInlineStartWidth(Void),
    /// `border-left-width`
    BorderLeftWidth(<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-right-width`
    BorderRightWidth(<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-top-width`
    BorderTopWidth(<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `outline-width`
    OutlineWidth(<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `background-color`
    BackgroundColor(<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-block-end-color`
    BorderBlockEndColor(Void),
    /// `border-block-start-color`
    BorderBlockStartColor(Void),
    /// `border-bottom-color`
    BorderBottomColor(<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-inline-end-color`
    BorderInlineEndColor(Void),
    /// `border-inline-start-color`
    BorderInlineStartColor(Void),
    /// `border-left-color`
    BorderLeftColor(<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-right-color`
    BorderRightColor(<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `border-top-color`
    BorderTopColor(<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `outline-color`
    OutlineColor(<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// `text-decoration-color`
    TextDecorationColor(<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
    /// A custom property.
    Custom(CustomAnimatedValue),
}



#[repr(C)]
struct AnimationValueVariantRepr<T> {
    tag: u16,
    value: T
}

impl Clone for AnimationValue {
    #[inline]
    fn clone(&self) -> Self {
        use self::AnimationValue::*;

        

        let self_tag = unsafe { *(self as *const _ as *const u16) };
        if self_tag <= LonghandId::BorderTopStyle as u16 {
            #[derive(Clone, Copy)]
            #[repr(u16)]
            enum CopyVariants {
                _AlignItems(<crate::values::specified::ItemPlacement as ToComputedValue>::ComputedValue),
                _AspectRatio(<<crate::values::specified::AspectRatio as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _BackfaceVisibility(<longhands::backface_visibility::SpecifiedValue as ToComputedValue>::ComputedValue),
                _BaselineSource(<crate::values::specified::BaselineSource as ToComputedValue>::ComputedValue),
                _BorderCollapse(<longhands::border_collapse::SpecifiedValue as ToComputedValue>::ComputedValue),
                _BorderImageRepeat(<crate::values::specified::BorderImageRepeat as ToComputedValue>::ComputedValue),
                _BoxSizing(<longhands::box_sizing::SpecifiedValue as ToComputedValue>::ComputedValue),
                _CaptionSide(<crate::values::specified::table::CaptionSide as ToComputedValue>::ComputedValue),
                _Clear(<crate::values::specified::Clear as ToComputedValue>::ComputedValue),
                _ColumnCount(<<crate::values::specified::ColumnCount as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _ColumnSpan(<longhands::column_span::SpecifiedValue as ToComputedValue>::ComputedValue),
                _Display(<crate::values::specified::Display as ToComputedValue>::ComputedValue),
                _EmptyCells(<longhands::empty_cells::SpecifiedValue as ToComputedValue>::ComputedValue),
                _FlexDirection(<longhands::flex_direction::SpecifiedValue as ToComputedValue>::ComputedValue),
                _FlexWrap(<longhands::flex_wrap::SpecifiedValue as ToComputedValue>::ComputedValue),
                _Float(<crate::values::specified::Float as ToComputedValue>::ComputedValue),
                _FontLanguageOverride(<crate::values::specified::FontLanguageOverride as ToComputedValue>::ComputedValue),
                _FontStretch(<<crate::values::specified::FontStretch as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _FontStyle(<<crate::values::specified::FontStyle as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _FontSynthesisWeight(<crate::values::specified::FontSynthesis as ToComputedValue>::ComputedValue),
                _FontVariantCaps(<longhands::font_variant_caps::SpecifiedValue as ToComputedValue>::ComputedValue),
                _FontWeight(<<crate::values::specified::FontWeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _GridAutoFlow(<crate::values::specified::GridAutoFlow as ToComputedValue>::ComputedValue),
                _ImageRendering(<crate::values::specified::ImageRendering as ToComputedValue>::ComputedValue),
                _Isolation(<longhands::isolation::SpecifiedValue as ToComputedValue>::ComputedValue),
                _JustifyItems(<crate::values::specified::JustifyItems as ToComputedValue>::ComputedValue),
                _ListStylePosition(<longhands::list_style_position::SpecifiedValue as ToComputedValue>::ComputedValue),
                _ListStyleType(<longhands::list_style_type::SpecifiedValue as ToComputedValue>::ComputedValue),
                _MixBlendMode(<longhands::mix_blend_mode::SpecifiedValue as ToComputedValue>::ComputedValue),
                _ObjectFit(<longhands::object_fit::SpecifiedValue as ToComputedValue>::ComputedValue),
                _Opacity(<<crate::values::specified::Opacity as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _Order(<<crate::values::specified::Integer as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _OutlineStyle(<crate::values::specified::OutlineStyle as ToComputedValue>::ComputedValue),
                _OverflowWrap(<crate::values::specified::OverflowWrap as ToComputedValue>::ComputedValue),
                _PointerEvents(<crate::values::specified::PointerEvents as ToComputedValue>::ComputedValue),
                _Position(<crate::values::specified::PositionProperty as ToComputedValue>::ComputedValue),
                _PositionArea(<crate::values::specified::PositionArea as ToComputedValue>::ComputedValue),
                _TableLayout(<longhands::table_layout::SpecifiedValue as ToComputedValue>::ComputedValue),
                _TextAlign(<crate::values::specified::TextAlign as ToComputedValue>::ComputedValue),
                _TextAlignLast(<crate::values::specified::TextAlignLast as ToComputedValue>::ComputedValue),
                _TextDecorationLine(<crate::values::specified::TextDecorationLine as ToComputedValue>::ComputedValue),
                _TextDecorationStyle(<longhands::text_decoration_style::SpecifiedValue as ToComputedValue>::ComputedValue),
                _TextJustify(<crate::values::specified::TextJustify as ToComputedValue>::ComputedValue),
                _TextRendering(<longhands::text_rendering::SpecifiedValue as ToComputedValue>::ComputedValue),
                _TextTransform(<crate::values::specified::TextTransform as ToComputedValue>::ComputedValue),
                _TextWrapMode(<longhands::text_wrap_mode::SpecifiedValue as ToComputedValue>::ComputedValue),
                _TransformStyle(<crate::values::specified::TransformStyle as ToComputedValue>::ComputedValue),
                _Visibility(<<longhands::visibility::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _WhiteSpaceCollapse(<longhands::white_space_collapse::SpecifiedValue as ToComputedValue>::ComputedValue),
                _WordBreak(<crate::values::specified::WordBreak as ToComputedValue>::ComputedValue),
                _ZIndex(<<crate::values::specified::ZIndex as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _Zoom(<<crate::values::specified::Zoom as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _AlignContent(<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue),
                _JustifyContent(<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue),
                _FlexGrow(<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _FlexShrink(<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue),
                _AlignSelf(<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue),
                _JustifySelf(<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue),
                _OverflowX(<crate::values::specified::Overflow as ToComputedValue>::ComputedValue),
                _OverflowY(<crate::values::specified::Overflow as ToComputedValue>::ComputedValue),
                _BorderBottomStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
                _BorderLeftStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
                _BorderRightStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
                _BorderTopStyle(<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue),
            }

            unsafe {
                let mut out = mem::MaybeUninit::uninit();
                ptr::write(
                    out.as_mut_ptr() as *mut CopyVariants,
                    *(self as *const _ as *const CopyVariants),
                );
                return out.assume_init();
            }
        }

        match *self {
            
            BackdropFilter(ref value) => {
                BackdropFilter(value.clone())
            }
            
            BackgroundAttachment(ref value) => {
                BackgroundAttachment(value.clone())
            }
            
            BackgroundClip(ref value) => {
                BackgroundClip(value.clone())
            }
            
            BackgroundImage(ref value) => {
                BackgroundImage(value.clone())
            }
            
            BackgroundOrigin(ref value) => {
                BackgroundOrigin(value.clone())
            }
            
            BackgroundPositionX(ref value) => {
                BackgroundPositionX(value.clone())
            }
            
            BackgroundPositionY(ref value) => {
                BackgroundPositionY(value.clone())
            }
            
            BackgroundRepeat(ref value) => {
                BackgroundRepeat(value.clone())
            }
            
            BackgroundSize(ref value) => {
                BackgroundSize(value.clone())
            }
            
            BorderImageOutset(ref value) => {
                BorderImageOutset(value.clone())
            }
            
            BorderImageSlice(ref value) => {
                BorderImageSlice(value.clone())
            }
            
            BorderImageWidth(ref value) => {
                BorderImageWidth(value.clone())
            }
            
            BorderSpacing(ref value) => {
                BorderSpacing(value.clone())
            }
            
            BoxShadow(ref value) => {
                BoxShadow(value.clone())
            }
            
            Clip(ref value) => {
                Clip(value.clone())
            }
            
            ClipPath(ref value) => {
                ClipPath(value.clone())
            }
            
            Color(ref value) => {
                Color(value.clone())
            }
            
            ColorScheme(ref value) => {
                ColorScheme(value.clone())
            }
            
            ColumnWidth(ref value) => {
                ColumnWidth(value.clone())
            }
            
            Content(ref value) => {
                Content(value.clone())
            }
            
            CounterIncrement(ref value) => {
                CounterIncrement(value.clone())
            }
            
            CounterReset(ref value) => {
                CounterReset(value.clone())
            }
            
            Cursor(ref value) => {
                Cursor(value.clone())
            }
            
            Filter(ref value) => {
                Filter(value.clone())
            }
            
            FlexBasis(ref value) => {
                FlexBasis(value.clone())
            }
            
            FontFamily(ref value) => {
                FontFamily(value.clone())
            }
            
            FontSize(ref value) => {
                FontSize(value.clone())
            }
            
            FontVariationSettings(ref value) => {
                FontVariationSettings(value.clone())
            }
            
            GridTemplateAreas(ref value) => {
                GridTemplateAreas(value.clone())
            }
            
            LetterSpacing(ref value) => {
                LetterSpacing(value.clone())
            }
            
            LineHeight(ref value) => {
                LineHeight(value.clone())
            }
            
            MaskImage(ref value) => {
                MaskImage(value.clone())
            }
            
            OffsetPath(ref value) => {
                OffsetPath(value.clone())
            }
            
            OutlineOffset(ref value) => {
                OutlineOffset(value.clone())
            }
            
            OverflowClipMargin(ref value) => {
                OverflowClipMargin(value.clone())
            }
            
            Perspective(ref value) => {
                Perspective(value.clone())
            }
            
            Quotes(ref value) => {
                Quotes(value.clone())
            }
            
            Rotate(ref value) => {
                Rotate(value.clone())
            }
            
            Scale(ref value) => {
                Scale(value.clone())
            }
            
            TextIndent(ref value) => {
                TextIndent(value.clone())
            }
            
            TextOverflow(ref value) => {
                TextOverflow(value.clone())
            }
            
            TextShadow(ref value) => {
                TextShadow(value.clone())
            }
            
            Transform(ref value) => {
                Transform(value.clone())
            }
            
            TransformOrigin(ref value) => {
                TransformOrigin(value.clone())
            }
            
            Translate(ref value) => {
                Translate(value.clone())
            }
            
            VerticalAlign(ref value) => {
                VerticalAlign(value.clone())
            }
            
            ViewTransitionClass(ref value) => {
                ViewTransitionClass(value.clone())
            }
            
            ViewTransitionName(ref value) => {
                ViewTransitionName(value.clone())
            }
            
            WordSpacing(ref value) => {
                WordSpacing(value.clone())
            }
            
            ObjectPosition(ref value) |
PerspectiveOrigin(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridTemplateColumns(ref value) |
GridTemplateRows(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderImageSource(ref value) |
ListStyleImage(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Image as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridAutoColumns(ref value) |
GridAutoRows(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ImplicitGridTracks as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            ColumnGap(ref value) |
RowGap(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridColumnEnd(ref value) |
GridColumnStart(ref value) |
GridRowEnd(ref value) |
GridRowStart(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::GridLine as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            MaxHeight(ref value) |
MaxWidth(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderBottomLeftRadius(ref value) |
BorderBottomRightRadius(ref value) |
BorderTopLeftRadius(ref value) |
BorderTopRightRadius(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            Bottom(ref value) |
Left(ref value) |
Right(ref value) |
Top(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            MarginBottom(ref value) |
MarginLeft(ref value) |
MarginRight(ref value) |
MarginTop(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            PaddingBottom(ref value) |
PaddingLeft(ref value) |
PaddingRight(ref value) |
PaddingTop(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            Height(ref value) |
MinHeight(ref value) |
MinWidth(ref value) |
Width(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderBottomWidth(ref value) |
BorderLeftWidth(ref value) |
BorderRightWidth(ref value) |
BorderTopWidth(ref value) |
OutlineWidth(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            
            BackgroundColor(ref value) |
BorderBottomColor(ref value) |
BorderLeftColor(ref value) |
BorderRightColor(ref value) |
BorderTopColor(ref value) |
OutlineColor(ref value) |
TextDecorationColor(ref value) => {
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value: value.clone(),
                        },
                    );
                    out.assume_init()
                }
            }
            Custom(ref animated_value) => Custom(animated_value.clone()),
            _ => unsafe { debug_unreachable!() }
        }
    }
}

impl PartialEq for AnimationValue {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        use self::AnimationValue::*;

        unsafe {
            let this_tag = *(self as *const _ as *const u16);
            let other_tag = *(other as *const _ as *const u16);
            if this_tag != other_tag {
                return false;
            }

            match *self {
                AlignItems(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ItemPlacement as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                AspectRatio(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::AspectRatio as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BackfaceVisibility(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::backface_visibility::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BaselineSource(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::BaselineSource as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BorderCollapse(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::border_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BorderImageRepeat(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::BorderImageRepeat as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BoxSizing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::box_sizing::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                CaptionSide(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::table::CaptionSide as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Clear(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Clear as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ColumnCount(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ColumnCount as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                ColumnSpan(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::column_span::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Display(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Display as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                EmptyCells(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::empty_cells::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FlexDirection(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::flex_direction::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FlexWrap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::flex_wrap::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Float(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Float as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FontLanguageOverride(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::FontLanguageOverride as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FontStretch(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontStretch as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                FontStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontStyle as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                FontSynthesisWeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::FontSynthesis as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FontVariantCaps(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::font_variant_caps::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FontWeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontWeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                GridAutoFlow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::GridAutoFlow as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ImageRendering(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ImageRendering as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Isolation(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::isolation::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                JustifyItems(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::JustifyItems as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ListStylePosition(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::list_style_position::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ListStyleType(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::list_style_type::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                MixBlendMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::mix_blend_mode::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ObjectFit(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::object_fit::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Opacity(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Opacity as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Order(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Integer as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                OutlineStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::OutlineStyle as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                OverflowWrap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::OverflowWrap as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                PointerEvents(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::PointerEvents as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Position(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::PositionProperty as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                PositionArea(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::PositionArea as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TableLayout(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::table_layout::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextAlign(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextAlign as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextAlignLast(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextAlignLast as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextDecorationLine(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextDecorationLine as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextDecorationStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::text_decoration_style::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextJustify(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextJustify as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextRendering(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::text_rendering::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextTransform(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextTransform as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextWrapMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::text_wrap_mode::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TransformStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TransformStyle as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Visibility(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::visibility::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                WhiteSpaceCollapse(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::white_space_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                WordBreak(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::WordBreak as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ZIndex(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ZIndex as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Zoom(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Zoom as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                AlignContent(ref this) |
JustifyContent(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FlexGrow(ref this) |
FlexShrink(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                AlignSelf(ref this) |
JustifySelf(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                OverflowX(ref this) |
OverflowY(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Overflow as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BorderBottomStyle(ref this) |
BorderLeftStyle(ref this) |
BorderRightStyle(ref this) |
BorderTopStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BackdropFilter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::backdrop_filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BackgroundAttachment(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_attachment::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BackgroundClip(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_clip::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BackgroundImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_image::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BackgroundOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_origin::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BackgroundPositionX(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_position_x::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BackgroundPositionY(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_position_y::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BackgroundRepeat(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_repeat::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                BackgroundSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_size::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BorderImageOutset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthOrNumberRect as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BorderImageSlice(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderImageSlice as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BorderImageWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderImageWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BorderSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BoxShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::box_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Clip(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ClipRectOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                ClipPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::basic_shape::ClipPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Color(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ColorPropertyValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                ColorScheme(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ColorScheme as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ColumnWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Content(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Content as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                CounterIncrement(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::CounterIncrement as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                CounterReset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::CounterReset as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Cursor(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Cursor as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Filter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                FlexBasis(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FlexBasis as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                FontFamily(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::FontFamily as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                FontSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                FontVariationSettings(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontVariationSettings as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                GridTemplateAreas(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::GridTemplateAreas as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                LetterSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::LetterSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                LineHeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::LineHeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                MaskImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::mask_image::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                OffsetPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::OffsetPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                OutlineOffset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSideOffset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                OverflowClipMargin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Length as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Perspective(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Perspective as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Quotes(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Quotes as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                Rotate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Rotate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Scale(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Scale as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                TextIndent(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::TextIndent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                TextOverflow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextOverflow as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                TextShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::text_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Transform(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Transform as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                TransformOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::TransformOrigin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Translate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Translate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                VerticalAlign(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::VerticalAlign as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                ViewTransitionClass(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ViewTransitionClass as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ViewTransitionName(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ViewTransitionName as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                WordSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::WordSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                ObjectPosition(ref this) |
PerspectiveOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                GridTemplateColumns(ref this) |
GridTemplateRows(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BorderImageSource(ref this) |
ListStyleImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Image as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                GridAutoColumns(ref this) |
GridAutoRows(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ImplicitGridTracks as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                ColumnGap(ref this) |
RowGap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                GridColumnEnd(ref this) |
GridColumnStart(ref this) |
GridRowEnd(ref this) |
GridRowStart(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::GridLine as ToComputedValue>::ComputedValue>);
                    *this == other_repr.value
                }
                MaxHeight(ref this) |
MaxWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BorderBottomLeftRadius(ref this) |
BorderBottomRightRadius(ref this) |
BorderTopLeftRadius(ref this) |
BorderTopRightRadius(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Bottom(ref this) |
Left(ref this) |
Right(ref this) |
Top(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                MarginBottom(ref this) |
MarginLeft(ref this) |
MarginRight(ref this) |
MarginTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                PaddingBottom(ref this) |
PaddingLeft(ref this) |
PaddingRight(ref this) |
PaddingTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Height(ref this) |
MinHeight(ref this) |
MinWidth(ref this) |
Width(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BorderBottomWidth(ref this) |
BorderLeftWidth(ref this) |
BorderRightWidth(ref this) |
BorderTopWidth(ref this) |
OutlineWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                BackgroundColor(ref this) |
BorderBottomColor(ref this) |
BorderLeftColor(ref this) |
BorderRightColor(ref this) |
BorderTopColor(ref this) |
OutlineColor(ref this) |
TextDecorationColor(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    *this == other_repr.value
                }
                Contain(void) |
ContainerType(void) |
Direction(void) |
ServoOverflowClipBox(void) |
ServoTopLayer(void) |
UnicodeBidi(void) |
WritingMode(void) |
OverflowBlock(void) |
OverflowInline(void) |
BorderBlockEndStyle(void) |
BorderBlockStartStyle(void) |
BorderInlineEndStyle(void) |
BorderInlineStartStyle(void) |
AnimationComposition(void) |
AnimationDelay(void) |
AnimationDirection(void) |
AnimationDuration(void) |
AnimationFillMode(void) |
AnimationIterationCount(void) |
AnimationName(void) |
AnimationPlayState(void) |
AnimationTimeline(void) |
AnimationTimingFunction(void) |
ContainerName(void) |
TransitionBehavior(void) |
TransitionDelay(void) |
TransitionDuration(void) |
TransitionProperty(void) |
TransitionTimingFunction(void) |
WillChange(void) |
XLang(void) |
MaxBlockSize(void) |
MaxInlineSize(void) |
BorderEndEndRadius(void) |
BorderEndStartRadius(void) |
BorderStartEndRadius(void) |
BorderStartStartRadius(void) |
InsetBlockEnd(void) |
InsetBlockStart(void) |
InsetInlineEnd(void) |
InsetInlineStart(void) |
MarginBlockEnd(void) |
MarginBlockStart(void) |
MarginInlineEnd(void) |
MarginInlineStart(void) |
PaddingBlockEnd(void) |
PaddingBlockStart(void) |
PaddingInlineEnd(void) |
PaddingInlineStart(void) |
BlockSize(void) |
InlineSize(void) |
MinBlockSize(void) |
MinInlineSize(void) |
BorderBlockEndWidth(void) |
BorderBlockStartWidth(void) |
BorderInlineEndWidth(void) |
BorderInlineStartWidth(void) |
BorderBlockEndColor(void) |
BorderBlockStartColor(void) |
BorderInlineEndColor(void) |
BorderInlineStartColor(void) => {
                    void::unreachable(void)
                },
                AnimationValue::Custom(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<CustomAnimatedValue>);
                    *this == other_repr.value
                },
            }
        }
    }
}

impl AnimationValue {
    /// Returns the longhand id this animated value corresponds to.
    #[inline]
    pub fn id(&self) -> PropertyDeclarationId<'_> {
        if let AnimationValue::Custom(animated_value) = self {
            return PropertyDeclarationId::Custom(&animated_value.name);
        }

        let id = unsafe { *(self as *const _ as *const LonghandId) };
        debug_assert_eq!(id, match *self {
            AnimationValue::AlignItems(..) => LonghandId::AlignItems,
            AnimationValue::AspectRatio(..) => LonghandId::AspectRatio,
            AnimationValue::BackfaceVisibility(..) => LonghandId::BackfaceVisibility,
            AnimationValue::BaselineSource(..) => LonghandId::BaselineSource,
            AnimationValue::BorderCollapse(..) => LonghandId::BorderCollapse,
            AnimationValue::BorderImageRepeat(..) => LonghandId::BorderImageRepeat,
            AnimationValue::BoxSizing(..) => LonghandId::BoxSizing,
            AnimationValue::CaptionSide(..) => LonghandId::CaptionSide,
            AnimationValue::Clear(..) => LonghandId::Clear,
            AnimationValue::ColumnCount(..) => LonghandId::ColumnCount,
            AnimationValue::ColumnSpan(..) => LonghandId::ColumnSpan,
            AnimationValue::Contain(void) => void::unreachable(void),
            AnimationValue::ContainerType(void) => void::unreachable(void),
            AnimationValue::Direction(void) => void::unreachable(void),
            AnimationValue::Display(..) => LonghandId::Display,
            AnimationValue::EmptyCells(..) => LonghandId::EmptyCells,
            AnimationValue::FlexDirection(..) => LonghandId::FlexDirection,
            AnimationValue::FlexWrap(..) => LonghandId::FlexWrap,
            AnimationValue::Float(..) => LonghandId::Float,
            AnimationValue::FontLanguageOverride(..) => LonghandId::FontLanguageOverride,
            AnimationValue::FontStretch(..) => LonghandId::FontStretch,
            AnimationValue::FontStyle(..) => LonghandId::FontStyle,
            AnimationValue::FontSynthesisWeight(..) => LonghandId::FontSynthesisWeight,
            AnimationValue::FontVariantCaps(..) => LonghandId::FontVariantCaps,
            AnimationValue::FontWeight(..) => LonghandId::FontWeight,
            AnimationValue::GridAutoFlow(..) => LonghandId::GridAutoFlow,
            AnimationValue::ImageRendering(..) => LonghandId::ImageRendering,
            AnimationValue::Isolation(..) => LonghandId::Isolation,
            AnimationValue::JustifyItems(..) => LonghandId::JustifyItems,
            AnimationValue::ListStylePosition(..) => LonghandId::ListStylePosition,
            AnimationValue::ListStyleType(..) => LonghandId::ListStyleType,
            AnimationValue::MixBlendMode(..) => LonghandId::MixBlendMode,
            AnimationValue::ObjectFit(..) => LonghandId::ObjectFit,
            AnimationValue::Opacity(..) => LonghandId::Opacity,
            AnimationValue::Order(..) => LonghandId::Order,
            AnimationValue::OutlineStyle(..) => LonghandId::OutlineStyle,
            AnimationValue::OverflowWrap(..) => LonghandId::OverflowWrap,
            AnimationValue::PointerEvents(..) => LonghandId::PointerEvents,
            AnimationValue::Position(..) => LonghandId::Position,
            AnimationValue::PositionArea(..) => LonghandId::PositionArea,
            AnimationValue::ServoOverflowClipBox(void) => void::unreachable(void),
            AnimationValue::ServoTopLayer(void) => void::unreachable(void),
            AnimationValue::TableLayout(..) => LonghandId::TableLayout,
            AnimationValue::TextAlign(..) => LonghandId::TextAlign,
            AnimationValue::TextAlignLast(..) => LonghandId::TextAlignLast,
            AnimationValue::TextDecorationLine(..) => LonghandId::TextDecorationLine,
            AnimationValue::TextDecorationStyle(..) => LonghandId::TextDecorationStyle,
            AnimationValue::TextJustify(..) => LonghandId::TextJustify,
            AnimationValue::TextRendering(..) => LonghandId::TextRendering,
            AnimationValue::TextTransform(..) => LonghandId::TextTransform,
            AnimationValue::TextWrapMode(..) => LonghandId::TextWrapMode,
            AnimationValue::TransformStyle(..) => LonghandId::TransformStyle,
            AnimationValue::UnicodeBidi(void) => void::unreachable(void),
            AnimationValue::Visibility(..) => LonghandId::Visibility,
            AnimationValue::WhiteSpaceCollapse(..) => LonghandId::WhiteSpaceCollapse,
            AnimationValue::WordBreak(..) => LonghandId::WordBreak,
            AnimationValue::WritingMode(void) => void::unreachable(void),
            AnimationValue::ZIndex(..) => LonghandId::ZIndex,
            AnimationValue::Zoom(..) => LonghandId::Zoom,
            AnimationValue::AlignContent(..) => LonghandId::AlignContent,
            AnimationValue::JustifyContent(..) => LonghandId::JustifyContent,
            AnimationValue::FlexGrow(..) => LonghandId::FlexGrow,
            AnimationValue::FlexShrink(..) => LonghandId::FlexShrink,
            AnimationValue::AlignSelf(..) => LonghandId::AlignSelf,
            AnimationValue::JustifySelf(..) => LonghandId::JustifySelf,
            AnimationValue::OverflowBlock(void) => void::unreachable(void),
            AnimationValue::OverflowInline(void) => void::unreachable(void),
            AnimationValue::OverflowX(..) => LonghandId::OverflowX,
            AnimationValue::OverflowY(..) => LonghandId::OverflowY,
            AnimationValue::BorderBlockEndStyle(void) => void::unreachable(void),
            AnimationValue::BorderBlockStartStyle(void) => void::unreachable(void),
            AnimationValue::BorderBottomStyle(..) => LonghandId::BorderBottomStyle,
            AnimationValue::BorderInlineEndStyle(void) => void::unreachable(void),
            AnimationValue::BorderInlineStartStyle(void) => void::unreachable(void),
            AnimationValue::BorderLeftStyle(..) => LonghandId::BorderLeftStyle,
            AnimationValue::BorderRightStyle(..) => LonghandId::BorderRightStyle,
            AnimationValue::BorderTopStyle(..) => LonghandId::BorderTopStyle,
            AnimationValue::AnimationComposition(void) => void::unreachable(void),
            AnimationValue::AnimationDelay(void) => void::unreachable(void),
            AnimationValue::AnimationDirection(void) => void::unreachable(void),
            AnimationValue::AnimationDuration(void) => void::unreachable(void),
            AnimationValue::AnimationFillMode(void) => void::unreachable(void),
            AnimationValue::AnimationIterationCount(void) => void::unreachable(void),
            AnimationValue::AnimationName(void) => void::unreachable(void),
            AnimationValue::AnimationPlayState(void) => void::unreachable(void),
            AnimationValue::AnimationTimeline(void) => void::unreachable(void),
            AnimationValue::AnimationTimingFunction(void) => void::unreachable(void),
            AnimationValue::BackdropFilter(..) => LonghandId::BackdropFilter,
            AnimationValue::BackgroundAttachment(..) => LonghandId::BackgroundAttachment,
            AnimationValue::BackgroundClip(..) => LonghandId::BackgroundClip,
            AnimationValue::BackgroundImage(..) => LonghandId::BackgroundImage,
            AnimationValue::BackgroundOrigin(..) => LonghandId::BackgroundOrigin,
            AnimationValue::BackgroundPositionX(..) => LonghandId::BackgroundPositionX,
            AnimationValue::BackgroundPositionY(..) => LonghandId::BackgroundPositionY,
            AnimationValue::BackgroundRepeat(..) => LonghandId::BackgroundRepeat,
            AnimationValue::BackgroundSize(..) => LonghandId::BackgroundSize,
            AnimationValue::BorderImageOutset(..) => LonghandId::BorderImageOutset,
            AnimationValue::BorderImageSlice(..) => LonghandId::BorderImageSlice,
            AnimationValue::BorderImageWidth(..) => LonghandId::BorderImageWidth,
            AnimationValue::BorderSpacing(..) => LonghandId::BorderSpacing,
            AnimationValue::BoxShadow(..) => LonghandId::BoxShadow,
            AnimationValue::Clip(..) => LonghandId::Clip,
            AnimationValue::ClipPath(..) => LonghandId::ClipPath,
            AnimationValue::Color(..) => LonghandId::Color,
            AnimationValue::ColorScheme(..) => LonghandId::ColorScheme,
            AnimationValue::ColumnWidth(..) => LonghandId::ColumnWidth,
            AnimationValue::ContainerName(void) => void::unreachable(void),
            AnimationValue::Content(..) => LonghandId::Content,
            AnimationValue::CounterIncrement(..) => LonghandId::CounterIncrement,
            AnimationValue::CounterReset(..) => LonghandId::CounterReset,
            AnimationValue::Cursor(..) => LonghandId::Cursor,
            AnimationValue::Filter(..) => LonghandId::Filter,
            AnimationValue::FlexBasis(..) => LonghandId::FlexBasis,
            AnimationValue::FontFamily(..) => LonghandId::FontFamily,
            AnimationValue::FontSize(..) => LonghandId::FontSize,
            AnimationValue::FontVariationSettings(..) => LonghandId::FontVariationSettings,
            AnimationValue::GridTemplateAreas(..) => LonghandId::GridTemplateAreas,
            AnimationValue::LetterSpacing(..) => LonghandId::LetterSpacing,
            AnimationValue::LineHeight(..) => LonghandId::LineHeight,
            AnimationValue::MaskImage(..) => LonghandId::MaskImage,
            AnimationValue::OffsetPath(..) => LonghandId::OffsetPath,
            AnimationValue::OutlineOffset(..) => LonghandId::OutlineOffset,
            AnimationValue::OverflowClipMargin(..) => LonghandId::OverflowClipMargin,
            AnimationValue::Perspective(..) => LonghandId::Perspective,
            AnimationValue::Quotes(..) => LonghandId::Quotes,
            AnimationValue::Rotate(..) => LonghandId::Rotate,
            AnimationValue::Scale(..) => LonghandId::Scale,
            AnimationValue::TextIndent(..) => LonghandId::TextIndent,
            AnimationValue::TextOverflow(..) => LonghandId::TextOverflow,
            AnimationValue::TextShadow(..) => LonghandId::TextShadow,
            AnimationValue::Transform(..) => LonghandId::Transform,
            AnimationValue::TransformOrigin(..) => LonghandId::TransformOrigin,
            AnimationValue::TransitionBehavior(void) => void::unreachable(void),
            AnimationValue::TransitionDelay(void) => void::unreachable(void),
            AnimationValue::TransitionDuration(void) => void::unreachable(void),
            AnimationValue::TransitionProperty(void) => void::unreachable(void),
            AnimationValue::TransitionTimingFunction(void) => void::unreachable(void),
            AnimationValue::Translate(..) => LonghandId::Translate,
            AnimationValue::VerticalAlign(..) => LonghandId::VerticalAlign,
            AnimationValue::ViewTransitionClass(..) => LonghandId::ViewTransitionClass,
            AnimationValue::ViewTransitionName(..) => LonghandId::ViewTransitionName,
            AnimationValue::WillChange(void) => void::unreachable(void),
            AnimationValue::WordSpacing(..) => LonghandId::WordSpacing,
            AnimationValue::XLang(void) => void::unreachable(void),
            AnimationValue::ObjectPosition(..) => LonghandId::ObjectPosition,
            AnimationValue::PerspectiveOrigin(..) => LonghandId::PerspectiveOrigin,
            AnimationValue::GridTemplateColumns(..) => LonghandId::GridTemplateColumns,
            AnimationValue::GridTemplateRows(..) => LonghandId::GridTemplateRows,
            AnimationValue::BorderImageSource(..) => LonghandId::BorderImageSource,
            AnimationValue::ListStyleImage(..) => LonghandId::ListStyleImage,
            AnimationValue::GridAutoColumns(..) => LonghandId::GridAutoColumns,
            AnimationValue::GridAutoRows(..) => LonghandId::GridAutoRows,
            AnimationValue::ColumnGap(..) => LonghandId::ColumnGap,
            AnimationValue::RowGap(..) => LonghandId::RowGap,
            AnimationValue::GridColumnEnd(..) => LonghandId::GridColumnEnd,
            AnimationValue::GridColumnStart(..) => LonghandId::GridColumnStart,
            AnimationValue::GridRowEnd(..) => LonghandId::GridRowEnd,
            AnimationValue::GridRowStart(..) => LonghandId::GridRowStart,
            AnimationValue::MaxBlockSize(void) => void::unreachable(void),
            AnimationValue::MaxHeight(..) => LonghandId::MaxHeight,
            AnimationValue::MaxInlineSize(void) => void::unreachable(void),
            AnimationValue::MaxWidth(..) => LonghandId::MaxWidth,
            AnimationValue::BorderBottomLeftRadius(..) => LonghandId::BorderBottomLeftRadius,
            AnimationValue::BorderBottomRightRadius(..) => LonghandId::BorderBottomRightRadius,
            AnimationValue::BorderEndEndRadius(void) => void::unreachable(void),
            AnimationValue::BorderEndStartRadius(void) => void::unreachable(void),
            AnimationValue::BorderStartEndRadius(void) => void::unreachable(void),
            AnimationValue::BorderStartStartRadius(void) => void::unreachable(void),
            AnimationValue::BorderTopLeftRadius(..) => LonghandId::BorderTopLeftRadius,
            AnimationValue::BorderTopRightRadius(..) => LonghandId::BorderTopRightRadius,
            AnimationValue::Bottom(..) => LonghandId::Bottom,
            AnimationValue::InsetBlockEnd(void) => void::unreachable(void),
            AnimationValue::InsetBlockStart(void) => void::unreachable(void),
            AnimationValue::InsetInlineEnd(void) => void::unreachable(void),
            AnimationValue::InsetInlineStart(void) => void::unreachable(void),
            AnimationValue::Left(..) => LonghandId::Left,
            AnimationValue::Right(..) => LonghandId::Right,
            AnimationValue::Top(..) => LonghandId::Top,
            AnimationValue::MarginBlockEnd(void) => void::unreachable(void),
            AnimationValue::MarginBlockStart(void) => void::unreachable(void),
            AnimationValue::MarginBottom(..) => LonghandId::MarginBottom,
            AnimationValue::MarginInlineEnd(void) => void::unreachable(void),
            AnimationValue::MarginInlineStart(void) => void::unreachable(void),
            AnimationValue::MarginLeft(..) => LonghandId::MarginLeft,
            AnimationValue::MarginRight(..) => LonghandId::MarginRight,
            AnimationValue::MarginTop(..) => LonghandId::MarginTop,
            AnimationValue::PaddingBlockEnd(void) => void::unreachable(void),
            AnimationValue::PaddingBlockStart(void) => void::unreachable(void),
            AnimationValue::PaddingBottom(..) => LonghandId::PaddingBottom,
            AnimationValue::PaddingInlineEnd(void) => void::unreachable(void),
            AnimationValue::PaddingInlineStart(void) => void::unreachable(void),
            AnimationValue::PaddingLeft(..) => LonghandId::PaddingLeft,
            AnimationValue::PaddingRight(..) => LonghandId::PaddingRight,
            AnimationValue::PaddingTop(..) => LonghandId::PaddingTop,
            AnimationValue::BlockSize(void) => void::unreachable(void),
            AnimationValue::Height(..) => LonghandId::Height,
            AnimationValue::InlineSize(void) => void::unreachable(void),
            AnimationValue::MinBlockSize(void) => void::unreachable(void),
            AnimationValue::MinHeight(..) => LonghandId::MinHeight,
            AnimationValue::MinInlineSize(void) => void::unreachable(void),
            AnimationValue::MinWidth(..) => LonghandId::MinWidth,
            AnimationValue::Width(..) => LonghandId::Width,
            AnimationValue::BorderBlockEndWidth(void) => void::unreachable(void),
            AnimationValue::BorderBlockStartWidth(void) => void::unreachable(void),
            AnimationValue::BorderBottomWidth(..) => LonghandId::BorderBottomWidth,
            AnimationValue::BorderInlineEndWidth(void) => void::unreachable(void),
            AnimationValue::BorderInlineStartWidth(void) => void::unreachable(void),
            AnimationValue::BorderLeftWidth(..) => LonghandId::BorderLeftWidth,
            AnimationValue::BorderRightWidth(..) => LonghandId::BorderRightWidth,
            AnimationValue::BorderTopWidth(..) => LonghandId::BorderTopWidth,
            AnimationValue::OutlineWidth(..) => LonghandId::OutlineWidth,
            AnimationValue::BackgroundColor(..) => LonghandId::BackgroundColor,
            AnimationValue::BorderBlockEndColor(void) => void::unreachable(void),
            AnimationValue::BorderBlockStartColor(void) => void::unreachable(void),
            AnimationValue::BorderBottomColor(..) => LonghandId::BorderBottomColor,
            AnimationValue::BorderInlineEndColor(void) => void::unreachable(void),
            AnimationValue::BorderInlineStartColor(void) => void::unreachable(void),
            AnimationValue::BorderLeftColor(..) => LonghandId::BorderLeftColor,
            AnimationValue::BorderRightColor(..) => LonghandId::BorderRightColor,
            AnimationValue::BorderTopColor(..) => LonghandId::BorderTopColor,
            AnimationValue::OutlineColor(..) => LonghandId::OutlineColor,
            AnimationValue::TextDecorationColor(..) => LonghandId::TextDecorationColor,
            AnimationValue::Custom(..) => unsafe { debug_unreachable!() },
        });
        PropertyDeclarationId::Longhand(id)
    }

    /// Returns whether this value is interpolable with another one.
    pub fn interpolable_with(&self, other: &Self) -> bool {
        self.animate(other, Procedure::Interpolate { progress: 0.5 }).is_ok()
    }

    /// "Uncompute" this animation value in order to be used inside the CSS
    /// cascade.
    pub fn uncompute(&self) -> PropertyDeclaration {
        use crate::properties::longhands;
        use self::AnimationValue::*;

        use super::PropertyDeclarationVariantRepr;

        match *self {
            
            
            AlignItems(ref value) => {
                let value = crate::values::specified::ItemPlacement::from_computed_value(&value);
                PropertyDeclaration::AlignItems(value)
            }
            
            AspectRatio(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::AspectRatio::from_computed_value(&value);
                PropertyDeclaration::AspectRatio(value)
            }
            
            BackfaceVisibility(ref value) => {
                let value = longhands::backface_visibility::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackfaceVisibility(value)
            }
            
            BaselineSource(ref value) => {
                let value = crate::values::specified::BaselineSource::from_computed_value(&value);
                PropertyDeclaration::BaselineSource(value)
            }
            
            BorderCollapse(ref value) => {
                let value = longhands::border_collapse::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BorderCollapse(value)
            }
            
            BorderImageRepeat(ref value) => {
                let value = crate::values::specified::BorderImageRepeat::from_computed_value(&value);
                PropertyDeclaration::BorderImageRepeat(value)
            }
            
            BoxSizing(ref value) => {
                let value = longhands::box_sizing::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BoxSizing(value)
            }
            
            CaptionSide(ref value) => {
                let value = crate::values::specified::table::CaptionSide::from_computed_value(&value);
                PropertyDeclaration::CaptionSide(value)
            }
            
            Clear(ref value) => {
                let value = crate::values::specified::Clear::from_computed_value(&value);
                PropertyDeclaration::Clear(value)
            }
            
            ColumnCount(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::ColumnCount::from_computed_value(&value);
                PropertyDeclaration::ColumnCount(value)
            }
            
            ColumnSpan(ref value) => {
                let value = longhands::column_span::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::ColumnSpan(value)
            }
            
            Display(ref value) => {
                let value = crate::values::specified::Display::from_computed_value(&value);
                PropertyDeclaration::Display(value)
            }
            
            EmptyCells(ref value) => {
                let value = longhands::empty_cells::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::EmptyCells(value)
            }
            
            FlexDirection(ref value) => {
                let value = longhands::flex_direction::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::FlexDirection(value)
            }
            
            FlexWrap(ref value) => {
                let value = longhands::flex_wrap::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::FlexWrap(value)
            }
            
            Float(ref value) => {
                let value = crate::values::specified::Float::from_computed_value(&value);
                PropertyDeclaration::Float(value)
            }
            
            FontLanguageOverride(ref value) => {
                let value = crate::values::specified::FontLanguageOverride::from_computed_value(&value);
                PropertyDeclaration::FontLanguageOverride(value)
            }
            
            FontStretch(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::FontStretch::from_computed_value(&value);
                PropertyDeclaration::FontStretch(value)
            }
            
            FontStyle(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::FontStyle::from_computed_value(&value);
                PropertyDeclaration::FontStyle(value)
            }
            
            FontSynthesisWeight(ref value) => {
                let value = crate::values::specified::FontSynthesis::from_computed_value(&value);
                PropertyDeclaration::FontSynthesisWeight(value)
            }
            
            FontVariantCaps(ref value) => {
                let value = longhands::font_variant_caps::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::FontVariantCaps(value)
            }
            
            FontWeight(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::FontWeight::from_computed_value(&value);
                PropertyDeclaration::FontWeight(value)
            }
            
            GridAutoFlow(ref value) => {
                let value = crate::values::specified::GridAutoFlow::from_computed_value(&value);
                PropertyDeclaration::GridAutoFlow(value)
            }
            
            ImageRendering(ref value) => {
                let value = crate::values::specified::ImageRendering::from_computed_value(&value);
                PropertyDeclaration::ImageRendering(value)
            }
            
            Isolation(ref value) => {
                let value = longhands::isolation::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::Isolation(value)
            }
            
            JustifyItems(ref value) => {
                let value = crate::values::specified::JustifyItems::from_computed_value(&value);
                PropertyDeclaration::JustifyItems(value)
            }
            
            ListStylePosition(ref value) => {
                let value = longhands::list_style_position::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::ListStylePosition(value)
            }
            
            ListStyleType(ref value) => {
                let value = longhands::list_style_type::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::ListStyleType(value)
            }
            
            MixBlendMode(ref value) => {
                let value = longhands::mix_blend_mode::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::MixBlendMode(value)
            }
            
            ObjectFit(ref value) => {
                let value = longhands::object_fit::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::ObjectFit(value)
            }
            
            Opacity(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Opacity::from_computed_value(&value);
                PropertyDeclaration::Opacity(value)
            }
            
            Order(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Integer::from_computed_value(&value);
                PropertyDeclaration::Order(value)
            }
            
            OutlineStyle(ref value) => {
                let value = crate::values::specified::OutlineStyle::from_computed_value(&value);
                PropertyDeclaration::OutlineStyle(value)
            }
            
            OverflowWrap(ref value) => {
                let value = crate::values::specified::OverflowWrap::from_computed_value(&value);
                PropertyDeclaration::OverflowWrap(value)
            }
            
            PointerEvents(ref value) => {
                let value = crate::values::specified::PointerEvents::from_computed_value(&value);
                PropertyDeclaration::PointerEvents(value)
            }
            
            Position(ref value) => {
                let value = crate::values::specified::PositionProperty::from_computed_value(&value);
                PropertyDeclaration::Position(value)
            }
            
            PositionArea(ref value) => {
                let value = crate::values::specified::PositionArea::from_computed_value(&value);
                PropertyDeclaration::PositionArea(value)
            }
            
            TableLayout(ref value) => {
                let value = longhands::table_layout::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::TableLayout(value)
            }
            
            TextAlign(ref value) => {
                let value = crate::values::specified::TextAlign::from_computed_value(&value);
                PropertyDeclaration::TextAlign(value)
            }
            
            TextAlignLast(ref value) => {
                let value = crate::values::specified::TextAlignLast::from_computed_value(&value);
                PropertyDeclaration::TextAlignLast(value)
            }
            
            TextDecorationLine(ref value) => {
                let value = crate::values::specified::TextDecorationLine::from_computed_value(&value);
                PropertyDeclaration::TextDecorationLine(value)
            }
            
            TextDecorationStyle(ref value) => {
                let value = longhands::text_decoration_style::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::TextDecorationStyle(value)
            }
            
            TextJustify(ref value) => {
                let value = crate::values::specified::TextJustify::from_computed_value(&value);
                PropertyDeclaration::TextJustify(value)
            }
            
            TextRendering(ref value) => {
                let value = longhands::text_rendering::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::TextRendering(value)
            }
            
            TextTransform(ref value) => {
                let value = crate::values::specified::TextTransform::from_computed_value(&value);
                PropertyDeclaration::TextTransform(value)
            }
            
            TextWrapMode(ref value) => {
                let value = longhands::text_wrap_mode::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::TextWrapMode(value)
            }
            
            TransformStyle(ref value) => {
                let value = crate::values::specified::TransformStyle::from_computed_value(&value);
                PropertyDeclaration::TransformStyle(value)
            }
            
            Visibility(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::visibility::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::Visibility(value)
            }
            
            WhiteSpaceCollapse(ref value) => {
                let value = longhands::white_space_collapse::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::WhiteSpaceCollapse(value)
            }
            
            WordBreak(ref value) => {
                let value = crate::values::specified::WordBreak::from_computed_value(&value);
                PropertyDeclaration::WordBreak(value)
            }
            
            ZIndex(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::ZIndex::from_computed_value(&value);
                PropertyDeclaration::ZIndex(value)
            }
            
            Zoom(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Zoom::from_computed_value(&value);
                PropertyDeclaration::Zoom(value)
            }
            
            AlignContent(ref value) |
JustifyContent(ref value) => {
                let value = crate::values::specified::ContentDistribution::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::ContentDistribution>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            FlexGrow(ref value) |
FlexShrink(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::NonNegativeNumber::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeNumber>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            AlignSelf(ref value) |
JustifySelf(ref value) => {
                let value = crate::values::specified::SelfAlignment::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::SelfAlignment>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            OverflowX(ref value) |
OverflowY(ref value) => {
                let value = crate::values::specified::Overflow::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Overflow>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderBottomStyle(ref value) |
BorderLeftStyle(ref value) |
BorderRightStyle(ref value) |
BorderTopStyle(ref value) => {
                let value = crate::values::specified::BorderStyle::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::BorderStyle>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            BackdropFilter(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::backdrop_filter::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackdropFilter(value)
            }
            
            BackgroundAttachment(ref value) => {
                let value = longhands::background_attachment::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundAttachment(value)
            }
            
            BackgroundClip(ref value) => {
                let value = longhands::background_clip::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundClip(value)
            }
            
            BackgroundImage(ref value) => {
                let value = longhands::background_image::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundImage(value)
            }
            
            BackgroundOrigin(ref value) => {
                let value = longhands::background_origin::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundOrigin(value)
            }
            
            BackgroundPositionX(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::background_position_x::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundPositionX(value)
            }
            
            BackgroundPositionY(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::background_position_y::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundPositionY(value)
            }
            
            BackgroundRepeat(ref value) => {
                let value = longhands::background_repeat::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundRepeat(value)
            }
            
            BackgroundSize(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::background_size::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BackgroundSize(value)
            }
            
            BorderImageOutset(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::NonNegativeLengthOrNumberRect::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::BorderImageOutset(value)
            }
            
            BorderImageSlice(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::BorderImageSlice::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::BorderImageSlice(value)
            }
            
            BorderImageWidth(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::BorderImageWidth::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::BorderImageWidth(value)
            }
            
            BorderSpacing(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::BorderSpacing::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::BorderSpacing(value)
            }
            
            BoxShadow(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::box_shadow::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::BoxShadow(value)
            }
            
            Clip(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::ClipRectOrAuto::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::Clip(value)
            }
            
            ClipPath(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::basic_shape::ClipPath::from_computed_value(&value);
                PropertyDeclaration::ClipPath(value)
            }
            
            Color(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::ColorPropertyValue::from_computed_value(&value);
                PropertyDeclaration::Color(value)
            }
            
            ColorScheme(ref value) => {
                let value = crate::values::specified::ColorScheme::from_computed_value(&value);
                PropertyDeclaration::ColorScheme(value)
            }
            
            ColumnWidth(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::length::NonNegativeLengthOrAuto::from_computed_value(&value);
                PropertyDeclaration::ColumnWidth(value)
            }
            
            Content(ref value) => {
                let value = crate::values::specified::Content::from_computed_value(&value);
                PropertyDeclaration::Content(value)
            }
            
            CounterIncrement(ref value) => {
                let value = crate::values::specified::CounterIncrement::from_computed_value(&value);
                PropertyDeclaration::CounterIncrement(value)
            }
            
            CounterReset(ref value) => {
                let value = crate::values::specified::CounterReset::from_computed_value(&value);
                PropertyDeclaration::CounterReset(value)
            }
            
            Cursor(ref value) => {
                let value = crate::values::specified::Cursor::from_computed_value(&value);
                PropertyDeclaration::Cursor(value)
            }
            
            Filter(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::filter::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::Filter(value)
            }
            
            FlexBasis(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::FlexBasis::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::FlexBasis(value)
            }
            
            FontFamily(ref value) => {
                let value = crate::values::specified::FontFamily::from_computed_value(&value);
                PropertyDeclaration::FontFamily(value)
            }
            
            FontSize(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::FontSize::from_computed_value(&value);
                PropertyDeclaration::FontSize(value)
            }
            
            FontVariationSettings(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::FontVariationSettings::from_computed_value(&value);
                PropertyDeclaration::FontVariationSettings(value)
            }
            
            GridTemplateAreas(ref value) => {
                let value = crate::values::specified::GridTemplateAreas::from_computed_value(&value);
                PropertyDeclaration::GridTemplateAreas(value)
            }
            
            LetterSpacing(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::LetterSpacing::from_computed_value(&value);
                PropertyDeclaration::LetterSpacing(value)
            }
            
            LineHeight(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::LineHeight::from_computed_value(&value);
                PropertyDeclaration::LineHeight(value)
            }
            
            MaskImage(ref value) => {
                let value = longhands::mask_image::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::MaskImage(value)
            }
            
            OffsetPath(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::OffsetPath::from_computed_value(&value);
                PropertyDeclaration::OffsetPath(value)
            }
            
            OutlineOffset(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::BorderSideOffset::from_computed_value(&value);
                PropertyDeclaration::OutlineOffset(value)
            }
            
            OverflowClipMargin(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Length::from_computed_value(&value);
                PropertyDeclaration::OverflowClipMargin(value)
            }
            
            Perspective(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Perspective::from_computed_value(&value);
                PropertyDeclaration::Perspective(value)
            }
            
            Quotes(ref value) => {
                let value = crate::values::specified::Quotes::from_computed_value(&value);
                PropertyDeclaration::Quotes(value)
            }
            
            Rotate(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Rotate::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::Rotate(value)
            }
            
            Scale(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Scale::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::Scale(value)
            }
            
            TextIndent(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::TextIndent::from_computed_value(&value);
                PropertyDeclaration::TextIndent(value)
            }
            
            TextOverflow(ref value) => {
                let value = crate::values::specified::TextOverflow::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::TextOverflow(value)
            }
            
            TextShadow(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = longhands::text_shadow::SpecifiedValue::from_computed_value(&value);
                PropertyDeclaration::TextShadow(value)
            }
            
            Transform(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Transform::from_computed_value(&value);
                PropertyDeclaration::Transform(value)
            }
            
            TransformOrigin(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::TransformOrigin::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::TransformOrigin(value)
            }
            
            Translate(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Translate::from_computed_value(&value);
                let value = Box::new(value);
                PropertyDeclaration::Translate(value)
            }
            
            VerticalAlign(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::VerticalAlign::from_computed_value(&value);
                PropertyDeclaration::VerticalAlign(value)
            }
            
            ViewTransitionClass(ref value) => {
                let value = crate::values::specified::ViewTransitionClass::from_computed_value(&value);
                PropertyDeclaration::ViewTransitionClass(value)
            }
            
            ViewTransitionName(ref value) => {
                let value = crate::values::specified::ViewTransitionName::from_computed_value(&value);
                PropertyDeclaration::ViewTransitionName(value)
            }
            
            WordSpacing(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::WordSpacing::from_computed_value(&value);
                PropertyDeclaration::WordSpacing(value)
            }
            
            ObjectPosition(ref value) |
PerspectiveOrigin(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Position::from_computed_value(&value);
                let value = Box::new(value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<Box<crate::values::specified::Position>>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridTemplateColumns(ref value) |
GridTemplateRows(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::GridTemplateComponent::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::GridTemplateComponent>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderImageSource(ref value) |
ListStyleImage(ref value) => {
                let value = crate::values::specified::Image::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Image>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridAutoColumns(ref value) |
GridAutoRows(ref value) => {
                let value = crate::values::specified::ImplicitGridTracks::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::ImplicitGridTracks>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            ColumnGap(ref value) |
RowGap(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::length::NonNegativeLengthPercentageOrNormal::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            GridColumnEnd(ref value) |
GridColumnStart(ref value) |
GridRowEnd(ref value) |
GridRowStart(ref value) => {
                let value = crate::values::specified::GridLine::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::GridLine>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            MaxHeight(ref value) |
MaxWidth(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::MaxSize::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::MaxSize>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderBottomLeftRadius(ref value) |
BorderBottomRightRadius(ref value) |
BorderTopLeftRadius(ref value) |
BorderTopRightRadius(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::BorderCornerRadius::from_computed_value(&value);
                let value = Box::new(value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderCornerRadius>>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            Bottom(ref value) |
Left(ref value) |
Right(ref value) |
Top(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Inset::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Inset>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            MarginBottom(ref value) |
MarginLeft(ref value) |
MarginRight(ref value) |
MarginTop(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Margin::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Margin>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            PaddingBottom(ref value) |
PaddingLeft(ref value) |
PaddingRight(ref value) |
PaddingTop(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::NonNegativeLengthPercentage::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeLengthPercentage>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            Height(ref value) |
MinHeight(ref value) |
MinWidth(ref value) |
Width(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Size::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Size>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            BorderBottomWidth(ref value) |
BorderLeftWidth(ref value) |
BorderRightWidth(ref value) |
BorderTopWidth(ref value) |
OutlineWidth(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::BorderSideWidth::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::BorderSideWidth>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            
            BackgroundColor(ref value) |
BorderBottomColor(ref value) |
BorderLeftColor(ref value) |
BorderRightColor(ref value) |
BorderTopColor(ref value) |
OutlineColor(ref value) |
TextDecorationColor(ref value) => {
                let value = ToAnimatedValue::from_animated_value(value.clone());
                let value = crate::values::specified::Color::from_computed_value(&value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Color>,
                        PropertyDeclarationVariantRepr {
                            tag: *(self as *const _ as *const u16),
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            Contain(void) |
ContainerType(void) |
Direction(void) |
ServoOverflowClipBox(void) |
ServoTopLayer(void) |
UnicodeBidi(void) |
WritingMode(void) |
OverflowBlock(void) |
OverflowInline(void) |
BorderBlockEndStyle(void) |
BorderBlockStartStyle(void) |
BorderInlineEndStyle(void) |
BorderInlineStartStyle(void) |
AnimationComposition(void) |
AnimationDelay(void) |
AnimationDirection(void) |
AnimationDuration(void) |
AnimationFillMode(void) |
AnimationIterationCount(void) |
AnimationName(void) |
AnimationPlayState(void) |
AnimationTimeline(void) |
AnimationTimingFunction(void) |
ContainerName(void) |
TransitionBehavior(void) |
TransitionDelay(void) |
TransitionDuration(void) |
TransitionProperty(void) |
TransitionTimingFunction(void) |
WillChange(void) |
XLang(void) |
MaxBlockSize(void) |
MaxInlineSize(void) |
BorderEndEndRadius(void) |
BorderEndStartRadius(void) |
BorderStartEndRadius(void) |
BorderStartStartRadius(void) |
InsetBlockEnd(void) |
InsetBlockStart(void) |
InsetInlineEnd(void) |
InsetInlineStart(void) |
MarginBlockEnd(void) |
MarginBlockStart(void) |
MarginInlineEnd(void) |
MarginInlineStart(void) |
PaddingBlockEnd(void) |
PaddingBlockStart(void) |
PaddingInlineEnd(void) |
PaddingInlineStart(void) |
BlockSize(void) |
InlineSize(void) |
MinBlockSize(void) |
MinInlineSize(void) |
BorderBlockEndWidth(void) |
BorderBlockStartWidth(void) |
BorderInlineEndWidth(void) |
BorderInlineStartWidth(void) |
BorderBlockEndColor(void) |
BorderBlockStartColor(void) |
BorderInlineEndColor(void) |
BorderInlineStartColor(void) => {
                void::unreachable(void)
            },
            Custom(ref animated_value) => animated_value.to_declaration(),
        }
    }

    /// Construct an AnimationValue from a property declaration.
    pub fn from_declaration(
        decl: &PropertyDeclaration,
        context: &mut Context,
        style: &ComputedValues,
        initial: &ComputedValues,
    ) -> Option<Self> {
        use super::PropertyDeclarationVariantRepr;

        

        let animatable = match *decl {
            PropertyDeclaration::AlignItems(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ItemPlacement>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ItemPlacement as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::AspectRatio(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::AspectRatio>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::AspectRatio as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackfaceVisibility(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::backface_visibility::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::backface_visibility::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BaselineSource(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BaselineSource>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::BaselineSource as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderCollapse(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::border_collapse::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::border_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderImageRepeat(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderImageRepeat>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::BorderImageRepeat as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BoxSizing(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::box_sizing::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::box_sizing::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::CaptionSide(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::table::CaptionSide>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::table::CaptionSide as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Clear(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Clear>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Clear as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ColumnCount(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ColumnCount>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ColumnCount as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ColumnSpan(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::column_span::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::column_span::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Display(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Display>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Display as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::EmptyCells(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::empty_cells::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::empty_cells::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FlexDirection(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::flex_direction::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::flex_direction::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FlexWrap(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::flex_wrap::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::flex_wrap::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Float(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Float>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Float as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontLanguageOverride(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontLanguageOverride>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::FontLanguageOverride as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontStretch(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontStretch>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontStretch as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontStyle(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontStyle>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontStyle as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontSynthesisWeight(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontSynthesis>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::FontSynthesis as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontVariantCaps(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::font_variant_caps::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::font_variant_caps::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontWeight(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontWeight>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontWeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::GridAutoFlow(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridAutoFlow>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::GridAutoFlow as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ImageRendering(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ImageRendering>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ImageRendering as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Isolation(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::isolation::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::isolation::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::JustifyItems(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::JustifyItems>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::JustifyItems as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ListStylePosition(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::list_style_position::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::list_style_position::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ListStyleType(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::list_style_type::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::list_style_type::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::MixBlendMode(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::mix_blend_mode::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::mix_blend_mode::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ObjectFit(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::object_fit::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::object_fit::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Opacity(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Opacity>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Opacity as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Order(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Integer>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Integer as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::OutlineStyle(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::OutlineStyle>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::OutlineStyle as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::OverflowWrap(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::OverflowWrap>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::OverflowWrap as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::PointerEvents(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::PointerEvents>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::PointerEvents as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Position(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::PositionProperty>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::PositionProperty as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::PositionArea(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::PositionArea>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::PositionArea as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TableLayout(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::table_layout::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::table_layout::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextAlign(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextAlign>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextAlign as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextAlignLast(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextAlignLast>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextAlignLast as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextDecorationLine(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextDecorationLine>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextDecorationLine as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextDecorationStyle(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_decoration_style::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::text_decoration_style::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextJustify(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextJustify>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextJustify as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextRendering(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_rendering::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::text_rendering::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextTransform(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextTransform>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextTransform as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextWrapMode(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_wrap_mode::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::text_wrap_mode::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TransformStyle(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TransformStyle>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TransformStyle as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Visibility(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::visibility::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::visibility::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::WhiteSpaceCollapse(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::white_space_collapse::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::white_space_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::WordBreak(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::WordBreak>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::WordBreak as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ZIndex(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ZIndex>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ZIndex as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Zoom(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Zoom>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Zoom as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::AlignContent(ref value) |
PropertyDeclaration::JustifyContent(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ContentDistribution>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FlexGrow(ref value) |
PropertyDeclaration::FlexShrink(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeNumber>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::AlignSelf(ref value) |
PropertyDeclaration::JustifySelf(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::SelfAlignment>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::OverflowBlock(ref value) |
PropertyDeclaration::OverflowInline(ref value) |
PropertyDeclaration::OverflowX(ref value) |
PropertyDeclaration::OverflowY(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Overflow>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Overflow as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderBottomStyle(ref value) |
PropertyDeclaration::BorderLeftStyle(ref value) |
PropertyDeclaration::BorderRightStyle(ref value) |
PropertyDeclaration::BorderTopStyle(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderStyle>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackdropFilter(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::backdrop_filter::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::backdrop_filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundAttachment(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_attachment::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_attachment::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundClip(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_clip::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_clip::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundImage(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_image::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_image::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundOrigin(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_origin::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_origin::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundPositionX(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_position_x::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::background_position_x::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundPositionY(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_position_y::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::background_position_y::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundRepeat(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_repeat::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_repeat::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundSize(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::background_size::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::background_size::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderImageOutset(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::NonNegativeLengthOrNumberRect>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthOrNumberRect as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderImageSlice(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderImageSlice>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderImageSlice as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderImageWidth(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderImageWidth>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderImageWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderSpacing(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderSpacing>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BoxShadow(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::box_shadow::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::box_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Clip(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::ClipRectOrAuto>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ClipRectOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ClipPath(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::basic_shape::ClipPath>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::basic_shape::ClipPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Color(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ColorPropertyValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ColorPropertyValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ColorScheme(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ColorScheme>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ColorScheme as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ColumnWidth(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::length::NonNegativeLengthOrAuto>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Content(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Content>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Content as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::CounterIncrement(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::CounterIncrement>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::CounterIncrement as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::CounterReset(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::CounterReset>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::CounterReset as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Cursor(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Cursor>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Cursor as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Filter(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::filter::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FlexBasis(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::FlexBasis>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FlexBasis as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontFamily(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontFamily>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::FontFamily as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontSize(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontSize>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::FontVariationSettings(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::FontVariationSettings>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontVariationSettings as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::GridTemplateAreas(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridTemplateAreas>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::GridTemplateAreas as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::LetterSpacing(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::LetterSpacing>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::LetterSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::LineHeight(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::LineHeight>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::LineHeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::MaskImage(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::mask_image::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::mask_image::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::OffsetPath(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::OffsetPath>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::OffsetPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::OutlineOffset(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderSideOffset>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderSideOffset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::OverflowClipMargin(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Length>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Length as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Perspective(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Perspective>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Perspective as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Quotes(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Quotes>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Quotes as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Rotate(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Rotate>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Rotate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Scale(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Scale>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Scale as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextIndent(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::TextIndent>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::TextIndent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextOverflow(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::TextOverflow>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextOverflow as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TextShadow(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<longhands::text_shadow::SpecifiedValue>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::text_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Transform(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Transform>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Transform as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::TransformOrigin(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::TransformOrigin>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::TransformOrigin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Translate(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Translate>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Translate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::VerticalAlign(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::VerticalAlign>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::VerticalAlign as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ViewTransitionClass(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ViewTransitionClass>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ViewTransitionClass as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ViewTransitionName(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ViewTransitionName>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ViewTransitionName as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::WordSpacing(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::WordSpacing>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::WordSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ObjectPosition(ref value) |
PropertyDeclaration::PerspectiveOrigin(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::Position>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::GridTemplateColumns(ref value) |
PropertyDeclaration::GridTemplateRows(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridTemplateComponent>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderImageSource(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Image>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Image as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ListStyleImage(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Image>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = false;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Image as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::GridAutoColumns(ref value) |
PropertyDeclaration::GridAutoRows(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::ImplicitGridTracks>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ImplicitGridTracks as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::ColumnGap(ref value) |
PropertyDeclaration::RowGap(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::GridColumnEnd(ref value) |
PropertyDeclaration::GridColumnStart(ref value) |
PropertyDeclaration::GridRowEnd(ref value) |
PropertyDeclaration::GridRowStart(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::GridLine>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::GridLine as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::MaxBlockSize(ref value) |
PropertyDeclaration::MaxHeight(ref value) |
PropertyDeclaration::MaxInlineSize(ref value) |
PropertyDeclaration::MaxWidth(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::MaxSize>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderBottomLeftRadius(ref value) |
PropertyDeclaration::BorderBottomRightRadius(ref value) |
PropertyDeclaration::BorderEndEndRadius(ref value) |
PropertyDeclaration::BorderEndStartRadius(ref value) |
PropertyDeclaration::BorderStartEndRadius(ref value) |
PropertyDeclaration::BorderStartStartRadius(ref value) |
PropertyDeclaration::BorderTopLeftRadius(ref value) |
PropertyDeclaration::BorderTopRightRadius(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderCornerRadius>>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = (**value).to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::Bottom(ref value) |
PropertyDeclaration::InsetBlockEnd(ref value) |
PropertyDeclaration::InsetBlockStart(ref value) |
PropertyDeclaration::InsetInlineEnd(ref value) |
PropertyDeclaration::InsetInlineStart(ref value) |
PropertyDeclaration::Left(ref value) |
PropertyDeclaration::Right(ref value) |
PropertyDeclaration::Top(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Inset>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::MarginBlockEnd(ref value) |
PropertyDeclaration::MarginBlockStart(ref value) |
PropertyDeclaration::MarginBottom(ref value) |
PropertyDeclaration::MarginInlineEnd(ref value) |
PropertyDeclaration::MarginInlineStart(ref value) |
PropertyDeclaration::MarginLeft(ref value) |
PropertyDeclaration::MarginRight(ref value) |
PropertyDeclaration::MarginTop(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Margin>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::PaddingBlockEnd(ref value) |
PropertyDeclaration::PaddingBlockStart(ref value) |
PropertyDeclaration::PaddingBottom(ref value) |
PropertyDeclaration::PaddingInlineEnd(ref value) |
PropertyDeclaration::PaddingInlineStart(ref value) |
PropertyDeclaration::PaddingLeft(ref value) |
PropertyDeclaration::PaddingRight(ref value) |
PropertyDeclaration::PaddingTop(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeLengthPercentage>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BlockSize(ref value) |
PropertyDeclaration::Height(ref value) |
PropertyDeclaration::InlineSize(ref value) |
PropertyDeclaration::MinBlockSize(ref value) |
PropertyDeclaration::MinHeight(ref value) |
PropertyDeclaration::MinInlineSize(ref value) |
PropertyDeclaration::MinWidth(ref value) |
PropertyDeclaration::Width(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Size>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BorderBlockEndWidth(ref value) |
PropertyDeclaration::BorderBlockStartWidth(ref value) |
PropertyDeclaration::BorderBottomWidth(ref value) |
PropertyDeclaration::BorderInlineEndWidth(ref value) |
PropertyDeclaration::BorderInlineStartWidth(ref value) |
PropertyDeclaration::BorderLeftWidth(ref value) |
PropertyDeclaration::BorderRightWidth(ref value) |
PropertyDeclaration::BorderTopWidth(ref value) |
PropertyDeclaration::OutlineWidth(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::BorderSideWidth>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::BackgroundColor(ref value) |
PropertyDeclaration::BorderBlockEndColor(ref value) |
PropertyDeclaration::BorderBlockStartColor(ref value) |
PropertyDeclaration::BorderBottomColor(ref value) |
PropertyDeclaration::BorderInlineEndColor(ref value) |
PropertyDeclaration::BorderInlineStartColor(ref value) |
PropertyDeclaration::BorderLeftColor(ref value) |
PropertyDeclaration::BorderRightColor(ref value) |
PropertyDeclaration::BorderTopColor(ref value) |
PropertyDeclaration::OutlineColor(ref value) |
PropertyDeclaration::TextDecorationColor(ref value) => {
                let decl_repr = unsafe {
                    &*(decl as *const _ as *const PropertyDeclarationVariantRepr<crate::values::specified::Color>)
                };
                let longhand_id = unsafe {
                    *(&decl_repr.tag as *const u16 as *const LonghandId)
                };
                context.for_non_inherited_property = true;
                let value = value.to_computed_value(context);
                let value = value.to_animated_value(&crate::values::animated::Context { style });

                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: longhand_id.to_physical(context.builder.writing_mode) as u16,
                            value,
                        },
                    );
                    out.assume_init()
                }
            }
            PropertyDeclaration::CSSWideKeyword(ref declaration) => {
                match declaration.id.to_physical(context.builder.writing_mode) {
                    // We put all the animatable properties first in the hopes
                    // that it might increase match locality.
                    LonghandId::AlignItems => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_align_items();

                        AnimationValue::AlignItems(computed)
                    },
                    LonghandId::AspectRatio => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_aspect_ratio();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::AspectRatio(computed)
                    },
                    LonghandId::BackfaceVisibility => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_backface_visibility();

                        AnimationValue::BackfaceVisibility(computed)
                    },
                    LonghandId::BaselineSource => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_baseline_source();

                        AnimationValue::BaselineSource(computed)
                    },
                    LonghandId::BorderCollapse => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_table()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_table()
                            },
                        };
                        let computed = style_struct
                            .clone_border_collapse();

                        AnimationValue::BorderCollapse(computed)
                    },
                    LonghandId::BorderImageRepeat => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_image_repeat();

                        AnimationValue::BorderImageRepeat(computed)
                    },
                    LonghandId::BoxSizing => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_box_sizing();

                        AnimationValue::BoxSizing(computed)
                    },
                    LonghandId::CaptionSide => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_table()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_table()
                            },
                        };
                        let computed = style_struct
                            .clone_caption_side();

                        AnimationValue::CaptionSide(computed)
                    },
                    LonghandId::Clear => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_clear();

                        AnimationValue::Clear(computed)
                    },
                    LonghandId::ColumnCount => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_column()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_column()
                            },
                        };
                        let computed = style_struct
                            .clone_column_count();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::ColumnCount(computed)
                    },
                    LonghandId::ColumnSpan => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_column()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_column()
                            },
                        };
                        let computed = style_struct
                            .clone_column_span();

                        AnimationValue::ColumnSpan(computed)
                    },
                    LonghandId::Display => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_display();

                        AnimationValue::Display(computed)
                    },
                    LonghandId::EmptyCells => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_table()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_table()
                            },
                        };
                        let computed = style_struct
                            .clone_empty_cells();

                        AnimationValue::EmptyCells(computed)
                    },
                    LonghandId::FlexDirection => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_flex_direction();

                        AnimationValue::FlexDirection(computed)
                    },
                    LonghandId::FlexWrap => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_flex_wrap();

                        AnimationValue::FlexWrap(computed)
                    },
                    LonghandId::Float => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_float();

                        AnimationValue::Float(computed)
                    },
                    LonghandId::FontLanguageOverride => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_language_override();

                        AnimationValue::FontLanguageOverride(computed)
                    },
                    LonghandId::FontStretch => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_stretch();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FontStretch(computed)
                    },
                    LonghandId::FontStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_style();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FontStyle(computed)
                    },
                    LonghandId::FontSynthesisWeight => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_synthesis_weight();

                        AnimationValue::FontSynthesisWeight(computed)
                    },
                    LonghandId::FontVariantCaps => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_variant_caps();

                        AnimationValue::FontVariantCaps(computed)
                    },
                    LonghandId::FontWeight => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_weight();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FontWeight(computed)
                    },
                    LonghandId::GridAutoFlow => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_auto_flow();

                        AnimationValue::GridAutoFlow(computed)
                    },
                    LonghandId::ImageRendering => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_box()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_box()
                            },
                        };
                        let computed = style_struct
                            .clone_image_rendering();

                        AnimationValue::ImageRendering(computed)
                    },
                    LonghandId::Isolation => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_isolation();

                        AnimationValue::Isolation(computed)
                    },
                    LonghandId::JustifyItems => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_justify_items();

                        AnimationValue::JustifyItems(computed)
                    },
                    LonghandId::ListStylePosition => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_list()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_list()
                            },
                        };
                        let computed = style_struct
                            .clone_list_style_position();

                        AnimationValue::ListStylePosition(computed)
                    },
                    LonghandId::ListStyleType => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_list()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_list()
                            },
                        };
                        let computed = style_struct
                            .clone_list_style_type();

                        AnimationValue::ListStyleType(computed)
                    },
                    LonghandId::MixBlendMode => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_effects()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_effects()
                            },
                        };
                        let computed = style_struct
                            .clone_mix_blend_mode();

                        AnimationValue::MixBlendMode(computed)
                    },
                    LonghandId::ObjectFit => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_object_fit();

                        AnimationValue::ObjectFit(computed)
                    },
                    LonghandId::Opacity => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_effects()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_effects()
                            },
                        };
                        let computed = style_struct
                            .clone_opacity();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Opacity(computed)
                    },
                    LonghandId::Order => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_order();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Order(computed)
                    },
                    LonghandId::OutlineStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_outline()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_outline()
                            },
                        };
                        let computed = style_struct
                            .clone_outline_style();

                        AnimationValue::OutlineStyle(computed)
                    },
                    LonghandId::OverflowWrap => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_overflow_wrap();

                        AnimationValue::OverflowWrap(computed)
                    },
                    LonghandId::PointerEvents => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_ui()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_ui()
                            },
                        };
                        let computed = style_struct
                            .clone_pointer_events();

                        AnimationValue::PointerEvents(computed)
                    },
                    LonghandId::Position => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_position();

                        AnimationValue::Position(computed)
                    },
                    LonghandId::PositionArea => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_position_area();

                        AnimationValue::PositionArea(computed)
                    },
                    LonghandId::TableLayout => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_table()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_table()
                            },
                        };
                        let computed = style_struct
                            .clone_table_layout();

                        AnimationValue::TableLayout(computed)
                    },
                    LonghandId::TextAlign => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_align();

                        AnimationValue::TextAlign(computed)
                    },
                    LonghandId::TextAlignLast => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_align_last();

                        AnimationValue::TextAlignLast(computed)
                    },
                    LonghandId::TextDecorationLine => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_text()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_decoration_line();

                        AnimationValue::TextDecorationLine(computed)
                    },
                    LonghandId::TextDecorationStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_text()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_decoration_style();

                        AnimationValue::TextDecorationStyle(computed)
                    },
                    LonghandId::TextJustify => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_justify();

                        AnimationValue::TextJustify(computed)
                    },
                    LonghandId::TextRendering => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_rendering();

                        AnimationValue::TextRendering(computed)
                    },
                    LonghandId::TextTransform => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_transform();

                        AnimationValue::TextTransform(computed)
                    },
                    LonghandId::TextWrapMode => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_wrap_mode();

                        AnimationValue::TextWrapMode(computed)
                    },
                    LonghandId::TransformStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_transform_style();

                        AnimationValue::TransformStyle(computed)
                    },
                    LonghandId::Visibility => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_box()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_box()
                            },
                        };
                        let computed = style_struct
                            .clone_visibility();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Visibility(computed)
                    },
                    LonghandId::WhiteSpaceCollapse => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_white_space_collapse();

                        AnimationValue::WhiteSpaceCollapse(computed)
                    },
                    LonghandId::WordBreak => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_word_break();

                        AnimationValue::WordBreak(computed)
                    },
                    LonghandId::ZIndex => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_z_index();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::ZIndex(computed)
                    },
                    LonghandId::Zoom => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_zoom();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Zoom(computed)
                    },
                    LonghandId::AlignContent => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_align_content();

                        AnimationValue::AlignContent(computed)
                    },
                    LonghandId::JustifyContent => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_justify_content();

                        AnimationValue::JustifyContent(computed)
                    },
                    LonghandId::FlexGrow => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_flex_grow();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FlexGrow(computed)
                    },
                    LonghandId::FlexShrink => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_flex_shrink();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FlexShrink(computed)
                    },
                    LonghandId::AlignSelf => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_align_self();

                        AnimationValue::AlignSelf(computed)
                    },
                    LonghandId::JustifySelf => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_justify_self();

                        AnimationValue::JustifySelf(computed)
                    },
                    LonghandId::OverflowX => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_overflow_x();

                        AnimationValue::OverflowX(computed)
                    },
                    LonghandId::OverflowY => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_overflow_y();

                        AnimationValue::OverflowY(computed)
                    },
                    LonghandId::BorderBottomStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_bottom_style();

                        AnimationValue::BorderBottomStyle(computed)
                    },
                    LonghandId::BorderLeftStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_left_style();

                        AnimationValue::BorderLeftStyle(computed)
                    },
                    LonghandId::BorderRightStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_right_style();

                        AnimationValue::BorderRightStyle(computed)
                    },
                    LonghandId::BorderTopStyle => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_top_style();

                        AnimationValue::BorderTopStyle(computed)
                    },
                    LonghandId::BackdropFilter => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_effects()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_effects()
                            },
                        };
                        let computed = style_struct
                            .clone_backdrop_filter();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BackdropFilter(computed)
                    },
                    LonghandId::BackgroundAttachment => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_attachment();

                        AnimationValue::BackgroundAttachment(computed)
                    },
                    LonghandId::BackgroundClip => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_clip();

                        AnimationValue::BackgroundClip(computed)
                    },
                    LonghandId::BackgroundImage => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_image();

                        AnimationValue::BackgroundImage(computed)
                    },
                    LonghandId::BackgroundOrigin => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_origin();

                        AnimationValue::BackgroundOrigin(computed)
                    },
                    LonghandId::BackgroundPositionX => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_position_x();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BackgroundPositionX(computed)
                    },
                    LonghandId::BackgroundPositionY => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_position_y();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BackgroundPositionY(computed)
                    },
                    LonghandId::BackgroundRepeat => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_repeat();

                        AnimationValue::BackgroundRepeat(computed)
                    },
                    LonghandId::BackgroundSize => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_size();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BackgroundSize(computed)
                    },
                    LonghandId::BorderImageOutset => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_image_outset();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderImageOutset(computed)
                    },
                    LonghandId::BorderImageSlice => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_image_slice();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderImageSlice(computed)
                    },
                    LonghandId::BorderImageWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_image_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderImageWidth(computed)
                    },
                    LonghandId::BorderSpacing => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_table()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_table()
                            },
                        };
                        let computed = style_struct
                            .clone_border_spacing();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderSpacing(computed)
                    },
                    LonghandId::BoxShadow => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_effects()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_effects()
                            },
                        };
                        let computed = style_struct
                            .clone_box_shadow();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BoxShadow(computed)
                    },
                    LonghandId::Clip => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_effects()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_effects()
                            },
                        };
                        let computed = style_struct
                            .clone_clip();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Clip(computed)
                    },
                    LonghandId::ClipPath => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_svg()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_svg()
                            },
                        };
                        let computed = style_struct
                            .clone_clip_path();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::ClipPath(computed)
                    },
                    LonghandId::Color => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Color(computed)
                    },
                    LonghandId::ColorScheme => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_ui()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_ui()
                            },
                        };
                        let computed = style_struct
                            .clone_color_scheme();

                        AnimationValue::ColorScheme(computed)
                    },
                    LonghandId::ColumnWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_column()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_column()
                            },
                        };
                        let computed = style_struct
                            .clone_column_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::ColumnWidth(computed)
                    },
                    LonghandId::Content => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_counters()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_counters()
                            },
                        };
                        let computed = style_struct
                            .clone_content();

                        AnimationValue::Content(computed)
                    },
                    LonghandId::CounterIncrement => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_counters()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_counters()
                            },
                        };
                        let computed = style_struct
                            .clone_counter_increment();

                        AnimationValue::CounterIncrement(computed)
                    },
                    LonghandId::CounterReset => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_counters()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_counters()
                            },
                        };
                        let computed = style_struct
                            .clone_counter_reset();

                        AnimationValue::CounterReset(computed)
                    },
                    LonghandId::Cursor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_ui()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_ui()
                            },
                        };
                        let computed = style_struct
                            .clone_cursor();

                        AnimationValue::Cursor(computed)
                    },
                    LonghandId::Filter => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_effects()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_effects()
                            },
                        };
                        let computed = style_struct
                            .clone_filter();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Filter(computed)
                    },
                    LonghandId::FlexBasis => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_flex_basis();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FlexBasis(computed)
                    },
                    LonghandId::FontFamily => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_family();

                        AnimationValue::FontFamily(computed)
                    },
                    LonghandId::FontSize => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_size();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FontSize(computed)
                    },
                    LonghandId::FontVariationSettings => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_font_variation_settings();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::FontVariationSettings(computed)
                    },
                    LonghandId::GridTemplateAreas => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_template_areas();

                        AnimationValue::GridTemplateAreas(computed)
                    },
                    LonghandId::LetterSpacing => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_letter_spacing();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::LetterSpacing(computed)
                    },
                    LonghandId::LineHeight => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_font()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_font()
                            },
                        };
                        let computed = style_struct
                            .clone_line_height();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::LineHeight(computed)
                    },
                    LonghandId::MaskImage => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_svg()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_svg()
                            },
                        };
                        let computed = style_struct
                            .clone_mask_image();

                        AnimationValue::MaskImage(computed)
                    },
                    LonghandId::OffsetPath => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_offset_path();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::OffsetPath(computed)
                    },
                    LonghandId::OutlineOffset => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_outline()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_outline()
                            },
                        };
                        let computed = style_struct
                            .clone_outline_offset();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::OutlineOffset(computed)
                    },
                    LonghandId::OverflowClipMargin => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_margin()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_margin()
                            },
                        };
                        let computed = style_struct
                            .clone_overflow_clip_margin();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::OverflowClipMargin(computed)
                    },
                    LonghandId::Perspective => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_perspective();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Perspective(computed)
                    },
                    LonghandId::Quotes => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_list()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_list()
                            },
                        };
                        let computed = style_struct
                            .clone_quotes();

                        AnimationValue::Quotes(computed)
                    },
                    LonghandId::Rotate => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_rotate();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Rotate(computed)
                    },
                    LonghandId::Scale => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_scale();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Scale(computed)
                    },
                    LonghandId::TextIndent => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_indent();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::TextIndent(computed)
                    },
                    LonghandId::TextOverflow => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_text()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_overflow();

                        AnimationValue::TextOverflow(computed)
                    },
                    LonghandId::TextShadow => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_shadow();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::TextShadow(computed)
                    },
                    LonghandId::Transform => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_transform();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Transform(computed)
                    },
                    LonghandId::TransformOrigin => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_transform_origin();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::TransformOrigin(computed)
                    },
                    LonghandId::Translate => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_translate();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Translate(computed)
                    },
                    LonghandId::VerticalAlign => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_vertical_align();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::VerticalAlign(computed)
                    },
                    LonghandId::ViewTransitionClass => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_ui()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_ui()
                            },
                        };
                        let computed = style_struct
                            .clone_view_transition_class();

                        AnimationValue::ViewTransitionClass(computed)
                    },
                    LonghandId::ViewTransitionName => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_ui()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_ui()
                            },
                        };
                        let computed = style_struct
                            .clone_view_transition_name();

                        AnimationValue::ViewTransitionName(computed)
                    },
                    LonghandId::WordSpacing => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_inherited_text()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_inherited_text()
                            },
                        };
                        let computed = style_struct
                            .clone_word_spacing();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::WordSpacing(computed)
                    },
                    LonghandId::ObjectPosition => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_object_position();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::ObjectPosition(computed)
                    },
                    LonghandId::PerspectiveOrigin => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_box()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_box()
                            },
                        };
                        let computed = style_struct
                            .clone_perspective_origin();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::PerspectiveOrigin(computed)
                    },
                    LonghandId::GridTemplateColumns => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_template_columns();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::GridTemplateColumns(computed)
                    },
                    LonghandId::GridTemplateRows => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_template_rows();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::GridTemplateRows(computed)
                    },
                    LonghandId::BorderImageSource => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_image_source();

                        AnimationValue::BorderImageSource(computed)
                    },
                    LonghandId::ListStyleImage => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Initial => {
                                initial.get_list()
                            },
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_list()
                            },
                        };
                        let computed = style_struct
                            .clone_list_style_image();

                        AnimationValue::ListStyleImage(computed)
                    },
                    LonghandId::GridAutoColumns => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_auto_columns();

                        AnimationValue::GridAutoColumns(computed)
                    },
                    LonghandId::GridAutoRows => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_auto_rows();

                        AnimationValue::GridAutoRows(computed)
                    },
                    LonghandId::ColumnGap => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_column_gap();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::ColumnGap(computed)
                    },
                    LonghandId::RowGap => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_row_gap();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::RowGap(computed)
                    },
                    LonghandId::GridColumnEnd => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_column_end();

                        AnimationValue::GridColumnEnd(computed)
                    },
                    LonghandId::GridColumnStart => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_column_start();

                        AnimationValue::GridColumnStart(computed)
                    },
                    LonghandId::GridRowEnd => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_row_end();

                        AnimationValue::GridRowEnd(computed)
                    },
                    LonghandId::GridRowStart => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_grid_row_start();

                        AnimationValue::GridRowStart(computed)
                    },
                    LonghandId::MaxHeight => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_max_height();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MaxHeight(computed)
                    },
                    LonghandId::MaxWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_max_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MaxWidth(computed)
                    },
                    LonghandId::BorderBottomLeftRadius => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_bottom_left_radius();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderBottomLeftRadius(computed)
                    },
                    LonghandId::BorderBottomRightRadius => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_bottom_right_radius();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderBottomRightRadius(computed)
                    },
                    LonghandId::BorderTopLeftRadius => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_top_left_radius();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderTopLeftRadius(computed)
                    },
                    LonghandId::BorderTopRightRadius => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_top_right_radius();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderTopRightRadius(computed)
                    },
                    LonghandId::Bottom => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_bottom();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Bottom(computed)
                    },
                    LonghandId::Left => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_left();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Left(computed)
                    },
                    LonghandId::Right => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_right();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Right(computed)
                    },
                    LonghandId::Top => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_top();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Top(computed)
                    },
                    LonghandId::MarginBottom => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_margin()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_margin()
                            },
                        };
                        let computed = style_struct
                            .clone_margin_bottom();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MarginBottom(computed)
                    },
                    LonghandId::MarginLeft => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_margin()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_margin()
                            },
                        };
                        let computed = style_struct
                            .clone_margin_left();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MarginLeft(computed)
                    },
                    LonghandId::MarginRight => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_margin()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_margin()
                            },
                        };
                        let computed = style_struct
                            .clone_margin_right();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MarginRight(computed)
                    },
                    LonghandId::MarginTop => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_margin()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_margin()
                            },
                        };
                        let computed = style_struct
                            .clone_margin_top();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MarginTop(computed)
                    },
                    LonghandId::PaddingBottom => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_padding()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_padding()
                            },
                        };
                        let computed = style_struct
                            .clone_padding_bottom();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::PaddingBottom(computed)
                    },
                    LonghandId::PaddingLeft => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_padding()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_padding()
                            },
                        };
                        let computed = style_struct
                            .clone_padding_left();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::PaddingLeft(computed)
                    },
                    LonghandId::PaddingRight => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_padding()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_padding()
                            },
                        };
                        let computed = style_struct
                            .clone_padding_right();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::PaddingRight(computed)
                    },
                    LonghandId::PaddingTop => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_padding()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_padding()
                            },
                        };
                        let computed = style_struct
                            .clone_padding_top();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::PaddingTop(computed)
                    },
                    LonghandId::Height => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_height();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Height(computed)
                    },
                    LonghandId::MinHeight => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_min_height();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MinHeight(computed)
                    },
                    LonghandId::MinWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_min_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::MinWidth(computed)
                    },
                    LonghandId::Width => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_position()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_position()
                            },
                        };
                        let computed = style_struct
                            .clone_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::Width(computed)
                    },
                    LonghandId::BorderBottomWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_bottom_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderBottomWidth(computed)
                    },
                    LonghandId::BorderLeftWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_left_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderLeftWidth(computed)
                    },
                    LonghandId::BorderRightWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_right_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderRightWidth(computed)
                    },
                    LonghandId::BorderTopWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_top_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderTopWidth(computed)
                    },
                    LonghandId::OutlineWidth => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_outline()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_outline()
                            },
                        };
                        let computed = style_struct
                            .clone_outline_width();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::OutlineWidth(computed)
                    },
                    LonghandId::BackgroundColor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_background()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_background()
                            },
                        };
                        let computed = style_struct
                            .clone_background_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BackgroundColor(computed)
                    },
                    LonghandId::BorderBottomColor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_bottom_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderBottomColor(computed)
                    },
                    LonghandId::BorderLeftColor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_left_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderLeftColor(computed)
                    },
                    LonghandId::BorderRightColor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_right_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderRightColor(computed)
                    },
                    LonghandId::BorderTopColor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_border()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_border()
                            },
                        };
                        let computed = style_struct
                            .clone_border_top_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::BorderTopColor(computed)
                    },
                    LonghandId::OutlineColor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_outline()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_outline()
                            },
                        };
                        let computed = style_struct
                            .clone_outline_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::OutlineColor(computed)
                    },
                    LonghandId::TextDecorationColor => {
                        // FIXME(emilio, bug 1533327): I think revert (and
                        // revert-layer) handling is not fine here, but what to
                        // do instead?
                        //
                        // Seems we'd need the computed value as if it was
                        // revert, somehow. Treating it as `unset` seems fine
                        // for now...
                        let style_struct = match declaration.keyword {
                            CSSWideKeyword::Revert |
                            CSSWideKeyword::RevertLayer |
                            CSSWideKeyword::Unset |
                            CSSWideKeyword::Initial => {
                                initial.get_text()
                            },
                            CSSWideKeyword::Inherit => {
                                context.builder
                                       .get_parent_text()
                            },
                        };
                        let computed = style_struct
                            .clone_text_decoration_color();

                        let computed = computed.to_animated_value(&crate::values::animated::Context {
                            style
                        });
                        AnimationValue::TextDecorationColor(computed)
                    },
                    LonghandId::Contain => return None,
                    LonghandId::ContainerType => return None,
                    LonghandId::Direction => return None,
                    LonghandId::ServoOverflowClipBox => return None,
                    LonghandId::ServoTopLayer => return None,
                    LonghandId::UnicodeBidi => return None,
                    LonghandId::WritingMode => return None,
                    LonghandId::OverflowBlock => return None,
                    LonghandId::OverflowInline => return None,
                    LonghandId::BorderBlockEndStyle => return None,
                    LonghandId::BorderBlockStartStyle => return None,
                    LonghandId::BorderInlineEndStyle => return None,
                    LonghandId::BorderInlineStartStyle => return None,
                    LonghandId::AnimationComposition => return None,
                    LonghandId::AnimationDelay => return None,
                    LonghandId::AnimationDirection => return None,
                    LonghandId::AnimationDuration => return None,
                    LonghandId::AnimationFillMode => return None,
                    LonghandId::AnimationIterationCount => return None,
                    LonghandId::AnimationName => return None,
                    LonghandId::AnimationPlayState => return None,
                    LonghandId::AnimationTimeline => return None,
                    LonghandId::AnimationTimingFunction => return None,
                    LonghandId::ContainerName => return None,
                    LonghandId::TransitionBehavior => return None,
                    LonghandId::TransitionDelay => return None,
                    LonghandId::TransitionDuration => return None,
                    LonghandId::TransitionProperty => return None,
                    LonghandId::TransitionTimingFunction => return None,
                    LonghandId::WillChange => return None,
                    LonghandId::XLang => return None,
                    LonghandId::MaxBlockSize => return None,
                    LonghandId::MaxInlineSize => return None,
                    LonghandId::BorderEndEndRadius => return None,
                    LonghandId::BorderEndStartRadius => return None,
                    LonghandId::BorderStartEndRadius => return None,
                    LonghandId::BorderStartStartRadius => return None,
                    LonghandId::InsetBlockEnd => return None,
                    LonghandId::InsetBlockStart => return None,
                    LonghandId::InsetInlineEnd => return None,
                    LonghandId::InsetInlineStart => return None,
                    LonghandId::MarginBlockEnd => return None,
                    LonghandId::MarginBlockStart => return None,
                    LonghandId::MarginInlineEnd => return None,
                    LonghandId::MarginInlineStart => return None,
                    LonghandId::PaddingBlockEnd => return None,
                    LonghandId::PaddingBlockStart => return None,
                    LonghandId::PaddingInlineEnd => return None,
                    LonghandId::PaddingInlineStart => return None,
                    LonghandId::BlockSize => return None,
                    LonghandId::InlineSize => return None,
                    LonghandId::MinBlockSize => return None,
                    LonghandId::MinInlineSize => return None,
                    LonghandId::BorderBlockEndWidth => return None,
                    LonghandId::BorderBlockStartWidth => return None,
                    LonghandId::BorderInlineEndWidth => return None,
                    LonghandId::BorderInlineStartWidth => return None,
                    LonghandId::BorderBlockEndColor => return None,
                    LonghandId::BorderBlockStartColor => return None,
                    LonghandId::BorderInlineEndColor => return None,
                    LonghandId::BorderInlineStartColor => return None,
                }
            },
            PropertyDeclaration::WithVariables(ref declaration) => {
                let mut cache = Default::default();
                let substituted = {
                    let custom_properties = &context.style().custom_properties();

                    debug_assert!(
                        context.builder.stylist.is_some(),
                        "Need a Stylist to substitute variables!"
                    );
                    declaration.value.substitute_variables(
                        declaration.id,
                        custom_properties,
                        context.builder.stylist.unwrap(),
                        context,
                        &mut cache,
                    )
                };
                return AnimationValue::from_declaration(
                    &substituted,
                    context,
                    style,
                    initial,
                )
            },
            PropertyDeclaration::Custom(ref declaration) => {
                AnimationValue::Custom(CustomAnimatedValue::from_declaration(
                    declaration,
                    context,
                    initial,
                )?)
            },
            _ => return None // non animatable properties will get included because of shorthands. ignore.
        };
        Some(animatable)
    }

    /// Get an AnimationValue for an declaration id from a given computed values.
    pub fn from_computed_values(
        property: PropertyDeclarationId,
        style: &ComputedValues,
    ) -> Option<Self> {
        let property = match property {
            PropertyDeclarationId::Longhand(id) => id,
            PropertyDeclarationId::Custom(ref name) => {
                // FIXME(bug 1869476): This should use a stylist to determine whether the name
                // corresponds to an inherited custom property and then choose the
                // inherited/non_inherited map accordingly.
                let p = &style.custom_properties();
                let value = p.inherited.get(*name).or_else(|| p.non_inherited.get(*name))?;
                return Some(AnimationValue::Custom(CustomAnimatedValue::from_computed(name, value)))
            }
        };

        Some(match property {
            LonghandId::AlignItems => {
                let computed = style.clone_align_items();
                AnimationValue::AlignItems(
                    computed
                )
            }
            LonghandId::AspectRatio => {
                let computed = style.clone_aspect_ratio();
                AnimationValue::AspectRatio(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BackfaceVisibility => {
                let computed = style.clone_backface_visibility();
                AnimationValue::BackfaceVisibility(
                    computed
                )
            }
            LonghandId::BaselineSource => {
                let computed = style.clone_baseline_source();
                AnimationValue::BaselineSource(
                    computed
                )
            }
            LonghandId::BorderCollapse => {
                let computed = style.clone_border_collapse();
                AnimationValue::BorderCollapse(
                    computed
                )
            }
            LonghandId::BorderImageRepeat => {
                let computed = style.clone_border_image_repeat();
                AnimationValue::BorderImageRepeat(
                    computed
                )
            }
            LonghandId::BoxSizing => {
                let computed = style.clone_box_sizing();
                AnimationValue::BoxSizing(
                    computed
                )
            }
            LonghandId::CaptionSide => {
                let computed = style.clone_caption_side();
                AnimationValue::CaptionSide(
                    computed
                )
            }
            LonghandId::Clear => {
                let computed = style.clone_clear();
                AnimationValue::Clear(
                    computed
                )
            }
            LonghandId::ColumnCount => {
                let computed = style.clone_column_count();
                AnimationValue::ColumnCount(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::ColumnSpan => {
                let computed = style.clone_column_span();
                AnimationValue::ColumnSpan(
                    computed
                )
            }
            LonghandId::Display => {
                let computed = style.clone_display();
                AnimationValue::Display(
                    computed
                )
            }
            LonghandId::EmptyCells => {
                let computed = style.clone_empty_cells();
                AnimationValue::EmptyCells(
                    computed
                )
            }
            LonghandId::FlexDirection => {
                let computed = style.clone_flex_direction();
                AnimationValue::FlexDirection(
                    computed
                )
            }
            LonghandId::FlexWrap => {
                let computed = style.clone_flex_wrap();
                AnimationValue::FlexWrap(
                    computed
                )
            }
            LonghandId::Float => {
                let computed = style.clone_float();
                AnimationValue::Float(
                    computed
                )
            }
            LonghandId::FontLanguageOverride => {
                let computed = style.clone_font_language_override();
                AnimationValue::FontLanguageOverride(
                    computed
                )
            }
            LonghandId::FontStretch => {
                let computed = style.clone_font_stretch();
                AnimationValue::FontStretch(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::FontStyle => {
                let computed = style.clone_font_style();
                AnimationValue::FontStyle(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::FontSynthesisWeight => {
                let computed = style.clone_font_synthesis_weight();
                AnimationValue::FontSynthesisWeight(
                    computed
                )
            }
            LonghandId::FontVariantCaps => {
                let computed = style.clone_font_variant_caps();
                AnimationValue::FontVariantCaps(
                    computed
                )
            }
            LonghandId::FontWeight => {
                let computed = style.clone_font_weight();
                AnimationValue::FontWeight(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::GridAutoFlow => {
                let computed = style.clone_grid_auto_flow();
                AnimationValue::GridAutoFlow(
                    computed
                )
            }
            LonghandId::ImageRendering => {
                let computed = style.clone_image_rendering();
                AnimationValue::ImageRendering(
                    computed
                )
            }
            LonghandId::Isolation => {
                let computed = style.clone_isolation();
                AnimationValue::Isolation(
                    computed
                )
            }
            LonghandId::JustifyItems => {
                let computed = style.clone_justify_items();
                AnimationValue::JustifyItems(
                    computed
                )
            }
            LonghandId::ListStylePosition => {
                let computed = style.clone_list_style_position();
                AnimationValue::ListStylePosition(
                    computed
                )
            }
            LonghandId::ListStyleType => {
                let computed = style.clone_list_style_type();
                AnimationValue::ListStyleType(
                    computed
                )
            }
            LonghandId::MixBlendMode => {
                let computed = style.clone_mix_blend_mode();
                AnimationValue::MixBlendMode(
                    computed
                )
            }
            LonghandId::ObjectFit => {
                let computed = style.clone_object_fit();
                AnimationValue::ObjectFit(
                    computed
                )
            }
            LonghandId::Opacity => {
                let computed = style.clone_opacity();
                AnimationValue::Opacity(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Order => {
                let computed = style.clone_order();
                AnimationValue::Order(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::OutlineStyle => {
                let computed = style.clone_outline_style();
                AnimationValue::OutlineStyle(
                    computed
                )
            }
            LonghandId::OverflowWrap => {
                let computed = style.clone_overflow_wrap();
                AnimationValue::OverflowWrap(
                    computed
                )
            }
            LonghandId::PointerEvents => {
                let computed = style.clone_pointer_events();
                AnimationValue::PointerEvents(
                    computed
                )
            }
            LonghandId::Position => {
                let computed = style.clone_position();
                AnimationValue::Position(
                    computed
                )
            }
            LonghandId::PositionArea => {
                let computed = style.clone_position_area();
                AnimationValue::PositionArea(
                    computed
                )
            }
            LonghandId::TableLayout => {
                let computed = style.clone_table_layout();
                AnimationValue::TableLayout(
                    computed
                )
            }
            LonghandId::TextAlign => {
                let computed = style.clone_text_align();
                AnimationValue::TextAlign(
                    computed
                )
            }
            LonghandId::TextAlignLast => {
                let computed = style.clone_text_align_last();
                AnimationValue::TextAlignLast(
                    computed
                )
            }
            LonghandId::TextDecorationLine => {
                let computed = style.clone_text_decoration_line();
                AnimationValue::TextDecorationLine(
                    computed
                )
            }
            LonghandId::TextDecorationStyle => {
                let computed = style.clone_text_decoration_style();
                AnimationValue::TextDecorationStyle(
                    computed
                )
            }
            LonghandId::TextJustify => {
                let computed = style.clone_text_justify();
                AnimationValue::TextJustify(
                    computed
                )
            }
            LonghandId::TextRendering => {
                let computed = style.clone_text_rendering();
                AnimationValue::TextRendering(
                    computed
                )
            }
            LonghandId::TextTransform => {
                let computed = style.clone_text_transform();
                AnimationValue::TextTransform(
                    computed
                )
            }
            LonghandId::TextWrapMode => {
                let computed = style.clone_text_wrap_mode();
                AnimationValue::TextWrapMode(
                    computed
                )
            }
            LonghandId::TransformStyle => {
                let computed = style.clone_transform_style();
                AnimationValue::TransformStyle(
                    computed
                )
            }
            LonghandId::Visibility => {
                let computed = style.clone_visibility();
                AnimationValue::Visibility(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::WhiteSpaceCollapse => {
                let computed = style.clone_white_space_collapse();
                AnimationValue::WhiteSpaceCollapse(
                    computed
                )
            }
            LonghandId::WordBreak => {
                let computed = style.clone_word_break();
                AnimationValue::WordBreak(
                    computed
                )
            }
            LonghandId::ZIndex => {
                let computed = style.clone_z_index();
                AnimationValue::ZIndex(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Zoom => {
                let computed = style.clone_zoom();
                AnimationValue::Zoom(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::AlignContent => {
                let computed = style.clone_align_content();
                AnimationValue::AlignContent(
                    computed
                )
            }
            LonghandId::JustifyContent => {
                let computed = style.clone_justify_content();
                AnimationValue::JustifyContent(
                    computed
                )
            }
            LonghandId::FlexGrow => {
                let computed = style.clone_flex_grow();
                AnimationValue::FlexGrow(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::FlexShrink => {
                let computed = style.clone_flex_shrink();
                AnimationValue::FlexShrink(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::AlignSelf => {
                let computed = style.clone_align_self();
                AnimationValue::AlignSelf(
                    computed
                )
            }
            LonghandId::JustifySelf => {
                let computed = style.clone_justify_self();
                AnimationValue::JustifySelf(
                    computed
                )
            }
            LonghandId::OverflowX => {
                let computed = style.clone_overflow_x();
                AnimationValue::OverflowX(
                    computed
                )
            }
            LonghandId::OverflowY => {
                let computed = style.clone_overflow_y();
                AnimationValue::OverflowY(
                    computed
                )
            }
            LonghandId::BorderBottomStyle => {
                let computed = style.clone_border_bottom_style();
                AnimationValue::BorderBottomStyle(
                    computed
                )
            }
            LonghandId::BorderLeftStyle => {
                let computed = style.clone_border_left_style();
                AnimationValue::BorderLeftStyle(
                    computed
                )
            }
            LonghandId::BorderRightStyle => {
                let computed = style.clone_border_right_style();
                AnimationValue::BorderRightStyle(
                    computed
                )
            }
            LonghandId::BorderTopStyle => {
                let computed = style.clone_border_top_style();
                AnimationValue::BorderTopStyle(
                    computed
                )
            }
            LonghandId::BackdropFilter => {
                let computed = style.clone_backdrop_filter();
                AnimationValue::BackdropFilter(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BackgroundAttachment => {
                let computed = style.clone_background_attachment();
                AnimationValue::BackgroundAttachment(
                    computed
                )
            }
            LonghandId::BackgroundClip => {
                let computed = style.clone_background_clip();
                AnimationValue::BackgroundClip(
                    computed
                )
            }
            LonghandId::BackgroundImage => {
                let computed = style.clone_background_image();
                AnimationValue::BackgroundImage(
                    computed
                )
            }
            LonghandId::BackgroundOrigin => {
                let computed = style.clone_background_origin();
                AnimationValue::BackgroundOrigin(
                    computed
                )
            }
            LonghandId::BackgroundPositionX => {
                let computed = style.clone_background_position_x();
                AnimationValue::BackgroundPositionX(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BackgroundPositionY => {
                let computed = style.clone_background_position_y();
                AnimationValue::BackgroundPositionY(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BackgroundRepeat => {
                let computed = style.clone_background_repeat();
                AnimationValue::BackgroundRepeat(
                    computed
                )
            }
            LonghandId::BackgroundSize => {
                let computed = style.clone_background_size();
                AnimationValue::BackgroundSize(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderImageOutset => {
                let computed = style.clone_border_image_outset();
                AnimationValue::BorderImageOutset(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderImageSlice => {
                let computed = style.clone_border_image_slice();
                AnimationValue::BorderImageSlice(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderImageWidth => {
                let computed = style.clone_border_image_width();
                AnimationValue::BorderImageWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderSpacing => {
                let computed = style.clone_border_spacing();
                AnimationValue::BorderSpacing(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BoxShadow => {
                let computed = style.clone_box_shadow();
                AnimationValue::BoxShadow(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Clip => {
                let computed = style.clone_clip();
                AnimationValue::Clip(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::ClipPath => {
                let computed = style.clone_clip_path();
                AnimationValue::ClipPath(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Color => {
                let computed = style.clone_color();
                AnimationValue::Color(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::ColorScheme => {
                let computed = style.clone_color_scheme();
                AnimationValue::ColorScheme(
                    computed
                )
            }
            LonghandId::ColumnWidth => {
                let computed = style.clone_column_width();
                AnimationValue::ColumnWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Content => {
                let computed = style.clone_content();
                AnimationValue::Content(
                    computed
                )
            }
            LonghandId::CounterIncrement => {
                let computed = style.clone_counter_increment();
                AnimationValue::CounterIncrement(
                    computed
                )
            }
            LonghandId::CounterReset => {
                let computed = style.clone_counter_reset();
                AnimationValue::CounterReset(
                    computed
                )
            }
            LonghandId::Cursor => {
                let computed = style.clone_cursor();
                AnimationValue::Cursor(
                    computed
                )
            }
            LonghandId::Filter => {
                let computed = style.clone_filter();
                AnimationValue::Filter(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::FlexBasis => {
                let computed = style.clone_flex_basis();
                AnimationValue::FlexBasis(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::FontFamily => {
                let computed = style.clone_font_family();
                AnimationValue::FontFamily(
                    computed
                )
            }
            LonghandId::FontSize => {
                let computed = style.clone_font_size();
                AnimationValue::FontSize(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::FontVariationSettings => {
                let computed = style.clone_font_variation_settings();
                AnimationValue::FontVariationSettings(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::GridTemplateAreas => {
                let computed = style.clone_grid_template_areas();
                AnimationValue::GridTemplateAreas(
                    computed
                )
            }
            LonghandId::LetterSpacing => {
                let computed = style.clone_letter_spacing();
                AnimationValue::LetterSpacing(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::LineHeight => {
                let computed = style.clone_line_height();
                AnimationValue::LineHeight(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MaskImage => {
                let computed = style.clone_mask_image();
                AnimationValue::MaskImage(
                    computed
                )
            }
            LonghandId::OffsetPath => {
                let computed = style.clone_offset_path();
                AnimationValue::OffsetPath(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::OutlineOffset => {
                let computed = style.clone_outline_offset();
                AnimationValue::OutlineOffset(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::OverflowClipMargin => {
                let computed = style.clone_overflow_clip_margin();
                AnimationValue::OverflowClipMargin(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Perspective => {
                let computed = style.clone_perspective();
                AnimationValue::Perspective(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Quotes => {
                let computed = style.clone_quotes();
                AnimationValue::Quotes(
                    computed
                )
            }
            LonghandId::Rotate => {
                let computed = style.clone_rotate();
                AnimationValue::Rotate(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Scale => {
                let computed = style.clone_scale();
                AnimationValue::Scale(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::TextIndent => {
                let computed = style.clone_text_indent();
                AnimationValue::TextIndent(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::TextOverflow => {
                let computed = style.clone_text_overflow();
                AnimationValue::TextOverflow(
                    computed
                )
            }
            LonghandId::TextShadow => {
                let computed = style.clone_text_shadow();
                AnimationValue::TextShadow(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Transform => {
                let computed = style.clone_transform();
                AnimationValue::Transform(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::TransformOrigin => {
                let computed = style.clone_transform_origin();
                AnimationValue::TransformOrigin(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Translate => {
                let computed = style.clone_translate();
                AnimationValue::Translate(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::VerticalAlign => {
                let computed = style.clone_vertical_align();
                AnimationValue::VerticalAlign(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::ViewTransitionClass => {
                let computed = style.clone_view_transition_class();
                AnimationValue::ViewTransitionClass(
                    computed
                )
            }
            LonghandId::ViewTransitionName => {
                let computed = style.clone_view_transition_name();
                AnimationValue::ViewTransitionName(
                    computed
                )
            }
            LonghandId::WordSpacing => {
                let computed = style.clone_word_spacing();
                AnimationValue::WordSpacing(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::ObjectPosition => {
                let computed = style.clone_object_position();
                AnimationValue::ObjectPosition(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::PerspectiveOrigin => {
                let computed = style.clone_perspective_origin();
                AnimationValue::PerspectiveOrigin(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::GridTemplateColumns => {
                let computed = style.clone_grid_template_columns();
                AnimationValue::GridTemplateColumns(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::GridTemplateRows => {
                let computed = style.clone_grid_template_rows();
                AnimationValue::GridTemplateRows(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderImageSource => {
                let computed = style.clone_border_image_source();
                AnimationValue::BorderImageSource(
                    computed
                )
            }
            LonghandId::ListStyleImage => {
                let computed = style.clone_list_style_image();
                AnimationValue::ListStyleImage(
                    computed
                )
            }
            LonghandId::GridAutoColumns => {
                let computed = style.clone_grid_auto_columns();
                AnimationValue::GridAutoColumns(
                    computed
                )
            }
            LonghandId::GridAutoRows => {
                let computed = style.clone_grid_auto_rows();
                AnimationValue::GridAutoRows(
                    computed
                )
            }
            LonghandId::ColumnGap => {
                let computed = style.clone_column_gap();
                AnimationValue::ColumnGap(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::RowGap => {
                let computed = style.clone_row_gap();
                AnimationValue::RowGap(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::GridColumnEnd => {
                let computed = style.clone_grid_column_end();
                AnimationValue::GridColumnEnd(
                    computed
                )
            }
            LonghandId::GridColumnStart => {
                let computed = style.clone_grid_column_start();
                AnimationValue::GridColumnStart(
                    computed
                )
            }
            LonghandId::GridRowEnd => {
                let computed = style.clone_grid_row_end();
                AnimationValue::GridRowEnd(
                    computed
                )
            }
            LonghandId::GridRowStart => {
                let computed = style.clone_grid_row_start();
                AnimationValue::GridRowStart(
                    computed
                )
            }
            LonghandId::MaxHeight => {
                let computed = style.clone_max_height();
                AnimationValue::MaxHeight(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MaxWidth => {
                let computed = style.clone_max_width();
                AnimationValue::MaxWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderBottomLeftRadius => {
                let computed = style.clone_border_bottom_left_radius();
                AnimationValue::BorderBottomLeftRadius(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderBottomRightRadius => {
                let computed = style.clone_border_bottom_right_radius();
                AnimationValue::BorderBottomRightRadius(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderTopLeftRadius => {
                let computed = style.clone_border_top_left_radius();
                AnimationValue::BorderTopLeftRadius(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderTopRightRadius => {
                let computed = style.clone_border_top_right_radius();
                AnimationValue::BorderTopRightRadius(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Bottom => {
                let computed = style.clone_bottom();
                AnimationValue::Bottom(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Left => {
                let computed = style.clone_left();
                AnimationValue::Left(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Right => {
                let computed = style.clone_right();
                AnimationValue::Right(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Top => {
                let computed = style.clone_top();
                AnimationValue::Top(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MarginBottom => {
                let computed = style.clone_margin_bottom();
                AnimationValue::MarginBottom(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MarginLeft => {
                let computed = style.clone_margin_left();
                AnimationValue::MarginLeft(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MarginRight => {
                let computed = style.clone_margin_right();
                AnimationValue::MarginRight(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MarginTop => {
                let computed = style.clone_margin_top();
                AnimationValue::MarginTop(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::PaddingBottom => {
                let computed = style.clone_padding_bottom();
                AnimationValue::PaddingBottom(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::PaddingLeft => {
                let computed = style.clone_padding_left();
                AnimationValue::PaddingLeft(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::PaddingRight => {
                let computed = style.clone_padding_right();
                AnimationValue::PaddingRight(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::PaddingTop => {
                let computed = style.clone_padding_top();
                AnimationValue::PaddingTop(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Height => {
                let computed = style.clone_height();
                AnimationValue::Height(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MinHeight => {
                let computed = style.clone_min_height();
                AnimationValue::MinHeight(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::MinWidth => {
                let computed = style.clone_min_width();
                AnimationValue::MinWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::Width => {
                let computed = style.clone_width();
                AnimationValue::Width(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderBottomWidth => {
                let computed = style.clone_border_bottom_width();
                AnimationValue::BorderBottomWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderLeftWidth => {
                let computed = style.clone_border_left_width();
                AnimationValue::BorderLeftWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderRightWidth => {
                let computed = style.clone_border_right_width();
                AnimationValue::BorderRightWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderTopWidth => {
                let computed = style.clone_border_top_width();
                AnimationValue::BorderTopWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::OutlineWidth => {
                let computed = style.clone_outline_width();
                AnimationValue::OutlineWidth(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BackgroundColor => {
                let computed = style.clone_background_color();
                AnimationValue::BackgroundColor(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderBottomColor => {
                let computed = style.clone_border_bottom_color();
                AnimationValue::BorderBottomColor(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderLeftColor => {
                let computed = style.clone_border_left_color();
                AnimationValue::BorderLeftColor(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderRightColor => {
                let computed = style.clone_border_right_color();
                AnimationValue::BorderRightColor(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::BorderTopColor => {
                let computed = style.clone_border_top_color();
                AnimationValue::BorderTopColor(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::OutlineColor => {
                let computed = style.clone_outline_color();
                AnimationValue::OutlineColor(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            LonghandId::TextDecorationColor => {
                let computed = style.clone_text_decoration_color();
                AnimationValue::TextDecorationColor(
                    computed.to_animated_value(&crate::values::animated::Context { style })
                )
            }
            _ => return None,
        })
    }

    /// Update `style` with the value of this `AnimationValue`.
    ///
    /// SERVO ONLY: This doesn't properly handle things like updating 'em' units
    /// when animated font-size.
    #[cfg(feature = "servo")]
    pub fn set_in_style_for_servo(&self, style: &mut ComputedValues) {
        match self {
            AnimationValue::AlignItems(ref value) => {
                let value: longhands::align_items::computed_value::T =
                    value.clone();
                style.mutate_position().set_align_items(value);
            }
            AnimationValue::AspectRatio(ref value) => {
                let value: longhands::aspect_ratio::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_aspect_ratio(value);
            }
            AnimationValue::BackfaceVisibility(ref value) => {
                let value: longhands::backface_visibility::computed_value::T =
                    value.clone();
                style.mutate_box().set_backface_visibility(value);
            }
            AnimationValue::BaselineSource(ref value) => {
                let value: longhands::baseline_source::computed_value::T =
                    value.clone();
                style.mutate_box().set_baseline_source(value);
            }
            AnimationValue::BorderCollapse(ref value) => {
                let value: longhands::border_collapse::computed_value::T =
                    value.clone();
                style.mutate_inherited_table().set_border_collapse(value);
            }
            AnimationValue::BorderImageRepeat(ref value) => {
                let value: longhands::border_image_repeat::computed_value::T =
                    value.clone();
                style.mutate_border().set_border_image_repeat(value);
            }
            AnimationValue::BoxSizing(ref value) => {
                let value: longhands::box_sizing::computed_value::T =
                    value.clone();
                style.mutate_position().set_box_sizing(value);
            }
            AnimationValue::CaptionSide(ref value) => {
                let value: longhands::caption_side::computed_value::T =
                    value.clone();
                style.mutate_inherited_table().set_caption_side(value);
            }
            AnimationValue::Clear(ref value) => {
                let value: longhands::clear::computed_value::T =
                    value.clone();
                style.mutate_box().set_clear(value);
            }
            AnimationValue::ColumnCount(ref value) => {
                let value: longhands::column_count::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_column().set_column_count(value);
            }
            AnimationValue::ColumnSpan(ref value) => {
                let value: longhands::column_span::computed_value::T =
                    value.clone();
                style.mutate_column().set_column_span(value);
            }
            AnimationValue::Contain(..) => unreachable!(),
            AnimationValue::ContainerType(..) => unreachable!(),
            AnimationValue::Direction(..) => unreachable!(),
            AnimationValue::Display(ref value) => {
                let value: longhands::display::computed_value::T =
                    value.clone();
                style.mutate_box().set_display(value);
            }
            AnimationValue::EmptyCells(ref value) => {
                let value: longhands::empty_cells::computed_value::T =
                    value.clone();
                style.mutate_inherited_table().set_empty_cells(value);
            }
            AnimationValue::FlexDirection(ref value) => {
                let value: longhands::flex_direction::computed_value::T =
                    value.clone();
                style.mutate_position().set_flex_direction(value);
            }
            AnimationValue::FlexWrap(ref value) => {
                let value: longhands::flex_wrap::computed_value::T =
                    value.clone();
                style.mutate_position().set_flex_wrap(value);
            }
            AnimationValue::Float(ref value) => {
                let value: longhands::float::computed_value::T =
                    value.clone();
                style.mutate_box().set_float(value);
            }
            AnimationValue::FontLanguageOverride(ref value) => {
                let value: longhands::font_language_override::computed_value::T =
                    value.clone();
                style.mutate_font().set_font_language_override(value);
            }
            AnimationValue::FontStretch(ref value) => {
                let value: longhands::font_stretch::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_font().set_font_stretch(value);
            }
            AnimationValue::FontStyle(ref value) => {
                let value: longhands::font_style::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_font().set_font_style(value);
            }
            AnimationValue::FontSynthesisWeight(ref value) => {
                let value: longhands::font_synthesis_weight::computed_value::T =
                    value.clone();
                style.mutate_font().set_font_synthesis_weight(value);
            }
            AnimationValue::FontVariantCaps(ref value) => {
                let value: longhands::font_variant_caps::computed_value::T =
                    value.clone();
                style.mutate_font().set_font_variant_caps(value);
            }
            AnimationValue::FontWeight(ref value) => {
                let value: longhands::font_weight::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_font().set_font_weight(value);
            }
            AnimationValue::GridAutoFlow(ref value) => {
                let value: longhands::grid_auto_flow::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_auto_flow(value);
            }
            AnimationValue::ImageRendering(ref value) => {
                let value: longhands::image_rendering::computed_value::T =
                    value.clone();
                style.mutate_inherited_box().set_image_rendering(value);
            }
            AnimationValue::Isolation(ref value) => {
                let value: longhands::isolation::computed_value::T =
                    value.clone();
                style.mutate_box().set_isolation(value);
            }
            AnimationValue::JustifyItems(ref value) => {
                let value: longhands::justify_items::computed_value::T =
                    value.clone();
                style.mutate_position().set_justify_items(value);
            }
            AnimationValue::ListStylePosition(ref value) => {
                let value: longhands::list_style_position::computed_value::T =
                    value.clone();
                style.mutate_list().set_list_style_position(value);
            }
            AnimationValue::ListStyleType(ref value) => {
                let value: longhands::list_style_type::computed_value::T =
                    value.clone();
                style.mutate_list().set_list_style_type(value);
            }
            AnimationValue::MixBlendMode(ref value) => {
                let value: longhands::mix_blend_mode::computed_value::T =
                    value.clone();
                style.mutate_effects().set_mix_blend_mode(value);
            }
            AnimationValue::ObjectFit(ref value) => {
                let value: longhands::object_fit::computed_value::T =
                    value.clone();
                style.mutate_position().set_object_fit(value);
            }
            AnimationValue::Opacity(ref value) => {
                let value: longhands::opacity::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_effects().set_opacity(value);
            }
            AnimationValue::Order(ref value) => {
                let value: longhands::order::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_order(value);
            }
            AnimationValue::OutlineStyle(ref value) => {
                let value: longhands::outline_style::computed_value::T =
                    value.clone();
                style.mutate_outline().set_outline_style(value);
            }
            AnimationValue::OverflowWrap(ref value) => {
                let value: longhands::overflow_wrap::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_overflow_wrap(value);
            }
            AnimationValue::PointerEvents(ref value) => {
                let value: longhands::pointer_events::computed_value::T =
                    value.clone();
                style.mutate_inherited_ui().set_pointer_events(value);
            }
            AnimationValue::Position(ref value) => {
                let value: longhands::position::computed_value::T =
                    value.clone();
                style.mutate_box().set_position(value);
            }
            AnimationValue::PositionArea(ref value) => {
                let value: longhands::position_area::computed_value::T =
                    value.clone();
                style.mutate_position().set_position_area(value);
            }
            AnimationValue::ServoOverflowClipBox(..) => unreachable!(),
            AnimationValue::ServoTopLayer(..) => unreachable!(),
            AnimationValue::TableLayout(ref value) => {
                let value: longhands::table_layout::computed_value::T =
                    value.clone();
                style.mutate_table().set_table_layout(value);
            }
            AnimationValue::TextAlign(ref value) => {
                let value: longhands::text_align::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_text_align(value);
            }
            AnimationValue::TextAlignLast(ref value) => {
                let value: longhands::text_align_last::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_text_align_last(value);
            }
            AnimationValue::TextDecorationLine(ref value) => {
                let value: longhands::text_decoration_line::computed_value::T =
                    value.clone();
                style.mutate_text().set_text_decoration_line(value);
            }
            AnimationValue::TextDecorationStyle(ref value) => {
                let value: longhands::text_decoration_style::computed_value::T =
                    value.clone();
                style.mutate_text().set_text_decoration_style(value);
            }
            AnimationValue::TextJustify(ref value) => {
                let value: longhands::text_justify::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_text_justify(value);
            }
            AnimationValue::TextRendering(ref value) => {
                let value: longhands::text_rendering::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_text_rendering(value);
            }
            AnimationValue::TextTransform(ref value) => {
                let value: longhands::text_transform::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_text_transform(value);
            }
            AnimationValue::TextWrapMode(ref value) => {
                let value: longhands::text_wrap_mode::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_text_wrap_mode(value);
            }
            AnimationValue::TransformStyle(ref value) => {
                let value: longhands::transform_style::computed_value::T =
                    value.clone();
                style.mutate_box().set_transform_style(value);
            }
            AnimationValue::UnicodeBidi(..) => unreachable!(),
            AnimationValue::Visibility(ref value) => {
                let value: longhands::visibility::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_inherited_box().set_visibility(value);
            }
            AnimationValue::WhiteSpaceCollapse(ref value) => {
                let value: longhands::white_space_collapse::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_white_space_collapse(value);
            }
            AnimationValue::WordBreak(ref value) => {
                let value: longhands::word_break::computed_value::T =
                    value.clone();
                style.mutate_inherited_text().set_word_break(value);
            }
            AnimationValue::WritingMode(..) => unreachable!(),
            AnimationValue::ZIndex(ref value) => {
                let value: longhands::z_index::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_z_index(value);
            }
            AnimationValue::Zoom(ref value) => {
                let value: longhands::zoom::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_zoom(value);
            }
            AnimationValue::AlignContent(ref value) => {
                let value: longhands::align_content::computed_value::T =
                    value.clone();
                style.mutate_position().set_align_content(value);
            }
            AnimationValue::JustifyContent(ref value) => {
                let value: longhands::justify_content::computed_value::T =
                    value.clone();
                style.mutate_position().set_justify_content(value);
            }
            AnimationValue::FlexGrow(ref value) => {
                let value: longhands::flex_grow::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_flex_grow(value);
            }
            AnimationValue::FlexShrink(ref value) => {
                let value: longhands::flex_shrink::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_flex_shrink(value);
            }
            AnimationValue::AlignSelf(ref value) => {
                let value: longhands::align_self::computed_value::T =
                    value.clone();
                style.mutate_position().set_align_self(value);
            }
            AnimationValue::JustifySelf(ref value) => {
                let value: longhands::justify_self::computed_value::T =
                    value.clone();
                style.mutate_position().set_justify_self(value);
            }
            AnimationValue::OverflowBlock(..) => unreachable!(),
            AnimationValue::OverflowInline(..) => unreachable!(),
            AnimationValue::OverflowX(ref value) => {
                let value: longhands::overflow_x::computed_value::T =
                    value.clone();
                style.mutate_box().set_overflow_x(value);
            }
            AnimationValue::OverflowY(ref value) => {
                let value: longhands::overflow_y::computed_value::T =
                    value.clone();
                style.mutate_box().set_overflow_y(value);
            }
            AnimationValue::BorderBlockEndStyle(..) => unreachable!(),
            AnimationValue::BorderBlockStartStyle(..) => unreachable!(),
            AnimationValue::BorderBottomStyle(ref value) => {
                let value: longhands::border_bottom_style::computed_value::T =
                    value.clone();
                style.mutate_border().set_border_bottom_style(value);
            }
            AnimationValue::BorderInlineEndStyle(..) => unreachable!(),
            AnimationValue::BorderInlineStartStyle(..) => unreachable!(),
            AnimationValue::BorderLeftStyle(ref value) => {
                let value: longhands::border_left_style::computed_value::T =
                    value.clone();
                style.mutate_border().set_border_left_style(value);
            }
            AnimationValue::BorderRightStyle(ref value) => {
                let value: longhands::border_right_style::computed_value::T =
                    value.clone();
                style.mutate_border().set_border_right_style(value);
            }
            AnimationValue::BorderTopStyle(ref value) => {
                let value: longhands::border_top_style::computed_value::T =
                    value.clone();
                style.mutate_border().set_border_top_style(value);
            }
            AnimationValue::AnimationComposition(..) => unreachable!(),
            AnimationValue::AnimationDelay(..) => unreachable!(),
            AnimationValue::AnimationDirection(..) => unreachable!(),
            AnimationValue::AnimationDuration(..) => unreachable!(),
            AnimationValue::AnimationFillMode(..) => unreachable!(),
            AnimationValue::AnimationIterationCount(..) => unreachable!(),
            AnimationValue::AnimationName(..) => unreachable!(),
            AnimationValue::AnimationPlayState(..) => unreachable!(),
            AnimationValue::AnimationTimeline(..) => unreachable!(),
            AnimationValue::AnimationTimingFunction(..) => unreachable!(),
            AnimationValue::BackdropFilter(ref value) => {
                let value: longhands::backdrop_filter::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_effects().set_backdrop_filter(value);
            }
            AnimationValue::BackgroundAttachment(ref value) => {
                let value: longhands::background_attachment::computed_value::T =
                    value.clone();
                style.mutate_background().set_background_attachment(value);
            }
            AnimationValue::BackgroundClip(ref value) => {
                let value: longhands::background_clip::computed_value::T =
                    value.clone();
                style.mutate_background().set_background_clip(value);
            }
            AnimationValue::BackgroundImage(ref value) => {
                let value: longhands::background_image::computed_value::T =
                    value.clone();
                style.mutate_background().set_background_image(value);
            }
            AnimationValue::BackgroundOrigin(ref value) => {
                let value: longhands::background_origin::computed_value::T =
                    value.clone();
                style.mutate_background().set_background_origin(value);
            }
            AnimationValue::BackgroundPositionX(ref value) => {
                let value: longhands::background_position_x::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_background().set_background_position_x(value);
            }
            AnimationValue::BackgroundPositionY(ref value) => {
                let value: longhands::background_position_y::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_background().set_background_position_y(value);
            }
            AnimationValue::BackgroundRepeat(ref value) => {
                let value: longhands::background_repeat::computed_value::T =
                    value.clone();
                style.mutate_background().set_background_repeat(value);
            }
            AnimationValue::BackgroundSize(ref value) => {
                let value: longhands::background_size::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_background().set_background_size(value);
            }
            AnimationValue::BorderImageOutset(ref value) => {
                let value: longhands::border_image_outset::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_image_outset(value);
            }
            AnimationValue::BorderImageSlice(ref value) => {
                let value: longhands::border_image_slice::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_image_slice(value);
            }
            AnimationValue::BorderImageWidth(ref value) => {
                let value: longhands::border_image_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_image_width(value);
            }
            AnimationValue::BorderSpacing(ref value) => {
                let value: longhands::border_spacing::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_inherited_table().set_border_spacing(value);
            }
            AnimationValue::BoxShadow(ref value) => {
                let value: longhands::box_shadow::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_effects().set_box_shadow(value);
            }
            AnimationValue::Clip(ref value) => {
                let value: longhands::clip::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_effects().set_clip(value);
            }
            AnimationValue::ClipPath(ref value) => {
                let value: longhands::clip_path::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_svg().set_clip_path(value);
            }
            AnimationValue::Color(ref value) => {
                let value: longhands::color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_inherited_text().set_color(value);
            }
            AnimationValue::ColorScheme(ref value) => {
                let value: longhands::color_scheme::computed_value::T =
                    value.clone();
                style.mutate_inherited_ui().set_color_scheme(value);
            }
            AnimationValue::ColumnWidth(ref value) => {
                let value: longhands::column_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_column().set_column_width(value);
            }
            AnimationValue::ContainerName(..) => unreachable!(),
            AnimationValue::Content(ref value) => {
                let value: longhands::content::computed_value::T =
                    value.clone();
                style.mutate_counters().set_content(value);
            }
            AnimationValue::CounterIncrement(ref value) => {
                let value: longhands::counter_increment::computed_value::T =
                    value.clone();
                style.mutate_counters().set_counter_increment(value);
            }
            AnimationValue::CounterReset(ref value) => {
                let value: longhands::counter_reset::computed_value::T =
                    value.clone();
                style.mutate_counters().set_counter_reset(value);
            }
            AnimationValue::Cursor(ref value) => {
                let value: longhands::cursor::computed_value::T =
                    value.clone();
                style.mutate_inherited_ui().set_cursor(value);
            }
            AnimationValue::Filter(ref value) => {
                let value: longhands::filter::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_effects().set_filter(value);
            }
            AnimationValue::FlexBasis(ref value) => {
                let value: longhands::flex_basis::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_flex_basis(value);
            }
            AnimationValue::FontFamily(ref value) => {
                let value: longhands::font_family::computed_value::T =
                    value.clone();
                style.mutate_font().set_font_family(value);
            }
            AnimationValue::FontSize(ref value) => {
                let value: longhands::font_size::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_font().set_font_size(value);
            }
            AnimationValue::FontVariationSettings(ref value) => {
                let value: longhands::font_variation_settings::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_font().set_font_variation_settings(value);
            }
            AnimationValue::GridTemplateAreas(ref value) => {
                let value: longhands::grid_template_areas::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_template_areas(value);
            }
            AnimationValue::LetterSpacing(ref value) => {
                let value: longhands::letter_spacing::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_inherited_text().set_letter_spacing(value);
            }
            AnimationValue::LineHeight(ref value) => {
                let value: longhands::line_height::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_font().set_line_height(value);
            }
            AnimationValue::MaskImage(ref value) => {
                let value: longhands::mask_image::computed_value::T =
                    value.clone();
                style.mutate_svg().set_mask_image(value);
            }
            AnimationValue::OffsetPath(ref value) => {
                let value: longhands::offset_path::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_offset_path(value);
            }
            AnimationValue::OutlineOffset(ref value) => {
                let value: longhands::outline_offset::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_outline().set_outline_offset(value);
            }
            AnimationValue::OverflowClipMargin(ref value) => {
                let value: longhands::overflow_clip_margin::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_margin().set_overflow_clip_margin(value);
            }
            AnimationValue::Perspective(ref value) => {
                let value: longhands::perspective::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_perspective(value);
            }
            AnimationValue::Quotes(ref value) => {
                let value: longhands::quotes::computed_value::T =
                    value.clone();
                style.mutate_list().set_quotes(value);
            }
            AnimationValue::Rotate(ref value) => {
                let value: longhands::rotate::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_rotate(value);
            }
            AnimationValue::Scale(ref value) => {
                let value: longhands::scale::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_scale(value);
            }
            AnimationValue::TextIndent(ref value) => {
                let value: longhands::text_indent::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_inherited_text().set_text_indent(value);
            }
            AnimationValue::TextOverflow(ref value) => {
                let value: longhands::text_overflow::computed_value::T =
                    value.clone();
                style.mutate_text().set_text_overflow(value);
            }
            AnimationValue::TextShadow(ref value) => {
                let value: longhands::text_shadow::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_inherited_text().set_text_shadow(value);
            }
            AnimationValue::Transform(ref value) => {
                let value: longhands::transform::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_transform(value);
            }
            AnimationValue::TransformOrigin(ref value) => {
                let value: longhands::transform_origin::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_transform_origin(value);
            }
            AnimationValue::TransitionBehavior(..) => unreachable!(),
            AnimationValue::TransitionDelay(..) => unreachable!(),
            AnimationValue::TransitionDuration(..) => unreachable!(),
            AnimationValue::TransitionProperty(..) => unreachable!(),
            AnimationValue::TransitionTimingFunction(..) => unreachable!(),
            AnimationValue::Translate(ref value) => {
                let value: longhands::translate::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_translate(value);
            }
            AnimationValue::VerticalAlign(ref value) => {
                let value: longhands::vertical_align::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_vertical_align(value);
            }
            AnimationValue::ViewTransitionClass(ref value) => {
                let value: longhands::view_transition_class::computed_value::T =
                    value.clone();
                style.mutate_ui().set_view_transition_class(value);
            }
            AnimationValue::ViewTransitionName(ref value) => {
                let value: longhands::view_transition_name::computed_value::T =
                    value.clone();
                style.mutate_ui().set_view_transition_name(value);
            }
            AnimationValue::WillChange(..) => unreachable!(),
            AnimationValue::WordSpacing(ref value) => {
                let value: longhands::word_spacing::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_inherited_text().set_word_spacing(value);
            }
            AnimationValue::XLang(..) => unreachable!(),
            AnimationValue::ObjectPosition(ref value) => {
                let value: longhands::object_position::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_object_position(value);
            }
            AnimationValue::PerspectiveOrigin(ref value) => {
                let value: longhands::perspective_origin::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_box().set_perspective_origin(value);
            }
            AnimationValue::GridTemplateColumns(ref value) => {
                let value: longhands::grid_template_columns::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_grid_template_columns(value);
            }
            AnimationValue::GridTemplateRows(ref value) => {
                let value: longhands::grid_template_rows::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_grid_template_rows(value);
            }
            AnimationValue::BorderImageSource(ref value) => {
                let value: longhands::border_image_source::computed_value::T =
                    value.clone();
                style.mutate_border().set_border_image_source(value);
            }
            AnimationValue::ListStyleImage(ref value) => {
                let value: longhands::list_style_image::computed_value::T =
                    value.clone();
                style.mutate_list().set_list_style_image(value);
            }
            AnimationValue::GridAutoColumns(ref value) => {
                let value: longhands::grid_auto_columns::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_auto_columns(value);
            }
            AnimationValue::GridAutoRows(ref value) => {
                let value: longhands::grid_auto_rows::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_auto_rows(value);
            }
            AnimationValue::ColumnGap(ref value) => {
                let value: longhands::column_gap::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_column_gap(value);
            }
            AnimationValue::RowGap(ref value) => {
                let value: longhands::row_gap::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_row_gap(value);
            }
            AnimationValue::GridColumnEnd(ref value) => {
                let value: longhands::grid_column_end::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_column_end(value);
            }
            AnimationValue::GridColumnStart(ref value) => {
                let value: longhands::grid_column_start::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_column_start(value);
            }
            AnimationValue::GridRowEnd(ref value) => {
                let value: longhands::grid_row_end::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_row_end(value);
            }
            AnimationValue::GridRowStart(ref value) => {
                let value: longhands::grid_row_start::computed_value::T =
                    value.clone();
                style.mutate_position().set_grid_row_start(value);
            }
            AnimationValue::MaxBlockSize(..) => unreachable!(),
            AnimationValue::MaxHeight(ref value) => {
                let value: longhands::max_height::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_max_height(value);
            }
            AnimationValue::MaxInlineSize(..) => unreachable!(),
            AnimationValue::MaxWidth(ref value) => {
                let value: longhands::max_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_max_width(value);
            }
            AnimationValue::BorderBottomLeftRadius(ref value) => {
                let value: longhands::border_bottom_left_radius::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_bottom_left_radius(value);
            }
            AnimationValue::BorderBottomRightRadius(ref value) => {
                let value: longhands::border_bottom_right_radius::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_bottom_right_radius(value);
            }
            AnimationValue::BorderEndEndRadius(..) => unreachable!(),
            AnimationValue::BorderEndStartRadius(..) => unreachable!(),
            AnimationValue::BorderStartEndRadius(..) => unreachable!(),
            AnimationValue::BorderStartStartRadius(..) => unreachable!(),
            AnimationValue::BorderTopLeftRadius(ref value) => {
                let value: longhands::border_top_left_radius::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_top_left_radius(value);
            }
            AnimationValue::BorderTopRightRadius(ref value) => {
                let value: longhands::border_top_right_radius::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_top_right_radius(value);
            }
            AnimationValue::Bottom(ref value) => {
                let value: longhands::bottom::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_bottom(value);
            }
            AnimationValue::InsetBlockEnd(..) => unreachable!(),
            AnimationValue::InsetBlockStart(..) => unreachable!(),
            AnimationValue::InsetInlineEnd(..) => unreachable!(),
            AnimationValue::InsetInlineStart(..) => unreachable!(),
            AnimationValue::Left(ref value) => {
                let value: longhands::left::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_left(value);
            }
            AnimationValue::Right(ref value) => {
                let value: longhands::right::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_right(value);
            }
            AnimationValue::Top(ref value) => {
                let value: longhands::top::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_top(value);
            }
            AnimationValue::MarginBlockEnd(..) => unreachable!(),
            AnimationValue::MarginBlockStart(..) => unreachable!(),
            AnimationValue::MarginBottom(ref value) => {
                let value: longhands::margin_bottom::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_margin().set_margin_bottom(value);
            }
            AnimationValue::MarginInlineEnd(..) => unreachable!(),
            AnimationValue::MarginInlineStart(..) => unreachable!(),
            AnimationValue::MarginLeft(ref value) => {
                let value: longhands::margin_left::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_margin().set_margin_left(value);
            }
            AnimationValue::MarginRight(ref value) => {
                let value: longhands::margin_right::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_margin().set_margin_right(value);
            }
            AnimationValue::MarginTop(ref value) => {
                let value: longhands::margin_top::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_margin().set_margin_top(value);
            }
            AnimationValue::PaddingBlockEnd(..) => unreachable!(),
            AnimationValue::PaddingBlockStart(..) => unreachable!(),
            AnimationValue::PaddingBottom(ref value) => {
                let value: longhands::padding_bottom::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_padding().set_padding_bottom(value);
            }
            AnimationValue::PaddingInlineEnd(..) => unreachable!(),
            AnimationValue::PaddingInlineStart(..) => unreachable!(),
            AnimationValue::PaddingLeft(ref value) => {
                let value: longhands::padding_left::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_padding().set_padding_left(value);
            }
            AnimationValue::PaddingRight(ref value) => {
                let value: longhands::padding_right::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_padding().set_padding_right(value);
            }
            AnimationValue::PaddingTop(ref value) => {
                let value: longhands::padding_top::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_padding().set_padding_top(value);
            }
            AnimationValue::BlockSize(..) => unreachable!(),
            AnimationValue::Height(ref value) => {
                let value: longhands::height::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_height(value);
            }
            AnimationValue::InlineSize(..) => unreachable!(),
            AnimationValue::MinBlockSize(..) => unreachable!(),
            AnimationValue::MinHeight(ref value) => {
                let value: longhands::min_height::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_min_height(value);
            }
            AnimationValue::MinInlineSize(..) => unreachable!(),
            AnimationValue::MinWidth(ref value) => {
                let value: longhands::min_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_min_width(value);
            }
            AnimationValue::Width(ref value) => {
                let value: longhands::width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_position().set_width(value);
            }
            AnimationValue::BorderBlockEndWidth(..) => unreachable!(),
            AnimationValue::BorderBlockStartWidth(..) => unreachable!(),
            AnimationValue::BorderBottomWidth(ref value) => {
                let value: longhands::border_bottom_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_bottom_width(value);
            }
            AnimationValue::BorderInlineEndWidth(..) => unreachable!(),
            AnimationValue::BorderInlineStartWidth(..) => unreachable!(),
            AnimationValue::BorderLeftWidth(ref value) => {
                let value: longhands::border_left_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_left_width(value);
            }
            AnimationValue::BorderRightWidth(ref value) => {
                let value: longhands::border_right_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_right_width(value);
            }
            AnimationValue::BorderTopWidth(ref value) => {
                let value: longhands::border_top_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_top_width(value);
            }
            AnimationValue::OutlineWidth(ref value) => {
                let value: longhands::outline_width::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_outline().set_outline_width(value);
            }
            AnimationValue::BackgroundColor(ref value) => {
                let value: longhands::background_color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_background().set_background_color(value);
            }
            AnimationValue::BorderBlockEndColor(..) => unreachable!(),
            AnimationValue::BorderBlockStartColor(..) => unreachable!(),
            AnimationValue::BorderBottomColor(ref value) => {
                let value: longhands::border_bottom_color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_bottom_color(value);
            }
            AnimationValue::BorderInlineEndColor(..) => unreachable!(),
            AnimationValue::BorderInlineStartColor(..) => unreachable!(),
            AnimationValue::BorderLeftColor(ref value) => {
                let value: longhands::border_left_color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_left_color(value);
            }
            AnimationValue::BorderRightColor(ref value) => {
                let value: longhands::border_right_color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_right_color(value);
            }
            AnimationValue::BorderTopColor(ref value) => {
                let value: longhands::border_top_color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_border().set_border_top_color(value);
            }
            AnimationValue::OutlineColor(ref value) => {
                let value: longhands::outline_color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_outline().set_outline_color(value);
            }
            AnimationValue::TextDecorationColor(ref value) => {
                let value: longhands::text_decoration_color::computed_value::T =
                    ToAnimatedValue::from_animated_value(value.clone());
                style.mutate_text().set_text_decoration_color(value);
            }
            AnimationValue::Custom(..) => unreachable!(),
        }
    }

    /// As above, but a stub for Gecko.
    #[cfg(feature = "gecko")]
    pub fn set_in_style_for_servo(&self, _: &mut ComputedValues) {
    }
}

fn animate_discrete<T: Clone>(this: &T, other: &T, procedure: Procedure) -> Result<T, ()> {
    if let Procedure::Interpolate { progress } = procedure {
        Ok(if progress < 0.5 { this.clone() } else { other.clone() })
    } else {
        Err(())
    }
}

impl Animate for AnimationValue {
    fn animate(&self, other: &Self, procedure: Procedure) -> Result<Self, ()> {
        Ok(unsafe {
            use self::AnimationValue::*;

            let this_tag = *(self as *const _ as *const u16);
            let other_tag = *(other as *const _ as *const u16);
            if this_tag != other_tag {
                panic!("Unexpected AnimationValue::animate call");
            }

            match *self {
                
                AlignItems(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ItemPlacement as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ItemPlacement as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                AspectRatio(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::AspectRatio as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::AspectRatio as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackfaceVisibility(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::backface_visibility::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::backface_visibility::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BaselineSource(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::BaselineSource as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::BaselineSource as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderCollapse(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::border_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::border_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderImageRepeat(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::BorderImageRepeat as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::BorderImageRepeat as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BoxSizing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::box_sizing::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::box_sizing::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                CaptionSide(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::table::CaptionSide as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::table::CaptionSide as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Clear(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Clear as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Clear as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ColumnCount(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ColumnCount as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ColumnCount as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ColumnSpan(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::column_span::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::column_span::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Display(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Display as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Display as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                EmptyCells(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::empty_cells::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::empty_cells::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FlexDirection(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::flex_direction::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::flex_direction::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FlexWrap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::flex_wrap::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::flex_wrap::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Float(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Float as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Float as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontLanguageOverride(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::FontLanguageOverride as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::FontLanguageOverride as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontStretch(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontStretch as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontStretch as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontStyle as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontStyle as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontSynthesisWeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::FontSynthesis as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::FontSynthesis as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontVariantCaps(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::font_variant_caps::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::font_variant_caps::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontWeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontWeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontWeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                GridAutoFlow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::GridAutoFlow as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::GridAutoFlow as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ImageRendering(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ImageRendering as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ImageRendering as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Isolation(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::isolation::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::isolation::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                JustifyItems(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::JustifyItems as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::JustifyItems as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ListStylePosition(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::list_style_position::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::list_style_position::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ListStyleType(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::list_style_type::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::list_style_type::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                MixBlendMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::mix_blend_mode::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::mix_blend_mode::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ObjectFit(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::object_fit::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::object_fit::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Opacity(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Opacity as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Opacity as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Order(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Integer as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Integer as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                OutlineStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::OutlineStyle as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::OutlineStyle as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                OverflowWrap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::OverflowWrap as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::OverflowWrap as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                PointerEvents(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::PointerEvents as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::PointerEvents as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Position(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::PositionProperty as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::PositionProperty as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                PositionArea(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::PositionArea as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::PositionArea as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TableLayout(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::table_layout::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::table_layout::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextAlign(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextAlign as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextAlign as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextAlignLast(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextAlignLast as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextAlignLast as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextDecorationLine(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextDecorationLine as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextDecorationLine as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextDecorationStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::text_decoration_style::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::text_decoration_style::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextJustify(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextJustify as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextJustify as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextRendering(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::text_rendering::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::text_rendering::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextTransform(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextTransform as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextTransform as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextWrapMode(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::text_wrap_mode::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::text_wrap_mode::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TransformStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TransformStyle as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TransformStyle as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Visibility(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::visibility::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::visibility::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                WhiteSpaceCollapse(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::white_space_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::white_space_collapse::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                WordBreak(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::WordBreak as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::WordBreak as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ZIndex(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ZIndex as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ZIndex as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Zoom(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Zoom as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Zoom as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                AlignContent(ref this) |
JustifyContent(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ContentDistribution as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FlexGrow(ref this) |
FlexShrink(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                AlignSelf(ref this) |
JustifySelf(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::SelfAlignment as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                OverflowX(ref this) |
OverflowY(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Overflow as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Overflow as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderBottomStyle(ref this) |
BorderLeftStyle(ref this) |
BorderRightStyle(ref this) |
BorderTopStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::BorderStyle as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackdropFilter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::backdrop_filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::backdrop_filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundAttachment(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_attachment::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_attachment::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundClip(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_clip::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_clip::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_image::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_image::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_origin::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_origin::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundPositionX(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_position_x::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::background_position_x::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundPositionY(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_position_y::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::background_position_y::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundRepeat(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::background_repeat::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::background_repeat::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_size::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::background_size::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderImageOutset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthOrNumberRect as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthOrNumberRect as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderImageSlice(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderImageSlice as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderImageSlice as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderImageWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderImageWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderImageWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BoxShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::box_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::box_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Clip(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ClipRectOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ClipRectOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ClipPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::basic_shape::ClipPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::basic_shape::ClipPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Color(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ColorPropertyValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::ColorPropertyValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ColorScheme(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ColorScheme as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ColorScheme as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ColumnWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Content(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Content as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Content as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                CounterIncrement(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::CounterIncrement as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::CounterIncrement as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                CounterReset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::CounterReset as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::CounterReset as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Cursor(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Cursor as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Cursor as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Filter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FlexBasis(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FlexBasis as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FlexBasis as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontFamily(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::FontFamily as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::FontFamily as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                FontVariationSettings(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontVariationSettings as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::FontVariationSettings as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                GridTemplateAreas(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::GridTemplateAreas as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::GridTemplateAreas as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                LetterSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::LetterSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::LetterSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                LineHeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::LineHeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::LineHeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                MaskImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<longhands::mask_image::SpecifiedValue as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<longhands::mask_image::SpecifiedValue as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                OffsetPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::OffsetPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::OffsetPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                OutlineOffset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSideOffset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderSideOffset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                OverflowClipMargin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Length as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Length as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Perspective(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Perspective as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Perspective as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Quotes(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Quotes as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Quotes as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Rotate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Rotate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Rotate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Scale(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Scale as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Scale as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextIndent(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::TextIndent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::TextIndent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextOverflow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::TextOverflow as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::TextOverflow as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TextShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::text_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<longhands::text_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Transform(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Transform as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Transform as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                TransformOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::TransformOrigin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::TransformOrigin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Translate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Translate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Translate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                VerticalAlign(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::VerticalAlign as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::VerticalAlign as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ViewTransitionClass(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ViewTransitionClass as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ViewTransitionClass as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ViewTransitionName(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ViewTransitionName as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ViewTransitionName as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                WordSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::WordSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::WordSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ObjectPosition(ref this) |
PerspectiveOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                GridTemplateColumns(ref this) |
GridTemplateRows(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderImageSource(ref this) |
ListStyleImage(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::Image as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::Image as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                GridAutoColumns(ref this) |
GridAutoRows(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::ImplicitGridTracks as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::ImplicitGridTracks as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                ColumnGap(ref this) |
RowGap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                GridColumnEnd(ref this) |
GridColumnStart(ref this) |
GridRowEnd(ref this) |
GridRowStart(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<crate::values::specified::GridLine as ToComputedValue>::ComputedValue>);
                    let value = animate_discrete(this, &other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<crate::values::specified::GridLine as ToComputedValue>::ComputedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                MaxHeight(ref this) |
MaxWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderBottomLeftRadius(ref this) |
BorderBottomRightRadius(ref this) |
BorderTopLeftRadius(ref this) |
BorderTopRightRadius(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Bottom(ref this) |
Left(ref this) |
Right(ref this) |
Top(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                MarginBottom(ref this) |
MarginLeft(ref this) |
MarginRight(ref this) |
MarginTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                PaddingBottom(ref this) |
PaddingLeft(ref this) |
PaddingRight(ref this) |
PaddingTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Height(ref this) |
MinHeight(ref this) |
MinWidth(ref this) |
Width(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BorderBottomWidth(ref this) |
BorderLeftWidth(ref this) |
BorderRightWidth(ref this) |
BorderTopWidth(ref this) |
OutlineWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                BackgroundColor(ref this) |
BorderBottomColor(ref this) |
BorderLeftColor(ref this) |
BorderRightColor(ref this) |
BorderTopColor(ref this) |
OutlineColor(ref this) |
TextDecorationColor(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);
                    let value = this.animate(&other_repr.value, procedure)?;

                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut AnimationValueVariantRepr<<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>,
                        AnimationValueVariantRepr {
                            tag: this_tag,
                            value,
                        },
                    );
                    out.assume_init()
                },
                Contain(void) |
ContainerType(void) |
Direction(void) |
ServoOverflowClipBox(void) |
ServoTopLayer(void) |
UnicodeBidi(void) |
WritingMode(void) |
OverflowBlock(void) |
OverflowInline(void) |
BorderBlockEndStyle(void) |
BorderBlockStartStyle(void) |
BorderInlineEndStyle(void) |
BorderInlineStartStyle(void) |
AnimationComposition(void) |
AnimationDelay(void) |
AnimationDirection(void) |
AnimationDuration(void) |
AnimationFillMode(void) |
AnimationIterationCount(void) |
AnimationName(void) |
AnimationPlayState(void) |
AnimationTimeline(void) |
AnimationTimingFunction(void) |
ContainerName(void) |
TransitionBehavior(void) |
TransitionDelay(void) |
TransitionDuration(void) |
TransitionProperty(void) |
TransitionTimingFunction(void) |
WillChange(void) |
XLang(void) |
MaxBlockSize(void) |
MaxInlineSize(void) |
BorderEndEndRadius(void) |
BorderEndStartRadius(void) |
BorderStartEndRadius(void) |
BorderStartStartRadius(void) |
InsetBlockEnd(void) |
InsetBlockStart(void) |
InsetInlineEnd(void) |
InsetInlineStart(void) |
MarginBlockEnd(void) |
MarginBlockStart(void) |
MarginInlineEnd(void) |
MarginInlineStart(void) |
PaddingBlockEnd(void) |
PaddingBlockStart(void) |
PaddingInlineEnd(void) |
PaddingInlineStart(void) |
BlockSize(void) |
InlineSize(void) |
MinBlockSize(void) |
MinInlineSize(void) |
BorderBlockEndWidth(void) |
BorderBlockStartWidth(void) |
BorderInlineEndWidth(void) |
BorderInlineStartWidth(void) |
BorderBlockEndColor(void) |
BorderBlockStartColor(void) |
BorderInlineEndColor(void) |
BorderInlineStartColor(void) => {
                    void::unreachable(void)
                },
                Custom(ref self_value) => {
                    let Custom(ref other_value) = *other else { unreachable!() };
                    Custom(self_value.animate(other_value, procedure)?)
                },
            }
        })
    }
}



impl ComputeSquaredDistance for AnimationValue {
    fn compute_squared_distance(&self, other: &Self) -> Result<SquaredDistance, ()> {
        unsafe {
            use self::AnimationValue::*;

            let this_tag = *(self as *const _ as *const u16);
            let other_tag = *(other as *const _ as *const u16);
            if this_tag != other_tag {
                panic!("Unexpected AnimationValue::compute_squared_distance call");
            }

            match *self {
                AspectRatio(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::AspectRatio as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                ColumnCount(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ColumnCount as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                FontStretch(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontStretch as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                FontStyle(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontStyle as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                FontWeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontWeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Opacity(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Opacity as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Order(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Integer as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Visibility(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::visibility::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                ZIndex(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ZIndex as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Zoom(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Zoom as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                FlexGrow(ref this) |
FlexShrink(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeNumber as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BackdropFilter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::backdrop_filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BackgroundPositionX(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_position_x::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BackgroundPositionY(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_position_y::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BackgroundSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::background_size::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BorderImageOutset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthOrNumberRect as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BorderImageSlice(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderImageSlice as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BorderImageWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderImageWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BorderSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BoxShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::box_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Clip(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ClipRectOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                ClipPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::basic_shape::ClipPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Color(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::ColorPropertyValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                ColumnWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthOrAuto as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Filter(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::filter::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                FlexBasis(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FlexBasis as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                FontSize(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                FontVariationSettings(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::FontVariationSettings as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                LetterSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::LetterSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                LineHeight(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::LineHeight as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                OffsetPath(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::OffsetPath as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                OutlineOffset(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSideOffset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                OverflowClipMargin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Length as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Perspective(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Perspective as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Rotate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Rotate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Scale(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Scale as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                TextIndent(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::TextIndent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                TextShadow(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<longhands::text_shadow::SpecifiedValue as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Transform(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Transform as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                TransformOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::TransformOrigin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Translate(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Translate as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                VerticalAlign(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::VerticalAlign as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                WordSpacing(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::WordSpacing as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                ObjectPosition(ref this) |
PerspectiveOrigin(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Position as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                GridTemplateColumns(ref this) |
GridTemplateRows(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::GridTemplateComponent as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                ColumnGap(ref this) |
RowGap(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::length::NonNegativeLengthPercentageOrNormal as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                MaxHeight(ref this) |
MaxWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::MaxSize as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BorderBottomLeftRadius(ref this) |
BorderBottomRightRadius(ref this) |
BorderTopLeftRadius(ref this) |
BorderTopRightRadius(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderCornerRadius as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Bottom(ref this) |
Left(ref this) |
Right(ref this) |
Top(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Inset as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                MarginBottom(ref this) |
MarginLeft(ref this) |
MarginRight(ref this) |
MarginTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Margin as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                PaddingBottom(ref this) |
PaddingLeft(ref this) |
PaddingRight(ref this) |
PaddingTop(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::NonNegativeLengthPercentage as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                Height(ref this) |
MinHeight(ref this) |
MinWidth(ref this) |
Width(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Size as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BorderBottomWidth(ref this) |
BorderLeftWidth(ref this) |
BorderRightWidth(ref this) |
BorderTopWidth(ref this) |
OutlineWidth(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::BorderSideWidth as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                BackgroundColor(ref this) |
BorderBottomColor(ref this) |
BorderLeftColor(ref this) |
BorderRightColor(ref this) |
BorderTopColor(ref this) |
OutlineColor(ref this) |
TextDecorationColor(ref this) => {
                    let other_repr =
                        &*(other as *const _ as *const AnimationValueVariantRepr<<<crate::values::specified::Color as ToComputedValue>::ComputedValue as ToAnimatedValue>::AnimatedValue>);

                    this.compute_squared_distance(&other_repr.value)
                }
                _ => Err(()),
            }
        }
    }
}

impl ToAnimatedZero for AnimationValue {
    #[inline]
    fn to_animated_zero(&self) -> Result<Self, ()> {
        match *self {
            AnimationValue::AspectRatio(ref base) => {
                Ok(AnimationValue::AspectRatio(base.to_animated_zero()?))
            },
            AnimationValue::ColumnCount(ref base) => {
                Ok(AnimationValue::ColumnCount(base.to_animated_zero()?))
            },
            AnimationValue::FontStretch(ref base) => {
                Ok(AnimationValue::FontStretch(base.to_animated_zero()?))
            },
            AnimationValue::FontStyle(ref base) => {
                Ok(AnimationValue::FontStyle(base.to_animated_zero()?))
            },
            AnimationValue::FontWeight(ref base) => {
                Ok(AnimationValue::FontWeight(base.to_animated_zero()?))
            },
            AnimationValue::Opacity(ref base) => {
                Ok(AnimationValue::Opacity(base.to_animated_zero()?))
            },
            AnimationValue::Order(ref base) => {
                Ok(AnimationValue::Order(base.to_animated_zero()?))
            },
            AnimationValue::Visibility(ref base) => {
                Ok(AnimationValue::Visibility(base.to_animated_zero()?))
            },
            AnimationValue::ZIndex(ref base) => {
                Ok(AnimationValue::ZIndex(base.to_animated_zero()?))
            },
            AnimationValue::Zoom(ref base) => {
                Ok(AnimationValue::Zoom(base.to_animated_zero()?))
            },
            AnimationValue::FlexGrow(ref base) => {
                Ok(AnimationValue::FlexGrow(base.to_animated_zero()?))
            },
            AnimationValue::FlexShrink(ref base) => {
                Ok(AnimationValue::FlexShrink(base.to_animated_zero()?))
            },
            AnimationValue::BackdropFilter(ref base) => {
                Ok(AnimationValue::BackdropFilter(base.to_animated_zero()?))
            },
            AnimationValue::BackgroundPositionX(ref base) => {
                Ok(AnimationValue::BackgroundPositionX(base.to_animated_zero()?))
            },
            AnimationValue::BackgroundPositionY(ref base) => {
                Ok(AnimationValue::BackgroundPositionY(base.to_animated_zero()?))
            },
            AnimationValue::BackgroundSize(ref base) => {
                Ok(AnimationValue::BackgroundSize(base.to_animated_zero()?))
            },
            AnimationValue::BorderImageOutset(ref base) => {
                Ok(AnimationValue::BorderImageOutset(base.to_animated_zero()?))
            },
            AnimationValue::BorderImageSlice(ref base) => {
                Ok(AnimationValue::BorderImageSlice(base.to_animated_zero()?))
            },
            AnimationValue::BorderImageWidth(ref base) => {
                Ok(AnimationValue::BorderImageWidth(base.to_animated_zero()?))
            },
            AnimationValue::BorderSpacing(ref base) => {
                Ok(AnimationValue::BorderSpacing(base.to_animated_zero()?))
            },
            AnimationValue::BoxShadow(ref base) => {
                Ok(AnimationValue::BoxShadow(base.to_animated_zero()?))
            },
            AnimationValue::Clip(ref base) => {
                Ok(AnimationValue::Clip(base.to_animated_zero()?))
            },
            AnimationValue::ClipPath(ref base) => {
                Ok(AnimationValue::ClipPath(base.to_animated_zero()?))
            },
            AnimationValue::Color(ref base) => {
                Ok(AnimationValue::Color(base.to_animated_zero()?))
            },
            AnimationValue::ColumnWidth(ref base) => {
                Ok(AnimationValue::ColumnWidth(base.to_animated_zero()?))
            },
            AnimationValue::Filter(ref base) => {
                Ok(AnimationValue::Filter(base.to_animated_zero()?))
            },
            AnimationValue::FlexBasis(ref base) => {
                Ok(AnimationValue::FlexBasis(base.to_animated_zero()?))
            },
            AnimationValue::FontSize(ref base) => {
                Ok(AnimationValue::FontSize(base.to_animated_zero()?))
            },
            AnimationValue::FontVariationSettings(ref base) => {
                Ok(AnimationValue::FontVariationSettings(base.to_animated_zero()?))
            },
            AnimationValue::LetterSpacing(ref base) => {
                Ok(AnimationValue::LetterSpacing(base.to_animated_zero()?))
            },
            AnimationValue::LineHeight(ref base) => {
                Ok(AnimationValue::LineHeight(base.to_animated_zero()?))
            },
            AnimationValue::OffsetPath(ref base) => {
                Ok(AnimationValue::OffsetPath(base.to_animated_zero()?))
            },
            AnimationValue::OutlineOffset(ref base) => {
                Ok(AnimationValue::OutlineOffset(base.to_animated_zero()?))
            },
            AnimationValue::OverflowClipMargin(ref base) => {
                Ok(AnimationValue::OverflowClipMargin(base.to_animated_zero()?))
            },
            AnimationValue::Perspective(ref base) => {
                Ok(AnimationValue::Perspective(base.to_animated_zero()?))
            },
            AnimationValue::Rotate(ref base) => {
                Ok(AnimationValue::Rotate(base.to_animated_zero()?))
            },
            AnimationValue::Scale(ref base) => {
                Ok(AnimationValue::Scale(base.to_animated_zero()?))
            },
            AnimationValue::TextIndent(ref base) => {
                Ok(AnimationValue::TextIndent(base.to_animated_zero()?))
            },
            AnimationValue::TextShadow(ref base) => {
                Ok(AnimationValue::TextShadow(base.to_animated_zero()?))
            },
            AnimationValue::Transform(ref base) => {
                Ok(AnimationValue::Transform(base.to_animated_zero()?))
            },
            AnimationValue::TransformOrigin(ref base) => {
                Ok(AnimationValue::TransformOrigin(base.to_animated_zero()?))
            },
            AnimationValue::Translate(ref base) => {
                Ok(AnimationValue::Translate(base.to_animated_zero()?))
            },
            AnimationValue::VerticalAlign(ref base) => {
                Ok(AnimationValue::VerticalAlign(base.to_animated_zero()?))
            },
            AnimationValue::WordSpacing(ref base) => {
                Ok(AnimationValue::WordSpacing(base.to_animated_zero()?))
            },
            AnimationValue::ObjectPosition(ref base) => {
                Ok(AnimationValue::ObjectPosition(base.to_animated_zero()?))
            },
            AnimationValue::PerspectiveOrigin(ref base) => {
                Ok(AnimationValue::PerspectiveOrigin(base.to_animated_zero()?))
            },
            AnimationValue::GridTemplateColumns(ref base) => {
                Ok(AnimationValue::GridTemplateColumns(base.to_animated_zero()?))
            },
            AnimationValue::GridTemplateRows(ref base) => {
                Ok(AnimationValue::GridTemplateRows(base.to_animated_zero()?))
            },
            AnimationValue::ColumnGap(ref base) => {
                Ok(AnimationValue::ColumnGap(base.to_animated_zero()?))
            },
            AnimationValue::RowGap(ref base) => {
                Ok(AnimationValue::RowGap(base.to_animated_zero()?))
            },
            AnimationValue::MaxHeight(ref base) => {
                Ok(AnimationValue::MaxHeight(base.to_animated_zero()?))
            },
            AnimationValue::MaxWidth(ref base) => {
                Ok(AnimationValue::MaxWidth(base.to_animated_zero()?))
            },
            AnimationValue::BorderBottomLeftRadius(ref base) => {
                Ok(AnimationValue::BorderBottomLeftRadius(base.to_animated_zero()?))
            },
            AnimationValue::BorderBottomRightRadius(ref base) => {
                Ok(AnimationValue::BorderBottomRightRadius(base.to_animated_zero()?))
            },
            AnimationValue::BorderTopLeftRadius(ref base) => {
                Ok(AnimationValue::BorderTopLeftRadius(base.to_animated_zero()?))
            },
            AnimationValue::BorderTopRightRadius(ref base) => {
                Ok(AnimationValue::BorderTopRightRadius(base.to_animated_zero()?))
            },
            AnimationValue::Bottom(ref base) => {
                Ok(AnimationValue::Bottom(base.to_animated_zero()?))
            },
            AnimationValue::Left(ref base) => {
                Ok(AnimationValue::Left(base.to_animated_zero()?))
            },
            AnimationValue::Right(ref base) => {
                Ok(AnimationValue::Right(base.to_animated_zero()?))
            },
            AnimationValue::Top(ref base) => {
                Ok(AnimationValue::Top(base.to_animated_zero()?))
            },
            AnimationValue::MarginBottom(ref base) => {
                Ok(AnimationValue::MarginBottom(base.to_animated_zero()?))
            },
            AnimationValue::MarginLeft(ref base) => {
                Ok(AnimationValue::MarginLeft(base.to_animated_zero()?))
            },
            AnimationValue::MarginRight(ref base) => {
                Ok(AnimationValue::MarginRight(base.to_animated_zero()?))
            },
            AnimationValue::MarginTop(ref base) => {
                Ok(AnimationValue::MarginTop(base.to_animated_zero()?))
            },
            AnimationValue::PaddingBottom(ref base) => {
                Ok(AnimationValue::PaddingBottom(base.to_animated_zero()?))
            },
            AnimationValue::PaddingLeft(ref base) => {
                Ok(AnimationValue::PaddingLeft(base.to_animated_zero()?))
            },
            AnimationValue::PaddingRight(ref base) => {
                Ok(AnimationValue::PaddingRight(base.to_animated_zero()?))
            },
            AnimationValue::PaddingTop(ref base) => {
                Ok(AnimationValue::PaddingTop(base.to_animated_zero()?))
            },
            AnimationValue::Height(ref base) => {
                Ok(AnimationValue::Height(base.to_animated_zero()?))
            },
            AnimationValue::MinHeight(ref base) => {
                Ok(AnimationValue::MinHeight(base.to_animated_zero()?))
            },
            AnimationValue::MinWidth(ref base) => {
                Ok(AnimationValue::MinWidth(base.to_animated_zero()?))
            },
            AnimationValue::Width(ref base) => {
                Ok(AnimationValue::Width(base.to_animated_zero()?))
            },
            AnimationValue::BorderBottomWidth(ref base) => {
                Ok(AnimationValue::BorderBottomWidth(base.to_animated_zero()?))
            },
            AnimationValue::BorderLeftWidth(ref base) => {
                Ok(AnimationValue::BorderLeftWidth(base.to_animated_zero()?))
            },
            AnimationValue::BorderRightWidth(ref base) => {
                Ok(AnimationValue::BorderRightWidth(base.to_animated_zero()?))
            },
            AnimationValue::BorderTopWidth(ref base) => {
                Ok(AnimationValue::BorderTopWidth(base.to_animated_zero()?))
            },
            AnimationValue::OutlineWidth(ref base) => {
                Ok(AnimationValue::OutlineWidth(base.to_animated_zero()?))
            },
            AnimationValue::BackgroundColor(ref base) => {
                Ok(AnimationValue::BackgroundColor(base.to_animated_zero()?))
            },
            AnimationValue::BorderBottomColor(ref base) => {
                Ok(AnimationValue::BorderBottomColor(base.to_animated_zero()?))
            },
            AnimationValue::BorderLeftColor(ref base) => {
                Ok(AnimationValue::BorderLeftColor(base.to_animated_zero()?))
            },
            AnimationValue::BorderRightColor(ref base) => {
                Ok(AnimationValue::BorderRightColor(base.to_animated_zero()?))
            },
            AnimationValue::BorderTopColor(ref base) => {
                Ok(AnimationValue::BorderTopColor(base.to_animated_zero()?))
            },
            AnimationValue::OutlineColor(ref base) => {
                Ok(AnimationValue::OutlineColor(base.to_animated_zero()?))
            },
            AnimationValue::TextDecorationColor(ref base) => {
                Ok(AnimationValue::TextDecorationColor(base.to_animated_zero()?))
            },
            AnimationValue::Custom(..) => {
                // TODO(bug 1869185): For some non-universal registered custom properties, it may make sense to implement this.
                Err(())
            },
            _ => Err(()),
        }
    }
}

/// <https://drafts.csswg.org/web-animations-1/#animating-visibility>
impl Animate for Visibility {
    #[inline]
    fn animate(&self, other: &Self, procedure: Procedure) -> Result<Self, ()> {
        match procedure {
            Procedure::Interpolate { .. } => {
                let (this_weight, other_weight) = procedure.weights();
                match (*self, *other) {
                    (Visibility::Visible, _) => {
                        Ok(if this_weight > 0.0 { *self } else { *other })
                    },
                    (_, Visibility::Visible) => {
                        Ok(if other_weight > 0.0 { *other } else { *self })
                    },
                    _ => Err(()),
                }
            },
            _ => Err(()),
        }
    }
}

impl ComputeSquaredDistance for Visibility {
    #[inline]
    fn compute_squared_distance(&self, other: &Self) -> Result<SquaredDistance, ()> {
        Ok(SquaredDistance::from_sqrt(if *self == *other { 0. } else { 1. }))
    }
}

impl ToAnimatedZero for Visibility {
    #[inline]
    fn to_animated_zero(&self) -> Result<Self, ()> {
        Err(())
    }
}

/// <https://drafts.csswg.org/css-contain-3/#content-visibility-animation>
#[cfg(feature = "gecko")]
impl Animate for ContentVisibility {
    #[inline]
    fn animate(&self, other: &Self, procedure: Procedure) -> Result<Self, ()> {
        match procedure {
            Procedure::Interpolate { .. } => {
                let (this_weight, other_weight) = procedure.weights();
                match (*self, *other) {
                    (ContentVisibility::Hidden, _) => {
                        Ok(if other_weight > 0.0 { *other } else { *self })
                    },
                    (_, ContentVisibility::Hidden) => {
                        Ok(if this_weight > 0.0 { *self } else { *other })
                    },
                    _ => Err(()),
                }
            },
            _ => Err(()),
        }
    }
}

#[cfg(feature = "gecko")]
impl ComputeSquaredDistance for ContentVisibility {
    #[inline]
    fn compute_squared_distance(&self, other: &Self) -> Result<SquaredDistance, ()> {
        Ok(SquaredDistance::from_sqrt(if *self == *other { 0. } else { 1. }))
    }
}

#[cfg(feature = "gecko")]
impl ToAnimatedZero for ContentVisibility {
    #[inline]
    fn to_animated_zero(&self) -> Result<Self, ()> {
        Err(())
    }
}

/// <https://drafts.csswg.org/css-transitions/#animtype-rect>
impl Animate for ClipRect {
    #[inline]
    fn animate(&self, other: &Self, procedure: Procedure) -> Result<Self, ()> {
        use crate::values::computed::LengthOrAuto;
        let animate_component = |this: &LengthOrAuto, other: &LengthOrAuto| {
            let result = this.animate(other, procedure)?;
            if let Procedure::Interpolate { .. } = procedure {
                return Ok(result);
            }
            if result.is_auto() {
                // FIXME(emilio): Why? A couple SMIL tests fail without this,
                // but it seems extremely fishy.
                return Err(());
            }
            Ok(result)
        };

        Ok(ClipRect {
            top: animate_component(&self.top, &other.top)?,
            right: animate_component(&self.right, &other.right)?,
            bottom: animate_component(&self.bottom, &other.bottom)?,
            left: animate_component(&self.left, &other.left)?,
        })
    }
}



/// <https://drafts.fxtf.org/filters/#animation-of-filters>
impl Animate for AnimatedFilter {
    fn animate(
        &self,
        other: &Self,
        procedure: Procedure,
    ) -> Result<Self, ()> {
        use crate::values::animated::animate_multiplicative_factor;
        match (self, other) {
            (&Filter::Blur(ref this), &Filter::Blur(ref other)) => {
                Ok(Filter::Blur(this.animate(other, procedure)?))
            },
            (&Filter::DropShadow(ref this), &Filter::DropShadow(ref other)) => {
                Ok(Filter::DropShadow(this.animate(other, procedure)?))
            },
            (&Filter::Grayscale(ref this), &Filter::Grayscale(ref other)) => {
                Ok(Filter::Grayscale(this.animate(other, procedure)?))
            },
            (&Filter::HueRotate(ref this), &Filter::HueRotate(ref other)) => {
                Ok(Filter::HueRotate(this.animate(other, procedure)?))
            },
            (&Filter::Invert(ref this), &Filter::Invert(ref other)) => {
                Ok(Filter::Invert(this.animate(other, procedure)?))
            },
            (&Filter::Sepia(ref this), &Filter::Sepia(ref other)) => {
                Ok(Filter::Sepia(this.animate(other, procedure)?))
            },
            (&Filter::Brightness(this), &Filter::Brightness(other)) => {
                Ok(Filter::Brightness(animate_multiplicative_factor(this, other, procedure)?))
            },
            (&Filter::Contrast(this), &Filter::Contrast(other)) => {
                Ok(Filter::Contrast(animate_multiplicative_factor(this, other, procedure)?))
            },
            (&Filter::Opacity(this), &Filter::Opacity(other)) => {
                Ok(Filter::Opacity(animate_multiplicative_factor(this, other, procedure)?))
            },
            (&Filter::Saturate(this), &Filter::Saturate(other)) => {
                Ok(Filter::Saturate(animate_multiplicative_factor(this, other, procedure)?))
            },
            _ => Err(()),
        }
    }
}

/// <http://dev.w3.org/csswg/css-transforms/#none-transform-animation>
impl ToAnimatedZero for AnimatedFilter {
    fn to_animated_zero(&self) -> Result<Self, ()> {
        match *self {
            Filter::Blur(ref this) => Ok(Filter::Blur(this.to_animated_zero()?)),
            Filter::DropShadow(ref this) => Ok(Filter::DropShadow(this.to_animated_zero()?)),
            Filter::Grayscale(ref this) => Ok(Filter::Grayscale(this.to_animated_zero()?)),
            Filter::HueRotate(ref this) => Ok(Filter::HueRotate(this.to_animated_zero()?)),
            Filter::Invert(ref this) => Ok(Filter::Invert(this.to_animated_zero()?)),
            Filter::Sepia(ref this) => Ok(Filter::Sepia(this.to_animated_zero()?)),
            Filter::Brightness(_) => Ok(Filter::Brightness(1.)),
            Filter::Contrast(_) => Ok(Filter::Contrast(1.)),
            Filter::Opacity(_) => Ok(Filter::Opacity(1.)),
            Filter::Saturate(_) => Ok(Filter::Saturate(1.)),
            _ => Err(()),
        }
    }
}

/// An iterator over all the properties that transition on a given style.
pub struct TransitionPropertyIterator<'a> {
    style: &'a ComputedValues,
    index_range: core::ops::Range<usize>,
    longhand_iterator: Option<NonCustomPropertyIterator<LonghandId>>,
}

impl<'a> TransitionPropertyIterator<'a> {
    /// Create a `TransitionPropertyIterator` for the given style.
    pub fn from_style(style: &'a ComputedValues) -> Self {
        Self {
            style,
            index_range: 0..style.get_ui().transition_property_count(),
            longhand_iterator: None,
        }
    }
}

/// A single iteration of the TransitionPropertyIterator.
pub struct TransitionPropertyIteration {
    /// The id of the longhand for this property.
    pub property: OwnedPropertyDeclarationId,

    /// The index of this property in the list of transition properties for this
    /// iterator's style.
    pub index: usize,
}

impl<'a> Iterator for TransitionPropertyIterator<'a> {
    type Item = TransitionPropertyIteration;

    fn next(&mut self) -> Option<Self::Item> {
        use crate::values::computed::TransitionProperty;
        loop {
            if let Some(ref mut longhand_iterator) = self.longhand_iterator {
                if let Some(longhand_id) = longhand_iterator.next() {
                    return Some(TransitionPropertyIteration {
                        property: OwnedPropertyDeclarationId::Longhand(longhand_id),
                        index: self.index_range.start - 1,
                    });
                }
                self.longhand_iterator = None;
            }

            let index = self.index_range.next()?;
            match self.style.get_ui().transition_property_at(index) {
                TransitionProperty::NonCustom(id) => {
                    match id.longhand_or_shorthand() {
                        Ok(longhand_id) => {
                            return Some(TransitionPropertyIteration {
                                property: OwnedPropertyDeclarationId::Longhand(longhand_id),
                                index,
                            });
                        },
                        Err(shorthand_id) => {
                            // In the other cases, we set up our state so that we are ready to
                            // compute the next value of the iterator and then loop (equivalent
                            // to calling self.next()).
                            self.longhand_iterator = Some(shorthand_id.longhands());
                        },
                    }
                }
                TransitionProperty::Custom(name) => {
                    return Some(TransitionPropertyIteration {
                        property: OwnedPropertyDeclarationId::Custom(name),
                        index,
                    })
                },
                TransitionProperty::Unsupported(..) => {},
            }
        }
    }
}

}

/// A module to group various interesting property counts.
pub mod property_counts {
    /// The number of (non-alias) longhand properties.
    pub const LONGHANDS: usize = 222;
    /// The number of (non-alias) shorthand properties.
    pub const SHORTHANDS: usize = 55;
    /// The number of aliases.
    pub const ALIASES: usize = 4;
    /// The number of counted unknown properties.
    pub const COUNTED_UNKNOWN: usize = 102;
    /// The number of (non-alias) longhands and shorthands.
    pub const LONGHANDS_AND_SHORTHANDS: usize = LONGHANDS + SHORTHANDS;
    /// The number of non-custom properties.
    pub const NON_CUSTOM: usize = LONGHANDS_AND_SHORTHANDS + ALIASES;
    /// The number of prioritary properties that we have.
    
    
    pub const PRIORITARY: usize = 11;
    /// The max number of longhands that a shorthand other than "all" expands to.
    pub const MAX_SHORTHAND_EXPANDED: usize =
        17;
    /// The max amount of longhands that the `all` shorthand will ever contain.
    pub const ALL_SHORTHAND_EXPANDED: usize = 217;
    /// The number of animatable properties.
    pub const ANIMATABLE: usize = 193;
}


impl NonCustomPropertyId {
    /// Get the property name.
    #[inline]
    pub fn name(self) -> &'static str {
        static MAP: [&'static str; property_counts::NON_CUSTOM] = [
            "align-items",
            "aspect-ratio",
            "backface-visibility",
            "baseline-source",
            "border-collapse",
            "border-image-repeat",
            "box-sizing",
            "caption-side",
            "clear",
            "column-count",
            "column-span",
            "contain",
            "container-type",
            "direction",
            "display",
            "empty-cells",
            "flex-direction",
            "flex-wrap",
            "float",
            "font-language-override",
            "font-stretch",
            "font-style",
            "font-synthesis-weight",
            "font-variant-caps",
            "font-weight",
            "grid-auto-flow",
            "image-rendering",
            "isolation",
            "justify-items",
            "list-style-position",
            "list-style-type",
            "mix-blend-mode",
            "object-fit",
            "opacity",
            "order",
            "outline-style",
            "overflow-wrap",
            "pointer-events",
            "position",
            "position-area",
            "-servo-overflow-clip-box",
            "-servo-top-layer",
            "table-layout",
            "text-align",
            "text-align-last",
            "text-decoration-line",
            "text-decoration-style",
            "text-justify",
            "text-rendering",
            "text-transform",
            "text-wrap-mode",
            "transform-style",
            "unicode-bidi",
            "visibility",
            "white-space-collapse",
            "word-break",
            "writing-mode",
            "z-index",
            "zoom",
            "align-content",
            "justify-content",
            "flex-grow",
            "flex-shrink",
            "align-self",
            "justify-self",
            "overflow-block",
            "overflow-inline",
            "overflow-x",
            "overflow-y",
            "border-block-end-style",
            "border-block-start-style",
            "border-bottom-style",
            "border-inline-end-style",
            "border-inline-start-style",
            "border-left-style",
            "border-right-style",
            "border-top-style",
            "animation-composition",
            "animation-delay",
            "animation-direction",
            "animation-duration",
            "animation-fill-mode",
            "animation-iteration-count",
            "animation-name",
            "animation-play-state",
            "animation-timeline",
            "animation-timing-function",
            "backdrop-filter",
            "background-attachment",
            "background-clip",
            "background-image",
            "background-origin",
            "background-position-x",
            "background-position-y",
            "background-repeat",
            "background-size",
            "border-image-outset",
            "border-image-slice",
            "border-image-width",
            "border-spacing",
            "box-shadow",
            "clip",
            "clip-path",
            "color",
            "color-scheme",
            "column-width",
            "container-name",
            "content",
            "counter-increment",
            "counter-reset",
            "cursor",
            "filter",
            "flex-basis",
            "font-family",
            "font-size",
            "font-variation-settings",
            "grid-template-areas",
            "letter-spacing",
            "line-height",
            "mask-image",
            "offset-path",
            "outline-offset",
            "overflow-clip-margin",
            "perspective",
            "quotes",
            "rotate",
            "scale",
            "text-indent",
            "text-overflow",
            "text-shadow",
            "transform",
            "transform-origin",
            "transition-behavior",
            "transition-delay",
            "transition-duration",
            "transition-property",
            "transition-timing-function",
            "translate",
            "vertical-align",
            "view-transition-class",
            "view-transition-name",
            "will-change",
            "word-spacing",
            "-x-lang",
            "object-position",
            "perspective-origin",
            "grid-template-columns",
            "grid-template-rows",
            "border-image-source",
            "list-style-image",
            "grid-auto-columns",
            "grid-auto-rows",
            "column-gap",
            "row-gap",
            "grid-column-end",
            "grid-column-start",
            "grid-row-end",
            "grid-row-start",
            "max-block-size",
            "max-height",
            "max-inline-size",
            "max-width",
            "border-bottom-left-radius",
            "border-bottom-right-radius",
            "border-end-end-radius",
            "border-end-start-radius",
            "border-start-end-radius",
            "border-start-start-radius",
            "border-top-left-radius",
            "border-top-right-radius",
            "bottom",
            "inset-block-end",
            "inset-block-start",
            "inset-inline-end",
            "inset-inline-start",
            "left",
            "right",
            "top",
            "margin-block-end",
            "margin-block-start",
            "margin-bottom",
            "margin-inline-end",
            "margin-inline-start",
            "margin-left",
            "margin-right",
            "margin-top",
            "padding-block-end",
            "padding-block-start",
            "padding-bottom",
            "padding-inline-end",
            "padding-inline-start",
            "padding-left",
            "padding-right",
            "padding-top",
            "block-size",
            "height",
            "inline-size",
            "min-block-size",
            "min-height",
            "min-inline-size",
            "min-width",
            "width",
            "border-block-end-width",
            "border-block-start-width",
            "border-bottom-width",
            "border-inline-end-width",
            "border-inline-start-width",
            "border-left-width",
            "border-right-width",
            "border-top-width",
            "outline-width",
            "background-color",
            "border-block-end-color",
            "border-block-start-color",
            "border-bottom-color",
            "border-inline-end-color",
            "border-inline-start-color",
            "border-left-color",
            "border-right-color",
            "border-top-color",
            "outline-color",
            "text-decoration-color",
            "background",
            "background-position",
            "border-color",
            "border-style",
            "border-width",
            "border-top",
            "border-right",
            "border-bottom",
            "border-left",
            "border-block-start",
            "border-block-end",
            "border-inline-start",
            "border-inline-end",
            "border",
            "border-radius",
            "border-image",
            "border-block-width",
            "border-block-style",
            "border-block-color",
            "border-inline-width",
            "border-inline-style",
            "border-inline-color",
            "border-block",
            "border-inline",
            "overflow",
            "columns",
            "font",
            "font-variant",
            "white-space",
            "list-style",
            "margin",
            "margin-block",
            "margin-inline",
            "outline",
            "padding",
            "padding-block",
            "padding-inline",
            "flex-flow",
            "flex",
            "gap",
            "grid-row",
            "grid-column",
            "grid-area",
            "grid-template",
            "grid",
            "place-content",
            "place-self",
            "place-items",
            "inset",
            "inset-block",
            "inset-inline",
            "text-decoration",
            "transition",
            "animation",
            "all",
            "word-wrap",
            "grid-column-gap",
            "grid-row-gap",
            "grid-gap",
        ];
        MAP[self.0 as usize]
    }

    /// Returns whether this property is animatable.
    #[inline]
    pub fn is_animatable(self) -> bool {
        
static ANIMATABLE: NonCustomPropertyIdSet = NonCustomPropertyIdSet {
    
    storage: [0xffffc7ff, 0xfeeffcff, 0xff801c9f, 0xfffffbff, 0xffff5e0f, 0xffffffff, 0xffffffff, 0xfffb7fff, 0x1f3ffff]
};

        ANIMATABLE.contains(self)
    }

    /// Whether this property is enabled for all content right now.
    #[inline]
    pub(super) fn enabled_for_all_content(self) -> bool {
        
static EXPERIMENTAL: NonCustomPropertyIdSet = NonCustomPropertyIdSet {
    
    storage: [0x2001e00, 0x5000080, 0xa02000, 0x1983700, 0x3ccc1801, 0x0, 0x0, 0x800000, 0x7c0]
};


        
static ALWAYS_ENABLED: NonCustomPropertyIdSet = NonCustomPropertyIdSet {
    
    storage: [0xfdffe1ff, 0xfafffc7f, 0xff5fdfff, 0xfe67c8ff, 0xc33367fe, 0xffffffff, 0xffffffff, 0xff7fffff, 0x1fff83f]
};


        let passes_pref_check = || {
                static PREF_NAME: [Option<&str>; 281] = [
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.columns.enabled"),
                        
                            Some("layout.columns.enabled"),
                        
                            Some("layout.unimplemented"),
                        
                            Some("layout.container-queries.enabled"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.grid.enabled"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.writing-mode.enabled"),
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            Some("layout.columns.enabled"),
                        
                            Some("layout.container-queries.enabled"),
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.variable_fonts.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            None,
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.unimplemented"),
                        
                            Some("layout.unimplemented"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            None,
                        
                            None,
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            None,
                        
                            None,
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.columns.enabled"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            Some("layout.grid.enabled"),
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                        
                            None,
                ];
                let pref = match PREF_NAME[self.0 as usize] {
                    None => return true,
                    Some(pref) => pref,
                };

                style_config::get_bool(pref)
        };

        if ALWAYS_ENABLED.contains(self) {
            return true
        }

        if EXPERIMENTAL.contains(self) && passes_pref_check() {
            return true
        }

        false
    }

    /// Returns whether a given rule allows a given property.
    #[inline]
    pub fn allowed_in_rule(self, rule_types: CssRuleTypes) -> bool {
        debug_assert!(
            rule_types.contains(CssRuleType::Keyframe) ||
            rule_types.contains(CssRuleType::Page) ||
            rule_types.contains(CssRuleType::Style) ||
            rule_types.contains(CssRuleType::Scope) ||
            rule_types.contains(CssRuleType::PositionTry),
            "Given rule type does not allow declarations."
        );

        static MAP: [u32; property_counts::NON_CUSTOM] = [
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Page.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Page.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Page.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Page.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Page.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::PositionTry.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::PositionTry.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
            CssRuleType::Style.bit() |
            CssRuleType::Keyframe.bit() |
            CssRuleType::Scope.bit() |
            0,
        ];
        MAP[self.0 as usize] & rule_types.bits() != 0
    }

    pub(super) fn allowed_in(self, context: &ParserContext) -> bool {
        if !self.allowed_in_rule(context.rule_types()) {
            return false;
        }

        self.allowed_in_ignoring_rule_type(context)
    }


    pub(super) fn allowed_in_ignoring_rule_type(self, context: &ParserContext) -> bool {
        // The semantics of these are kinda hard to reason about, what follows
        // is a description of the different combinations that can happen with
        // these three sets.
        //
        // Experimental properties are generally controlled by prefs, but an
        // experimental property explicitly enabled in certain context (UA or
        // chrome sheets) is always usable in the context regardless of the
        // pref value.
        //
        // Non-experimental properties are either normal properties which are
        // usable everywhere, or internal-only properties which are only usable
        // in certain context they are explicitly enabled in.
        if self.enabled_for_all_content() {
            return true;
        }

        
static ENABLED_IN_UA_SHEETS: NonCustomPropertyIdSet = NonCustomPropertyIdSet {
    
    storage: [0x0, 0x4000300, 0x0, 0x0, 0x1800, 0x0, 0x0, 0x0, 0x0]
};

        
static ENABLED_IN_CHROME: NonCustomPropertyIdSet = NonCustomPropertyIdSet {
    
    storage: [0x0, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
};


        if context.stylesheet_origin == Origin::UserAgent &&
            ENABLED_IN_UA_SHEETS.contains(self)
        {
            return true
        }

        if context.chrome_rules_enabled() && ENABLED_IN_CHROME.contains(self) {
            return true
        }

        false
    }

    /// The supported types of this property. The return value should be
    /// style_traits::CssType when it can become a bitflags type.
    pub(super) fn supported_types(&self) -> u8 {
        const SUPPORTED_TYPES: [u8; 277] = [
                <crate::values::specified::ItemPlacement as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::AspectRatio as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::backface_visibility::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BaselineSource as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::border_collapse::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderImageRepeat as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::box_sizing::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::table::CaptionSide as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Clear as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ColumnCount as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::column_span::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Contain as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ContainerType as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::direction::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Display as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::empty_cells::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::flex_direction::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::flex_wrap::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Float as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontLanguageOverride as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontStretch as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontSynthesis as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::font_variant_caps::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontWeight as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridAutoFlow as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ImageRendering as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::isolation::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::JustifyItems as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::list_style_position::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::list_style_type::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::mix_blend_mode::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::object_fit::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Opacity as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Integer as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::OutlineStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::OverflowWrap as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::PointerEvents as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::PositionProperty as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::PositionArea as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::_servo_overflow_clip_box::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::_servo_top_layer::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::table_layout::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::TextAlign as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::TextAlignLast as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::TextDecorationLine as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::text_decoration_style::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::TextJustify as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::text_rendering::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::TextTransform as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::text_wrap_mode::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::TransformStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::unicode_bidi::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::visibility::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::white_space_collapse::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::WordBreak as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::WritingModeProperty as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ZIndex as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Zoom as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ContentDistribution as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ContentDistribution as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeNumber as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeNumber as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::SelfAlignment as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::SelfAlignment as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_composition::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_delay::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_direction::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_duration::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_fill_mode::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_iteration_count::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_name::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_play_state::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_timeline::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::animation_timing_function::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::backdrop_filter::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_attachment::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_clip::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_image::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_origin::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_position_x::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_position_y::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_repeat::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::background_size::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::NonNegativeLengthOrNumberRect> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderImageSlice> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderImageWidth> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderSpacing> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::box_shadow::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::ClipRectOrAuto> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::basic_shape::ClipPath as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ColorPropertyValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ColorScheme as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::length::NonNegativeLengthOrAuto as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ContainerName as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Content as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::CounterIncrement as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::CounterReset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Cursor as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::filter::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::FlexBasis> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontFamily as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontSize as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::FontVariationSettings as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridTemplateAreas as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::LetterSpacing as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::LineHeight as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::mask_image::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::OffsetPath as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideOffset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Length as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Perspective as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Quotes as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::Rotate> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::Scale> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::TextIndent as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::TextOverflow> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::text_shadow::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Transform as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::TransformOrigin> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::transition_behavior::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::transition_delay::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::transition_duration::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::transition_property::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <longhands::transition_timing_function::SpecifiedValue as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::Translate> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::VerticalAlign as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ViewTransitionClass as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ViewTransitionName as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::WillChange as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::WordSpacing as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::XLang as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::Position> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::Position> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridTemplateComponent as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridTemplateComponent as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Image as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Image as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ImplicitGridTracks as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::ImplicitGridTracks as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::length::NonNegativeLengthPercentageOrNormal as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::length::NonNegativeLengthPercentageOrNormal as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Inset as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Margin as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Size as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <crate::values::specified::Color as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::background::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::background_position::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_color::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_style::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_width::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_top::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_right::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_bottom::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_left::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_block_start::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_block_end::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_inline_start::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_inline_end::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_radius::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_image::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_block_width::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_block_style::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_block_color::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_inline_width::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_inline_style::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_inline_color::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_block::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::border_inline::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::overflow::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::columns::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::font::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::font_variant::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::white_space::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::list_style::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::margin::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::margin_block::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::margin_inline::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::outline::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::padding::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::padding_block::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::padding_inline::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::flex_flow::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::flex::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::gap::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::grid_row::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::grid_column::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::grid_area::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::grid_template::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::grid::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::place_content::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::place_self::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::place_items::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::inset::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::inset_block::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::inset_inline::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::text_decoration::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::transition::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                <shorthands::animation::Longhands as SpecifiedValueInfo>::SUPPORTED_TYPES,
                0, // 'all' accepts no value other than CSS-wide keywords
        ];
        SUPPORTED_TYPES[self.0 as usize]
    }

    /// See PropertyId::collect_property_completion_keywords.
    pub(super) fn collect_property_completion_keywords(&self, f: KeywordsCollectFn) {
        fn do_nothing(_: KeywordsCollectFn) {}
        const COLLECT_FUNCTIONS: [fn(KeywordsCollectFn);
                                  277] = [
                <crate::values::specified::ItemPlacement as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::AspectRatio as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::backface_visibility::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BaselineSource as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::border_collapse::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderImageRepeat as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::box_sizing::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::table::CaptionSide as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Clear as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ColumnCount as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::column_span::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Contain as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ContainerType as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::direction::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Display as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::empty_cells::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::flex_direction::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::flex_wrap::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Float as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontLanguageOverride as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontStretch as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontSynthesis as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::font_variant_caps::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontWeight as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridAutoFlow as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ImageRendering as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::isolation::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::JustifyItems as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::list_style_position::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::list_style_type::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::mix_blend_mode::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::object_fit::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Opacity as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Integer as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::OutlineStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::OverflowWrap as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::PointerEvents as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::PositionProperty as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::PositionArea as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::_servo_overflow_clip_box::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::_servo_top_layer::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::table_layout::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::TextAlign as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::TextAlignLast as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::TextDecorationLine as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::text_decoration_style::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::TextJustify as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::text_rendering::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::TextTransform as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::text_wrap_mode::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::TransformStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::unicode_bidi::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::visibility::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::white_space_collapse::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::WordBreak as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::WritingModeProperty as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ZIndex as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Zoom as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ContentDistribution as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ContentDistribution as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeNumber as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeNumber as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::SelfAlignment as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::SelfAlignment as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Overflow as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderStyle as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_composition::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_delay::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_direction::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_duration::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_fill_mode::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_iteration_count::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_name::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_play_state::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_timeline::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::animation_timing_function::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::backdrop_filter::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_attachment::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_clip::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_image::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_origin::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_position_x::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_position_y::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_repeat::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::background_size::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::NonNegativeLengthOrNumberRect> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderImageSlice> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderImageWidth> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderSpacing> as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::box_shadow::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::ClipRectOrAuto> as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::basic_shape::ClipPath as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ColorPropertyValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ColorScheme as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::length::NonNegativeLengthOrAuto as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ContainerName as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Content as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::CounterIncrement as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::CounterReset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Cursor as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::filter::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::FlexBasis> as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontFamily as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontSize as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::FontVariationSettings as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridTemplateAreas as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::LetterSpacing as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::LineHeight as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::mask_image::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::OffsetPath as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideOffset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Length as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Perspective as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Quotes as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::Rotate> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::Scale> as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::TextIndent as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::TextOverflow> as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::text_shadow::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Transform as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::TransformOrigin> as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::transition_behavior::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::transition_delay::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::transition_duration::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::transition_property::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <longhands::transition_timing_function::SpecifiedValue as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::Translate> as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::VerticalAlign as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ViewTransitionClass as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ViewTransitionName as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::WillChange as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::WordSpacing as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::XLang as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::Position> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::Position> as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridTemplateComponent as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridTemplateComponent as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Image as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Image as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ImplicitGridTracks as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::ImplicitGridTracks as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::length::NonNegativeLengthPercentageOrNormal as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::length::NonNegativeLengthPercentageOrNormal as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::GridLine as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::MaxSize as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <Box<crate::values::specified::BorderCornerRadius> as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Inset as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Margin as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::NonNegativeLengthPercentage as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Size as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::BorderSideWidth as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <crate::values::specified::Color as SpecifiedValueInfo>::collect_completion_keywords,
                <shorthands::background::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::background_position::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_color::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_style::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_width::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_top::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_right::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_bottom::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_left::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_block_start::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_block_end::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_inline_start::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_inline_end::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_radius::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_image::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_block_width::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_block_style::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_block_color::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_inline_width::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_inline_style::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_inline_color::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_block::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::border_inline::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::overflow::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::columns::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::font::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::font_variant::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::white_space::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::list_style::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::margin::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::margin_block::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::margin_inline::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::outline::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::padding::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::padding_block::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::padding_inline::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::flex_flow::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::flex::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::gap::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::grid_row::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::grid_column::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::grid_area::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::grid_template::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::grid::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::place_content::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::place_self::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::place_items::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::inset::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::inset_block::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::inset_inline::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::text_decoration::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::transition::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                <shorthands::animation::Longhands as SpecifiedValueInfo>::
                    collect_completion_keywords,
                do_nothing, // 'all' accepts no value other than CSS-wide keywords
        ];
        COLLECT_FUNCTIONS[self.0 as usize](f);
    }
}







/// A group for properties which may override each other via logical resolution.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
#[repr(u8)]
pub enum LogicalGroupId {
    /// overflow
    Overflow = 0,
    /// border-style
    BorderStyle = 1,
    /// max-size
    MaxSize = 2,
    /// border-radius
    BorderRadius = 3,
    /// inset
    Inset = 4,
    /// margin
    Margin = 5,
    /// padding
    Padding = 6,
    /// size
    Size = 7,
    /// min-size
    MinSize = 8,
    /// border-width
    BorderWidth = 9,
    /// border-color
    BorderColor = 10,
}

impl LogicalGroupId {
    /// Return the list of physical mapped properties for a given logical group.
    fn physical_properties(self) -> &'static [LonghandId] {
        static PROPS: [[LonghandId; 4]; 11] = [
        [
            
            LonghandId::OverflowY,
            LonghandId::OverflowX,
            LonghandId::OverflowY,
            LonghandId::OverflowY,
        ],
        [
            
            LonghandId::BorderTopStyle,
            LonghandId::BorderRightStyle,
            LonghandId::BorderBottomStyle,
            LonghandId::BorderLeftStyle,
        ],
        [
            
            LonghandId::MaxHeight,
            LonghandId::MaxWidth,
            LonghandId::MaxHeight,
            LonghandId::MaxHeight,
        ],
        [
            
            LonghandId::BorderTopLeftRadius,
            LonghandId::BorderTopRightRadius,
            LonghandId::BorderBottomRightRadius,
            LonghandId::BorderBottomLeftRadius,
        ],
        [
            
            LonghandId::Top,
            LonghandId::Right,
            LonghandId::Bottom,
            LonghandId::Left,
        ],
        [
            
            LonghandId::MarginTop,
            LonghandId::MarginRight,
            LonghandId::MarginBottom,
            LonghandId::MarginLeft,
        ],
        [
            
            LonghandId::PaddingTop,
            LonghandId::PaddingRight,
            LonghandId::PaddingBottom,
            LonghandId::PaddingLeft,
        ],
        [
            
            LonghandId::Height,
            LonghandId::Width,
            LonghandId::Height,
            LonghandId::Height,
        ],
        [
            
            LonghandId::MinHeight,
            LonghandId::MinWidth,
            LonghandId::MinHeight,
            LonghandId::MinHeight,
        ],
        [
            
            LonghandId::BorderTopWidth,
            LonghandId::BorderRightWidth,
            LonghandId::BorderBottomWidth,
            LonghandId::BorderLeftWidth,
        ],
        [
            
            LonghandId::BorderTopColor,
            LonghandId::BorderRightColor,
            LonghandId::BorderBottomColor,
            LonghandId::BorderLeftColor,
        ],
        ];
        &PROPS[self as usize]
    }
}

/// A set of logical groups.
#[derive(Clone, Copy, Debug, Default, MallocSizeOf, PartialEq)]
pub struct LogicalGroupSet {
    storage: [u32; (11 - 1 + 32) / 32]
}

impl LogicalGroupSet {
    /// Creates an empty `NonCustomPropertyIdSet`.
    pub fn new() -> Self {
        Self {
            storage: Default::default(),
        }
    }

    /// Return whether the given group is in the set
    #[inline]
    pub fn contains(&self, g: LogicalGroupId) -> bool {
        let bit = g as usize;
        (self.storage[bit / 32] & (1 << (bit % 32))) != 0
    }

    /// Insert a group the set.
    #[inline]
    pub fn insert(&mut self, g: LogicalGroupId) {
        let bit = g as usize;
        self.storage[bit / 32] |= 1 << (bit % 32);
    }
}


#[repr(u8)]
#[derive(Copy, Clone, Debug)]
pub(crate) enum PrioritaryPropertyId {
    Direction,
    FontStretch,
    FontStyle,
    FontWeight,
    WritingMode,
    Zoom,
    ColorScheme,
    FontFamily,
    FontSize,
    LineHeight,
    XLang,
}

impl PrioritaryPropertyId {
    #[inline]
    pub fn to_longhand(self) -> LonghandId {
        static PRIORITARY_TO_LONGHAND: [LonghandId; property_counts::PRIORITARY] = [
            LonghandId::Direction,
            LonghandId::FontStretch,
            LonghandId::FontStyle,
            LonghandId::FontWeight,
            LonghandId::WritingMode,
            LonghandId::Zoom,
            LonghandId::ColorScheme,
            LonghandId::FontFamily,
            LonghandId::FontSize,
            LonghandId::LineHeight,
            LonghandId::XLang,
        ];
        PRIORITARY_TO_LONGHAND[self as usize]
    }
    #[inline]
    pub fn from_longhand(l: LonghandId) -> Option<Self> {
        static LONGHAND_TO_PRIORITARY: [Option<PrioritaryPropertyId>; 222] = [
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(PrioritaryPropertyId::Direction),
            None,
            None,
            None,
            None,
            None,
            None,
            Some(PrioritaryPropertyId::FontStretch),
            Some(PrioritaryPropertyId::FontStyle),
            None,
            None,
            Some(PrioritaryPropertyId::FontWeight),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(PrioritaryPropertyId::WritingMode),
            None,
            Some(PrioritaryPropertyId::Zoom),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(PrioritaryPropertyId::ColorScheme),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(PrioritaryPropertyId::FontFamily),
            Some(PrioritaryPropertyId::FontSize),
            None,
            None,
            None,
            Some(PrioritaryPropertyId::LineHeight),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(PrioritaryPropertyId::XLang),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        ];
        LONGHAND_TO_PRIORITARY[l as usize]
    }
}

impl LonghandIdSet {
    /// The set of non-inherited longhands.
    #[inline]
    pub(super) fn reset() -> &'static Self {
        
static RESET: LonghandIdSet = LonghandIdSet {
    
    storage: [0x9a075f6f, 0xfe1867cf, 0xffffffff, 0x6f91be77, 0xffdf3ffd, 0xffffffff, 0x3fffffff]
};

        &RESET
    }

    #[inline]
    pub(super) fn discrete_animatable() -> &'static Self {
        
static DISCRETE_ANIMATABLE: LonghandIdSet = LonghandIdSet {
    
    storage: [0xfecfc5fd, 0x98cffcf9, 0x4f001c9f, 0x10927900, 0x3cf01801, 0x0, 0x0]
};

        &DISCRETE_ANIMATABLE
    }

    #[inline]
    pub(super) fn logical() -> &'static Self {
        
static LOGICAL: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x366, 0x0, 0x40000000, 0x6c6c78f1, 0x1b06cb4]
};

        &LOGICAL
    }

    /// Returns the set of longhands that are ignored when document colors are
    /// disabled.
    #[inline]
    pub(super) fn ignored_when_colors_disabled() -> &'static Self {
        
static IGNORED_WHEN_COLORS_DISABLED: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x4000000, 0x190, 0x100002, 0x0, 0x3ff80000]
};

        &IGNORED_WHEN_COLORS_DISABLED
    }

    /// Only a few properties are allowed to depend on the visited state of
    /// links. When cascading visited styles, we can save time by only
    /// processing these properties.
    pub(super) fn visited_dependent() -> &'static Self {
        
static VISITED_DEPENDENT: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x3ff80000]
};

        debug_assert!(Self::late_group().contains_all(&VISITED_DEPENDENT));
        &VISITED_DEPENDENT
    }

    #[inline]
    pub(super) fn prioritary_properties() -> &'static Self {
        
static PRIORITARY_PROPERTIES: LonghandIdSet = LonghandIdSet {
    
    storage: [0x1302000, 0x5000000, 0x0, 0x460100, 0x8000, 0x0, 0x0]
};

        &PRIORITARY_PROPERTIES
    }

    #[inline]
    pub(super) fn late_group_only_inherited() -> &'static Self {
        
static LATE_GROUP_ONLY_INHERITED: LonghandIdSet = LonghandIdSet {
    
    storage: [0x64c88090, 0xe79830, 0x0, 0x90284088, 0x204002, 0x0, 0x0]
};

        &LATE_GROUP_ONLY_INHERITED
    }

    #[inline]
    pub(super) fn late_group() -> &'static Self {
        
static LATE_GROUP: LonghandIdSet = LonghandIdSet {
    
    storage: [0xfecfdfff, 0xfaffffff, 0xffffffff, 0xffb9feff, 0xffff7fff, 0xffffffff, 0x3fffffff]
};

        &LATE_GROUP
    }

    /// Returns the set of properties that are declared as having no effect on
    /// Gecko <scrollbar> elements or their descendant scrollbar parts.
    #[cfg(debug_assertions)]
    #[cfg(feature = "gecko")]
    #[inline]
    pub fn has_no_effect_on_gecko_scrollbars() -> &'static Self {
        // data.py asserts that has_no_effect_on_gecko_scrollbars is True or
        // False for properties that are inherited and Gecko pref controlled,
        // and is None for all other properties.
        
static HAS_NO_EFFECT_ON_SCROLLBARS: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x0, 0x80000, 0x8000, 0x0, 0x0]
};

        &HAS_NO_EFFECT_ON_SCROLLBARS
    }

    /// Returns the set of margin properties, for the purposes of <h1> use counters / warnings.
    #[inline]
    pub fn margin_properties() -> &'static Self {
        
static MARGIN_PROPERTIES: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x0, 0x0, 0x0, 0x3fc0000, 0x0]
};

        &MARGIN_PROPERTIES
    }

    /// Returns the set of border properties for the purpose of disabling native
    /// appearance.
    #[inline]
    pub fn border_background_properties() -> &'static Self {
        
static BORDER_BACKGROUND_PROPERTIES: LonghandIdSet = LonghandIdSet {
    
    storage: [0x20, 0x0, 0xbf001fe0, 0x7, 0x100000, 0x3fc, 0xffbfc00]
};

        &BORDER_BACKGROUND_PROPERTIES
    }

    /// Returns properties that are zoom dependent (basically, that contain lengths).
    #[inline]
    pub fn zoom_dependent() -> &'static Self {
        
static ZOOM_DEPENDENT: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x0, 0x84640009, 0xc0034002, 0xfc03fc03, 0x3ff]
};

        &ZOOM_DEPENDENT
    }

    /// Note that it's different from zoom_dependent(), as this only includes inherited, physical
    /// properties.
    #[inline]
    pub fn zoom_dependent_inherited_properties() -> &'static Self {
        
static ZOOM_DEPENDENT_INHERITED: LonghandIdSet = LonghandIdSet {
    
    storage: [0x0, 0x0, 0x0, 0x80640008, 0x4002, 0x0, 0x0]
};

        &ZOOM_DEPENDENT_INHERITED
    }
}

/// An identifier for a given longhand property.
#[derive(Clone, Copy, Eq, Hash, MallocSizeOf, PartialEq, ToComputedValue, ToResolvedValue, ToShmem)]
#[repr(u16)]
pub enum LonghandId {
        /// align-items
        AlignItems = 0,
        /// aspect-ratio
        AspectRatio = 1,
        /// backface-visibility
        BackfaceVisibility = 2,
        /// baseline-source
        BaselineSource = 3,
        /// border-collapse
        BorderCollapse = 4,
        /// border-image-repeat
        BorderImageRepeat = 5,
        /// box-sizing
        BoxSizing = 6,
        /// caption-side
        CaptionSide = 7,
        /// clear
        Clear = 8,
        /// column-count
        ColumnCount = 9,
        /// column-span
        ColumnSpan = 10,
        /// contain
        Contain = 11,
        /// container-type
        ContainerType = 12,
        /// direction
        Direction = 13,
        /// display
        Display = 14,
        /// empty-cells
        EmptyCells = 15,
        /// flex-direction
        FlexDirection = 16,
        /// flex-wrap
        FlexWrap = 17,
        /// float
        Float = 18,
        /// font-language-override
        FontLanguageOverride = 19,
        /// font-stretch
        FontStretch = 20,
        /// font-style
        FontStyle = 21,
        /// font-synthesis-weight
        FontSynthesisWeight = 22,
        /// font-variant-caps
        FontVariantCaps = 23,
        /// font-weight
        FontWeight = 24,
        /// grid-auto-flow
        GridAutoFlow = 25,
        /// image-rendering
        ImageRendering = 26,
        /// isolation
        Isolation = 27,
        /// justify-items
        JustifyItems = 28,
        /// list-style-position
        ListStylePosition = 29,
        /// list-style-type
        ListStyleType = 30,
        /// mix-blend-mode
        MixBlendMode = 31,
        /// object-fit
        ObjectFit = 32,
        /// opacity
        Opacity = 33,
        /// order
        Order = 34,
        /// outline-style
        OutlineStyle = 35,
        /// overflow-wrap
        OverflowWrap = 36,
        /// pointer-events
        PointerEvents = 37,
        /// position
        Position = 38,
        /// position-area
        PositionArea = 39,
        /// -servo-overflow-clip-box
        ServoOverflowClipBox = 40,
        /// -servo-top-layer
        ServoTopLayer = 41,
        /// table-layout
        TableLayout = 42,
        /// text-align
        TextAlign = 43,
        /// text-align-last
        TextAlignLast = 44,
        /// text-decoration-line
        TextDecorationLine = 45,
        /// text-decoration-style
        TextDecorationStyle = 46,
        /// text-justify
        TextJustify = 47,
        /// text-rendering
        TextRendering = 48,
        /// text-transform
        TextTransform = 49,
        /// text-wrap-mode
        TextWrapMode = 50,
        /// transform-style
        TransformStyle = 51,
        /// unicode-bidi
        UnicodeBidi = 52,
        /// visibility
        Visibility = 53,
        /// white-space-collapse
        WhiteSpaceCollapse = 54,
        /// word-break
        WordBreak = 55,
        /// writing-mode
        WritingMode = 56,
        /// z-index
        ZIndex = 57,
        /// zoom
        Zoom = 58,
        /// align-content
        AlignContent = 59,
        /// justify-content
        JustifyContent = 60,
        /// flex-grow
        FlexGrow = 61,
        /// flex-shrink
        FlexShrink = 62,
        /// align-self
        AlignSelf = 63,
        /// justify-self
        JustifySelf = 64,
        /// overflow-block
        OverflowBlock = 65,
        /// overflow-inline
        OverflowInline = 66,
        /// overflow-x
        OverflowX = 67,
        /// overflow-y
        OverflowY = 68,
        /// border-block-end-style
        BorderBlockEndStyle = 69,
        /// border-block-start-style
        BorderBlockStartStyle = 70,
        /// border-bottom-style
        BorderBottomStyle = 71,
        /// border-inline-end-style
        BorderInlineEndStyle = 72,
        /// border-inline-start-style
        BorderInlineStartStyle = 73,
        /// border-left-style
        BorderLeftStyle = 74,
        /// border-right-style
        BorderRightStyle = 75,
        /// border-top-style
        BorderTopStyle = 76,
        /// animation-composition
        AnimationComposition = 77,
        /// animation-delay
        AnimationDelay = 78,
        /// animation-direction
        AnimationDirection = 79,
        /// animation-duration
        AnimationDuration = 80,
        /// animation-fill-mode
        AnimationFillMode = 81,
        /// animation-iteration-count
        AnimationIterationCount = 82,
        /// animation-name
        AnimationName = 83,
        /// animation-play-state
        AnimationPlayState = 84,
        /// animation-timeline
        AnimationTimeline = 85,
        /// animation-timing-function
        AnimationTimingFunction = 86,
        /// backdrop-filter
        BackdropFilter = 87,
        /// background-attachment
        BackgroundAttachment = 88,
        /// background-clip
        BackgroundClip = 89,
        /// background-image
        BackgroundImage = 90,
        /// background-origin
        BackgroundOrigin = 91,
        /// background-position-x
        BackgroundPositionX = 92,
        /// background-position-y
        BackgroundPositionY = 93,
        /// background-repeat
        BackgroundRepeat = 94,
        /// background-size
        BackgroundSize = 95,
        /// border-image-outset
        BorderImageOutset = 96,
        /// border-image-slice
        BorderImageSlice = 97,
        /// border-image-width
        BorderImageWidth = 98,
        /// border-spacing
        BorderSpacing = 99,
        /// box-shadow
        BoxShadow = 100,
        /// clip
        Clip = 101,
        /// clip-path
        ClipPath = 102,
        /// color
        Color = 103,
        /// color-scheme
        ColorScheme = 104,
        /// column-width
        ColumnWidth = 105,
        /// container-name
        ContainerName = 106,
        /// content
        Content = 107,
        /// counter-increment
        CounterIncrement = 108,
        /// counter-reset
        CounterReset = 109,
        /// cursor
        Cursor = 110,
        /// filter
        Filter = 111,
        /// flex-basis
        FlexBasis = 112,
        /// font-family
        FontFamily = 113,
        /// font-size
        FontSize = 114,
        /// font-variation-settings
        FontVariationSettings = 115,
        /// grid-template-areas
        GridTemplateAreas = 116,
        /// letter-spacing
        LetterSpacing = 117,
        /// line-height
        LineHeight = 118,
        /// mask-image
        MaskImage = 119,
        /// offset-path
        OffsetPath = 120,
        /// outline-offset
        OutlineOffset = 121,
        /// overflow-clip-margin
        OverflowClipMargin = 122,
        /// perspective
        Perspective = 123,
        /// quotes
        Quotes = 124,
        /// rotate
        Rotate = 125,
        /// scale
        Scale = 126,
        /// text-indent
        TextIndent = 127,
        /// text-overflow
        TextOverflow = 128,
        /// text-shadow
        TextShadow = 129,
        /// transform
        Transform = 130,
        /// transform-origin
        TransformOrigin = 131,
        /// transition-behavior
        TransitionBehavior = 132,
        /// transition-delay
        TransitionDelay = 133,
        /// transition-duration
        TransitionDuration = 134,
        /// transition-property
        TransitionProperty = 135,
        /// transition-timing-function
        TransitionTimingFunction = 136,
        /// translate
        Translate = 137,
        /// vertical-align
        VerticalAlign = 138,
        /// view-transition-class
        ViewTransitionClass = 139,
        /// view-transition-name
        ViewTransitionName = 140,
        /// will-change
        WillChange = 141,
        /// word-spacing
        WordSpacing = 142,
        /// -x-lang
        XLang = 143,
        /// object-position
        ObjectPosition = 144,
        /// perspective-origin
        PerspectiveOrigin = 145,
        /// grid-template-columns
        GridTemplateColumns = 146,
        /// grid-template-rows
        GridTemplateRows = 147,
        /// border-image-source
        BorderImageSource = 148,
        /// list-style-image
        ListStyleImage = 149,
        /// grid-auto-columns
        GridAutoColumns = 150,
        /// grid-auto-rows
        GridAutoRows = 151,
        /// column-gap
        ColumnGap = 152,
        /// row-gap
        RowGap = 153,
        /// grid-column-end
        GridColumnEnd = 154,
        /// grid-column-start
        GridColumnStart = 155,
        /// grid-row-end
        GridRowEnd = 156,
        /// grid-row-start
        GridRowStart = 157,
        /// max-block-size
        MaxBlockSize = 158,
        /// max-height
        MaxHeight = 159,
        /// max-inline-size
        MaxInlineSize = 160,
        /// max-width
        MaxWidth = 161,
        /// border-bottom-left-radius
        BorderBottomLeftRadius = 162,
        /// border-bottom-right-radius
        BorderBottomRightRadius = 163,
        /// border-end-end-radius
        BorderEndEndRadius = 164,
        /// border-end-start-radius
        BorderEndStartRadius = 165,
        /// border-start-end-radius
        BorderStartEndRadius = 166,
        /// border-start-start-radius
        BorderStartStartRadius = 167,
        /// border-top-left-radius
        BorderTopLeftRadius = 168,
        /// border-top-right-radius
        BorderTopRightRadius = 169,
        /// bottom
        Bottom = 170,
        /// inset-block-end
        InsetBlockEnd = 171,
        /// inset-block-start
        InsetBlockStart = 172,
        /// inset-inline-end
        InsetInlineEnd = 173,
        /// inset-inline-start
        InsetInlineStart = 174,
        /// left
        Left = 175,
        /// right
        Right = 176,
        /// top
        Top = 177,
        /// margin-block-end
        MarginBlockEnd = 178,
        /// margin-block-start
        MarginBlockStart = 179,
        /// margin-bottom
        MarginBottom = 180,
        /// margin-inline-end
        MarginInlineEnd = 181,
        /// margin-inline-start
        MarginInlineStart = 182,
        /// margin-left
        MarginLeft = 183,
        /// margin-right
        MarginRight = 184,
        /// margin-top
        MarginTop = 185,
        /// padding-block-end
        PaddingBlockEnd = 186,
        /// padding-block-start
        PaddingBlockStart = 187,
        /// padding-bottom
        PaddingBottom = 188,
        /// padding-inline-end
        PaddingInlineEnd = 189,
        /// padding-inline-start
        PaddingInlineStart = 190,
        /// padding-left
        PaddingLeft = 191,
        /// padding-right
        PaddingRight = 192,
        /// padding-top
        PaddingTop = 193,
        /// block-size
        BlockSize = 194,
        /// height
        Height = 195,
        /// inline-size
        InlineSize = 196,
        /// min-block-size
        MinBlockSize = 197,
        /// min-height
        MinHeight = 198,
        /// min-inline-size
        MinInlineSize = 199,
        /// min-width
        MinWidth = 200,
        /// width
        Width = 201,
        /// border-block-end-width
        BorderBlockEndWidth = 202,
        /// border-block-start-width
        BorderBlockStartWidth = 203,
        /// border-bottom-width
        BorderBottomWidth = 204,
        /// border-inline-end-width
        BorderInlineEndWidth = 205,
        /// border-inline-start-width
        BorderInlineStartWidth = 206,
        /// border-left-width
        BorderLeftWidth = 207,
        /// border-right-width
        BorderRightWidth = 208,
        /// border-top-width
        BorderTopWidth = 209,
        /// outline-width
        OutlineWidth = 210,
        /// background-color
        BackgroundColor = 211,
        /// border-block-end-color
        BorderBlockEndColor = 212,
        /// border-block-start-color
        BorderBlockStartColor = 213,
        /// border-bottom-color
        BorderBottomColor = 214,
        /// border-inline-end-color
        BorderInlineEndColor = 215,
        /// border-inline-start-color
        BorderInlineStartColor = 216,
        /// border-left-color
        BorderLeftColor = 217,
        /// border-right-color
        BorderRightColor = 218,
        /// border-top-color
        BorderTopColor = 219,
        /// outline-color
        OutlineColor = 220,
        /// text-decoration-color
        TextDecorationColor = 221,
}

enum LogicalMappingKind {
    Side(LogicalSide),
    Corner(LogicalCorner),
    Axis(LogicalAxis),
}

struct LogicalMappingData {
    group: LogicalGroupId,
    kind: LogicalMappingKind,
}

impl LogicalMappingData {
    fn to_physical(&self, wm: WritingMode) -> LonghandId {
        let index = match self.kind {
            LogicalMappingKind::Side(s) => s.to_physical(wm) as usize,
            LogicalMappingKind::Corner(c) => c.to_physical(wm) as usize,
            LogicalMappingKind::Axis(a) => a.to_physical(wm) as usize,
        };
        self.group.physical_properties()[index]
    }
}

impl LonghandId {
    /// Returns an iterator over all the shorthands that include this longhand.
    pub fn shorthands(self) -> NonCustomPropertyIterator<ShorthandId> {
        // first generate longhand to shorthands lookup map
        //
        // NOTE(emilio): This currently doesn't exclude the "all" shorthand. It
        // could potentially do so, which would speed up serialization
        // algorithms and what not, I guess.
        

        // based on lookup results for each longhand, create result arrays
        static MAP: [&'static [ShorthandId]; property_counts::LONGHANDS] = [
            &[
                    ShorthandId::All,
                    ShorthandId::PlaceItems,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderImage,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Columns,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::FlexFlow,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::FlexFlow,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Font,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Font,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Font,
                    ShorthandId::FontVariant,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Font,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Grid,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PlaceItems,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::ListStyle,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::ListStyle,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Outline,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
            ],
            &[
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::TextDecoration,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::TextDecoration,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::WhiteSpace,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::WhiteSpace,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PlaceContent,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PlaceContent,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Flex,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Flex,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PlaceSelf,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PlaceSelf,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Overflow,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Overflow,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderBlock,
                    ShorthandId::BorderBlockEnd,
                    ShorthandId::BorderBlockStyle,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderBlock,
                    ShorthandId::BorderBlockStart,
                    ShorthandId::BorderBlockStyle,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderStyle,
                    ShorthandId::BorderBottom,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderInline,
                    ShorthandId::BorderInlineEnd,
                    ShorthandId::BorderInlineStyle,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderInline,
                    ShorthandId::BorderInlineStart,
                    ShorthandId::BorderInlineStyle,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderStyle,
                    ShorthandId::BorderLeft,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderStyle,
                    ShorthandId::BorderRight,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderStyle,
                    ShorthandId::BorderTop,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Animation,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
                    ShorthandId::BackgroundPosition,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
                    ShorthandId::BackgroundPosition,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderImage,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderImage,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderImage,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Columns,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Flex,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Font,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Font,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Grid,
                    ShorthandId::GridTemplate,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Font,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Transition,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Transition,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Transition,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Transition,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Transition,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Grid,
                    ShorthandId::GridTemplate,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Grid,
                    ShorthandId::GridTemplate,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderImage,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::ListStyle,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Grid,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Grid,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Gap,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Gap,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::GridArea,
                    ShorthandId::GridColumn,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::GridArea,
                    ShorthandId::GridColumn,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::GridArea,
                    ShorthandId::GridRow,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::GridArea,
                    ShorthandId::GridRow,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderRadius,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderRadius,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderRadius,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderRadius,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Inset,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::InsetBlock,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::InsetBlock,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::InsetInline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::InsetInline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Inset,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Inset,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Inset,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::MarginBlock,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::MarginBlock,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Margin,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::MarginInline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::MarginInline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Margin,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Margin,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Margin,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PaddingBlock,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PaddingBlock,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Padding,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PaddingInline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::PaddingInline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Padding,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Padding,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Padding,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderBlock,
                    ShorthandId::BorderBlockEnd,
                    ShorthandId::BorderBlockWidth,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderBlock,
                    ShorthandId::BorderBlockStart,
                    ShorthandId::BorderBlockWidth,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderWidth,
                    ShorthandId::BorderBottom,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderInline,
                    ShorthandId::BorderInlineEnd,
                    ShorthandId::BorderInlineWidth,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderInline,
                    ShorthandId::BorderInlineStart,
                    ShorthandId::BorderInlineWidth,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderWidth,
                    ShorthandId::BorderLeft,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderWidth,
                    ShorthandId::BorderRight,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderWidth,
                    ShorthandId::BorderTop,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Outline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Background,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderBlock,
                    ShorthandId::BorderBlockEnd,
                    ShorthandId::BorderBlockColor,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderBlock,
                    ShorthandId::BorderBlockStart,
                    ShorthandId::BorderBlockColor,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderColor,
                    ShorthandId::BorderBottom,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderInline,
                    ShorthandId::BorderInlineEnd,
                    ShorthandId::BorderInlineColor,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::BorderInline,
                    ShorthandId::BorderInlineStart,
                    ShorthandId::BorderInlineColor,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderColor,
                    ShorthandId::BorderLeft,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderColor,
                    ShorthandId::BorderRight,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Border,
                    ShorthandId::BorderColor,
                    ShorthandId::BorderTop,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::Outline,
            ],
            &[
                    ShorthandId::All,
                    ShorthandId::TextDecoration,
            ],
        ];

        NonCustomPropertyIterator {
            filter: NonCustomPropertyId::from(self).enabled_for_all_content(),
            iter: MAP[self as usize].iter(),
        }
    }

    pub(super) fn parse_value<'i, 't>(
        self,
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<PropertyDeclaration, ParseError<'i>> {
        type ParsePropertyFn = for<'i, 't> fn(
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<PropertyDeclaration, ParseError<'i>>;
        static PARSE_PROPERTY: [ParsePropertyFn; 222] = [
            longhands::align_items::parse_declared,
            longhands::aspect_ratio::parse_declared,
            longhands::backface_visibility::parse_declared,
            longhands::baseline_source::parse_declared,
            longhands::border_collapse::parse_declared,
            longhands::border_image_repeat::parse_declared,
            longhands::box_sizing::parse_declared,
            longhands::caption_side::parse_declared,
            longhands::clear::parse_declared,
            longhands::column_count::parse_declared,
            longhands::column_span::parse_declared,
            longhands::contain::parse_declared,
            longhands::container_type::parse_declared,
            longhands::direction::parse_declared,
            longhands::display::parse_declared,
            longhands::empty_cells::parse_declared,
            longhands::flex_direction::parse_declared,
            longhands::flex_wrap::parse_declared,
            longhands::float::parse_declared,
            longhands::font_language_override::parse_declared,
            longhands::font_stretch::parse_declared,
            longhands::font_style::parse_declared,
            longhands::font_synthesis_weight::parse_declared,
            longhands::font_variant_caps::parse_declared,
            longhands::font_weight::parse_declared,
            longhands::grid_auto_flow::parse_declared,
            longhands::image_rendering::parse_declared,
            longhands::isolation::parse_declared,
            longhands::justify_items::parse_declared,
            longhands::list_style_position::parse_declared,
            longhands::list_style_type::parse_declared,
            longhands::mix_blend_mode::parse_declared,
            longhands::object_fit::parse_declared,
            longhands::opacity::parse_declared,
            longhands::order::parse_declared,
            longhands::outline_style::parse_declared,
            longhands::overflow_wrap::parse_declared,
            longhands::pointer_events::parse_declared,
            longhands::position::parse_declared,
            longhands::position_area::parse_declared,
            longhands::_servo_overflow_clip_box::parse_declared,
            longhands::_servo_top_layer::parse_declared,
            longhands::table_layout::parse_declared,
            longhands::text_align::parse_declared,
            longhands::text_align_last::parse_declared,
            longhands::text_decoration_line::parse_declared,
            longhands::text_decoration_style::parse_declared,
            longhands::text_justify::parse_declared,
            longhands::text_rendering::parse_declared,
            longhands::text_transform::parse_declared,
            longhands::text_wrap_mode::parse_declared,
            longhands::transform_style::parse_declared,
            longhands::unicode_bidi::parse_declared,
            longhands::visibility::parse_declared,
            longhands::white_space_collapse::parse_declared,
            longhands::word_break::parse_declared,
            longhands::writing_mode::parse_declared,
            longhands::z_index::parse_declared,
            longhands::zoom::parse_declared,
            longhands::align_content::parse_declared,
            longhands::justify_content::parse_declared,
            longhands::flex_grow::parse_declared,
            longhands::flex_shrink::parse_declared,
            longhands::align_self::parse_declared,
            longhands::justify_self::parse_declared,
            longhands::overflow_block::parse_declared,
            longhands::overflow_inline::parse_declared,
            longhands::overflow_x::parse_declared,
            longhands::overflow_y::parse_declared,
            longhands::border_block_end_style::parse_declared,
            longhands::border_block_start_style::parse_declared,
            longhands::border_bottom_style::parse_declared,
            longhands::border_inline_end_style::parse_declared,
            longhands::border_inline_start_style::parse_declared,
            longhands::border_left_style::parse_declared,
            longhands::border_right_style::parse_declared,
            longhands::border_top_style::parse_declared,
            longhands::animation_composition::parse_declared,
            longhands::animation_delay::parse_declared,
            longhands::animation_direction::parse_declared,
            longhands::animation_duration::parse_declared,
            longhands::animation_fill_mode::parse_declared,
            longhands::animation_iteration_count::parse_declared,
            longhands::animation_name::parse_declared,
            longhands::animation_play_state::parse_declared,
            longhands::animation_timeline::parse_declared,
            longhands::animation_timing_function::parse_declared,
            longhands::backdrop_filter::parse_declared,
            longhands::background_attachment::parse_declared,
            longhands::background_clip::parse_declared,
            longhands::background_image::parse_declared,
            longhands::background_origin::parse_declared,
            longhands::background_position_x::parse_declared,
            longhands::background_position_y::parse_declared,
            longhands::background_repeat::parse_declared,
            longhands::background_size::parse_declared,
            longhands::border_image_outset::parse_declared,
            longhands::border_image_slice::parse_declared,
            longhands::border_image_width::parse_declared,
            longhands::border_spacing::parse_declared,
            longhands::box_shadow::parse_declared,
            longhands::clip::parse_declared,
            longhands::clip_path::parse_declared,
            longhands::color::parse_declared,
            longhands::color_scheme::parse_declared,
            longhands::column_width::parse_declared,
            longhands::container_name::parse_declared,
            longhands::content::parse_declared,
            longhands::counter_increment::parse_declared,
            longhands::counter_reset::parse_declared,
            longhands::cursor::parse_declared,
            longhands::filter::parse_declared,
            longhands::flex_basis::parse_declared,
            longhands::font_family::parse_declared,
            longhands::font_size::parse_declared,
            longhands::font_variation_settings::parse_declared,
            longhands::grid_template_areas::parse_declared,
            longhands::letter_spacing::parse_declared,
            longhands::line_height::parse_declared,
            longhands::mask_image::parse_declared,
            longhands::offset_path::parse_declared,
            longhands::outline_offset::parse_declared,
            longhands::overflow_clip_margin::parse_declared,
            longhands::perspective::parse_declared,
            longhands::quotes::parse_declared,
            longhands::rotate::parse_declared,
            longhands::scale::parse_declared,
            longhands::text_indent::parse_declared,
            longhands::text_overflow::parse_declared,
            longhands::text_shadow::parse_declared,
            longhands::transform::parse_declared,
            longhands::transform_origin::parse_declared,
            longhands::transition_behavior::parse_declared,
            longhands::transition_delay::parse_declared,
            longhands::transition_duration::parse_declared,
            longhands::transition_property::parse_declared,
            longhands::transition_timing_function::parse_declared,
            longhands::translate::parse_declared,
            longhands::vertical_align::parse_declared,
            longhands::view_transition_class::parse_declared,
            longhands::view_transition_name::parse_declared,
            longhands::will_change::parse_declared,
            longhands::word_spacing::parse_declared,
            longhands::_x_lang::parse_declared,
            longhands::object_position::parse_declared,
            longhands::perspective_origin::parse_declared,
            longhands::grid_template_columns::parse_declared,
            longhands::grid_template_rows::parse_declared,
            longhands::border_image_source::parse_declared,
            longhands::list_style_image::parse_declared,
            longhands::grid_auto_columns::parse_declared,
            longhands::grid_auto_rows::parse_declared,
            longhands::column_gap::parse_declared,
            longhands::row_gap::parse_declared,
            longhands::grid_column_end::parse_declared,
            longhands::grid_column_start::parse_declared,
            longhands::grid_row_end::parse_declared,
            longhands::grid_row_start::parse_declared,
            longhands::max_block_size::parse_declared,
            longhands::max_height::parse_declared,
            longhands::max_inline_size::parse_declared,
            longhands::max_width::parse_declared,
            longhands::border_bottom_left_radius::parse_declared,
            longhands::border_bottom_right_radius::parse_declared,
            longhands::border_end_end_radius::parse_declared,
            longhands::border_end_start_radius::parse_declared,
            longhands::border_start_end_radius::parse_declared,
            longhands::border_start_start_radius::parse_declared,
            longhands::border_top_left_radius::parse_declared,
            longhands::border_top_right_radius::parse_declared,
            longhands::bottom::parse_declared,
            longhands::inset_block_end::parse_declared,
            longhands::inset_block_start::parse_declared,
            longhands::inset_inline_end::parse_declared,
            longhands::inset_inline_start::parse_declared,
            longhands::left::parse_declared,
            longhands::right::parse_declared,
            longhands::top::parse_declared,
            longhands::margin_block_end::parse_declared,
            longhands::margin_block_start::parse_declared,
            longhands::margin_bottom::parse_declared,
            longhands::margin_inline_end::parse_declared,
            longhands::margin_inline_start::parse_declared,
            longhands::margin_left::parse_declared,
            longhands::margin_right::parse_declared,
            longhands::margin_top::parse_declared,
            longhands::padding_block_end::parse_declared,
            longhands::padding_block_start::parse_declared,
            longhands::padding_bottom::parse_declared,
            longhands::padding_inline_end::parse_declared,
            longhands::padding_inline_start::parse_declared,
            longhands::padding_left::parse_declared,
            longhands::padding_right::parse_declared,
            longhands::padding_top::parse_declared,
            longhands::block_size::parse_declared,
            longhands::height::parse_declared,
            longhands::inline_size::parse_declared,
            longhands::min_block_size::parse_declared,
            longhands::min_height::parse_declared,
            longhands::min_inline_size::parse_declared,
            longhands::min_width::parse_declared,
            longhands::width::parse_declared,
            longhands::border_block_end_width::parse_declared,
            longhands::border_block_start_width::parse_declared,
            longhands::border_bottom_width::parse_declared,
            longhands::border_inline_end_width::parse_declared,
            longhands::border_inline_start_width::parse_declared,
            longhands::border_left_width::parse_declared,
            longhands::border_right_width::parse_declared,
            longhands::border_top_width::parse_declared,
            longhands::outline_width::parse_declared,
            longhands::background_color::parse_declared,
            longhands::border_block_end_color::parse_declared,
            longhands::border_block_start_color::parse_declared,
            longhands::border_bottom_color::parse_declared,
            longhands::border_inline_end_color::parse_declared,
            longhands::border_inline_start_color::parse_declared,
            longhands::border_left_color::parse_declared,
            longhands::border_right_color::parse_declared,
            longhands::border_top_color::parse_declared,
            longhands::outline_color::parse_declared,
            longhands::text_decoration_color::parse_declared,
        ];
        (PARSE_PROPERTY[self as usize])(context, input)
    }

    /// Return the relevant data to map a particular logical property into physical.
    fn logical_mapping_data(self) -> Option<&'static LogicalMappingData> {
        const LOGICAL_MAPPING_DATA: [Option<LogicalMappingData>; 222] = [
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Overflow,
                kind: LogicalMappingKind::Axis(LogicalAxis::Block)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Overflow,
                kind: LogicalMappingKind::Axis(LogicalAxis::Inline)
            }),
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderStyle,
                kind: LogicalMappingKind::Side(LogicalSide::BlockEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderStyle,
                kind: LogicalMappingKind::Side(LogicalSide::BlockStart)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderStyle,
                kind: LogicalMappingKind::Side(LogicalSide::InlineEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderStyle,
                kind: LogicalMappingKind::Side(LogicalSide::InlineStart)
            }),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::MaxSize,
                kind: LogicalMappingKind::Axis(LogicalAxis::Block)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::MaxSize,
                kind: LogicalMappingKind::Axis(LogicalAxis::Inline)
            }),
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderRadius,
                kind: LogicalMappingKind::Corner(LogicalCorner::EndEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderRadius,
                kind: LogicalMappingKind::Corner(LogicalCorner::EndStart)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderRadius,
                kind: LogicalMappingKind::Corner(LogicalCorner::StartEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderRadius,
                kind: LogicalMappingKind::Corner(LogicalCorner::StartStart)
            }),
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Inset,
                kind: LogicalMappingKind::Side(LogicalSide::BlockEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Inset,
                kind: LogicalMappingKind::Side(LogicalSide::BlockStart)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Inset,
                kind: LogicalMappingKind::Side(LogicalSide::InlineEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Inset,
                kind: LogicalMappingKind::Side(LogicalSide::InlineStart)
            }),
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Margin,
                kind: LogicalMappingKind::Side(LogicalSide::BlockEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Margin,
                kind: LogicalMappingKind::Side(LogicalSide::BlockStart)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Margin,
                kind: LogicalMappingKind::Side(LogicalSide::InlineEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Margin,
                kind: LogicalMappingKind::Side(LogicalSide::InlineStart)
            }),
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Padding,
                kind: LogicalMappingKind::Side(LogicalSide::BlockEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Padding,
                kind: LogicalMappingKind::Side(LogicalSide::BlockStart)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Padding,
                kind: LogicalMappingKind::Side(LogicalSide::InlineEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::Padding,
                kind: LogicalMappingKind::Side(LogicalSide::InlineStart)
            }),
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Size,
                kind: LogicalMappingKind::Axis(LogicalAxis::Block)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::Size,
                kind: LogicalMappingKind::Axis(LogicalAxis::Inline)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::MinSize,
                kind: LogicalMappingKind::Axis(LogicalAxis::Block)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::MinSize,
                kind: LogicalMappingKind::Axis(LogicalAxis::Inline)
            }),
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderWidth,
                kind: LogicalMappingKind::Side(LogicalSide::BlockEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderWidth,
                kind: LogicalMappingKind::Side(LogicalSide::BlockStart)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderWidth,
                kind: LogicalMappingKind::Side(LogicalSide::InlineEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderWidth,
                kind: LogicalMappingKind::Side(LogicalSide::InlineStart)
            }),
            None,
            None,
            None,
            None,
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderColor,
                kind: LogicalMappingKind::Side(LogicalSide::BlockEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderColor,
                kind: LogicalMappingKind::Side(LogicalSide::BlockStart)
            }),
            None,
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderColor,
                kind: LogicalMappingKind::Side(LogicalSide::InlineEnd)
            }),
            Some(LogicalMappingData {
                group: LogicalGroupId::BorderColor,
                kind: LogicalMappingKind::Side(LogicalSide::InlineStart)
            }),
            None,
            None,
            None,
            None,
            None,
        ];
        LOGICAL_MAPPING_DATA[self as usize].as_ref()
    }

    /// If this is a logical property, return the corresponding physical one in the given
    /// writing mode. Otherwise, return unchanged.
    #[inline]
    pub fn to_physical(self, wm: WritingMode) -> Self {
        let Some(data) = self.logical_mapping_data() else { return self };
        data.to_physical(wm)
    }

    /// Return the logical group of this longhand property.
    pub fn logical_group(self) -> Option<LogicalGroupId> {
        const LOGICAL_GROUP_IDS: [Option<LogicalGroupId>; 222] = [
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(LogicalGroupId::Overflow),
            Some(LogicalGroupId::Overflow),
            Some(LogicalGroupId::Overflow),
            Some(LogicalGroupId::Overflow),
            Some(LogicalGroupId::BorderStyle),
            Some(LogicalGroupId::BorderStyle),
            Some(LogicalGroupId::BorderStyle),
            Some(LogicalGroupId::BorderStyle),
            Some(LogicalGroupId::BorderStyle),
            Some(LogicalGroupId::BorderStyle),
            Some(LogicalGroupId::BorderStyle),
            Some(LogicalGroupId::BorderStyle),
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            Some(LogicalGroupId::MaxSize),
            Some(LogicalGroupId::MaxSize),
            Some(LogicalGroupId::MaxSize),
            Some(LogicalGroupId::MaxSize),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::BorderRadius),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Inset),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Margin),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Padding),
            Some(LogicalGroupId::Size),
            Some(LogicalGroupId::Size),
            Some(LogicalGroupId::Size),
            Some(LogicalGroupId::MinSize),
            Some(LogicalGroupId::MinSize),
            Some(LogicalGroupId::MinSize),
            Some(LogicalGroupId::MinSize),
            Some(LogicalGroupId::Size),
            Some(LogicalGroupId::BorderWidth),
            Some(LogicalGroupId::BorderWidth),
            Some(LogicalGroupId::BorderWidth),
            Some(LogicalGroupId::BorderWidth),
            Some(LogicalGroupId::BorderWidth),
            Some(LogicalGroupId::BorderWidth),
            Some(LogicalGroupId::BorderWidth),
            Some(LogicalGroupId::BorderWidth),
            None,
            None,
            Some(LogicalGroupId::BorderColor),
            Some(LogicalGroupId::BorderColor),
            Some(LogicalGroupId::BorderColor),
            Some(LogicalGroupId::BorderColor),
            Some(LogicalGroupId::BorderColor),
            Some(LogicalGroupId::BorderColor),
            Some(LogicalGroupId::BorderColor),
            Some(LogicalGroupId::BorderColor),
            None,
            None,
        ];
        LOGICAL_GROUP_IDS[self as usize]
    }

    /// Returns PropertyFlags for given longhand property.
    #[inline(always)]
    pub fn flags(self) -> PropertyFlags {
        const FLAGS: [PropertyFlags; 222] = [
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::CAN_ANIMATE_ON_COMPOSITOR)
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::CAN_ANIMATE_ON_COMPOSITOR)
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::CAN_ANIMATE_ON_COMPOSITOR)
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::CAN_ANIMATE_ON_COMPOSITOR)
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::CAN_ANIMATE_ON_COMPOSITOR)
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::APPLIES_TO_MARKER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::CAN_ANIMATE_ON_COMPOSITOR)
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                ,
                PropertyFlags::empty()
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_LAYOUT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_OVERFLOW)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::CAN_ANIMATE_ON_COMPOSITOR)
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
                PropertyFlags::empty()
                    .union(PropertyFlags::AFFECTS_PAINT)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LINE)
                    .union(PropertyFlags::APPLIES_TO_FIRST_LETTER)
                    .union(PropertyFlags::APPLIES_TO_PLACEHOLDER)
                    .union(PropertyFlags::APPLIES_TO_CUE)
                ,
        ];
        FLAGS[self as usize]
    }
}

/// An identifier for a given shorthand property.
#[derive(Clone, Copy, Debug, Eq, Hash, MallocSizeOf, PartialEq, ToComputedValue, ToResolvedValue, ToShmem)]
#[repr(u16)]
pub enum ShorthandId {
        /// background
        Background = 0,
        /// background-position
        BackgroundPosition = 1,
        /// border-color
        BorderColor = 2,
        /// border-style
        BorderStyle = 3,
        /// border-width
        BorderWidth = 4,
        /// border-top
        BorderTop = 5,
        /// border-right
        BorderRight = 6,
        /// border-bottom
        BorderBottom = 7,
        /// border-left
        BorderLeft = 8,
        /// border-block-start
        BorderBlockStart = 9,
        /// border-block-end
        BorderBlockEnd = 10,
        /// border-inline-start
        BorderInlineStart = 11,
        /// border-inline-end
        BorderInlineEnd = 12,
        /// border
        Border = 13,
        /// border-radius
        BorderRadius = 14,
        /// border-image
        BorderImage = 15,
        /// border-block-width
        BorderBlockWidth = 16,
        /// border-block-style
        BorderBlockStyle = 17,
        /// border-block-color
        BorderBlockColor = 18,
        /// border-inline-width
        BorderInlineWidth = 19,
        /// border-inline-style
        BorderInlineStyle = 20,
        /// border-inline-color
        BorderInlineColor = 21,
        /// border-block
        BorderBlock = 22,
        /// border-inline
        BorderInline = 23,
        /// overflow
        Overflow = 24,
        /// columns
        Columns = 25,
        /// font
        Font = 26,
        /// font-variant
        FontVariant = 27,
        /// white-space
        WhiteSpace = 28,
        /// list-style
        ListStyle = 29,
        /// margin
        Margin = 30,
        /// margin-block
        MarginBlock = 31,
        /// margin-inline
        MarginInline = 32,
        /// outline
        Outline = 33,
        /// padding
        Padding = 34,
        /// padding-block
        PaddingBlock = 35,
        /// padding-inline
        PaddingInline = 36,
        /// flex-flow
        FlexFlow = 37,
        /// flex
        Flex = 38,
        /// gap
        Gap = 39,
        /// grid-row
        GridRow = 40,
        /// grid-column
        GridColumn = 41,
        /// grid-area
        GridArea = 42,
        /// grid-template
        GridTemplate = 43,
        /// grid
        Grid = 44,
        /// place-content
        PlaceContent = 45,
        /// place-self
        PlaceSelf = 46,
        /// place-items
        PlaceItems = 47,
        /// inset
        Inset = 48,
        /// inset-block
        InsetBlock = 49,
        /// inset-inline
        InsetInline = 50,
        /// text-decoration
        TextDecoration = 51,
        /// transition
        Transition = 52,
        /// animation
        Animation = 53,
        /// all
        All = 54,
}

impl ShorthandId {
    /// Get the longhand ids that form this shorthand.
    pub fn longhands(self) -> NonCustomPropertyIterator<LonghandId> {
        static MAP: [&'static [LonghandId]; property_counts::SHORTHANDS] = [
            &[
                    LonghandId::BackgroundColor,
                    LonghandId::BackgroundPositionX,
                    LonghandId::BackgroundPositionY,
                    LonghandId::BackgroundRepeat,
                    LonghandId::BackgroundAttachment,
                    LonghandId::BackgroundImage,
                    LonghandId::BackgroundSize,
                    LonghandId::BackgroundOrigin,
                    LonghandId::BackgroundClip,
            ],
            &[
                    LonghandId::BackgroundPositionX,
                    LonghandId::BackgroundPositionY,
            ],
            &[
                    LonghandId::BorderTopColor,
                    LonghandId::BorderRightColor,
                    LonghandId::BorderBottomColor,
                    LonghandId::BorderLeftColor,
            ],
            &[
                    LonghandId::BorderTopStyle,
                    LonghandId::BorderRightStyle,
                    LonghandId::BorderBottomStyle,
                    LonghandId::BorderLeftStyle,
            ],
            &[
                    LonghandId::BorderTopWidth,
                    LonghandId::BorderRightWidth,
                    LonghandId::BorderBottomWidth,
                    LonghandId::BorderLeftWidth,
            ],
            &[
                    LonghandId::BorderTopWidth,
                    LonghandId::BorderTopStyle,
                    LonghandId::BorderTopColor,
            ],
            &[
                    LonghandId::BorderRightWidth,
                    LonghandId::BorderRightStyle,
                    LonghandId::BorderRightColor,
            ],
            &[
                    LonghandId::BorderBottomWidth,
                    LonghandId::BorderBottomStyle,
                    LonghandId::BorderBottomColor,
            ],
            &[
                    LonghandId::BorderLeftWidth,
                    LonghandId::BorderLeftStyle,
                    LonghandId::BorderLeftColor,
            ],
            &[
                    LonghandId::BorderBlockStartWidth,
                    LonghandId::BorderBlockStartStyle,
                    LonghandId::BorderBlockStartColor,
            ],
            &[
                    LonghandId::BorderBlockEndWidth,
                    LonghandId::BorderBlockEndStyle,
                    LonghandId::BorderBlockEndColor,
            ],
            &[
                    LonghandId::BorderInlineStartWidth,
                    LonghandId::BorderInlineStartStyle,
                    LonghandId::BorderInlineStartColor,
            ],
            &[
                    LonghandId::BorderInlineEndWidth,
                    LonghandId::BorderInlineEndStyle,
                    LonghandId::BorderInlineEndColor,
            ],
            &[
                    LonghandId::BorderTopWidth,
                    LonghandId::BorderTopStyle,
                    LonghandId::BorderTopColor,
                    LonghandId::BorderRightWidth,
                    LonghandId::BorderRightStyle,
                    LonghandId::BorderRightColor,
                    LonghandId::BorderBottomWidth,
                    LonghandId::BorderBottomStyle,
                    LonghandId::BorderBottomColor,
                    LonghandId::BorderLeftWidth,
                    LonghandId::BorderLeftStyle,
                    LonghandId::BorderLeftColor,
                    LonghandId::BorderImageOutset,
                    LonghandId::BorderImageRepeat,
                    LonghandId::BorderImageSlice,
                    LonghandId::BorderImageSource,
                    LonghandId::BorderImageWidth,
            ],
            &[
                    LonghandId::BorderTopLeftRadius,
                    LonghandId::BorderTopRightRadius,
                    LonghandId::BorderBottomRightRadius,
                    LonghandId::BorderBottomLeftRadius,
            ],
            &[
                    LonghandId::BorderImageOutset,
                    LonghandId::BorderImageRepeat,
                    LonghandId::BorderImageSlice,
                    LonghandId::BorderImageSource,
                    LonghandId::BorderImageWidth,
            ],
            &[
                    LonghandId::BorderBlockStartWidth,
                    LonghandId::BorderBlockEndWidth,
            ],
            &[
                    LonghandId::BorderBlockStartStyle,
                    LonghandId::BorderBlockEndStyle,
            ],
            &[
                    LonghandId::BorderBlockStartColor,
                    LonghandId::BorderBlockEndColor,
            ],
            &[
                    LonghandId::BorderInlineStartWidth,
                    LonghandId::BorderInlineEndWidth,
            ],
            &[
                    LonghandId::BorderInlineStartStyle,
                    LonghandId::BorderInlineEndStyle,
            ],
            &[
                    LonghandId::BorderInlineStartColor,
                    LonghandId::BorderInlineEndColor,
            ],
            &[
                    LonghandId::BorderBlockStartWidth,
                    LonghandId::BorderBlockEndWidth,
                    LonghandId::BorderBlockStartStyle,
                    LonghandId::BorderBlockEndStyle,
                    LonghandId::BorderBlockStartColor,
                    LonghandId::BorderBlockEndColor,
            ],
            &[
                    LonghandId::BorderInlineStartWidth,
                    LonghandId::BorderInlineEndWidth,
                    LonghandId::BorderInlineStartStyle,
                    LonghandId::BorderInlineEndStyle,
                    LonghandId::BorderInlineStartColor,
                    LonghandId::BorderInlineEndColor,
            ],
            &[
                    LonghandId::OverflowX,
                    LonghandId::OverflowY,
            ],
            &[
                    LonghandId::ColumnWidth,
                    LonghandId::ColumnCount,
            ],
            &[
                    LonghandId::FontStyle,
                    LonghandId::FontVariantCaps,
                    LonghandId::FontWeight,
                    LonghandId::FontStretch,
                    LonghandId::FontSize,
                    LonghandId::LineHeight,
                    LonghandId::FontFamily,
            ],
            &[
                    LonghandId::FontVariantCaps,
            ],
            &[
                    LonghandId::TextWrapMode,
                    LonghandId::WhiteSpaceCollapse,
            ],
            &[
                    LonghandId::ListStylePosition,
                    LonghandId::ListStyleImage,
                    LonghandId::ListStyleType,
            ],
            &[
                    LonghandId::MarginTop,
                    LonghandId::MarginRight,
                    LonghandId::MarginBottom,
                    LonghandId::MarginLeft,
            ],
            &[
                    LonghandId::MarginBlockStart,
                    LonghandId::MarginBlockEnd,
            ],
            &[
                    LonghandId::MarginInlineStart,
                    LonghandId::MarginInlineEnd,
            ],
            &[
                    LonghandId::OutlineColor,
                    LonghandId::OutlineStyle,
                    LonghandId::OutlineWidth,
            ],
            &[
                    LonghandId::PaddingTop,
                    LonghandId::PaddingRight,
                    LonghandId::PaddingBottom,
                    LonghandId::PaddingLeft,
            ],
            &[
                    LonghandId::PaddingBlockStart,
                    LonghandId::PaddingBlockEnd,
            ],
            &[
                    LonghandId::PaddingInlineStart,
                    LonghandId::PaddingInlineEnd,
            ],
            &[
                    LonghandId::FlexDirection,
                    LonghandId::FlexWrap,
            ],
            &[
                    LonghandId::FlexGrow,
                    LonghandId::FlexShrink,
                    LonghandId::FlexBasis,
            ],
            &[
                    LonghandId::RowGap,
                    LonghandId::ColumnGap,
            ],
            &[
                    LonghandId::GridRowStart,
                    LonghandId::GridRowEnd,
            ],
            &[
                    LonghandId::GridColumnStart,
                    LonghandId::GridColumnEnd,
            ],
            &[
                    LonghandId::GridRowStart,
                    LonghandId::GridRowEnd,
                    LonghandId::GridColumnStart,
                    LonghandId::GridColumnEnd,
            ],
            &[
                    LonghandId::GridTemplateRows,
                    LonghandId::GridTemplateColumns,
                    LonghandId::GridTemplateAreas,
            ],
            &[
                    LonghandId::GridTemplateRows,
                    LonghandId::GridTemplateColumns,
                    LonghandId::GridTemplateAreas,
                    LonghandId::GridAutoRows,
                    LonghandId::GridAutoColumns,
                    LonghandId::GridAutoFlow,
            ],
            &[
                    LonghandId::AlignContent,
                    LonghandId::JustifyContent,
            ],
            &[
                    LonghandId::AlignSelf,
                    LonghandId::JustifySelf,
            ],
            &[
                    LonghandId::AlignItems,
                    LonghandId::JustifyItems,
            ],
            &[
                    LonghandId::Top,
                    LonghandId::Right,
                    LonghandId::Bottom,
                    LonghandId::Left,
            ],
            &[
                    LonghandId::InsetBlockStart,
                    LonghandId::InsetBlockEnd,
            ],
            &[
                    LonghandId::InsetInlineStart,
                    LonghandId::InsetInlineEnd,
            ],
            &[
                    LonghandId::TextDecorationColor,
                    LonghandId::TextDecorationLine,
                    LonghandId::TextDecorationStyle,
            ],
            &[
                    LonghandId::TransitionProperty,
                    LonghandId::TransitionDuration,
                    LonghandId::TransitionTimingFunction,
                    LonghandId::TransitionDelay,
                    LonghandId::TransitionBehavior,
            ],
            &[
                    LonghandId::AnimationName,
                    LonghandId::AnimationDuration,
                    LonghandId::AnimationTimingFunction,
                    LonghandId::AnimationDelay,
                    LonghandId::AnimationIterationCount,
                    LonghandId::AnimationDirection,
                    LonghandId::AnimationFillMode,
                    LonghandId::AnimationPlayState,
                    LonghandId::AnimationTimeline,
            ],
            &[
                    LonghandId::BorderBlockStartColor,
                    LonghandId::BorderBlockStartStyle,
                    LonghandId::BorderBlockStartWidth,
                    LonghandId::BorderBlockEndColor,
                    LonghandId::BorderBlockEndStyle,
                    LonghandId::BorderBlockEndWidth,
                    LonghandId::BorderInlineStartColor,
                    LonghandId::BorderInlineStartStyle,
                    LonghandId::BorderInlineStartWidth,
                    LonghandId::BorderInlineEndColor,
                    LonghandId::BorderInlineEndStyle,
                    LonghandId::BorderInlineEndWidth,
                    LonghandId::BorderStartStartRadius,
                    LonghandId::BorderStartEndRadius,
                    LonghandId::BorderEndStartRadius,
                    LonghandId::BorderEndEndRadius,
                    LonghandId::OverflowBlock,
                    LonghandId::OverflowInline,
                    LonghandId::MarginBlockStart,
                    LonghandId::MarginBlockEnd,
                    LonghandId::MarginInlineStart,
                    LonghandId::MarginInlineEnd,
                    LonghandId::PaddingBlockStart,
                    LonghandId::PaddingBlockEnd,
                    LonghandId::PaddingInlineStart,
                    LonghandId::PaddingInlineEnd,
                    LonghandId::InsetBlockStart,
                    LonghandId::InsetBlockEnd,
                    LonghandId::InsetInlineStart,
                    LonghandId::InsetInlineEnd,
                    LonghandId::BlockSize,
                    LonghandId::MinBlockSize,
                    LonghandId::MaxBlockSize,
                    LonghandId::InlineSize,
                    LonghandId::MinInlineSize,
                    LonghandId::MaxInlineSize,
                    LonghandId::BackgroundColor,
                    LonghandId::BackgroundImage,
                    LonghandId::BackgroundPositionX,
                    LonghandId::BackgroundPositionY,
                    LonghandId::BackgroundRepeat,
                    LonghandId::BackgroundAttachment,
                    LonghandId::BackgroundClip,
                    LonghandId::BackgroundOrigin,
                    LonghandId::BackgroundSize,
                    LonghandId::BorderTopColor,
                    LonghandId::BorderTopStyle,
                    LonghandId::BorderTopWidth,
                    LonghandId::BorderRightColor,
                    LonghandId::BorderRightStyle,
                    LonghandId::BorderRightWidth,
                    LonghandId::BorderBottomColor,
                    LonghandId::BorderBottomStyle,
                    LonghandId::BorderBottomWidth,
                    LonghandId::BorderLeftColor,
                    LonghandId::BorderLeftStyle,
                    LonghandId::BorderLeftWidth,
                    LonghandId::BorderTopLeftRadius,
                    LonghandId::BorderTopRightRadius,
                    LonghandId::BorderBottomRightRadius,
                    LonghandId::BorderBottomLeftRadius,
                    LonghandId::BorderImageSource,
                    LonghandId::BorderImageOutset,
                    LonghandId::BorderImageRepeat,
                    LonghandId::BorderImageWidth,
                    LonghandId::BorderImageSlice,
                    LonghandId::Display,
                    LonghandId::Position,
                    LonghandId::Float,
                    LonghandId::Clear,
                    LonghandId::VerticalAlign,
                    LonghandId::BaselineSource,
                    LonghandId::OverflowY,
                    LonghandId::OverflowX,
                    LonghandId::Transform,
                    LonghandId::Rotate,
                    LonghandId::Scale,
                    LonghandId::Translate,
                    LonghandId::OffsetPath,
                    LonghandId::Isolation,
                    LonghandId::Perspective,
                    LonghandId::PerspectiveOrigin,
                    LonghandId::BackfaceVisibility,
                    LonghandId::TransformStyle,
                    LonghandId::TransformOrigin,
                    LonghandId::Contain,
                    LonghandId::ContainerType,
                    LonghandId::ContainerName,
                    LonghandId::WillChange,
                    LonghandId::Zoom,
                    LonghandId::ColumnWidth,
                    LonghandId::ColumnCount,
                    LonghandId::ColumnSpan,
                    LonghandId::Content,
                    LonghandId::CounterIncrement,
                    LonghandId::CounterReset,
                    LonghandId::Opacity,
                    LonghandId::BoxShadow,
                    LonghandId::Clip,
                    LonghandId::Filter,
                    LonghandId::BackdropFilter,
                    LonghandId::MixBlendMode,
                    LonghandId::FontFamily,
                    LonghandId::FontStyle,
                    LonghandId::FontVariantCaps,
                    LonghandId::FontWeight,
                    LonghandId::FontSize,
                    LonghandId::FontSynthesisWeight,
                    LonghandId::FontStretch,
                    LonghandId::FontVariationSettings,
                    LonghandId::FontLanguageOverride,
                    LonghandId::LineHeight,
                    LonghandId::Visibility,
                    LonghandId::WritingMode,
                    LonghandId::ImageRendering,
                    LonghandId::BorderCollapse,
                    LonghandId::EmptyCells,
                    LonghandId::CaptionSide,
                    LonghandId::BorderSpacing,
                    LonghandId::Color,
                    LonghandId::TextTransform,
                    LonghandId::TextIndent,
                    LonghandId::OverflowWrap,
                    LonghandId::WordBreak,
                    LonghandId::TextJustify,
                    LonghandId::TextAlignLast,
                    LonghandId::TextAlign,
                    LonghandId::LetterSpacing,
                    LonghandId::WordSpacing,
                    LonghandId::WhiteSpaceCollapse,
                    LonghandId::TextShadow,
                    LonghandId::TextRendering,
                    LonghandId::TextWrapMode,
                    LonghandId::Cursor,
                    LonghandId::PointerEvents,
                    LonghandId::ColorScheme,
                    LonghandId::ListStylePosition,
                    LonghandId::ListStyleType,
                    LonghandId::ListStyleImage,
                    LonghandId::Quotes,
                    LonghandId::MarginTop,
                    LonghandId::MarginRight,
                    LonghandId::MarginBottom,
                    LonghandId::MarginLeft,
                    LonghandId::OverflowClipMargin,
                    LonghandId::OutlineColor,
                    LonghandId::OutlineStyle,
                    LonghandId::OutlineWidth,
                    LonghandId::OutlineOffset,
                    LonghandId::PaddingTop,
                    LonghandId::PaddingRight,
                    LonghandId::PaddingBottom,
                    LonghandId::PaddingLeft,
                    LonghandId::Top,
                    LonghandId::Right,
                    LonghandId::Bottom,
                    LonghandId::Left,
                    LonghandId::ZIndex,
                    LonghandId::FlexDirection,
                    LonghandId::FlexWrap,
                    LonghandId::JustifyContent,
                    LonghandId::AlignContent,
                    LonghandId::AlignItems,
                    LonghandId::JustifyItems,
                    LonghandId::FlexGrow,
                    LonghandId::FlexShrink,
                    LonghandId::AlignSelf,
                    LonghandId::JustifySelf,
                    LonghandId::Order,
                    LonghandId::FlexBasis,
                    LonghandId::Height,
                    LonghandId::MinHeight,
                    LonghandId::MaxHeight,
                    LonghandId::Width,
                    LonghandId::MinWidth,
                    LonghandId::MaxWidth,
                    LonghandId::PositionArea,
                    LonghandId::BoxSizing,
                    LonghandId::ObjectFit,
                    LonghandId::ObjectPosition,
                    LonghandId::GridRowStart,
                    LonghandId::GridRowEnd,
                    LonghandId::GridAutoRows,
                    LonghandId::GridTemplateRows,
                    LonghandId::GridColumnStart,
                    LonghandId::GridColumnEnd,
                    LonghandId::GridAutoColumns,
                    LonghandId::GridTemplateColumns,
                    LonghandId::GridAutoFlow,
                    LonghandId::GridTemplateAreas,
                    LonghandId::ColumnGap,
                    LonghandId::RowGap,
                    LonghandId::AspectRatio,
                    LonghandId::ClipPath,
                    LonghandId::MaskImage,
                    LonghandId::TableLayout,
                    LonghandId::TextOverflow,
                    LonghandId::TextDecorationLine,
                    LonghandId::TextDecorationStyle,
                    LonghandId::TextDecorationColor,
                    LonghandId::TransitionDuration,
                    LonghandId::TransitionTimingFunction,
                    LonghandId::TransitionProperty,
                    LonghandId::TransitionDelay,
                    LonghandId::TransitionBehavior,
                    LonghandId::AnimationName,
                    LonghandId::AnimationDuration,
                    LonghandId::AnimationTimingFunction,
                    LonghandId::AnimationIterationCount,
                    LonghandId::AnimationDirection,
                    LonghandId::AnimationPlayState,
                    LonghandId::AnimationFillMode,
                    LonghandId::AnimationComposition,
                    LonghandId::AnimationDelay,
                    LonghandId::AnimationTimeline,
                    LonghandId::ViewTransitionName,
                    LonghandId::ViewTransitionClass,
            ],
        ];
        NonCustomPropertyIterator {
            filter: NonCustomPropertyId::from(self).enabled_for_all_content(),
            iter: MAP[self as usize].iter(),
        }
    }

    /// Try to serialize the given declarations as this shorthand.
    ///
    /// Returns an error if writing to the stream fails, or if the declarations
    /// do not map to a shorthand.
    pub fn longhands_to_css(
        self,
        declarations: &[&PropertyDeclaration],
        dest: &mut CssStringWriter,
    ) -> fmt::Result {
        type LonghandsToCssFn = for<'a, 'b> fn(&'a [&'b PropertyDeclaration], &mut CssStringWriter) -> fmt::Result;
        fn all_to_css(_: &[&PropertyDeclaration], _: &mut CssStringWriter) -> fmt::Result {
            // No need to try to serialize the declarations as the 'all'
            // shorthand, since it only accepts CSS-wide keywords (and variable
            // references), which will be handled in
            // get_shorthand_appendable_value.
            Ok(())
        }

        static LONGHANDS_TO_CSS: [LonghandsToCssFn; 55] = [
                shorthands::background::to_css,
                shorthands::background_position::to_css,
                shorthands::border_color::to_css,
                shorthands::border_style::to_css,
                shorthands::border_width::to_css,
                shorthands::border_top::to_css,
                shorthands::border_right::to_css,
                shorthands::border_bottom::to_css,
                shorthands::border_left::to_css,
                shorthands::border_block_start::to_css,
                shorthands::border_block_end::to_css,
                shorthands::border_inline_start::to_css,
                shorthands::border_inline_end::to_css,
                shorthands::border::to_css,
                shorthands::border_radius::to_css,
                shorthands::border_image::to_css,
                shorthands::border_block_width::to_css,
                shorthands::border_block_style::to_css,
                shorthands::border_block_color::to_css,
                shorthands::border_inline_width::to_css,
                shorthands::border_inline_style::to_css,
                shorthands::border_inline_color::to_css,
                shorthands::border_block::to_css,
                shorthands::border_inline::to_css,
                shorthands::overflow::to_css,
                shorthands::columns::to_css,
                shorthands::font::to_css,
                shorthands::font_variant::to_css,
                shorthands::white_space::to_css,
                shorthands::list_style::to_css,
                shorthands::margin::to_css,
                shorthands::margin_block::to_css,
                shorthands::margin_inline::to_css,
                shorthands::outline::to_css,
                shorthands::padding::to_css,
                shorthands::padding_block::to_css,
                shorthands::padding_inline::to_css,
                shorthands::flex_flow::to_css,
                shorthands::flex::to_css,
                shorthands::gap::to_css,
                shorthands::grid_row::to_css,
                shorthands::grid_column::to_css,
                shorthands::grid_area::to_css,
                shorthands::grid_template::to_css,
                shorthands::grid::to_css,
                shorthands::place_content::to_css,
                shorthands::place_self::to_css,
                shorthands::place_items::to_css,
                shorthands::inset::to_css,
                shorthands::inset_block::to_css,
                shorthands::inset_inline::to_css,
                shorthands::text_decoration::to_css,
                shorthands::transition::to_css,
                shorthands::animation::to_css,
                all_to_css,
        ];

        LONGHANDS_TO_CSS[self as usize](declarations, dest)
    }

    /// Returns PropertyFlags for the given shorthand property.
    #[inline]
    pub fn flags(self) -> PropertyFlags {
        const FLAGS: [u16; 55] = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
        ];
        PropertyFlags::from_bits_retain(FLAGS[self as usize])
    }

    /// Returns the order in which this property appears relative to other
    /// shorthands in idl-name-sorting order.
    #[inline]
    pub fn idl_name_sort_order(self) -> u32 {
        
        static IDL_NAME_SORT_ORDER: [u32; 55] = [
            2,
            3,
            12,
            23,
            25,
            24,
            22,
            11,
            20,
            8,
            7,
            17,
            16,
            4,
            21,
            13,
            10,
            9,
            6,
            19,
            18,
            15,
            5,
            14,
            45,
            26,
            29,
            30,
            54,
            40,
            41,
            42,
            43,
            44,
            46,
            47,
            48,
            28,
            27,
            31,
            35,
            34,
            33,
            36,
            32,
            49,
            51,
            50,
            37,
            38,
            39,
            52,
            53,
            1,
            0,
        ];
        IDL_NAME_SORT_ORDER[self as usize]
    }

    pub(super) fn parse_into<'i, 't>(
        self,
        declarations: &mut SourcePropertyDeclaration,
        context: &ParserContext,
        input: &mut Parser<'i, 't>,
    ) -> Result<(), ParseError<'i>> {
        type ParseIntoFn = for<'i, 't> fn(
            declarations: &mut SourcePropertyDeclaration,
            context: &ParserContext,
            input: &mut Parser<'i, 't>,
        ) -> Result<(), ParseError<'i>>;

        fn parse_all<'i, 't>(
            _: &mut SourcePropertyDeclaration,
            _: &ParserContext,
            input: &mut Parser<'i, 't>
        ) -> Result<(), ParseError<'i>> {
            // 'all' accepts no value other than CSS-wide keywords
            Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
        }

        static PARSE_INTO: [ParseIntoFn; 55] = [
            shorthands::background::parse_into,
            shorthands::background_position::parse_into,
            shorthands::border_color::parse_into,
            shorthands::border_style::parse_into,
            shorthands::border_width::parse_into,
            shorthands::border_top::parse_into,
            shorthands::border_right::parse_into,
            shorthands::border_bottom::parse_into,
            shorthands::border_left::parse_into,
            shorthands::border_block_start::parse_into,
            shorthands::border_block_end::parse_into,
            shorthands::border_inline_start::parse_into,
            shorthands::border_inline_end::parse_into,
            shorthands::border::parse_into,
            shorthands::border_radius::parse_into,
            shorthands::border_image::parse_into,
            shorthands::border_block_width::parse_into,
            shorthands::border_block_style::parse_into,
            shorthands::border_block_color::parse_into,
            shorthands::border_inline_width::parse_into,
            shorthands::border_inline_style::parse_into,
            shorthands::border_inline_color::parse_into,
            shorthands::border_block::parse_into,
            shorthands::border_inline::parse_into,
            shorthands::overflow::parse_into,
            shorthands::columns::parse_into,
            shorthands::font::parse_into,
            shorthands::font_variant::parse_into,
            shorthands::white_space::parse_into,
            shorthands::list_style::parse_into,
            shorthands::margin::parse_into,
            shorthands::margin_block::parse_into,
            shorthands::margin_inline::parse_into,
            shorthands::outline::parse_into,
            shorthands::padding::parse_into,
            shorthands::padding_block::parse_into,
            shorthands::padding_inline::parse_into,
            shorthands::flex_flow::parse_into,
            shorthands::flex::parse_into,
            shorthands::gap::parse_into,
            shorthands::grid_row::parse_into,
            shorthands::grid_column::parse_into,
            shorthands::grid_area::parse_into,
            shorthands::grid_template::parse_into,
            shorthands::grid::parse_into,
            shorthands::place_content::parse_into,
            shorthands::place_self::parse_into,
            shorthands::place_items::parse_into,
            shorthands::inset::parse_into,
            shorthands::inset_block::parse_into,
            shorthands::inset_inline::parse_into,
            shorthands::text_decoration::parse_into,
            shorthands::transition::parse_into,
            shorthands::animation::parse_into,
            parse_all,
        ];

        (PARSE_INTO[self as usize])(declarations, context, input)
    }
}

/// The counted unknown property list which is used for css use counters.
///
/// FIXME: This should be just #[repr(u8)], but can't be because of ABI issues,
/// see https://bugs.llvm.org/show_bug.cgi?id=44228.
#[derive(Clone, Copy, Debug, Eq, FromPrimitive, Hash, PartialEq)]
#[repr(u32)]
pub enum CountedUnknownProperty {
    /// -webkit-tap-highlight-color
    WebkitTapHighlightColor,
    /// speak
    Speak,
    /// text-size-adjust
    TextSizeAdjust,
    /// -webkit-user-drag
    WebkitUserDrag,
    /// orphans
    Orphans,
    /// widows
    Widows,
    /// -webkit-user-modify
    WebkitUserModify,
    /// -webkit-margin-before
    WebkitMarginBefore,
    /// -webkit-margin-after
    WebkitMarginAfter,
    /// -webkit-margin-start
    WebkitMarginStart,
    /// -webkit-column-break-inside
    WebkitColumnBreakInside,
    /// -webkit-padding-start
    WebkitPaddingStart,
    /// -webkit-margin-end
    WebkitMarginEnd,
    /// -webkit-box-reflect
    WebkitBoxReflect,
    /// -webkit-print-color-adjust
    WebkitPrintColorAdjust,
    /// -webkit-mask-box-image
    WebkitMaskBoxImage,
    /// -webkit-line-break
    WebkitLineBreak,
    /// alignment-baseline
    AlignmentBaseline,
    /// -webkit-writing-mode
    WebkitWritingMode,
    /// baseline-shift
    BaselineShift,
    /// -webkit-hyphenate-character
    WebkitHyphenateCharacter,
    /// -webkit-highlight
    WebkitHighlight,
    /// background-repeat-x
    BackgroundRepeatX,
    /// -webkit-padding-end
    WebkitPaddingEnd,
    /// background-repeat-y
    BackgroundRepeatY,
    /// -webkit-text-emphasis-color
    WebkitTextEmphasisColor,
    /// -webkit-margin-top-collapse
    WebkitMarginTopCollapse,
    /// -webkit-rtl-ordering
    WebkitRtlOrdering,
    /// -webkit-padding-before
    WebkitPaddingBefore,
    /// -webkit-text-decorations-in-effect
    WebkitTextDecorationsInEffect,
    /// -webkit-border-vertical-spacing
    WebkitBorderVerticalSpacing,
    /// -webkit-locale
    WebkitLocale,
    /// -webkit-padding-after
    WebkitPaddingAfter,
    /// -webkit-border-horizontal-spacing
    WebkitBorderHorizontalSpacing,
    /// color-rendering
    ColorRendering,
    /// -webkit-column-break-before
    WebkitColumnBreakBefore,
    /// -webkit-transform-origin-x
    WebkitTransformOriginX,
    /// -webkit-transform-origin-y
    WebkitTransformOriginY,
    /// -webkit-text-emphasis-position
    WebkitTextEmphasisPosition,
    /// buffered-rendering
    BufferedRendering,
    /// -webkit-text-orientation
    WebkitTextOrientation,
    /// -webkit-text-combine
    WebkitTextCombine,
    /// -webkit-text-emphasis-style
    WebkitTextEmphasisStyle,
    /// -webkit-text-emphasis
    WebkitTextEmphasis,
    /// -webkit-mask-box-image-width
    WebkitMaskBoxImageWidth,
    /// -webkit-mask-box-image-source
    WebkitMaskBoxImageSource,
    /// -webkit-mask-box-image-outset
    WebkitMaskBoxImageOutset,
    /// -webkit-mask-box-image-slice
    WebkitMaskBoxImageSlice,
    /// -webkit-mask-box-image-repeat
    WebkitMaskBoxImageRepeat,
    /// -webkit-margin-after-collapse
    WebkitMarginAfterCollapse,
    /// -webkit-border-before-color
    WebkitBorderBeforeColor,
    /// -webkit-border-before-width
    WebkitBorderBeforeWidth,
    /// -webkit-perspective-origin-x
    WebkitPerspectiveOriginX,
    /// -webkit-perspective-origin-y
    WebkitPerspectiveOriginY,
    /// -webkit-margin-before-collapse
    WebkitMarginBeforeCollapse,
    /// -webkit-border-before-style
    WebkitBorderBeforeStyle,
    /// -webkit-margin-bottom-collapse
    WebkitMarginBottomCollapse,
    /// -webkit-ruby-position
    WebkitRubyPosition,
    /// -webkit-column-break-after
    WebkitColumnBreakAfter,
    /// -webkit-margin-collapse
    WebkitMarginCollapse,
    /// -webkit-border-before
    WebkitBorderBefore,
    /// -webkit-border-end
    WebkitBorderEnd,
    /// -webkit-border-after
    WebkitBorderAfter,
    /// -webkit-border-start
    WebkitBorderStart,
    /// -webkit-min-logical-width
    WebkitMinLogicalWidth,
    /// -webkit-logical-height
    WebkitLogicalHeight,
    /// -webkit-transform-origin-z
    WebkitTransformOriginZ,
    /// -webkit-font-size-delta
    WebkitFontSizeDelta,
    /// -webkit-logical-width
    WebkitLogicalWidth,
    /// -webkit-max-logical-width
    WebkitMaxLogicalWidth,
    /// -webkit-min-logical-height
    WebkitMinLogicalHeight,
    /// -webkit-max-logical-height
    WebkitMaxLogicalHeight,
    /// -webkit-border-end-color
    WebkitBorderEndColor,
    /// -webkit-border-end-width
    WebkitBorderEndWidth,
    /// -webkit-border-start-color
    WebkitBorderStartColor,
    /// -webkit-border-start-width
    WebkitBorderStartWidth,
    /// -webkit-border-after-color
    WebkitBorderAfterColor,
    /// -webkit-border-after-width
    WebkitBorderAfterWidth,
    /// -webkit-border-end-style
    WebkitBorderEndStyle,
    /// -webkit-border-after-style
    WebkitBorderAfterStyle,
    /// -webkit-border-start-style
    WebkitBorderStartStyle,
    /// -webkit-mask-repeat-x
    WebkitMaskRepeatX,
    /// -webkit-mask-repeat-y
    WebkitMaskRepeatY,
    /// user-zoom
    UserZoom,
    /// min-zoom
    MinZoom,
    /// -webkit-box-decoration-break
    WebkitBoxDecorationBreak,
    /// orientation
    Orientation,
    /// max-zoom
    MaxZoom,
    /// -webkit-app-region
    WebkitAppRegion,
    /// -webkit-column-rule
    WebkitColumnRule,
    /// -webkit-column-span
    WebkitColumnSpan,
    /// -webkit-column-gap
    WebkitColumnGap,
    /// -webkit-shape-outside
    WebkitShapeOutside,
    /// -webkit-column-rule-width
    WebkitColumnRuleWidth,
    /// -webkit-column-count
    WebkitColumnCount,
    /// -webkit-opacity
    WebkitOpacity,
    /// -webkit-column-width
    WebkitColumnWidth,
    /// -webkit-shape-image-threshold
    WebkitShapeImageThreshold,
    /// -webkit-column-rule-style
    WebkitColumnRuleStyle,
    /// -webkit-columns
    WebkitColumns,
    /// -webkit-column-rule-color
    WebkitColumnRuleColor,
    /// -webkit-shape-margin
    WebkitShapeMargin,
}

impl CountedUnknownProperty {
    /// Parse the counted unknown property, for testing purposes only.
    pub fn parse_for_testing(property_name: &str) -> Option<Self> {
        ascii_case_insensitive_phf_map! {
            unknown_ids -> CountedUnknownProperty = {
                "-webkit-tap-highlight-color" => CountedUnknownProperty::WebkitTapHighlightColor,
                "speak" => CountedUnknownProperty::Speak,
                "text-size-adjust" => CountedUnknownProperty::TextSizeAdjust,
                "-webkit-user-drag" => CountedUnknownProperty::WebkitUserDrag,
                "orphans" => CountedUnknownProperty::Orphans,
                "widows" => CountedUnknownProperty::Widows,
                "-webkit-user-modify" => CountedUnknownProperty::WebkitUserModify,
                "-webkit-margin-before" => CountedUnknownProperty::WebkitMarginBefore,
                "-webkit-margin-after" => CountedUnknownProperty::WebkitMarginAfter,
                "-webkit-margin-start" => CountedUnknownProperty::WebkitMarginStart,
                "-webkit-column-break-inside" => CountedUnknownProperty::WebkitColumnBreakInside,
                "-webkit-padding-start" => CountedUnknownProperty::WebkitPaddingStart,
                "-webkit-margin-end" => CountedUnknownProperty::WebkitMarginEnd,
                "-webkit-box-reflect" => CountedUnknownProperty::WebkitBoxReflect,
                "-webkit-print-color-adjust" => CountedUnknownProperty::WebkitPrintColorAdjust,
                "-webkit-mask-box-image" => CountedUnknownProperty::WebkitMaskBoxImage,
                "-webkit-line-break" => CountedUnknownProperty::WebkitLineBreak,
                "alignment-baseline" => CountedUnknownProperty::AlignmentBaseline,
                "-webkit-writing-mode" => CountedUnknownProperty::WebkitWritingMode,
                "baseline-shift" => CountedUnknownProperty::BaselineShift,
                "-webkit-hyphenate-character" => CountedUnknownProperty::WebkitHyphenateCharacter,
                "-webkit-highlight" => CountedUnknownProperty::WebkitHighlight,
                "background-repeat-x" => CountedUnknownProperty::BackgroundRepeatX,
                "-webkit-padding-end" => CountedUnknownProperty::WebkitPaddingEnd,
                "background-repeat-y" => CountedUnknownProperty::BackgroundRepeatY,
                "-webkit-text-emphasis-color" => CountedUnknownProperty::WebkitTextEmphasisColor,
                "-webkit-margin-top-collapse" => CountedUnknownProperty::WebkitMarginTopCollapse,
                "-webkit-rtl-ordering" => CountedUnknownProperty::WebkitRtlOrdering,
                "-webkit-padding-before" => CountedUnknownProperty::WebkitPaddingBefore,
                "-webkit-text-decorations-in-effect" => CountedUnknownProperty::WebkitTextDecorationsInEffect,
                "-webkit-border-vertical-spacing" => CountedUnknownProperty::WebkitBorderVerticalSpacing,
                "-webkit-locale" => CountedUnknownProperty::WebkitLocale,
                "-webkit-padding-after" => CountedUnknownProperty::WebkitPaddingAfter,
                "-webkit-border-horizontal-spacing" => CountedUnknownProperty::WebkitBorderHorizontalSpacing,
                "color-rendering" => CountedUnknownProperty::ColorRendering,
                "-webkit-column-break-before" => CountedUnknownProperty::WebkitColumnBreakBefore,
                "-webkit-transform-origin-x" => CountedUnknownProperty::WebkitTransformOriginX,
                "-webkit-transform-origin-y" => CountedUnknownProperty::WebkitTransformOriginY,
                "-webkit-text-emphasis-position" => CountedUnknownProperty::WebkitTextEmphasisPosition,
                "buffered-rendering" => CountedUnknownProperty::BufferedRendering,
                "-webkit-text-orientation" => CountedUnknownProperty::WebkitTextOrientation,
                "-webkit-text-combine" => CountedUnknownProperty::WebkitTextCombine,
                "-webkit-text-emphasis-style" => CountedUnknownProperty::WebkitTextEmphasisStyle,
                "-webkit-text-emphasis" => CountedUnknownProperty::WebkitTextEmphasis,
                "-webkit-mask-box-image-width" => CountedUnknownProperty::WebkitMaskBoxImageWidth,
                "-webkit-mask-box-image-source" => CountedUnknownProperty::WebkitMaskBoxImageSource,
                "-webkit-mask-box-image-outset" => CountedUnknownProperty::WebkitMaskBoxImageOutset,
                "-webkit-mask-box-image-slice" => CountedUnknownProperty::WebkitMaskBoxImageSlice,
                "-webkit-mask-box-image-repeat" => CountedUnknownProperty::WebkitMaskBoxImageRepeat,
                "-webkit-margin-after-collapse" => CountedUnknownProperty::WebkitMarginAfterCollapse,
                "-webkit-border-before-color" => CountedUnknownProperty::WebkitBorderBeforeColor,
                "-webkit-border-before-width" => CountedUnknownProperty::WebkitBorderBeforeWidth,
                "-webkit-perspective-origin-x" => CountedUnknownProperty::WebkitPerspectiveOriginX,
                "-webkit-perspective-origin-y" => CountedUnknownProperty::WebkitPerspectiveOriginY,
                "-webkit-margin-before-collapse" => CountedUnknownProperty::WebkitMarginBeforeCollapse,
                "-webkit-border-before-style" => CountedUnknownProperty::WebkitBorderBeforeStyle,
                "-webkit-margin-bottom-collapse" => CountedUnknownProperty::WebkitMarginBottomCollapse,
                "-webkit-ruby-position" => CountedUnknownProperty::WebkitRubyPosition,
                "-webkit-column-break-after" => CountedUnknownProperty::WebkitColumnBreakAfter,
                "-webkit-margin-collapse" => CountedUnknownProperty::WebkitMarginCollapse,
                "-webkit-border-before" => CountedUnknownProperty::WebkitBorderBefore,
                "-webkit-border-end" => CountedUnknownProperty::WebkitBorderEnd,
                "-webkit-border-after" => CountedUnknownProperty::WebkitBorderAfter,
                "-webkit-border-start" => CountedUnknownProperty::WebkitBorderStart,
                "-webkit-min-logical-width" => CountedUnknownProperty::WebkitMinLogicalWidth,
                "-webkit-logical-height" => CountedUnknownProperty::WebkitLogicalHeight,
                "-webkit-transform-origin-z" => CountedUnknownProperty::WebkitTransformOriginZ,
                "-webkit-font-size-delta" => CountedUnknownProperty::WebkitFontSizeDelta,
                "-webkit-logical-width" => CountedUnknownProperty::WebkitLogicalWidth,
                "-webkit-max-logical-width" => CountedUnknownProperty::WebkitMaxLogicalWidth,
                "-webkit-min-logical-height" => CountedUnknownProperty::WebkitMinLogicalHeight,
                "-webkit-max-logical-height" => CountedUnknownProperty::WebkitMaxLogicalHeight,
                "-webkit-border-end-color" => CountedUnknownProperty::WebkitBorderEndColor,
                "-webkit-border-end-width" => CountedUnknownProperty::WebkitBorderEndWidth,
                "-webkit-border-start-color" => CountedUnknownProperty::WebkitBorderStartColor,
                "-webkit-border-start-width" => CountedUnknownProperty::WebkitBorderStartWidth,
                "-webkit-border-after-color" => CountedUnknownProperty::WebkitBorderAfterColor,
                "-webkit-border-after-width" => CountedUnknownProperty::WebkitBorderAfterWidth,
                "-webkit-border-end-style" => CountedUnknownProperty::WebkitBorderEndStyle,
                "-webkit-border-after-style" => CountedUnknownProperty::WebkitBorderAfterStyle,
                "-webkit-border-start-style" => CountedUnknownProperty::WebkitBorderStartStyle,
                "-webkit-mask-repeat-x" => CountedUnknownProperty::WebkitMaskRepeatX,
                "-webkit-mask-repeat-y" => CountedUnknownProperty::WebkitMaskRepeatY,
                "user-zoom" => CountedUnknownProperty::UserZoom,
                "min-zoom" => CountedUnknownProperty::MinZoom,
                "-webkit-box-decoration-break" => CountedUnknownProperty::WebkitBoxDecorationBreak,
                "orientation" => CountedUnknownProperty::Orientation,
                "max-zoom" => CountedUnknownProperty::MaxZoom,
                "-webkit-app-region" => CountedUnknownProperty::WebkitAppRegion,
                "-webkit-column-rule" => CountedUnknownProperty::WebkitColumnRule,
                "-webkit-column-span" => CountedUnknownProperty::WebkitColumnSpan,
                "-webkit-column-gap" => CountedUnknownProperty::WebkitColumnGap,
                "-webkit-shape-outside" => CountedUnknownProperty::WebkitShapeOutside,
                "-webkit-column-rule-width" => CountedUnknownProperty::WebkitColumnRuleWidth,
                "-webkit-column-count" => CountedUnknownProperty::WebkitColumnCount,
                "-webkit-opacity" => CountedUnknownProperty::WebkitOpacity,
                "-webkit-column-width" => CountedUnknownProperty::WebkitColumnWidth,
                "-webkit-shape-image-threshold" => CountedUnknownProperty::WebkitShapeImageThreshold,
                "-webkit-column-rule-style" => CountedUnknownProperty::WebkitColumnRuleStyle,
                "-webkit-columns" => CountedUnknownProperty::WebkitColumns,
                "-webkit-column-rule-color" => CountedUnknownProperty::WebkitColumnRuleColor,
                "-webkit-shape-margin" => CountedUnknownProperty::WebkitShapeMargin,
            }
        }
        unknown_ids::get(property_name).cloned()
    }

    /// Returns the underlying index, used for use counter.
    #[inline]
    pub fn bit(self) -> usize {
        self as usize
    }
}

impl PropertyId {
    /// Returns a given property from the given name, _regardless of whether it
    /// is enabled or not_, or Err(()) for unknown properties.
    pub(super) fn parse_unchecked(
        property_name: &str,
        use_counters: Option<&UseCounters>,
    ) -> Result<Self, ()> {
        // A special id for css use counters. ShorthandAlias is not used in the Servo build.
        // That's why we need to allow dead_code.
        pub enum StaticId {
            NonCustom(NonCustomPropertyId),
            CountedUnknown(CountedUnknownProperty),
        }
        ascii_case_insensitive_phf_map! {
            static_ids -> StaticId = {
                "align-items" => StaticId::NonCustom(NonCustomPropertyId(0)),
                "aspect-ratio" => StaticId::NonCustom(NonCustomPropertyId(1)),
                "backface-visibility" => StaticId::NonCustom(NonCustomPropertyId(2)),
                "baseline-source" => StaticId::NonCustom(NonCustomPropertyId(3)),
                "border-collapse" => StaticId::NonCustom(NonCustomPropertyId(4)),
                "border-image-repeat" => StaticId::NonCustom(NonCustomPropertyId(5)),
                "box-sizing" => StaticId::NonCustom(NonCustomPropertyId(6)),
                "caption-side" => StaticId::NonCustom(NonCustomPropertyId(7)),
                "clear" => StaticId::NonCustom(NonCustomPropertyId(8)),
                "column-count" => StaticId::NonCustom(NonCustomPropertyId(9)),
                "column-span" => StaticId::NonCustom(NonCustomPropertyId(10)),
                "contain" => StaticId::NonCustom(NonCustomPropertyId(11)),
                "container-type" => StaticId::NonCustom(NonCustomPropertyId(12)),
                "direction" => StaticId::NonCustom(NonCustomPropertyId(13)),
                "display" => StaticId::NonCustom(NonCustomPropertyId(14)),
                "empty-cells" => StaticId::NonCustom(NonCustomPropertyId(15)),
                "flex-direction" => StaticId::NonCustom(NonCustomPropertyId(16)),
                "flex-wrap" => StaticId::NonCustom(NonCustomPropertyId(17)),
                "float" => StaticId::NonCustom(NonCustomPropertyId(18)),
                "font-language-override" => StaticId::NonCustom(NonCustomPropertyId(19)),
                "font-stretch" => StaticId::NonCustom(NonCustomPropertyId(20)),
                "font-style" => StaticId::NonCustom(NonCustomPropertyId(21)),
                "font-synthesis-weight" => StaticId::NonCustom(NonCustomPropertyId(22)),
                "font-variant-caps" => StaticId::NonCustom(NonCustomPropertyId(23)),
                "font-weight" => StaticId::NonCustom(NonCustomPropertyId(24)),
                "grid-auto-flow" => StaticId::NonCustom(NonCustomPropertyId(25)),
                "image-rendering" => StaticId::NonCustom(NonCustomPropertyId(26)),
                "isolation" => StaticId::NonCustom(NonCustomPropertyId(27)),
                "justify-items" => StaticId::NonCustom(NonCustomPropertyId(28)),
                "list-style-position" => StaticId::NonCustom(NonCustomPropertyId(29)),
                "list-style-type" => StaticId::NonCustom(NonCustomPropertyId(30)),
                "mix-blend-mode" => StaticId::NonCustom(NonCustomPropertyId(31)),
                "object-fit" => StaticId::NonCustom(NonCustomPropertyId(32)),
                "opacity" => StaticId::NonCustom(NonCustomPropertyId(33)),
                "order" => StaticId::NonCustom(NonCustomPropertyId(34)),
                "outline-style" => StaticId::NonCustom(NonCustomPropertyId(35)),
                "overflow-wrap" => StaticId::NonCustom(NonCustomPropertyId(36)),
                "pointer-events" => StaticId::NonCustom(NonCustomPropertyId(37)),
                "position" => StaticId::NonCustom(NonCustomPropertyId(38)),
                "position-area" => StaticId::NonCustom(NonCustomPropertyId(39)),
                "-servo-overflow-clip-box" => StaticId::NonCustom(NonCustomPropertyId(40)),
                "-servo-top-layer" => StaticId::NonCustom(NonCustomPropertyId(41)),
                "table-layout" => StaticId::NonCustom(NonCustomPropertyId(42)),
                "text-align" => StaticId::NonCustom(NonCustomPropertyId(43)),
                "text-align-last" => StaticId::NonCustom(NonCustomPropertyId(44)),
                "text-decoration-line" => StaticId::NonCustom(NonCustomPropertyId(45)),
                "text-decoration-style" => StaticId::NonCustom(NonCustomPropertyId(46)),
                "text-justify" => StaticId::NonCustom(NonCustomPropertyId(47)),
                "text-rendering" => StaticId::NonCustom(NonCustomPropertyId(48)),
                "text-transform" => StaticId::NonCustom(NonCustomPropertyId(49)),
                "text-wrap-mode" => StaticId::NonCustom(NonCustomPropertyId(50)),
                "transform-style" => StaticId::NonCustom(NonCustomPropertyId(51)),
                "unicode-bidi" => StaticId::NonCustom(NonCustomPropertyId(52)),
                "visibility" => StaticId::NonCustom(NonCustomPropertyId(53)),
                "white-space-collapse" => StaticId::NonCustom(NonCustomPropertyId(54)),
                "word-break" => StaticId::NonCustom(NonCustomPropertyId(55)),
                "writing-mode" => StaticId::NonCustom(NonCustomPropertyId(56)),
                "z-index" => StaticId::NonCustom(NonCustomPropertyId(57)),
                "zoom" => StaticId::NonCustom(NonCustomPropertyId(58)),
                "align-content" => StaticId::NonCustom(NonCustomPropertyId(59)),
                "justify-content" => StaticId::NonCustom(NonCustomPropertyId(60)),
                "flex-grow" => StaticId::NonCustom(NonCustomPropertyId(61)),
                "flex-shrink" => StaticId::NonCustom(NonCustomPropertyId(62)),
                "align-self" => StaticId::NonCustom(NonCustomPropertyId(63)),
                "justify-self" => StaticId::NonCustom(NonCustomPropertyId(64)),
                "overflow-block" => StaticId::NonCustom(NonCustomPropertyId(65)),
                "overflow-inline" => StaticId::NonCustom(NonCustomPropertyId(66)),
                "overflow-x" => StaticId::NonCustom(NonCustomPropertyId(67)),
                "overflow-y" => StaticId::NonCustom(NonCustomPropertyId(68)),
                "border-block-end-style" => StaticId::NonCustom(NonCustomPropertyId(69)),
                "border-block-start-style" => StaticId::NonCustom(NonCustomPropertyId(70)),
                "border-bottom-style" => StaticId::NonCustom(NonCustomPropertyId(71)),
                "border-inline-end-style" => StaticId::NonCustom(NonCustomPropertyId(72)),
                "border-inline-start-style" => StaticId::NonCustom(NonCustomPropertyId(73)),
                "border-left-style" => StaticId::NonCustom(NonCustomPropertyId(74)),
                "border-right-style" => StaticId::NonCustom(NonCustomPropertyId(75)),
                "border-top-style" => StaticId::NonCustom(NonCustomPropertyId(76)),
                "animation-composition" => StaticId::NonCustom(NonCustomPropertyId(77)),
                "animation-delay" => StaticId::NonCustom(NonCustomPropertyId(78)),
                "animation-direction" => StaticId::NonCustom(NonCustomPropertyId(79)),
                "animation-duration" => StaticId::NonCustom(NonCustomPropertyId(80)),
                "animation-fill-mode" => StaticId::NonCustom(NonCustomPropertyId(81)),
                "animation-iteration-count" => StaticId::NonCustom(NonCustomPropertyId(82)),
                "animation-name" => StaticId::NonCustom(NonCustomPropertyId(83)),
                "animation-play-state" => StaticId::NonCustom(NonCustomPropertyId(84)),
                "animation-timeline" => StaticId::NonCustom(NonCustomPropertyId(85)),
                "animation-timing-function" => StaticId::NonCustom(NonCustomPropertyId(86)),
                "backdrop-filter" => StaticId::NonCustom(NonCustomPropertyId(87)),
                "background-attachment" => StaticId::NonCustom(NonCustomPropertyId(88)),
                "background-clip" => StaticId::NonCustom(NonCustomPropertyId(89)),
                "background-image" => StaticId::NonCustom(NonCustomPropertyId(90)),
                "background-origin" => StaticId::NonCustom(NonCustomPropertyId(91)),
                "background-position-x" => StaticId::NonCustom(NonCustomPropertyId(92)),
                "background-position-y" => StaticId::NonCustom(NonCustomPropertyId(93)),
                "background-repeat" => StaticId::NonCustom(NonCustomPropertyId(94)),
                "background-size" => StaticId::NonCustom(NonCustomPropertyId(95)),
                "border-image-outset" => StaticId::NonCustom(NonCustomPropertyId(96)),
                "border-image-slice" => StaticId::NonCustom(NonCustomPropertyId(97)),
                "border-image-width" => StaticId::NonCustom(NonCustomPropertyId(98)),
                "border-spacing" => StaticId::NonCustom(NonCustomPropertyId(99)),
                "box-shadow" => StaticId::NonCustom(NonCustomPropertyId(100)),
                "clip" => StaticId::NonCustom(NonCustomPropertyId(101)),
                "clip-path" => StaticId::NonCustom(NonCustomPropertyId(102)),
                "color" => StaticId::NonCustom(NonCustomPropertyId(103)),
                "color-scheme" => StaticId::NonCustom(NonCustomPropertyId(104)),
                "column-width" => StaticId::NonCustom(NonCustomPropertyId(105)),
                "container-name" => StaticId::NonCustom(NonCustomPropertyId(106)),
                "content" => StaticId::NonCustom(NonCustomPropertyId(107)),
                "counter-increment" => StaticId::NonCustom(NonCustomPropertyId(108)),
                "counter-reset" => StaticId::NonCustom(NonCustomPropertyId(109)),
                "cursor" => StaticId::NonCustom(NonCustomPropertyId(110)),
                "filter" => StaticId::NonCustom(NonCustomPropertyId(111)),
                "flex-basis" => StaticId::NonCustom(NonCustomPropertyId(112)),
                "font-family" => StaticId::NonCustom(NonCustomPropertyId(113)),
                "font-size" => StaticId::NonCustom(NonCustomPropertyId(114)),
                "font-variation-settings" => StaticId::NonCustom(NonCustomPropertyId(115)),
                "grid-template-areas" => StaticId::NonCustom(NonCustomPropertyId(116)),
                "letter-spacing" => StaticId::NonCustom(NonCustomPropertyId(117)),
                "line-height" => StaticId::NonCustom(NonCustomPropertyId(118)),
                "mask-image" => StaticId::NonCustom(NonCustomPropertyId(119)),
                "offset-path" => StaticId::NonCustom(NonCustomPropertyId(120)),
                "outline-offset" => StaticId::NonCustom(NonCustomPropertyId(121)),
                "overflow-clip-margin" => StaticId::NonCustom(NonCustomPropertyId(122)),
                "perspective" => StaticId::NonCustom(NonCustomPropertyId(123)),
                "quotes" => StaticId::NonCustom(NonCustomPropertyId(124)),
                "rotate" => StaticId::NonCustom(NonCustomPropertyId(125)),
                "scale" => StaticId::NonCustom(NonCustomPropertyId(126)),
                "text-indent" => StaticId::NonCustom(NonCustomPropertyId(127)),
                "text-overflow" => StaticId::NonCustom(NonCustomPropertyId(128)),
                "text-shadow" => StaticId::NonCustom(NonCustomPropertyId(129)),
                "transform" => StaticId::NonCustom(NonCustomPropertyId(130)),
                "transform-origin" => StaticId::NonCustom(NonCustomPropertyId(131)),
                "transition-behavior" => StaticId::NonCustom(NonCustomPropertyId(132)),
                "transition-delay" => StaticId::NonCustom(NonCustomPropertyId(133)),
                "transition-duration" => StaticId::NonCustom(NonCustomPropertyId(134)),
                "transition-property" => StaticId::NonCustom(NonCustomPropertyId(135)),
                "transition-timing-function" => StaticId::NonCustom(NonCustomPropertyId(136)),
                "translate" => StaticId::NonCustom(NonCustomPropertyId(137)),
                "vertical-align" => StaticId::NonCustom(NonCustomPropertyId(138)),
                "view-transition-class" => StaticId::NonCustom(NonCustomPropertyId(139)),
                "view-transition-name" => StaticId::NonCustom(NonCustomPropertyId(140)),
                "will-change" => StaticId::NonCustom(NonCustomPropertyId(141)),
                "word-spacing" => StaticId::NonCustom(NonCustomPropertyId(142)),
                "-x-lang" => StaticId::NonCustom(NonCustomPropertyId(143)),
                "object-position" => StaticId::NonCustom(NonCustomPropertyId(144)),
                "perspective-origin" => StaticId::NonCustom(NonCustomPropertyId(145)),
                "grid-template-columns" => StaticId::NonCustom(NonCustomPropertyId(146)),
                "grid-template-rows" => StaticId::NonCustom(NonCustomPropertyId(147)),
                "border-image-source" => StaticId::NonCustom(NonCustomPropertyId(148)),
                "list-style-image" => StaticId::NonCustom(NonCustomPropertyId(149)),
                "grid-auto-columns" => StaticId::NonCustom(NonCustomPropertyId(150)),
                "grid-auto-rows" => StaticId::NonCustom(NonCustomPropertyId(151)),
                "column-gap" => StaticId::NonCustom(NonCustomPropertyId(152)),
                "row-gap" => StaticId::NonCustom(NonCustomPropertyId(153)),
                "grid-column-end" => StaticId::NonCustom(NonCustomPropertyId(154)),
                "grid-column-start" => StaticId::NonCustom(NonCustomPropertyId(155)),
                "grid-row-end" => StaticId::NonCustom(NonCustomPropertyId(156)),
                "grid-row-start" => StaticId::NonCustom(NonCustomPropertyId(157)),
                "max-block-size" => StaticId::NonCustom(NonCustomPropertyId(158)),
                "max-height" => StaticId::NonCustom(NonCustomPropertyId(159)),
                "max-inline-size" => StaticId::NonCustom(NonCustomPropertyId(160)),
                "max-width" => StaticId::NonCustom(NonCustomPropertyId(161)),
                "border-bottom-left-radius" => StaticId::NonCustom(NonCustomPropertyId(162)),
                "border-bottom-right-radius" => StaticId::NonCustom(NonCustomPropertyId(163)),
                "border-end-end-radius" => StaticId::NonCustom(NonCustomPropertyId(164)),
                "border-end-start-radius" => StaticId::NonCustom(NonCustomPropertyId(165)),
                "border-start-end-radius" => StaticId::NonCustom(NonCustomPropertyId(166)),
                "border-start-start-radius" => StaticId::NonCustom(NonCustomPropertyId(167)),
                "border-top-left-radius" => StaticId::NonCustom(NonCustomPropertyId(168)),
                "border-top-right-radius" => StaticId::NonCustom(NonCustomPropertyId(169)),
                "bottom" => StaticId::NonCustom(NonCustomPropertyId(170)),
                "inset-block-end" => StaticId::NonCustom(NonCustomPropertyId(171)),
                "inset-block-start" => StaticId::NonCustom(NonCustomPropertyId(172)),
                "inset-inline-end" => StaticId::NonCustom(NonCustomPropertyId(173)),
                "inset-inline-start" => StaticId::NonCustom(NonCustomPropertyId(174)),
                "left" => StaticId::NonCustom(NonCustomPropertyId(175)),
                "right" => StaticId::NonCustom(NonCustomPropertyId(176)),
                "top" => StaticId::NonCustom(NonCustomPropertyId(177)),
                "margin-block-end" => StaticId::NonCustom(NonCustomPropertyId(178)),
                "margin-block-start" => StaticId::NonCustom(NonCustomPropertyId(179)),
                "margin-bottom" => StaticId::NonCustom(NonCustomPropertyId(180)),
                "margin-inline-end" => StaticId::NonCustom(NonCustomPropertyId(181)),
                "margin-inline-start" => StaticId::NonCustom(NonCustomPropertyId(182)),
                "margin-left" => StaticId::NonCustom(NonCustomPropertyId(183)),
                "margin-right" => StaticId::NonCustom(NonCustomPropertyId(184)),
                "margin-top" => StaticId::NonCustom(NonCustomPropertyId(185)),
                "padding-block-end" => StaticId::NonCustom(NonCustomPropertyId(186)),
                "padding-block-start" => StaticId::NonCustom(NonCustomPropertyId(187)),
                "padding-bottom" => StaticId::NonCustom(NonCustomPropertyId(188)),
                "padding-inline-end" => StaticId::NonCustom(NonCustomPropertyId(189)),
                "padding-inline-start" => StaticId::NonCustom(NonCustomPropertyId(190)),
                "padding-left" => StaticId::NonCustom(NonCustomPropertyId(191)),
                "padding-right" => StaticId::NonCustom(NonCustomPropertyId(192)),
                "padding-top" => StaticId::NonCustom(NonCustomPropertyId(193)),
                "block-size" => StaticId::NonCustom(NonCustomPropertyId(194)),
                "height" => StaticId::NonCustom(NonCustomPropertyId(195)),
                "inline-size" => StaticId::NonCustom(NonCustomPropertyId(196)),
                "min-block-size" => StaticId::NonCustom(NonCustomPropertyId(197)),
                "min-height" => StaticId::NonCustom(NonCustomPropertyId(198)),
                "min-inline-size" => StaticId::NonCustom(NonCustomPropertyId(199)),
                "min-width" => StaticId::NonCustom(NonCustomPropertyId(200)),
                "width" => StaticId::NonCustom(NonCustomPropertyId(201)),
                "border-block-end-width" => StaticId::NonCustom(NonCustomPropertyId(202)),
                "border-block-start-width" => StaticId::NonCustom(NonCustomPropertyId(203)),
                "border-bottom-width" => StaticId::NonCustom(NonCustomPropertyId(204)),
                "border-inline-end-width" => StaticId::NonCustom(NonCustomPropertyId(205)),
                "border-inline-start-width" => StaticId::NonCustom(NonCustomPropertyId(206)),
                "border-left-width" => StaticId::NonCustom(NonCustomPropertyId(207)),
                "border-right-width" => StaticId::NonCustom(NonCustomPropertyId(208)),
                "border-top-width" => StaticId::NonCustom(NonCustomPropertyId(209)),
                "outline-width" => StaticId::NonCustom(NonCustomPropertyId(210)),
                "background-color" => StaticId::NonCustom(NonCustomPropertyId(211)),
                "border-block-end-color" => StaticId::NonCustom(NonCustomPropertyId(212)),
                "border-block-start-color" => StaticId::NonCustom(NonCustomPropertyId(213)),
                "border-bottom-color" => StaticId::NonCustom(NonCustomPropertyId(214)),
                "border-inline-end-color" => StaticId::NonCustom(NonCustomPropertyId(215)),
                "border-inline-start-color" => StaticId::NonCustom(NonCustomPropertyId(216)),
                "border-left-color" => StaticId::NonCustom(NonCustomPropertyId(217)),
                "border-right-color" => StaticId::NonCustom(NonCustomPropertyId(218)),
                "border-top-color" => StaticId::NonCustom(NonCustomPropertyId(219)),
                "outline-color" => StaticId::NonCustom(NonCustomPropertyId(220)),
                "text-decoration-color" => StaticId::NonCustom(NonCustomPropertyId(221)),
                "background" => StaticId::NonCustom(NonCustomPropertyId(222)),
                "background-position" => StaticId::NonCustom(NonCustomPropertyId(223)),
                "border-color" => StaticId::NonCustom(NonCustomPropertyId(224)),
                "border-style" => StaticId::NonCustom(NonCustomPropertyId(225)),
                "border-width" => StaticId::NonCustom(NonCustomPropertyId(226)),
                "border-top" => StaticId::NonCustom(NonCustomPropertyId(227)),
                "border-right" => StaticId::NonCustom(NonCustomPropertyId(228)),
                "border-bottom" => StaticId::NonCustom(NonCustomPropertyId(229)),
                "border-left" => StaticId::NonCustom(NonCustomPropertyId(230)),
                "border-block-start" => StaticId::NonCustom(NonCustomPropertyId(231)),
                "border-block-end" => StaticId::NonCustom(NonCustomPropertyId(232)),
                "border-inline-start" => StaticId::NonCustom(NonCustomPropertyId(233)),
                "border-inline-end" => StaticId::NonCustom(NonCustomPropertyId(234)),
                "border" => StaticId::NonCustom(NonCustomPropertyId(235)),
                "border-radius" => StaticId::NonCustom(NonCustomPropertyId(236)),
                "border-image" => StaticId::NonCustom(NonCustomPropertyId(237)),
                "border-block-width" => StaticId::NonCustom(NonCustomPropertyId(238)),
                "border-block-style" => StaticId::NonCustom(NonCustomPropertyId(239)),
                "border-block-color" => StaticId::NonCustom(NonCustomPropertyId(240)),
                "border-inline-width" => StaticId::NonCustom(NonCustomPropertyId(241)),
                "border-inline-style" => StaticId::NonCustom(NonCustomPropertyId(242)),
                "border-inline-color" => StaticId::NonCustom(NonCustomPropertyId(243)),
                "border-block" => StaticId::NonCustom(NonCustomPropertyId(244)),
                "border-inline" => StaticId::NonCustom(NonCustomPropertyId(245)),
                "overflow" => StaticId::NonCustom(NonCustomPropertyId(246)),
                "columns" => StaticId::NonCustom(NonCustomPropertyId(247)),
                "font" => StaticId::NonCustom(NonCustomPropertyId(248)),
                "font-variant" => StaticId::NonCustom(NonCustomPropertyId(249)),
                "white-space" => StaticId::NonCustom(NonCustomPropertyId(250)),
                "list-style" => StaticId::NonCustom(NonCustomPropertyId(251)),
                "margin" => StaticId::NonCustom(NonCustomPropertyId(252)),
                "margin-block" => StaticId::NonCustom(NonCustomPropertyId(253)),
                "margin-inline" => StaticId::NonCustom(NonCustomPropertyId(254)),
                "outline" => StaticId::NonCustom(NonCustomPropertyId(255)),
                "padding" => StaticId::NonCustom(NonCustomPropertyId(256)),
                "padding-block" => StaticId::NonCustom(NonCustomPropertyId(257)),
                "padding-inline" => StaticId::NonCustom(NonCustomPropertyId(258)),
                "flex-flow" => StaticId::NonCustom(NonCustomPropertyId(259)),
                "flex" => StaticId::NonCustom(NonCustomPropertyId(260)),
                "gap" => StaticId::NonCustom(NonCustomPropertyId(261)),
                "grid-row" => StaticId::NonCustom(NonCustomPropertyId(262)),
                "grid-column" => StaticId::NonCustom(NonCustomPropertyId(263)),
                "grid-area" => StaticId::NonCustom(NonCustomPropertyId(264)),
                "grid-template" => StaticId::NonCustom(NonCustomPropertyId(265)),
                "grid" => StaticId::NonCustom(NonCustomPropertyId(266)),
                "place-content" => StaticId::NonCustom(NonCustomPropertyId(267)),
                "place-self" => StaticId::NonCustom(NonCustomPropertyId(268)),
                "place-items" => StaticId::NonCustom(NonCustomPropertyId(269)),
                "inset" => StaticId::NonCustom(NonCustomPropertyId(270)),
                "inset-block" => StaticId::NonCustom(NonCustomPropertyId(271)),
                "inset-inline" => StaticId::NonCustom(NonCustomPropertyId(272)),
                "text-decoration" => StaticId::NonCustom(NonCustomPropertyId(273)),
                "transition" => StaticId::NonCustom(NonCustomPropertyId(274)),
                "animation" => StaticId::NonCustom(NonCustomPropertyId(275)),
                "all" => StaticId::NonCustom(NonCustomPropertyId(276)),
                "word-wrap" => StaticId::NonCustom(NonCustomPropertyId(277)),
                "grid-column-gap" => StaticId::NonCustom(NonCustomPropertyId(278)),
                "grid-row-gap" => StaticId::NonCustom(NonCustomPropertyId(279)),
                "grid-gap" => StaticId::NonCustom(NonCustomPropertyId(280)),
                "-webkit-tap-highlight-color" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTapHighlightColor)
                },
                "speak" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::Speak)
                },
                "text-size-adjust" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::TextSizeAdjust)
                },
                "-webkit-user-drag" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitUserDrag)
                },
                "orphans" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::Orphans)
                },
                "widows" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::Widows)
                },
                "-webkit-user-modify" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitUserModify)
                },
                "-webkit-margin-before" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginBefore)
                },
                "-webkit-margin-after" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginAfter)
                },
                "-webkit-margin-start" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginStart)
                },
                "-webkit-column-break-inside" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnBreakInside)
                },
                "-webkit-padding-start" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitPaddingStart)
                },
                "-webkit-margin-end" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginEnd)
                },
                "-webkit-box-reflect" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBoxReflect)
                },
                "-webkit-print-color-adjust" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitPrintColorAdjust)
                },
                "-webkit-mask-box-image" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskBoxImage)
                },
                "-webkit-line-break" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitLineBreak)
                },
                "alignment-baseline" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::AlignmentBaseline)
                },
                "-webkit-writing-mode" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitWritingMode)
                },
                "baseline-shift" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::BaselineShift)
                },
                "-webkit-hyphenate-character" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitHyphenateCharacter)
                },
                "-webkit-highlight" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitHighlight)
                },
                "background-repeat-x" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::BackgroundRepeatX)
                },
                "-webkit-padding-end" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitPaddingEnd)
                },
                "background-repeat-y" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::BackgroundRepeatY)
                },
                "-webkit-text-emphasis-color" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTextEmphasisColor)
                },
                "-webkit-margin-top-collapse" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginTopCollapse)
                },
                "-webkit-rtl-ordering" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitRtlOrdering)
                },
                "-webkit-padding-before" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitPaddingBefore)
                },
                "-webkit-text-decorations-in-effect" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTextDecorationsInEffect)
                },
                "-webkit-border-vertical-spacing" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderVerticalSpacing)
                },
                "-webkit-locale" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitLocale)
                },
                "-webkit-padding-after" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitPaddingAfter)
                },
                "-webkit-border-horizontal-spacing" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderHorizontalSpacing)
                },
                "color-rendering" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::ColorRendering)
                },
                "-webkit-column-break-before" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnBreakBefore)
                },
                "-webkit-transform-origin-x" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTransformOriginX)
                },
                "-webkit-transform-origin-y" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTransformOriginY)
                },
                "-webkit-text-emphasis-position" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTextEmphasisPosition)
                },
                "buffered-rendering" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::BufferedRendering)
                },
                "-webkit-text-orientation" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTextOrientation)
                },
                "-webkit-text-combine" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTextCombine)
                },
                "-webkit-text-emphasis-style" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTextEmphasisStyle)
                },
                "-webkit-text-emphasis" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTextEmphasis)
                },
                "-webkit-mask-box-image-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskBoxImageWidth)
                },
                "-webkit-mask-box-image-source" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskBoxImageSource)
                },
                "-webkit-mask-box-image-outset" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskBoxImageOutset)
                },
                "-webkit-mask-box-image-slice" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskBoxImageSlice)
                },
                "-webkit-mask-box-image-repeat" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskBoxImageRepeat)
                },
                "-webkit-margin-after-collapse" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginAfterCollapse)
                },
                "-webkit-border-before-color" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderBeforeColor)
                },
                "-webkit-border-before-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderBeforeWidth)
                },
                "-webkit-perspective-origin-x" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitPerspectiveOriginX)
                },
                "-webkit-perspective-origin-y" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitPerspectiveOriginY)
                },
                "-webkit-margin-before-collapse" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginBeforeCollapse)
                },
                "-webkit-border-before-style" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderBeforeStyle)
                },
                "-webkit-margin-bottom-collapse" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginBottomCollapse)
                },
                "-webkit-ruby-position" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitRubyPosition)
                },
                "-webkit-column-break-after" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnBreakAfter)
                },
                "-webkit-margin-collapse" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMarginCollapse)
                },
                "-webkit-border-before" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderBefore)
                },
                "-webkit-border-end" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderEnd)
                },
                "-webkit-border-after" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderAfter)
                },
                "-webkit-border-start" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderStart)
                },
                "-webkit-min-logical-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMinLogicalWidth)
                },
                "-webkit-logical-height" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitLogicalHeight)
                },
                "-webkit-transform-origin-z" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitTransformOriginZ)
                },
                "-webkit-font-size-delta" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitFontSizeDelta)
                },
                "-webkit-logical-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitLogicalWidth)
                },
                "-webkit-max-logical-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaxLogicalWidth)
                },
                "-webkit-min-logical-height" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMinLogicalHeight)
                },
                "-webkit-max-logical-height" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaxLogicalHeight)
                },
                "-webkit-border-end-color" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderEndColor)
                },
                "-webkit-border-end-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderEndWidth)
                },
                "-webkit-border-start-color" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderStartColor)
                },
                "-webkit-border-start-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderStartWidth)
                },
                "-webkit-border-after-color" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderAfterColor)
                },
                "-webkit-border-after-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderAfterWidth)
                },
                "-webkit-border-end-style" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderEndStyle)
                },
                "-webkit-border-after-style" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderAfterStyle)
                },
                "-webkit-border-start-style" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBorderStartStyle)
                },
                "-webkit-mask-repeat-x" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskRepeatX)
                },
                "-webkit-mask-repeat-y" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitMaskRepeatY)
                },
                "user-zoom" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::UserZoom)
                },
                "min-zoom" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::MinZoom)
                },
                "-webkit-box-decoration-break" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitBoxDecorationBreak)
                },
                "orientation" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::Orientation)
                },
                "max-zoom" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::MaxZoom)
                },
                "-webkit-app-region" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitAppRegion)
                },
                "-webkit-column-rule" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnRule)
                },
                "-webkit-column-span" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnSpan)
                },
                "-webkit-column-gap" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnGap)
                },
                "-webkit-shape-outside" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitShapeOutside)
                },
                "-webkit-column-rule-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnRuleWidth)
                },
                "-webkit-column-count" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnCount)
                },
                "-webkit-opacity" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitOpacity)
                },
                "-webkit-column-width" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnWidth)
                },
                "-webkit-shape-image-threshold" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitShapeImageThreshold)
                },
                "-webkit-column-rule-style" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnRuleStyle)
                },
                "-webkit-columns" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumns)
                },
                "-webkit-column-rule-color" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitColumnRuleColor)
                },
                "-webkit-shape-margin" => {
                    StaticId::CountedUnknown(CountedUnknownProperty::WebkitShapeMargin)
                },
            }
        }

        if let Some(id) = static_ids::get(property_name) {
            return Ok(match *id {
                StaticId::NonCustom(id) => PropertyId::NonCustom(id),
                StaticId::CountedUnknown(unknown_prop) => {
                    if let Some(counters) = use_counters {
                        counters.counted_unknown_properties.record(unknown_prop);
                    }
                    // Always return Err(()) because these aren't valid custom property names.
                    return Err(());
                }
            });
        }

        let name = crate::custom_properties::parse_name(property_name)?;
        Ok(PropertyId::Custom(crate::custom_properties::Name::from(name)))
    }
}

impl PropertyDeclaration {
    /// Given a property declaration, return the property declaration id.
    #[inline]
    pub fn id(&self) -> PropertyDeclarationId<'_> {
        match *self {
            PropertyDeclaration::Custom(ref declaration) => {
                return PropertyDeclarationId::Custom(&declaration.name)
            }
            PropertyDeclaration::CSSWideKeyword(ref declaration) => {
                return PropertyDeclarationId::Longhand(declaration.id);
            }
            PropertyDeclaration::WithVariables(ref declaration) => {
                return PropertyDeclarationId::Longhand(declaration.id);
            }
            _ => {}
        }
        // This is just fine because PropertyDeclaration and LonghandId
        // have corresponding discriminants.
        let id = unsafe { *(self as *const _ as *const LonghandId) };
        debug_assert_eq!(id, match *self {
            PropertyDeclaration::AlignItems(..) => LonghandId::AlignItems,
            PropertyDeclaration::AspectRatio(..) => LonghandId::AspectRatio,
            PropertyDeclaration::BackfaceVisibility(..) => LonghandId::BackfaceVisibility,
            PropertyDeclaration::BaselineSource(..) => LonghandId::BaselineSource,
            PropertyDeclaration::BorderCollapse(..) => LonghandId::BorderCollapse,
            PropertyDeclaration::BorderImageRepeat(..) => LonghandId::BorderImageRepeat,
            PropertyDeclaration::BoxSizing(..) => LonghandId::BoxSizing,
            PropertyDeclaration::CaptionSide(..) => LonghandId::CaptionSide,
            PropertyDeclaration::Clear(..) => LonghandId::Clear,
            PropertyDeclaration::ColumnCount(..) => LonghandId::ColumnCount,
            PropertyDeclaration::ColumnSpan(..) => LonghandId::ColumnSpan,
            PropertyDeclaration::Contain(..) => LonghandId::Contain,
            PropertyDeclaration::ContainerType(..) => LonghandId::ContainerType,
            PropertyDeclaration::Direction(..) => LonghandId::Direction,
            PropertyDeclaration::Display(..) => LonghandId::Display,
            PropertyDeclaration::EmptyCells(..) => LonghandId::EmptyCells,
            PropertyDeclaration::FlexDirection(..) => LonghandId::FlexDirection,
            PropertyDeclaration::FlexWrap(..) => LonghandId::FlexWrap,
            PropertyDeclaration::Float(..) => LonghandId::Float,
            PropertyDeclaration::FontLanguageOverride(..) => LonghandId::FontLanguageOverride,
            PropertyDeclaration::FontStretch(..) => LonghandId::FontStretch,
            PropertyDeclaration::FontStyle(..) => LonghandId::FontStyle,
            PropertyDeclaration::FontSynthesisWeight(..) => LonghandId::FontSynthesisWeight,
            PropertyDeclaration::FontVariantCaps(..) => LonghandId::FontVariantCaps,
            PropertyDeclaration::FontWeight(..) => LonghandId::FontWeight,
            PropertyDeclaration::GridAutoFlow(..) => LonghandId::GridAutoFlow,
            PropertyDeclaration::ImageRendering(..) => LonghandId::ImageRendering,
            PropertyDeclaration::Isolation(..) => LonghandId::Isolation,
            PropertyDeclaration::JustifyItems(..) => LonghandId::JustifyItems,
            PropertyDeclaration::ListStylePosition(..) => LonghandId::ListStylePosition,
            PropertyDeclaration::ListStyleType(..) => LonghandId::ListStyleType,
            PropertyDeclaration::MixBlendMode(..) => LonghandId::MixBlendMode,
            PropertyDeclaration::ObjectFit(..) => LonghandId::ObjectFit,
            PropertyDeclaration::Opacity(..) => LonghandId::Opacity,
            PropertyDeclaration::Order(..) => LonghandId::Order,
            PropertyDeclaration::OutlineStyle(..) => LonghandId::OutlineStyle,
            PropertyDeclaration::OverflowWrap(..) => LonghandId::OverflowWrap,
            PropertyDeclaration::PointerEvents(..) => LonghandId::PointerEvents,
            PropertyDeclaration::Position(..) => LonghandId::Position,
            PropertyDeclaration::PositionArea(..) => LonghandId::PositionArea,
            PropertyDeclaration::ServoOverflowClipBox(..) => LonghandId::ServoOverflowClipBox,
            PropertyDeclaration::ServoTopLayer(..) => LonghandId::ServoTopLayer,
            PropertyDeclaration::TableLayout(..) => LonghandId::TableLayout,
            PropertyDeclaration::TextAlign(..) => LonghandId::TextAlign,
            PropertyDeclaration::TextAlignLast(..) => LonghandId::TextAlignLast,
            PropertyDeclaration::TextDecorationLine(..) => LonghandId::TextDecorationLine,
            PropertyDeclaration::TextDecorationStyle(..) => LonghandId::TextDecorationStyle,
            PropertyDeclaration::TextJustify(..) => LonghandId::TextJustify,
            PropertyDeclaration::TextRendering(..) => LonghandId::TextRendering,
            PropertyDeclaration::TextTransform(..) => LonghandId::TextTransform,
            PropertyDeclaration::TextWrapMode(..) => LonghandId::TextWrapMode,
            PropertyDeclaration::TransformStyle(..) => LonghandId::TransformStyle,
            PropertyDeclaration::UnicodeBidi(..) => LonghandId::UnicodeBidi,
            PropertyDeclaration::Visibility(..) => LonghandId::Visibility,
            PropertyDeclaration::WhiteSpaceCollapse(..) => LonghandId::WhiteSpaceCollapse,
            PropertyDeclaration::WordBreak(..) => LonghandId::WordBreak,
            PropertyDeclaration::WritingMode(..) => LonghandId::WritingMode,
            PropertyDeclaration::ZIndex(..) => LonghandId::ZIndex,
            PropertyDeclaration::Zoom(..) => LonghandId::Zoom,
            PropertyDeclaration::AlignContent(..) => LonghandId::AlignContent,
            PropertyDeclaration::JustifyContent(..) => LonghandId::JustifyContent,
            PropertyDeclaration::FlexGrow(..) => LonghandId::FlexGrow,
            PropertyDeclaration::FlexShrink(..) => LonghandId::FlexShrink,
            PropertyDeclaration::AlignSelf(..) => LonghandId::AlignSelf,
            PropertyDeclaration::JustifySelf(..) => LonghandId::JustifySelf,
            PropertyDeclaration::OverflowBlock(..) => LonghandId::OverflowBlock,
            PropertyDeclaration::OverflowInline(..) => LonghandId::OverflowInline,
            PropertyDeclaration::OverflowX(..) => LonghandId::OverflowX,
            PropertyDeclaration::OverflowY(..) => LonghandId::OverflowY,
            PropertyDeclaration::BorderBlockEndStyle(..) => LonghandId::BorderBlockEndStyle,
            PropertyDeclaration::BorderBlockStartStyle(..) => LonghandId::BorderBlockStartStyle,
            PropertyDeclaration::BorderBottomStyle(..) => LonghandId::BorderBottomStyle,
            PropertyDeclaration::BorderInlineEndStyle(..) => LonghandId::BorderInlineEndStyle,
            PropertyDeclaration::BorderInlineStartStyle(..) => LonghandId::BorderInlineStartStyle,
            PropertyDeclaration::BorderLeftStyle(..) => LonghandId::BorderLeftStyle,
            PropertyDeclaration::BorderRightStyle(..) => LonghandId::BorderRightStyle,
            PropertyDeclaration::BorderTopStyle(..) => LonghandId::BorderTopStyle,
            PropertyDeclaration::AnimationComposition(..) => LonghandId::AnimationComposition,
            PropertyDeclaration::AnimationDelay(..) => LonghandId::AnimationDelay,
            PropertyDeclaration::AnimationDirection(..) => LonghandId::AnimationDirection,
            PropertyDeclaration::AnimationDuration(..) => LonghandId::AnimationDuration,
            PropertyDeclaration::AnimationFillMode(..) => LonghandId::AnimationFillMode,
            PropertyDeclaration::AnimationIterationCount(..) => LonghandId::AnimationIterationCount,
            PropertyDeclaration::AnimationName(..) => LonghandId::AnimationName,
            PropertyDeclaration::AnimationPlayState(..) => LonghandId::AnimationPlayState,
            PropertyDeclaration::AnimationTimeline(..) => LonghandId::AnimationTimeline,
            PropertyDeclaration::AnimationTimingFunction(..) => LonghandId::AnimationTimingFunction,
            PropertyDeclaration::BackdropFilter(..) => LonghandId::BackdropFilter,
            PropertyDeclaration::BackgroundAttachment(..) => LonghandId::BackgroundAttachment,
            PropertyDeclaration::BackgroundClip(..) => LonghandId::BackgroundClip,
            PropertyDeclaration::BackgroundImage(..) => LonghandId::BackgroundImage,
            PropertyDeclaration::BackgroundOrigin(..) => LonghandId::BackgroundOrigin,
            PropertyDeclaration::BackgroundPositionX(..) => LonghandId::BackgroundPositionX,
            PropertyDeclaration::BackgroundPositionY(..) => LonghandId::BackgroundPositionY,
            PropertyDeclaration::BackgroundRepeat(..) => LonghandId::BackgroundRepeat,
            PropertyDeclaration::BackgroundSize(..) => LonghandId::BackgroundSize,
            PropertyDeclaration::BorderImageOutset(..) => LonghandId::BorderImageOutset,
            PropertyDeclaration::BorderImageSlice(..) => LonghandId::BorderImageSlice,
            PropertyDeclaration::BorderImageWidth(..) => LonghandId::BorderImageWidth,
            PropertyDeclaration::BorderSpacing(..) => LonghandId::BorderSpacing,
            PropertyDeclaration::BoxShadow(..) => LonghandId::BoxShadow,
            PropertyDeclaration::Clip(..) => LonghandId::Clip,
            PropertyDeclaration::ClipPath(..) => LonghandId::ClipPath,
            PropertyDeclaration::Color(..) => LonghandId::Color,
            PropertyDeclaration::ColorScheme(..) => LonghandId::ColorScheme,
            PropertyDeclaration::ColumnWidth(..) => LonghandId::ColumnWidth,
            PropertyDeclaration::ContainerName(..) => LonghandId::ContainerName,
            PropertyDeclaration::Content(..) => LonghandId::Content,
            PropertyDeclaration::CounterIncrement(..) => LonghandId::CounterIncrement,
            PropertyDeclaration::CounterReset(..) => LonghandId::CounterReset,
            PropertyDeclaration::Cursor(..) => LonghandId::Cursor,
            PropertyDeclaration::Filter(..) => LonghandId::Filter,
            PropertyDeclaration::FlexBasis(..) => LonghandId::FlexBasis,
            PropertyDeclaration::FontFamily(..) => LonghandId::FontFamily,
            PropertyDeclaration::FontSize(..) => LonghandId::FontSize,
            PropertyDeclaration::FontVariationSettings(..) => LonghandId::FontVariationSettings,
            PropertyDeclaration::GridTemplateAreas(..) => LonghandId::GridTemplateAreas,
            PropertyDeclaration::LetterSpacing(..) => LonghandId::LetterSpacing,
            PropertyDeclaration::LineHeight(..) => LonghandId::LineHeight,
            PropertyDeclaration::MaskImage(..) => LonghandId::MaskImage,
            PropertyDeclaration::OffsetPath(..) => LonghandId::OffsetPath,
            PropertyDeclaration::OutlineOffset(..) => LonghandId::OutlineOffset,
            PropertyDeclaration::OverflowClipMargin(..) => LonghandId::OverflowClipMargin,
            PropertyDeclaration::Perspective(..) => LonghandId::Perspective,
            PropertyDeclaration::Quotes(..) => LonghandId::Quotes,
            PropertyDeclaration::Rotate(..) => LonghandId::Rotate,
            PropertyDeclaration::Scale(..) => LonghandId::Scale,
            PropertyDeclaration::TextIndent(..) => LonghandId::TextIndent,
            PropertyDeclaration::TextOverflow(..) => LonghandId::TextOverflow,
            PropertyDeclaration::TextShadow(..) => LonghandId::TextShadow,
            PropertyDeclaration::Transform(..) => LonghandId::Transform,
            PropertyDeclaration::TransformOrigin(..) => LonghandId::TransformOrigin,
            PropertyDeclaration::TransitionBehavior(..) => LonghandId::TransitionBehavior,
            PropertyDeclaration::TransitionDelay(..) => LonghandId::TransitionDelay,
            PropertyDeclaration::TransitionDuration(..) => LonghandId::TransitionDuration,
            PropertyDeclaration::TransitionProperty(..) => LonghandId::TransitionProperty,
            PropertyDeclaration::TransitionTimingFunction(..) => LonghandId::TransitionTimingFunction,
            PropertyDeclaration::Translate(..) => LonghandId::Translate,
            PropertyDeclaration::VerticalAlign(..) => LonghandId::VerticalAlign,
            PropertyDeclaration::ViewTransitionClass(..) => LonghandId::ViewTransitionClass,
            PropertyDeclaration::ViewTransitionName(..) => LonghandId::ViewTransitionName,
            PropertyDeclaration::WillChange(..) => LonghandId::WillChange,
            PropertyDeclaration::WordSpacing(..) => LonghandId::WordSpacing,
            PropertyDeclaration::XLang(..) => LonghandId::XLang,
            PropertyDeclaration::ObjectPosition(..) => LonghandId::ObjectPosition,
            PropertyDeclaration::PerspectiveOrigin(..) => LonghandId::PerspectiveOrigin,
            PropertyDeclaration::GridTemplateColumns(..) => LonghandId::GridTemplateColumns,
            PropertyDeclaration::GridTemplateRows(..) => LonghandId::GridTemplateRows,
            PropertyDeclaration::BorderImageSource(..) => LonghandId::BorderImageSource,
            PropertyDeclaration::ListStyleImage(..) => LonghandId::ListStyleImage,
            PropertyDeclaration::GridAutoColumns(..) => LonghandId::GridAutoColumns,
            PropertyDeclaration::GridAutoRows(..) => LonghandId::GridAutoRows,
            PropertyDeclaration::ColumnGap(..) => LonghandId::ColumnGap,
            PropertyDeclaration::RowGap(..) => LonghandId::RowGap,
            PropertyDeclaration::GridColumnEnd(..) => LonghandId::GridColumnEnd,
            PropertyDeclaration::GridColumnStart(..) => LonghandId::GridColumnStart,
            PropertyDeclaration::GridRowEnd(..) => LonghandId::GridRowEnd,
            PropertyDeclaration::GridRowStart(..) => LonghandId::GridRowStart,
            PropertyDeclaration::MaxBlockSize(..) => LonghandId::MaxBlockSize,
            PropertyDeclaration::MaxHeight(..) => LonghandId::MaxHeight,
            PropertyDeclaration::MaxInlineSize(..) => LonghandId::MaxInlineSize,
            PropertyDeclaration::MaxWidth(..) => LonghandId::MaxWidth,
            PropertyDeclaration::BorderBottomLeftRadius(..) => LonghandId::BorderBottomLeftRadius,
            PropertyDeclaration::BorderBottomRightRadius(..) => LonghandId::BorderBottomRightRadius,
            PropertyDeclaration::BorderEndEndRadius(..) => LonghandId::BorderEndEndRadius,
            PropertyDeclaration::BorderEndStartRadius(..) => LonghandId::BorderEndStartRadius,
            PropertyDeclaration::BorderStartEndRadius(..) => LonghandId::BorderStartEndRadius,
            PropertyDeclaration::BorderStartStartRadius(..) => LonghandId::BorderStartStartRadius,
            PropertyDeclaration::BorderTopLeftRadius(..) => LonghandId::BorderTopLeftRadius,
            PropertyDeclaration::BorderTopRightRadius(..) => LonghandId::BorderTopRightRadius,
            PropertyDeclaration::Bottom(..) => LonghandId::Bottom,
            PropertyDeclaration::InsetBlockEnd(..) => LonghandId::InsetBlockEnd,
            PropertyDeclaration::InsetBlockStart(..) => LonghandId::InsetBlockStart,
            PropertyDeclaration::InsetInlineEnd(..) => LonghandId::InsetInlineEnd,
            PropertyDeclaration::InsetInlineStart(..) => LonghandId::InsetInlineStart,
            PropertyDeclaration::Left(..) => LonghandId::Left,
            PropertyDeclaration::Right(..) => LonghandId::Right,
            PropertyDeclaration::Top(..) => LonghandId::Top,
            PropertyDeclaration::MarginBlockEnd(..) => LonghandId::MarginBlockEnd,
            PropertyDeclaration::MarginBlockStart(..) => LonghandId::MarginBlockStart,
            PropertyDeclaration::MarginBottom(..) => LonghandId::MarginBottom,
            PropertyDeclaration::MarginInlineEnd(..) => LonghandId::MarginInlineEnd,
            PropertyDeclaration::MarginInlineStart(..) => LonghandId::MarginInlineStart,
            PropertyDeclaration::MarginLeft(..) => LonghandId::MarginLeft,
            PropertyDeclaration::MarginRight(..) => LonghandId::MarginRight,
            PropertyDeclaration::MarginTop(..) => LonghandId::MarginTop,
            PropertyDeclaration::PaddingBlockEnd(..) => LonghandId::PaddingBlockEnd,
            PropertyDeclaration::PaddingBlockStart(..) => LonghandId::PaddingBlockStart,
            PropertyDeclaration::PaddingBottom(..) => LonghandId::PaddingBottom,
            PropertyDeclaration::PaddingInlineEnd(..) => LonghandId::PaddingInlineEnd,
            PropertyDeclaration::PaddingInlineStart(..) => LonghandId::PaddingInlineStart,
            PropertyDeclaration::PaddingLeft(..) => LonghandId::PaddingLeft,
            PropertyDeclaration::PaddingRight(..) => LonghandId::PaddingRight,
            PropertyDeclaration::PaddingTop(..) => LonghandId::PaddingTop,
            PropertyDeclaration::BlockSize(..) => LonghandId::BlockSize,
            PropertyDeclaration::Height(..) => LonghandId::Height,
            PropertyDeclaration::InlineSize(..) => LonghandId::InlineSize,
            PropertyDeclaration::MinBlockSize(..) => LonghandId::MinBlockSize,
            PropertyDeclaration::MinHeight(..) => LonghandId::MinHeight,
            PropertyDeclaration::MinInlineSize(..) => LonghandId::MinInlineSize,
            PropertyDeclaration::MinWidth(..) => LonghandId::MinWidth,
            PropertyDeclaration::Width(..) => LonghandId::Width,
            PropertyDeclaration::BorderBlockEndWidth(..) => LonghandId::BorderBlockEndWidth,
            PropertyDeclaration::BorderBlockStartWidth(..) => LonghandId::BorderBlockStartWidth,
            PropertyDeclaration::BorderBottomWidth(..) => LonghandId::BorderBottomWidth,
            PropertyDeclaration::BorderInlineEndWidth(..) => LonghandId::BorderInlineEndWidth,
            PropertyDeclaration::BorderInlineStartWidth(..) => LonghandId::BorderInlineStartWidth,
            PropertyDeclaration::BorderLeftWidth(..) => LonghandId::BorderLeftWidth,
            PropertyDeclaration::BorderRightWidth(..) => LonghandId::BorderRightWidth,
            PropertyDeclaration::BorderTopWidth(..) => LonghandId::BorderTopWidth,
            PropertyDeclaration::OutlineWidth(..) => LonghandId::OutlineWidth,
            PropertyDeclaration::BackgroundColor(..) => LonghandId::BackgroundColor,
            PropertyDeclaration::BorderBlockEndColor(..) => LonghandId::BorderBlockEndColor,
            PropertyDeclaration::BorderBlockStartColor(..) => LonghandId::BorderBlockStartColor,
            PropertyDeclaration::BorderBottomColor(..) => LonghandId::BorderBottomColor,
            PropertyDeclaration::BorderInlineEndColor(..) => LonghandId::BorderInlineEndColor,
            PropertyDeclaration::BorderInlineStartColor(..) => LonghandId::BorderInlineStartColor,
            PropertyDeclaration::BorderLeftColor(..) => LonghandId::BorderLeftColor,
            PropertyDeclaration::BorderRightColor(..) => LonghandId::BorderRightColor,
            PropertyDeclaration::BorderTopColor(..) => LonghandId::BorderTopColor,
            PropertyDeclaration::OutlineColor(..) => LonghandId::OutlineColor,
            PropertyDeclaration::TextDecorationColor(..) => LonghandId::TextDecorationColor,
            _ => id,
        });
        PropertyDeclarationId::Longhand(id)
    }

    /// Given a declaration, convert it into a declaration for a corresponding
    /// physical property.
    #[inline]
    pub fn to_physical(&self, wm: WritingMode) -> Self {
        match *self {
            PropertyDeclaration::WithVariables(VariableDeclaration {
                id,
                ref value,
            }) => {
                return PropertyDeclaration::WithVariables(VariableDeclaration {
                    id: id.to_physical(wm),
                    value: value.clone(),
                })
            }
            PropertyDeclaration::CSSWideKeyword(WideKeywordDeclaration {
                id,
                keyword,
            }) => {
                return PropertyDeclaration::CSSWideKeyword(WideKeywordDeclaration {
                    id: id.to_physical(wm),
                    keyword,
                })
            }
            PropertyDeclaration::Custom(..) => return self.clone(),
            PropertyDeclaration::AlignItems(..) => {},
            PropertyDeclaration::AspectRatio(..) => {},
            PropertyDeclaration::BackfaceVisibility(..) => {},
            PropertyDeclaration::BaselineSource(..) => {},
            PropertyDeclaration::BorderCollapse(..) => {},
            PropertyDeclaration::BorderImageRepeat(..) => {},
            PropertyDeclaration::BoxSizing(..) => {},
            PropertyDeclaration::CaptionSide(..) => {},
            PropertyDeclaration::Clear(..) => {},
            PropertyDeclaration::ColumnCount(..) => {},
            PropertyDeclaration::ColumnSpan(..) => {},
            PropertyDeclaration::Contain(..) => {},
            PropertyDeclaration::ContainerType(..) => {},
            PropertyDeclaration::Direction(..) => {},
            PropertyDeclaration::Display(..) => {},
            PropertyDeclaration::EmptyCells(..) => {},
            PropertyDeclaration::FlexDirection(..) => {},
            PropertyDeclaration::FlexWrap(..) => {},
            PropertyDeclaration::Float(..) => {},
            PropertyDeclaration::FontLanguageOverride(..) => {},
            PropertyDeclaration::FontStretch(..) => {},
            PropertyDeclaration::FontStyle(..) => {},
            PropertyDeclaration::FontSynthesisWeight(..) => {},
            PropertyDeclaration::FontVariantCaps(..) => {},
            PropertyDeclaration::FontWeight(..) => {},
            PropertyDeclaration::GridAutoFlow(..) => {},
            PropertyDeclaration::ImageRendering(..) => {},
            PropertyDeclaration::Isolation(..) => {},
            PropertyDeclaration::JustifyItems(..) => {},
            PropertyDeclaration::ListStylePosition(..) => {},
            PropertyDeclaration::ListStyleType(..) => {},
            PropertyDeclaration::MixBlendMode(..) => {},
            PropertyDeclaration::ObjectFit(..) => {},
            PropertyDeclaration::Opacity(..) => {},
            PropertyDeclaration::Order(..) => {},
            PropertyDeclaration::OutlineStyle(..) => {},
            PropertyDeclaration::OverflowWrap(..) => {},
            PropertyDeclaration::PointerEvents(..) => {},
            PropertyDeclaration::Position(..) => {},
            PropertyDeclaration::PositionArea(..) => {},
            PropertyDeclaration::ServoOverflowClipBox(..) => {},
            PropertyDeclaration::ServoTopLayer(..) => {},
            PropertyDeclaration::TableLayout(..) => {},
            PropertyDeclaration::TextAlign(..) => {},
            PropertyDeclaration::TextAlignLast(..) => {},
            PropertyDeclaration::TextDecorationLine(..) => {},
            PropertyDeclaration::TextDecorationStyle(..) => {},
            PropertyDeclaration::TextJustify(..) => {},
            PropertyDeclaration::TextRendering(..) => {},
            PropertyDeclaration::TextTransform(..) => {},
            PropertyDeclaration::TextWrapMode(..) => {},
            PropertyDeclaration::TransformStyle(..) => {},
            PropertyDeclaration::UnicodeBidi(..) => {},
            PropertyDeclaration::Visibility(..) => {},
            PropertyDeclaration::WhiteSpaceCollapse(..) => {},
            PropertyDeclaration::WordBreak(..) => {},
            PropertyDeclaration::WritingMode(..) => {},
            PropertyDeclaration::ZIndex(..) => {},
            PropertyDeclaration::Zoom(..) => {},
            PropertyDeclaration::AlignContent(..) => {},
            PropertyDeclaration::JustifyContent(..) => {},
            PropertyDeclaration::FlexGrow(..) => {},
            PropertyDeclaration::FlexShrink(..) => {},
            PropertyDeclaration::AlignSelf(..) => {},
            PropertyDeclaration::JustifySelf(..) => {},
            PropertyDeclaration::OverflowBlock(..) => {},
            PropertyDeclaration::OverflowInline(..) => {},
            PropertyDeclaration::OverflowX(..) => {},
            PropertyDeclaration::OverflowY(..) => {},
            PropertyDeclaration::BorderBlockEndStyle(..) => {},
            PropertyDeclaration::BorderBlockStartStyle(..) => {},
            PropertyDeclaration::BorderBottomStyle(..) => {},
            PropertyDeclaration::BorderInlineEndStyle(..) => {},
            PropertyDeclaration::BorderInlineStartStyle(..) => {},
            PropertyDeclaration::BorderLeftStyle(..) => {},
            PropertyDeclaration::BorderRightStyle(..) => {},
            PropertyDeclaration::BorderTopStyle(..) => {},
            PropertyDeclaration::AnimationComposition(..) => {},
            PropertyDeclaration::AnimationDelay(..) => {},
            PropertyDeclaration::AnimationDirection(..) => {},
            PropertyDeclaration::AnimationDuration(..) => {},
            PropertyDeclaration::AnimationFillMode(..) => {},
            PropertyDeclaration::AnimationIterationCount(..) => {},
            PropertyDeclaration::AnimationName(..) => {},
            PropertyDeclaration::AnimationPlayState(..) => {},
            PropertyDeclaration::AnimationTimeline(..) => {},
            PropertyDeclaration::AnimationTimingFunction(..) => {},
            PropertyDeclaration::BackdropFilter(..) => {},
            PropertyDeclaration::BackgroundAttachment(..) => {},
            PropertyDeclaration::BackgroundClip(..) => {},
            PropertyDeclaration::BackgroundImage(..) => {},
            PropertyDeclaration::BackgroundOrigin(..) => {},
            PropertyDeclaration::BackgroundPositionX(..) => {},
            PropertyDeclaration::BackgroundPositionY(..) => {},
            PropertyDeclaration::BackgroundRepeat(..) => {},
            PropertyDeclaration::BackgroundSize(..) => {},
            PropertyDeclaration::BorderImageOutset(..) => {},
            PropertyDeclaration::BorderImageSlice(..) => {},
            PropertyDeclaration::BorderImageWidth(..) => {},
            PropertyDeclaration::BorderSpacing(..) => {},
            PropertyDeclaration::BoxShadow(..) => {},
            PropertyDeclaration::Clip(..) => {},
            PropertyDeclaration::ClipPath(..) => {},
            PropertyDeclaration::Color(..) => {},
            PropertyDeclaration::ColorScheme(..) => {},
            PropertyDeclaration::ColumnWidth(..) => {},
            PropertyDeclaration::ContainerName(..) => {},
            PropertyDeclaration::Content(..) => {},
            PropertyDeclaration::CounterIncrement(..) => {},
            PropertyDeclaration::CounterReset(..) => {},
            PropertyDeclaration::Cursor(..) => {},
            PropertyDeclaration::Filter(..) => {},
            PropertyDeclaration::FlexBasis(..) => {},
            PropertyDeclaration::FontFamily(..) => {},
            PropertyDeclaration::FontSize(..) => {},
            PropertyDeclaration::FontVariationSettings(..) => {},
            PropertyDeclaration::GridTemplateAreas(..) => {},
            PropertyDeclaration::LetterSpacing(..) => {},
            PropertyDeclaration::LineHeight(..) => {},
            PropertyDeclaration::MaskImage(..) => {},
            PropertyDeclaration::OffsetPath(..) => {},
            PropertyDeclaration::OutlineOffset(..) => {},
            PropertyDeclaration::OverflowClipMargin(..) => {},
            PropertyDeclaration::Perspective(..) => {},
            PropertyDeclaration::Quotes(..) => {},
            PropertyDeclaration::Rotate(..) => {},
            PropertyDeclaration::Scale(..) => {},
            PropertyDeclaration::TextIndent(..) => {},
            PropertyDeclaration::TextOverflow(..) => {},
            PropertyDeclaration::TextShadow(..) => {},
            PropertyDeclaration::Transform(..) => {},
            PropertyDeclaration::TransformOrigin(..) => {},
            PropertyDeclaration::TransitionBehavior(..) => {},
            PropertyDeclaration::TransitionDelay(..) => {},
            PropertyDeclaration::TransitionDuration(..) => {},
            PropertyDeclaration::TransitionProperty(..) => {},
            PropertyDeclaration::TransitionTimingFunction(..) => {},
            PropertyDeclaration::Translate(..) => {},
            PropertyDeclaration::VerticalAlign(..) => {},
            PropertyDeclaration::ViewTransitionClass(..) => {},
            PropertyDeclaration::ViewTransitionName(..) => {},
            PropertyDeclaration::WillChange(..) => {},
            PropertyDeclaration::WordSpacing(..) => {},
            PropertyDeclaration::XLang(..) => {},
            PropertyDeclaration::ObjectPosition(..) => {},
            PropertyDeclaration::PerspectiveOrigin(..) => {},
            PropertyDeclaration::GridTemplateColumns(..) => {},
            PropertyDeclaration::GridTemplateRows(..) => {},
            PropertyDeclaration::BorderImageSource(..) => {},
            PropertyDeclaration::ListStyleImage(..) => {},
            PropertyDeclaration::GridAutoColumns(..) => {},
            PropertyDeclaration::GridAutoRows(..) => {},
            PropertyDeclaration::ColumnGap(..) => {},
            PropertyDeclaration::RowGap(..) => {},
            PropertyDeclaration::GridColumnEnd(..) => {},
            PropertyDeclaration::GridColumnStart(..) => {},
            PropertyDeclaration::GridRowEnd(..) => {},
            PropertyDeclaration::GridRowStart(..) => {},
            PropertyDeclaration::MaxBlockSize(..) => {},
            PropertyDeclaration::MaxHeight(..) => {},
            PropertyDeclaration::MaxInlineSize(..) => {},
            PropertyDeclaration::MaxWidth(..) => {},
            PropertyDeclaration::BorderBottomLeftRadius(..) => {},
            PropertyDeclaration::BorderBottomRightRadius(..) => {},
            PropertyDeclaration::BorderEndEndRadius(..) => {},
            PropertyDeclaration::BorderEndStartRadius(..) => {},
            PropertyDeclaration::BorderStartEndRadius(..) => {},
            PropertyDeclaration::BorderStartStartRadius(..) => {},
            PropertyDeclaration::BorderTopLeftRadius(..) => {},
            PropertyDeclaration::BorderTopRightRadius(..) => {},
            PropertyDeclaration::Bottom(..) => {},
            PropertyDeclaration::InsetBlockEnd(..) => {},
            PropertyDeclaration::InsetBlockStart(..) => {},
            PropertyDeclaration::InsetInlineEnd(..) => {},
            PropertyDeclaration::InsetInlineStart(..) => {},
            PropertyDeclaration::Left(..) => {},
            PropertyDeclaration::Right(..) => {},
            PropertyDeclaration::Top(..) => {},
            PropertyDeclaration::MarginBlockEnd(..) => {},
            PropertyDeclaration::MarginBlockStart(..) => {},
            PropertyDeclaration::MarginBottom(..) => {},
            PropertyDeclaration::MarginInlineEnd(..) => {},
            PropertyDeclaration::MarginInlineStart(..) => {},
            PropertyDeclaration::MarginLeft(..) => {},
            PropertyDeclaration::MarginRight(..) => {},
            PropertyDeclaration::MarginTop(..) => {},
            PropertyDeclaration::PaddingBlockEnd(..) => {},
            PropertyDeclaration::PaddingBlockStart(..) => {},
            PropertyDeclaration::PaddingBottom(..) => {},
            PropertyDeclaration::PaddingInlineEnd(..) => {},
            PropertyDeclaration::PaddingInlineStart(..) => {},
            PropertyDeclaration::PaddingLeft(..) => {},
            PropertyDeclaration::PaddingRight(..) => {},
            PropertyDeclaration::PaddingTop(..) => {},
            PropertyDeclaration::BlockSize(..) => {},
            PropertyDeclaration::Height(..) => {},
            PropertyDeclaration::InlineSize(..) => {},
            PropertyDeclaration::MinBlockSize(..) => {},
            PropertyDeclaration::MinHeight(..) => {},
            PropertyDeclaration::MinInlineSize(..) => {},
            PropertyDeclaration::MinWidth(..) => {},
            PropertyDeclaration::Width(..) => {},
            PropertyDeclaration::BorderBlockEndWidth(..) => {},
            PropertyDeclaration::BorderBlockStartWidth(..) => {},
            PropertyDeclaration::BorderBottomWidth(..) => {},
            PropertyDeclaration::BorderInlineEndWidth(..) => {},
            PropertyDeclaration::BorderInlineStartWidth(..) => {},
            PropertyDeclaration::BorderLeftWidth(..) => {},
            PropertyDeclaration::BorderRightWidth(..) => {},
            PropertyDeclaration::BorderTopWidth(..) => {},
            PropertyDeclaration::OutlineWidth(..) => {},
            PropertyDeclaration::BackgroundColor(..) => {},
            PropertyDeclaration::BorderBlockEndColor(..) => {},
            PropertyDeclaration::BorderBlockStartColor(..) => {},
            PropertyDeclaration::BorderBottomColor(..) => {},
            PropertyDeclaration::BorderInlineEndColor(..) => {},
            PropertyDeclaration::BorderInlineStartColor(..) => {},
            PropertyDeclaration::BorderLeftColor(..) => {},
            PropertyDeclaration::BorderRightColor(..) => {},
            PropertyDeclaration::BorderTopColor(..) => {},
            PropertyDeclaration::OutlineColor(..) => {},
            PropertyDeclaration::TextDecorationColor(..) => {},
        }

        let mut ret = self.clone();


        unsafe {
            let longhand_id = *(&mut ret as *mut _ as *mut LonghandId);

            debug_assert_eq!(
                PropertyDeclarationId::Longhand(longhand_id),
                ret.id()
            );

            // This is just fine because PropertyDeclaration and LonghandId
            // have corresponding discriminants.
            *(&mut ret as *mut _ as *mut LonghandId) = longhand_id.to_physical(wm);

            debug_assert_eq!(
                PropertyDeclarationId::Longhand(longhand_id.to_physical(wm)),
                ret.id()
            );
        }

        ret
    }

    /// Returns whether or not the property is set by a system font
    pub fn get_system(&self) -> Option<SystemFont> {
        match *self {
            _ => None,
        }
    }
}

#[cfg(feature = "gecko")]
pub use super::gecko::style_structs;

/// The module where all the style structs are defined.
#[cfg(feature = "servo")]
pub mod style_structs {
    use rustc_hash::FxHasher;
    use super::longhands;
    use std::hash::{Hash, Hasher};
    use crate::logical_geometry::PhysicalSide;
    use crate::values::specified::color::ColorSchemeFlags;

    

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Background style struct.
        pub struct Background {
                    /// The background-color computed value.
                    pub background_color: longhands::background_color::computed_value::T,
                    /// The background-image computed value.
                    pub background_image: longhands::background_image::computed_value::T,
                    /// The background-position-x computed value.
                    pub background_position_x: longhands::background_position_x::computed_value::T,
                    /// The background-position-y computed value.
                    pub background_position_y: longhands::background_position_y::computed_value::T,
                    /// The background-repeat computed value.
                    pub background_repeat: longhands::background_repeat::computed_value::T,
                    /// The background-attachment computed value.
                    pub background_attachment: longhands::background_attachment::computed_value::T,
                    /// The background-clip computed value.
                    pub background_clip: longhands::background_clip::computed_value::T,
                    /// The background-origin computed value.
                    pub background_origin: longhands::background_origin::computed_value::T,
                    /// The background-size computed value.
                    pub background_size: longhands::background_size::computed_value::T,
        }

        impl Background {
                        /// Set background-color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_color(&mut self, v: longhands::background_color::computed_value::T) {
                            self.background_color = v;
                        }
                        /// Set background-color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_color_from(&mut self, other: &Self) {
                            self.background_color = other.background_color.clone();
                        }
                    /// Reset background-color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_color(&mut self, other: &Self) {
                        self.copy_background_color_from(other)
                    }

                    /// Get the computed value for background-color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_color(&self) -> longhands::background_color::computed_value::T {
                        self.background_color.clone()
                    }
                        /// Set background-image.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_image(&mut self, v: longhands::background_image::computed_value::T) {
                            self.background_image = v;
                        }
                        /// Set background-image from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_image_from(&mut self, other: &Self) {
                            self.background_image = other.background_image.clone();
                        }
                    /// Reset background-image from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_image(&mut self, other: &Self) {
                        self.copy_background_image_from(other)
                    }

                    /// Get the computed value for background-image.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_image(&self) -> longhands::background_image::computed_value::T {
                        self.background_image.clone()
                    }
                        /// Set background-position-x.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_position_x(&mut self, v: longhands::background_position_x::computed_value::T) {
                            self.background_position_x = v;
                        }
                        /// Set background-position-x from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_position_x_from(&mut self, other: &Self) {
                            self.background_position_x = other.background_position_x.clone();
                        }
                    /// Reset background-position-x from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_position_x(&mut self, other: &Self) {
                        self.copy_background_position_x_from(other)
                    }

                    /// Get the computed value for background-position-x.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_position_x(&self) -> longhands::background_position_x::computed_value::T {
                        self.background_position_x.clone()
                    }
                        /// Set background-position-y.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_position_y(&mut self, v: longhands::background_position_y::computed_value::T) {
                            self.background_position_y = v;
                        }
                        /// Set background-position-y from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_position_y_from(&mut self, other: &Self) {
                            self.background_position_y = other.background_position_y.clone();
                        }
                    /// Reset background-position-y from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_position_y(&mut self, other: &Self) {
                        self.copy_background_position_y_from(other)
                    }

                    /// Get the computed value for background-position-y.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_position_y(&self) -> longhands::background_position_y::computed_value::T {
                        self.background_position_y.clone()
                    }
                        /// Set background-repeat.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_repeat(&mut self, v: longhands::background_repeat::computed_value::T) {
                            self.background_repeat = v;
                        }
                        /// Set background-repeat from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_repeat_from(&mut self, other: &Self) {
                            self.background_repeat = other.background_repeat.clone();
                        }
                    /// Reset background-repeat from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_repeat(&mut self, other: &Self) {
                        self.copy_background_repeat_from(other)
                    }

                    /// Get the computed value for background-repeat.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_repeat(&self) -> longhands::background_repeat::computed_value::T {
                        self.background_repeat.clone()
                    }
                        /// Set background-attachment.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_attachment(&mut self, v: longhands::background_attachment::computed_value::T) {
                            self.background_attachment = v;
                        }
                        /// Set background-attachment from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_attachment_from(&mut self, other: &Self) {
                            self.background_attachment = other.background_attachment.clone();
                        }
                    /// Reset background-attachment from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_attachment(&mut self, other: &Self) {
                        self.copy_background_attachment_from(other)
                    }

                    /// Get the computed value for background-attachment.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_attachment(&self) -> longhands::background_attachment::computed_value::T {
                        self.background_attachment.clone()
                    }
                        /// Set background-clip.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_clip(&mut self, v: longhands::background_clip::computed_value::T) {
                            self.background_clip = v;
                        }
                        /// Set background-clip from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_clip_from(&mut self, other: &Self) {
                            self.background_clip = other.background_clip.clone();
                        }
                    /// Reset background-clip from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_clip(&mut self, other: &Self) {
                        self.copy_background_clip_from(other)
                    }

                    /// Get the computed value for background-clip.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_clip(&self) -> longhands::background_clip::computed_value::T {
                        self.background_clip.clone()
                    }
                        /// Set background-origin.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_origin(&mut self, v: longhands::background_origin::computed_value::T) {
                            self.background_origin = v;
                        }
                        /// Set background-origin from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_origin_from(&mut self, other: &Self) {
                            self.background_origin = other.background_origin.clone();
                        }
                    /// Reset background-origin from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_origin(&mut self, other: &Self) {
                        self.copy_background_origin_from(other)
                    }

                    /// Get the computed value for background-origin.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_origin(&self) -> longhands::background_origin::computed_value::T {
                        self.background_origin.clone()
                    }
                        /// Set background-size.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_background_size(&mut self, v: longhands::background_size::computed_value::T) {
                            self.background_size = v;
                        }
                        /// Set background-size from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_background_size_from(&mut self, other: &Self) {
                            self.background_size = other.background_size.clone();
                        }
                    /// Reset background-size from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_background_size(&mut self, other: &Self) {
                        self.copy_background_size_from(other)
                    }

                    /// Get the computed value for background-size.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_background_size(&self) -> longhands::background_size::computed_value::T {
                        self.background_size.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Border style struct.
        pub struct Border {
                    /// The border-top-color computed value.
                    pub border_top_color: longhands::border_top_color::computed_value::T,
                    /// The border-top-style computed value.
                    pub border_top_style: longhands::border_top_style::computed_value::T,
                    /// The border-top-width computed value.
                    pub border_top_width: longhands::border_top_width::computed_value::T,
                    /// The border-right-color computed value.
                    pub border_right_color: longhands::border_right_color::computed_value::T,
                    /// The border-right-style computed value.
                    pub border_right_style: longhands::border_right_style::computed_value::T,
                    /// The border-right-width computed value.
                    pub border_right_width: longhands::border_right_width::computed_value::T,
                    /// The border-bottom-color computed value.
                    pub border_bottom_color: longhands::border_bottom_color::computed_value::T,
                    /// The border-bottom-style computed value.
                    pub border_bottom_style: longhands::border_bottom_style::computed_value::T,
                    /// The border-bottom-width computed value.
                    pub border_bottom_width: longhands::border_bottom_width::computed_value::T,
                    /// The border-left-color computed value.
                    pub border_left_color: longhands::border_left_color::computed_value::T,
                    /// The border-left-style computed value.
                    pub border_left_style: longhands::border_left_style::computed_value::T,
                    /// The border-left-width computed value.
                    pub border_left_width: longhands::border_left_width::computed_value::T,
                    /// The border-top-left-radius computed value.
                    pub border_top_left_radius: longhands::border_top_left_radius::computed_value::T,
                    /// The border-top-right-radius computed value.
                    pub border_top_right_radius: longhands::border_top_right_radius::computed_value::T,
                    /// The border-bottom-right-radius computed value.
                    pub border_bottom_right_radius: longhands::border_bottom_right_radius::computed_value::T,
                    /// The border-bottom-left-radius computed value.
                    pub border_bottom_left_radius: longhands::border_bottom_left_radius::computed_value::T,
                    /// The border-image-source computed value.
                    pub border_image_source: longhands::border_image_source::computed_value::T,
                    /// The border-image-outset computed value.
                    pub border_image_outset: longhands::border_image_outset::computed_value::T,
                    /// The border-image-repeat computed value.
                    pub border_image_repeat: longhands::border_image_repeat::computed_value::T,
                    /// The border-image-width computed value.
                    pub border_image_width: longhands::border_image_width::computed_value::T,
                    /// The border-image-slice computed value.
                    pub border_image_slice: longhands::border_image_slice::computed_value::T,
        }

        impl Border {
                        /// Set border-top-color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_top_color(&mut self, v: longhands::border_top_color::computed_value::T) {
                            self.border_top_color = v;
                        }
                        /// Set border-top-color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_top_color_from(&mut self, other: &Self) {
                            self.border_top_color = other.border_top_color.clone();
                        }
                    /// Reset border-top-color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_top_color(&mut self, other: &Self) {
                        self.copy_border_top_color_from(other)
                    }

                    /// Get the computed value for border-top-color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_top_color(&self) -> longhands::border_top_color::computed_value::T {
                        self.border_top_color.clone()
                    }
                        /// Set border-top-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_top_style(&mut self, v: longhands::border_top_style::computed_value::T) {
                            self.border_top_style = v;
                        }
                        /// Set border-top-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_top_style_from(&mut self, other: &Self) {
                            self.border_top_style = other.border_top_style.clone();
                        }
                    /// Reset border-top-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_top_style(&mut self, other: &Self) {
                        self.copy_border_top_style_from(other)
                    }

                    /// Get the computed value for border-top-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_top_style(&self) -> longhands::border_top_style::computed_value::T {
                        self.border_top_style.clone()
                    }
                        /// Set border-top-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_top_width(&mut self, v: longhands::border_top_width::computed_value::T) {
                            self.border_top_width = v;
                        }
                        /// Set border-top-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_top_width_from(&mut self, other: &Self) {
                            self.border_top_width = other.border_top_width.clone();
                        }
                    /// Reset border-top-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_top_width(&mut self, other: &Self) {
                        self.copy_border_top_width_from(other)
                    }

                    /// Get the computed value for border-top-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_top_width(&self) -> longhands::border_top_width::computed_value::T {
                        self.border_top_width.clone()
                    }
                        /// Set border-right-color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_right_color(&mut self, v: longhands::border_right_color::computed_value::T) {
                            self.border_right_color = v;
                        }
                        /// Set border-right-color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_right_color_from(&mut self, other: &Self) {
                            self.border_right_color = other.border_right_color.clone();
                        }
                    /// Reset border-right-color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_right_color(&mut self, other: &Self) {
                        self.copy_border_right_color_from(other)
                    }

                    /// Get the computed value for border-right-color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_right_color(&self) -> longhands::border_right_color::computed_value::T {
                        self.border_right_color.clone()
                    }
                        /// Set border-right-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_right_style(&mut self, v: longhands::border_right_style::computed_value::T) {
                            self.border_right_style = v;
                        }
                        /// Set border-right-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_right_style_from(&mut self, other: &Self) {
                            self.border_right_style = other.border_right_style.clone();
                        }
                    /// Reset border-right-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_right_style(&mut self, other: &Self) {
                        self.copy_border_right_style_from(other)
                    }

                    /// Get the computed value for border-right-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_right_style(&self) -> longhands::border_right_style::computed_value::T {
                        self.border_right_style.clone()
                    }
                        /// Set border-right-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_right_width(&mut self, v: longhands::border_right_width::computed_value::T) {
                            self.border_right_width = v;
                        }
                        /// Set border-right-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_right_width_from(&mut self, other: &Self) {
                            self.border_right_width = other.border_right_width.clone();
                        }
                    /// Reset border-right-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_right_width(&mut self, other: &Self) {
                        self.copy_border_right_width_from(other)
                    }

                    /// Get the computed value for border-right-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_right_width(&self) -> longhands::border_right_width::computed_value::T {
                        self.border_right_width.clone()
                    }
                        /// Set border-bottom-color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_bottom_color(&mut self, v: longhands::border_bottom_color::computed_value::T) {
                            self.border_bottom_color = v;
                        }
                        /// Set border-bottom-color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_bottom_color_from(&mut self, other: &Self) {
                            self.border_bottom_color = other.border_bottom_color.clone();
                        }
                    /// Reset border-bottom-color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_bottom_color(&mut self, other: &Self) {
                        self.copy_border_bottom_color_from(other)
                    }

                    /// Get the computed value for border-bottom-color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_bottom_color(&self) -> longhands::border_bottom_color::computed_value::T {
                        self.border_bottom_color.clone()
                    }
                        /// Set border-bottom-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_bottom_style(&mut self, v: longhands::border_bottom_style::computed_value::T) {
                            self.border_bottom_style = v;
                        }
                        /// Set border-bottom-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_bottom_style_from(&mut self, other: &Self) {
                            self.border_bottom_style = other.border_bottom_style.clone();
                        }
                    /// Reset border-bottom-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_bottom_style(&mut self, other: &Self) {
                        self.copy_border_bottom_style_from(other)
                    }

                    /// Get the computed value for border-bottom-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_bottom_style(&self) -> longhands::border_bottom_style::computed_value::T {
                        self.border_bottom_style.clone()
                    }
                        /// Set border-bottom-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_bottom_width(&mut self, v: longhands::border_bottom_width::computed_value::T) {
                            self.border_bottom_width = v;
                        }
                        /// Set border-bottom-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_bottom_width_from(&mut self, other: &Self) {
                            self.border_bottom_width = other.border_bottom_width.clone();
                        }
                    /// Reset border-bottom-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_bottom_width(&mut self, other: &Self) {
                        self.copy_border_bottom_width_from(other)
                    }

                    /// Get the computed value for border-bottom-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_bottom_width(&self) -> longhands::border_bottom_width::computed_value::T {
                        self.border_bottom_width.clone()
                    }
                        /// Set border-left-color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_left_color(&mut self, v: longhands::border_left_color::computed_value::T) {
                            self.border_left_color = v;
                        }
                        /// Set border-left-color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_left_color_from(&mut self, other: &Self) {
                            self.border_left_color = other.border_left_color.clone();
                        }
                    /// Reset border-left-color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_left_color(&mut self, other: &Self) {
                        self.copy_border_left_color_from(other)
                    }

                    /// Get the computed value for border-left-color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_left_color(&self) -> longhands::border_left_color::computed_value::T {
                        self.border_left_color.clone()
                    }
                        /// Set border-left-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_left_style(&mut self, v: longhands::border_left_style::computed_value::T) {
                            self.border_left_style = v;
                        }
                        /// Set border-left-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_left_style_from(&mut self, other: &Self) {
                            self.border_left_style = other.border_left_style.clone();
                        }
                    /// Reset border-left-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_left_style(&mut self, other: &Self) {
                        self.copy_border_left_style_from(other)
                    }

                    /// Get the computed value for border-left-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_left_style(&self) -> longhands::border_left_style::computed_value::T {
                        self.border_left_style.clone()
                    }
                        /// Set border-left-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_left_width(&mut self, v: longhands::border_left_width::computed_value::T) {
                            self.border_left_width = v;
                        }
                        /// Set border-left-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_left_width_from(&mut self, other: &Self) {
                            self.border_left_width = other.border_left_width.clone();
                        }
                    /// Reset border-left-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_left_width(&mut self, other: &Self) {
                        self.copy_border_left_width_from(other)
                    }

                    /// Get the computed value for border-left-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_left_width(&self) -> longhands::border_left_width::computed_value::T {
                        self.border_left_width.clone()
                    }
                        /// Set border-top-left-radius.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_top_left_radius(&mut self, v: longhands::border_top_left_radius::computed_value::T) {
                            self.border_top_left_radius = v;
                        }
                        /// Set border-top-left-radius from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_top_left_radius_from(&mut self, other: &Self) {
                            self.border_top_left_radius = other.border_top_left_radius.clone();
                        }
                    /// Reset border-top-left-radius from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_top_left_radius(&mut self, other: &Self) {
                        self.copy_border_top_left_radius_from(other)
                    }

                    /// Get the computed value for border-top-left-radius.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_top_left_radius(&self) -> longhands::border_top_left_radius::computed_value::T {
                        self.border_top_left_radius.clone()
                    }
                        /// Set border-top-right-radius.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_top_right_radius(&mut self, v: longhands::border_top_right_radius::computed_value::T) {
                            self.border_top_right_radius = v;
                        }
                        /// Set border-top-right-radius from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_top_right_radius_from(&mut self, other: &Self) {
                            self.border_top_right_radius = other.border_top_right_radius.clone();
                        }
                    /// Reset border-top-right-radius from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_top_right_radius(&mut self, other: &Self) {
                        self.copy_border_top_right_radius_from(other)
                    }

                    /// Get the computed value for border-top-right-radius.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_top_right_radius(&self) -> longhands::border_top_right_radius::computed_value::T {
                        self.border_top_right_radius.clone()
                    }
                        /// Set border-bottom-right-radius.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_bottom_right_radius(&mut self, v: longhands::border_bottom_right_radius::computed_value::T) {
                            self.border_bottom_right_radius = v;
                        }
                        /// Set border-bottom-right-radius from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_bottom_right_radius_from(&mut self, other: &Self) {
                            self.border_bottom_right_radius = other.border_bottom_right_radius.clone();
                        }
                    /// Reset border-bottom-right-radius from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_bottom_right_radius(&mut self, other: &Self) {
                        self.copy_border_bottom_right_radius_from(other)
                    }

                    /// Get the computed value for border-bottom-right-radius.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_bottom_right_radius(&self) -> longhands::border_bottom_right_radius::computed_value::T {
                        self.border_bottom_right_radius.clone()
                    }
                        /// Set border-bottom-left-radius.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_bottom_left_radius(&mut self, v: longhands::border_bottom_left_radius::computed_value::T) {
                            self.border_bottom_left_radius = v;
                        }
                        /// Set border-bottom-left-radius from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_bottom_left_radius_from(&mut self, other: &Self) {
                            self.border_bottom_left_radius = other.border_bottom_left_radius.clone();
                        }
                    /// Reset border-bottom-left-radius from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_bottom_left_radius(&mut self, other: &Self) {
                        self.copy_border_bottom_left_radius_from(other)
                    }

                    /// Get the computed value for border-bottom-left-radius.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_bottom_left_radius(&self) -> longhands::border_bottom_left_radius::computed_value::T {
                        self.border_bottom_left_radius.clone()
                    }
                        /// Set border-image-source.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_image_source(&mut self, v: longhands::border_image_source::computed_value::T) {
                            self.border_image_source = v;
                        }
                        /// Set border-image-source from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_image_source_from(&mut self, other: &Self) {
                            self.border_image_source = other.border_image_source.clone();
                        }
                    /// Reset border-image-source from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_image_source(&mut self, other: &Self) {
                        self.copy_border_image_source_from(other)
                    }

                    /// Get the computed value for border-image-source.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_image_source(&self) -> longhands::border_image_source::computed_value::T {
                        self.border_image_source.clone()
                    }
                        /// Set border-image-outset.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_image_outset(&mut self, v: longhands::border_image_outset::computed_value::T) {
                            self.border_image_outset = v;
                        }
                        /// Set border-image-outset from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_image_outset_from(&mut self, other: &Self) {
                            self.border_image_outset = other.border_image_outset.clone();
                        }
                    /// Reset border-image-outset from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_image_outset(&mut self, other: &Self) {
                        self.copy_border_image_outset_from(other)
                    }

                    /// Get the computed value for border-image-outset.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_image_outset(&self) -> longhands::border_image_outset::computed_value::T {
                        self.border_image_outset.clone()
                    }
                        /// Set border-image-repeat.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_image_repeat(&mut self, v: longhands::border_image_repeat::computed_value::T) {
                            self.border_image_repeat = v;
                        }
                        /// Set border-image-repeat from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_image_repeat_from(&mut self, other: &Self) {
                            self.border_image_repeat = other.border_image_repeat.clone();
                        }
                    /// Reset border-image-repeat from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_image_repeat(&mut self, other: &Self) {
                        self.copy_border_image_repeat_from(other)
                    }

                    /// Get the computed value for border-image-repeat.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_image_repeat(&self) -> longhands::border_image_repeat::computed_value::T {
                        self.border_image_repeat.clone()
                    }
                        /// Set border-image-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_image_width(&mut self, v: longhands::border_image_width::computed_value::T) {
                            self.border_image_width = v;
                        }
                        /// Set border-image-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_image_width_from(&mut self, other: &Self) {
                            self.border_image_width = other.border_image_width.clone();
                        }
                    /// Reset border-image-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_image_width(&mut self, other: &Self) {
                        self.copy_border_image_width_from(other)
                    }

                    /// Get the computed value for border-image-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_image_width(&self) -> longhands::border_image_width::computed_value::T {
                        self.border_image_width.clone()
                    }
                        /// Set border-image-slice.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_image_slice(&mut self, v: longhands::border_image_slice::computed_value::T) {
                            self.border_image_slice = v;
                        }
                        /// Set border-image-slice from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_image_slice_from(&mut self, other: &Self) {
                            self.border_image_slice = other.border_image_slice.clone();
                        }
                    /// Reset border-image-slice from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_image_slice(&mut self, other: &Self) {
                        self.copy_border_image_slice_from(other)
                    }

                    /// Get the computed value for border-image-slice.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_image_slice(&self) -> longhands::border_image_slice::computed_value::T {
                        self.border_image_slice.clone()
                    }
                    /// Whether the border-top property has nonzero width.
                    #[allow(non_snake_case)]
                    pub fn border_top_has_nonzero_width(&self) -> bool {
                        use crate::Zero;
                        !self.border_top_width.is_zero()
                    }
                    /// Whether the border-right property has nonzero width.
                    #[allow(non_snake_case)]
                    pub fn border_right_has_nonzero_width(&self) -> bool {
                        use crate::Zero;
                        !self.border_right_width.is_zero()
                    }
                    /// Whether the border-bottom property has nonzero width.
                    #[allow(non_snake_case)]
                    pub fn border_bottom_has_nonzero_width(&self) -> bool {
                        use crate::Zero;
                        !self.border_bottom_width.is_zero()
                    }
                    /// Whether the border-left property has nonzero width.
                    #[allow(non_snake_case)]
                    pub fn border_left_has_nonzero_width(&self) -> bool {
                        use crate::Zero;
                        !self.border_left_width.is_zero()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Box style struct.
        pub struct Box {
                    /// The display computed value.
                    pub display: longhands::display::computed_value::T,
                    /// The -servo-top-layer computed value.
                    pub _servo_top_layer: longhands::_servo_top_layer::computed_value::T,
                    /// The position computed value.
                    pub position: longhands::position::computed_value::T,
                    /// The float computed value.
                    pub float: longhands::float::computed_value::T,
                    /// The clear computed value.
                    pub clear: longhands::clear::computed_value::T,
                    /// The vertical-align computed value.
                    pub vertical_align: longhands::vertical_align::computed_value::T,
                    /// The baseline-source computed value.
                    pub baseline_source: longhands::baseline_source::computed_value::T,
                    /// The -servo-overflow-clip-box computed value.
                    pub _servo_overflow_clip_box: longhands::_servo_overflow_clip_box::computed_value::T,
                    /// The overflow-y computed value.
                    pub overflow_y: longhands::overflow_y::computed_value::T,
                    /// The overflow-x computed value.
                    pub overflow_x: longhands::overflow_x::computed_value::T,
                    /// The transform computed value.
                    pub transform: longhands::transform::computed_value::T,
                    /// The rotate computed value.
                    pub rotate: longhands::rotate::computed_value::T,
                    /// The scale computed value.
                    pub scale: longhands::scale::computed_value::T,
                    /// The translate computed value.
                    pub translate: longhands::translate::computed_value::T,
                    /// The offset-path computed value.
                    pub offset_path: longhands::offset_path::computed_value::T,
                    /// The isolation computed value.
                    pub isolation: longhands::isolation::computed_value::T,
                    /// The perspective computed value.
                    pub perspective: longhands::perspective::computed_value::T,
                    /// The perspective-origin computed value.
                    pub perspective_origin: longhands::perspective_origin::computed_value::T,
                    /// The backface-visibility computed value.
                    pub backface_visibility: longhands::backface_visibility::computed_value::T,
                    /// The transform-style computed value.
                    pub transform_style: longhands::transform_style::computed_value::T,
                    /// The transform-origin computed value.
                    pub transform_origin: longhands::transform_origin::computed_value::T,
                    /// The contain computed value.
                    pub contain: longhands::contain::computed_value::T,
                    /// The container-type computed value.
                    pub container_type: longhands::container_type::computed_value::T,
                    /// The container-name computed value.
                    pub container_name: longhands::container_name::computed_value::T,
                    /// The will-change computed value.
                    pub will_change: longhands::will_change::computed_value::T,
                    /// The zoom computed value.
                    pub zoom: longhands::zoom::computed_value::T,
                /// The display value specified by the CSS stylesheets (without any style adjustments),
                /// which is needed for hypothetical layout boxes.
                pub original_display: longhands::display::computed_value::T,
        }

        impl Box {
                        /// Set `display`.
                        ///
                        /// We need to keep track of the original display for hypothetical boxes,
                        /// so we need to special-case this.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_display(&mut self, v: longhands::display::computed_value::T) {
                            self.display = v;
                            self.original_display = v;
                        }
                        /// Set `display` from other struct.
                        ///
                        /// Same as `set_display` above.
                        /// Thus, we need to special-case this.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_display_from(&mut self, other: &Self) {
                            self.display = other.display.clone();
                            self.original_display = other.display.clone();
                        }
                    /// Reset display from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_display(&mut self, other: &Self) {
                        self.copy_display_from(other)
                    }

                    /// Get the computed value for display.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_display(&self) -> longhands::display::computed_value::T {
                        self.display.clone()
                    }
                        /// Set -servo-top-layer.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set__servo_top_layer(&mut self, v: longhands::_servo_top_layer::computed_value::T) {
                            self._servo_top_layer = v;
                        }
                        /// Set -servo-top-layer from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy__servo_top_layer_from(&mut self, other: &Self) {
                            self._servo_top_layer = other._servo_top_layer.clone();
                        }
                    /// Reset -servo-top-layer from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset__servo_top_layer(&mut self, other: &Self) {
                        self.copy__servo_top_layer_from(other)
                    }

                    /// Get the computed value for -servo-top-layer.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone__servo_top_layer(&self) -> longhands::_servo_top_layer::computed_value::T {
                        self._servo_top_layer.clone()
                    }
                        /// Set position.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_position(&mut self, v: longhands::position::computed_value::T) {
                            self.position = v;
                        }
                        /// Set position from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_position_from(&mut self, other: &Self) {
                            self.position = other.position.clone();
                        }
                    /// Reset position from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_position(&mut self, other: &Self) {
                        self.copy_position_from(other)
                    }

                    /// Get the computed value for position.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_position(&self) -> longhands::position::computed_value::T {
                        self.position.clone()
                    }
                        /// Set float.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_float(&mut self, v: longhands::float::computed_value::T) {
                            self.float = v;
                        }
                        /// Set float from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_float_from(&mut self, other: &Self) {
                            self.float = other.float.clone();
                        }
                    /// Reset float from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_float(&mut self, other: &Self) {
                        self.copy_float_from(other)
                    }

                    /// Get the computed value for float.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_float(&self) -> longhands::float::computed_value::T {
                        self.float.clone()
                    }
                        /// Set clear.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_clear(&mut self, v: longhands::clear::computed_value::T) {
                            self.clear = v;
                        }
                        /// Set clear from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_clear_from(&mut self, other: &Self) {
                            self.clear = other.clear.clone();
                        }
                    /// Reset clear from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_clear(&mut self, other: &Self) {
                        self.copy_clear_from(other)
                    }

                    /// Get the computed value for clear.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_clear(&self) -> longhands::clear::computed_value::T {
                        self.clear.clone()
                    }
                        /// Set vertical-align.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_vertical_align(&mut self, v: longhands::vertical_align::computed_value::T) {
                            self.vertical_align = v;
                        }
                        /// Set vertical-align from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_vertical_align_from(&mut self, other: &Self) {
                            self.vertical_align = other.vertical_align.clone();
                        }
                    /// Reset vertical-align from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_vertical_align(&mut self, other: &Self) {
                        self.copy_vertical_align_from(other)
                    }

                    /// Get the computed value for vertical-align.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_vertical_align(&self) -> longhands::vertical_align::computed_value::T {
                        self.vertical_align.clone()
                    }
                        /// Set baseline-source.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_baseline_source(&mut self, v: longhands::baseline_source::computed_value::T) {
                            self.baseline_source = v;
                        }
                        /// Set baseline-source from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_baseline_source_from(&mut self, other: &Self) {
                            self.baseline_source = other.baseline_source.clone();
                        }
                    /// Reset baseline-source from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_baseline_source(&mut self, other: &Self) {
                        self.copy_baseline_source_from(other)
                    }

                    /// Get the computed value for baseline-source.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_baseline_source(&self) -> longhands::baseline_source::computed_value::T {
                        self.baseline_source.clone()
                    }
                        /// Set -servo-overflow-clip-box.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set__servo_overflow_clip_box(&mut self, v: longhands::_servo_overflow_clip_box::computed_value::T) {
                            self._servo_overflow_clip_box = v;
                        }
                        /// Set -servo-overflow-clip-box from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy__servo_overflow_clip_box_from(&mut self, other: &Self) {
                            self._servo_overflow_clip_box = other._servo_overflow_clip_box.clone();
                        }
                    /// Reset -servo-overflow-clip-box from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset__servo_overflow_clip_box(&mut self, other: &Self) {
                        self.copy__servo_overflow_clip_box_from(other)
                    }

                    /// Get the computed value for -servo-overflow-clip-box.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone__servo_overflow_clip_box(&self) -> longhands::_servo_overflow_clip_box::computed_value::T {
                        self._servo_overflow_clip_box.clone()
                    }
                        /// Set overflow-y.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_overflow_y(&mut self, v: longhands::overflow_y::computed_value::T) {
                            self.overflow_y = v;
                        }
                        /// Set overflow-y from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_overflow_y_from(&mut self, other: &Self) {
                            self.overflow_y = other.overflow_y.clone();
                        }
                    /// Reset overflow-y from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_overflow_y(&mut self, other: &Self) {
                        self.copy_overflow_y_from(other)
                    }

                    /// Get the computed value for overflow-y.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_overflow_y(&self) -> longhands::overflow_y::computed_value::T {
                        self.overflow_y.clone()
                    }
                        /// Set overflow-x.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_overflow_x(&mut self, v: longhands::overflow_x::computed_value::T) {
                            self.overflow_x = v;
                        }
                        /// Set overflow-x from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_overflow_x_from(&mut self, other: &Self) {
                            self.overflow_x = other.overflow_x.clone();
                        }
                    /// Reset overflow-x from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_overflow_x(&mut self, other: &Self) {
                        self.copy_overflow_x_from(other)
                    }

                    /// Get the computed value for overflow-x.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_overflow_x(&self) -> longhands::overflow_x::computed_value::T {
                        self.overflow_x.clone()
                    }
                        /// Set transform.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transform(&mut self, v: longhands::transform::computed_value::T) {
                            self.transform = v;
                        }
                        /// Set transform from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transform_from(&mut self, other: &Self) {
                            self.transform = other.transform.clone();
                        }
                    /// Reset transform from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transform(&mut self, other: &Self) {
                        self.copy_transform_from(other)
                    }

                    /// Get the computed value for transform.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transform(&self) -> longhands::transform::computed_value::T {
                        self.transform.clone()
                    }
                        /// Set rotate.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_rotate(&mut self, v: longhands::rotate::computed_value::T) {
                            self.rotate = v;
                        }
                        /// Set rotate from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_rotate_from(&mut self, other: &Self) {
                            self.rotate = other.rotate.clone();
                        }
                    /// Reset rotate from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_rotate(&mut self, other: &Self) {
                        self.copy_rotate_from(other)
                    }

                    /// Get the computed value for rotate.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_rotate(&self) -> longhands::rotate::computed_value::T {
                        self.rotate.clone()
                    }
                        /// Set scale.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_scale(&mut self, v: longhands::scale::computed_value::T) {
                            self.scale = v;
                        }
                        /// Set scale from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_scale_from(&mut self, other: &Self) {
                            self.scale = other.scale.clone();
                        }
                    /// Reset scale from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_scale(&mut self, other: &Self) {
                        self.copy_scale_from(other)
                    }

                    /// Get the computed value for scale.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_scale(&self) -> longhands::scale::computed_value::T {
                        self.scale.clone()
                    }
                        /// Set translate.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_translate(&mut self, v: longhands::translate::computed_value::T) {
                            self.translate = v;
                        }
                        /// Set translate from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_translate_from(&mut self, other: &Self) {
                            self.translate = other.translate.clone();
                        }
                    /// Reset translate from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_translate(&mut self, other: &Self) {
                        self.copy_translate_from(other)
                    }

                    /// Get the computed value for translate.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_translate(&self) -> longhands::translate::computed_value::T {
                        self.translate.clone()
                    }
                        /// Set offset-path.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_offset_path(&mut self, v: longhands::offset_path::computed_value::T) {
                            self.offset_path = v;
                        }
                        /// Set offset-path from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_offset_path_from(&mut self, other: &Self) {
                            self.offset_path = other.offset_path.clone();
                        }
                    /// Reset offset-path from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_offset_path(&mut self, other: &Self) {
                        self.copy_offset_path_from(other)
                    }

                    /// Get the computed value for offset-path.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_offset_path(&self) -> longhands::offset_path::computed_value::T {
                        self.offset_path.clone()
                    }
                        /// Set isolation.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_isolation(&mut self, v: longhands::isolation::computed_value::T) {
                            self.isolation = v;
                        }
                        /// Set isolation from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_isolation_from(&mut self, other: &Self) {
                            self.isolation = other.isolation.clone();
                        }
                    /// Reset isolation from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_isolation(&mut self, other: &Self) {
                        self.copy_isolation_from(other)
                    }

                    /// Get the computed value for isolation.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_isolation(&self) -> longhands::isolation::computed_value::T {
                        self.isolation.clone()
                    }
                        /// Set perspective.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_perspective(&mut self, v: longhands::perspective::computed_value::T) {
                            self.perspective = v;
                        }
                        /// Set perspective from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_perspective_from(&mut self, other: &Self) {
                            self.perspective = other.perspective.clone();
                        }
                    /// Reset perspective from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_perspective(&mut self, other: &Self) {
                        self.copy_perspective_from(other)
                    }

                    /// Get the computed value for perspective.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_perspective(&self) -> longhands::perspective::computed_value::T {
                        self.perspective.clone()
                    }
                        /// Set perspective-origin.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_perspective_origin(&mut self, v: longhands::perspective_origin::computed_value::T) {
                            self.perspective_origin = v;
                        }
                        /// Set perspective-origin from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_perspective_origin_from(&mut self, other: &Self) {
                            self.perspective_origin = other.perspective_origin.clone();
                        }
                    /// Reset perspective-origin from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_perspective_origin(&mut self, other: &Self) {
                        self.copy_perspective_origin_from(other)
                    }

                    /// Get the computed value for perspective-origin.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_perspective_origin(&self) -> longhands::perspective_origin::computed_value::T {
                        self.perspective_origin.clone()
                    }
                        /// Set backface-visibility.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_backface_visibility(&mut self, v: longhands::backface_visibility::computed_value::T) {
                            self.backface_visibility = v;
                        }
                        /// Set backface-visibility from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_backface_visibility_from(&mut self, other: &Self) {
                            self.backface_visibility = other.backface_visibility.clone();
                        }
                    /// Reset backface-visibility from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_backface_visibility(&mut self, other: &Self) {
                        self.copy_backface_visibility_from(other)
                    }

                    /// Get the computed value for backface-visibility.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_backface_visibility(&self) -> longhands::backface_visibility::computed_value::T {
                        self.backface_visibility.clone()
                    }
                        /// Set transform-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transform_style(&mut self, v: longhands::transform_style::computed_value::T) {
                            self.transform_style = v;
                        }
                        /// Set transform-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transform_style_from(&mut self, other: &Self) {
                            self.transform_style = other.transform_style.clone();
                        }
                    /// Reset transform-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transform_style(&mut self, other: &Self) {
                        self.copy_transform_style_from(other)
                    }

                    /// Get the computed value for transform-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transform_style(&self) -> longhands::transform_style::computed_value::T {
                        self.transform_style.clone()
                    }
                        /// Set transform-origin.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transform_origin(&mut self, v: longhands::transform_origin::computed_value::T) {
                            self.transform_origin = v;
                        }
                        /// Set transform-origin from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transform_origin_from(&mut self, other: &Self) {
                            self.transform_origin = other.transform_origin.clone();
                        }
                    /// Reset transform-origin from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transform_origin(&mut self, other: &Self) {
                        self.copy_transform_origin_from(other)
                    }

                    /// Get the computed value for transform-origin.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transform_origin(&self) -> longhands::transform_origin::computed_value::T {
                        self.transform_origin.clone()
                    }
                        /// Set contain.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_contain(&mut self, v: longhands::contain::computed_value::T) {
                            self.contain = v;
                        }
                        /// Set contain from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_contain_from(&mut self, other: &Self) {
                            self.contain = other.contain.clone();
                        }
                    /// Reset contain from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_contain(&mut self, other: &Self) {
                        self.copy_contain_from(other)
                    }

                    /// Get the computed value for contain.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_contain(&self) -> longhands::contain::computed_value::T {
                        self.contain.clone()
                    }
                        /// Set container-type.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_container_type(&mut self, v: longhands::container_type::computed_value::T) {
                            self.container_type = v;
                        }
                        /// Set container-type from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_container_type_from(&mut self, other: &Self) {
                            self.container_type = other.container_type.clone();
                        }
                    /// Reset container-type from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_container_type(&mut self, other: &Self) {
                        self.copy_container_type_from(other)
                    }

                    /// Get the computed value for container-type.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_container_type(&self) -> longhands::container_type::computed_value::T {
                        self.container_type.clone()
                    }
                        /// Set container-name.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_container_name(&mut self, v: longhands::container_name::computed_value::T) {
                            self.container_name = v;
                        }
                        /// Set container-name from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_container_name_from(&mut self, other: &Self) {
                            self.container_name = other.container_name.clone();
                        }
                    /// Reset container-name from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_container_name(&mut self, other: &Self) {
                        self.copy_container_name_from(other)
                    }

                    /// Get the computed value for container-name.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_container_name(&self) -> longhands::container_name::computed_value::T {
                        self.container_name.clone()
                    }
                        /// Set will-change.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_will_change(&mut self, v: longhands::will_change::computed_value::T) {
                            self.will_change = v;
                        }
                        /// Set will-change from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_will_change_from(&mut self, other: &Self) {
                            self.will_change = other.will_change.clone();
                        }
                    /// Reset will-change from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_will_change(&mut self, other: &Self) {
                        self.copy_will_change_from(other)
                    }

                    /// Get the computed value for will-change.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_will_change(&self) -> longhands::will_change::computed_value::T {
                        self.will_change.clone()
                    }
                        /// Set zoom.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_zoom(&mut self, v: longhands::zoom::computed_value::T) {
                            self.zoom = v;
                        }
                        /// Set zoom from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_zoom_from(&mut self, other: &Self) {
                            self.zoom = other.zoom.clone();
                        }
                    /// Reset zoom from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_zoom(&mut self, other: &Self) {
                        self.copy_zoom_from(other)
                    }

                    /// Get the computed value for zoom.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_zoom(&self) -> longhands::zoom::computed_value::T {
                        self.zoom.clone()
                    }
                /// Sets the display property, but without touching original_display,
                /// except when the adjustment comes from root or item display fixups.
                pub fn set_adjusted_display(
                    &mut self,
                    dpy: longhands::display::computed_value::T,
                    is_item_or_root: bool
                ) {
                    self.display = dpy;
                    if is_item_or_root {
                        self.original_display = dpy;
                    }
                }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Column style struct.
        pub struct Column {
                    /// The column-width computed value.
                    pub column_width: longhands::column_width::computed_value::T,
                    /// The column-count computed value.
                    pub column_count: longhands::column_count::computed_value::T,
                    /// The column-span computed value.
                    pub column_span: longhands::column_span::computed_value::T,
        }

        impl Column {
                        /// Set column-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_column_width(&mut self, v: longhands::column_width::computed_value::T) {
                            self.column_width = v;
                        }
                        /// Set column-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_column_width_from(&mut self, other: &Self) {
                            self.column_width = other.column_width.clone();
                        }
                    /// Reset column-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_column_width(&mut self, other: &Self) {
                        self.copy_column_width_from(other)
                    }

                    /// Get the computed value for column-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_column_width(&self) -> longhands::column_width::computed_value::T {
                        self.column_width.clone()
                    }
                        /// Set column-count.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_column_count(&mut self, v: longhands::column_count::computed_value::T) {
                            self.column_count = v;
                        }
                        /// Set column-count from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_column_count_from(&mut self, other: &Self) {
                            self.column_count = other.column_count.clone();
                        }
                    /// Reset column-count from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_column_count(&mut self, other: &Self) {
                        self.copy_column_count_from(other)
                    }

                    /// Get the computed value for column-count.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_column_count(&self) -> longhands::column_count::computed_value::T {
                        self.column_count.clone()
                    }
                        /// Set column-span.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_column_span(&mut self, v: longhands::column_span::computed_value::T) {
                            self.column_span = v;
                        }
                        /// Set column-span from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_column_span_from(&mut self, other: &Self) {
                            self.column_span = other.column_span.clone();
                        }
                    /// Reset column-span from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_column_span(&mut self, other: &Self) {
                        self.copy_column_span_from(other)
                    }

                    /// Get the computed value for column-span.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_column_span(&self) -> longhands::column_span::computed_value::T {
                        self.column_span.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Counters style struct.
        pub struct Counters {
                    /// The content computed value.
                    pub content: longhands::content::computed_value::T,
                    /// The counter-increment computed value.
                    pub counter_increment: longhands::counter_increment::computed_value::T,
                    /// The counter-reset computed value.
                    pub counter_reset: longhands::counter_reset::computed_value::T,
        }

        impl Counters {
                        /// Set content.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_content(&mut self, v: longhands::content::computed_value::T) {
                            self.content = v;
                        }
                        /// Set content from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_content_from(&mut self, other: &Self) {
                            self.content = other.content.clone();
                        }
                    /// Reset content from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_content(&mut self, other: &Self) {
                        self.copy_content_from(other)
                    }

                    /// Get the computed value for content.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_content(&self) -> longhands::content::computed_value::T {
                        self.content.clone()
                    }
                        /// Set counter-increment.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_counter_increment(&mut self, v: longhands::counter_increment::computed_value::T) {
                            self.counter_increment = v;
                        }
                        /// Set counter-increment from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_counter_increment_from(&mut self, other: &Self) {
                            self.counter_increment = other.counter_increment.clone();
                        }
                    /// Reset counter-increment from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_counter_increment(&mut self, other: &Self) {
                        self.copy_counter_increment_from(other)
                    }

                    /// Get the computed value for counter-increment.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_counter_increment(&self) -> longhands::counter_increment::computed_value::T {
                        self.counter_increment.clone()
                    }
                        /// Set counter-reset.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_counter_reset(&mut self, v: longhands::counter_reset::computed_value::T) {
                            self.counter_reset = v;
                        }
                        /// Set counter-reset from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_counter_reset_from(&mut self, other: &Self) {
                            self.counter_reset = other.counter_reset.clone();
                        }
                    /// Reset counter-reset from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_counter_reset(&mut self, other: &Self) {
                        self.copy_counter_reset_from(other)
                    }

                    /// Get the computed value for counter-reset.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_counter_reset(&self) -> longhands::counter_reset::computed_value::T {
                        self.counter_reset.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Effects style struct.
        pub struct Effects {
                    /// The opacity computed value.
                    pub opacity: longhands::opacity::computed_value::T,
                    /// The box-shadow computed value.
                    pub box_shadow: longhands::box_shadow::computed_value::T,
                    /// The clip computed value.
                    pub clip: longhands::clip::computed_value::T,
                    /// The filter computed value.
                    pub filter: longhands::filter::computed_value::T,
                    /// The backdrop-filter computed value.
                    pub backdrop_filter: longhands::backdrop_filter::computed_value::T,
                    /// The mix-blend-mode computed value.
                    pub mix_blend_mode: longhands::mix_blend_mode::computed_value::T,
        }

        impl Effects {
                        /// Set opacity.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_opacity(&mut self, v: longhands::opacity::computed_value::T) {
                            self.opacity = v;
                        }
                        /// Set opacity from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_opacity_from(&mut self, other: &Self) {
                            self.opacity = other.opacity.clone();
                        }
                    /// Reset opacity from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_opacity(&mut self, other: &Self) {
                        self.copy_opacity_from(other)
                    }

                    /// Get the computed value for opacity.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_opacity(&self) -> longhands::opacity::computed_value::T {
                        self.opacity.clone()
                    }
                        /// Set box-shadow.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_box_shadow(&mut self, v: longhands::box_shadow::computed_value::T) {
                            self.box_shadow = v;
                        }
                        /// Set box-shadow from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_box_shadow_from(&mut self, other: &Self) {
                            self.box_shadow = other.box_shadow.clone();
                        }
                    /// Reset box-shadow from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_box_shadow(&mut self, other: &Self) {
                        self.copy_box_shadow_from(other)
                    }

                    /// Get the computed value for box-shadow.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_box_shadow(&self) -> longhands::box_shadow::computed_value::T {
                        self.box_shadow.clone()
                    }
                        /// Set clip.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_clip(&mut self, v: longhands::clip::computed_value::T) {
                            self.clip = v;
                        }
                        /// Set clip from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_clip_from(&mut self, other: &Self) {
                            self.clip = other.clip.clone();
                        }
                    /// Reset clip from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_clip(&mut self, other: &Self) {
                        self.copy_clip_from(other)
                    }

                    /// Get the computed value for clip.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_clip(&self) -> longhands::clip::computed_value::T {
                        self.clip.clone()
                    }
                        /// Set filter.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_filter(&mut self, v: longhands::filter::computed_value::T) {
                            self.filter = v;
                        }
                        /// Set filter from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_filter_from(&mut self, other: &Self) {
                            self.filter = other.filter.clone();
                        }
                    /// Reset filter from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_filter(&mut self, other: &Self) {
                        self.copy_filter_from(other)
                    }

                    /// Get the computed value for filter.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_filter(&self) -> longhands::filter::computed_value::T {
                        self.filter.clone()
                    }
                        /// Set backdrop-filter.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_backdrop_filter(&mut self, v: longhands::backdrop_filter::computed_value::T) {
                            self.backdrop_filter = v;
                        }
                        /// Set backdrop-filter from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_backdrop_filter_from(&mut self, other: &Self) {
                            self.backdrop_filter = other.backdrop_filter.clone();
                        }
                    /// Reset backdrop-filter from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_backdrop_filter(&mut self, other: &Self) {
                        self.copy_backdrop_filter_from(other)
                    }

                    /// Get the computed value for backdrop-filter.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_backdrop_filter(&self) -> longhands::backdrop_filter::computed_value::T {
                        self.backdrop_filter.clone()
                    }
                        /// Set mix-blend-mode.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_mix_blend_mode(&mut self, v: longhands::mix_blend_mode::computed_value::T) {
                            self.mix_blend_mode = v;
                        }
                        /// Set mix-blend-mode from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_mix_blend_mode_from(&mut self, other: &Self) {
                            self.mix_blend_mode = other.mix_blend_mode.clone();
                        }
                    /// Reset mix-blend-mode from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_mix_blend_mode(&mut self, other: &Self) {
                        self.copy_mix_blend_mode_from(other)
                    }

                    /// Get the computed value for mix-blend-mode.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_mix_blend_mode(&self) -> longhands::mix_blend_mode::computed_value::T {
                        self.mix_blend_mode.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf)]
        #[cfg_attr(feature = "servo", derive(Serialize, Deserialize))]
        /// The Font style struct.
        pub struct Font {
                    /// The font-family computed value.
                    pub font_family: longhands::font_family::computed_value::T,
                    /// The font-style computed value.
                    pub font_style: longhands::font_style::computed_value::T,
                    /// The font-variant-caps computed value.
                    pub font_variant_caps: longhands::font_variant_caps::computed_value::T,
                    /// The font-weight computed value.
                    pub font_weight: longhands::font_weight::computed_value::T,
                    /// The font-size computed value.
                    pub font_size: longhands::font_size::computed_value::T,
                    /// The font-synthesis-weight computed value.
                    pub font_synthesis_weight: longhands::font_synthesis_weight::computed_value::T,
                    /// The font-stretch computed value.
                    pub font_stretch: longhands::font_stretch::computed_value::T,
                    /// The font-variation-settings computed value.
                    pub font_variation_settings: longhands::font_variation_settings::computed_value::T,
                    /// The font-language-override computed value.
                    pub font_language_override: longhands::font_language_override::computed_value::T,
                    /// The -x-lang computed value.
                    pub _x_lang: longhands::_x_lang::computed_value::T,
                    /// The line-height computed value.
                    pub line_height: longhands::line_height::computed_value::T,
                /// The font hash, used for font caching.
                pub hash: u64,
        }
        impl PartialEq for Font {
            fn eq(&self, other: &Font) -> bool {
                self.hash == other.hash
                    && self.font_family == other.font_family
                    && self.font_style == other.font_style
                    && self.font_variant_caps == other.font_variant_caps
                    && self.font_weight == other.font_weight
                    && self.font_size == other.font_size
                    && self.font_synthesis_weight == other.font_synthesis_weight
                    && self.font_stretch == other.font_stretch
                    && self.font_variation_settings == other.font_variation_settings
                    && self.font_language_override == other.font_language_override
                    && self._x_lang == other._x_lang
                    && self.line_height == other.line_height
            }
        }

        impl Font {
                        /// Set font-family.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_family(&mut self, v: longhands::font_family::computed_value::T) {
                            self.font_family = v;
                        }
                        /// Set font-family from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_family_from(&mut self, other: &Self) {
                            self.font_family = other.font_family.clone();
                        }
                    /// Reset font-family from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_family(&mut self, other: &Self) {
                        self.copy_font_family_from(other)
                    }

                    /// Get the computed value for font-family.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_family(&self) -> longhands::font_family::computed_value::T {
                        self.font_family.clone()
                    }
                        /// Set font-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_style(&mut self, v: longhands::font_style::computed_value::T) {
                            self.font_style = v;
                        }
                        /// Set font-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_style_from(&mut self, other: &Self) {
                            self.font_style = other.font_style.clone();
                        }
                    /// Reset font-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_style(&mut self, other: &Self) {
                        self.copy_font_style_from(other)
                    }

                    /// Get the computed value for font-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_style(&self) -> longhands::font_style::computed_value::T {
                        self.font_style.clone()
                    }
                        /// Set font-variant-caps.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_variant_caps(&mut self, v: longhands::font_variant_caps::computed_value::T) {
                            self.font_variant_caps = v;
                        }
                        /// Set font-variant-caps from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_variant_caps_from(&mut self, other: &Self) {
                            self.font_variant_caps = other.font_variant_caps.clone();
                        }
                    /// Reset font-variant-caps from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_variant_caps(&mut self, other: &Self) {
                        self.copy_font_variant_caps_from(other)
                    }

                    /// Get the computed value for font-variant-caps.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_variant_caps(&self) -> longhands::font_variant_caps::computed_value::T {
                        self.font_variant_caps.clone()
                    }
                        /// Set font-weight.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_weight(&mut self, v: longhands::font_weight::computed_value::T) {
                            self.font_weight = v;
                        }
                        /// Set font-weight from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_weight_from(&mut self, other: &Self) {
                            self.font_weight = other.font_weight.clone();
                        }
                    /// Reset font-weight from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_weight(&mut self, other: &Self) {
                        self.copy_font_weight_from(other)
                    }

                    /// Get the computed value for font-weight.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_weight(&self) -> longhands::font_weight::computed_value::T {
                        self.font_weight.clone()
                    }
                        /// Set font-size.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_size(&mut self, v: longhands::font_size::computed_value::T) {
                            self.font_size = v;
                        }
                        /// Set font-size from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_size_from(&mut self, other: &Self) {
                            self.font_size = other.font_size.clone();
                        }
                    /// Reset font-size from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_size(&mut self, other: &Self) {
                        self.copy_font_size_from(other)
                    }

                    /// Get the computed value for font-size.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_size(&self) -> longhands::font_size::computed_value::T {
                        self.font_size.clone()
                    }
                        /// Set font-synthesis-weight.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_synthesis_weight(&mut self, v: longhands::font_synthesis_weight::computed_value::T) {
                            self.font_synthesis_weight = v;
                        }
                        /// Set font-synthesis-weight from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_synthesis_weight_from(&mut self, other: &Self) {
                            self.font_synthesis_weight = other.font_synthesis_weight.clone();
                        }
                    /// Reset font-synthesis-weight from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_synthesis_weight(&mut self, other: &Self) {
                        self.copy_font_synthesis_weight_from(other)
                    }

                    /// Get the computed value for font-synthesis-weight.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_synthesis_weight(&self) -> longhands::font_synthesis_weight::computed_value::T {
                        self.font_synthesis_weight.clone()
                    }
                        /// Set font-stretch.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_stretch(&mut self, v: longhands::font_stretch::computed_value::T) {
                            self.font_stretch = v;
                        }
                        /// Set font-stretch from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_stretch_from(&mut self, other: &Self) {
                            self.font_stretch = other.font_stretch.clone();
                        }
                    /// Reset font-stretch from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_stretch(&mut self, other: &Self) {
                        self.copy_font_stretch_from(other)
                    }

                    /// Get the computed value for font-stretch.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_stretch(&self) -> longhands::font_stretch::computed_value::T {
                        self.font_stretch.clone()
                    }
                        /// Set font-variation-settings.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_variation_settings(&mut self, v: longhands::font_variation_settings::computed_value::T) {
                            self.font_variation_settings = v;
                        }
                        /// Set font-variation-settings from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_variation_settings_from(&mut self, other: &Self) {
                            self.font_variation_settings = other.font_variation_settings.clone();
                        }
                    /// Reset font-variation-settings from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_variation_settings(&mut self, other: &Self) {
                        self.copy_font_variation_settings_from(other)
                    }

                    /// Get the computed value for font-variation-settings.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_variation_settings(&self) -> longhands::font_variation_settings::computed_value::T {
                        self.font_variation_settings.clone()
                    }
                        /// Set font-language-override.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_font_language_override(&mut self, v: longhands::font_language_override::computed_value::T) {
                            self.font_language_override = v;
                        }
                        /// Set font-language-override from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_font_language_override_from(&mut self, other: &Self) {
                            self.font_language_override = other.font_language_override.clone();
                        }
                    /// Reset font-language-override from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_font_language_override(&mut self, other: &Self) {
                        self.copy_font_language_override_from(other)
                    }

                    /// Get the computed value for font-language-override.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_font_language_override(&self) -> longhands::font_language_override::computed_value::T {
                        self.font_language_override.clone()
                    }
                        /// Set -x-lang.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set__x_lang(&mut self, v: longhands::_x_lang::computed_value::T) {
                            self._x_lang = v;
                        }
                        /// Set -x-lang from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy__x_lang_from(&mut self, other: &Self) {
                            self._x_lang = other._x_lang.clone();
                        }
                    /// Reset -x-lang from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset__x_lang(&mut self, other: &Self) {
                        self.copy__x_lang_from(other)
                    }

                    /// Get the computed value for -x-lang.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone__x_lang(&self) -> longhands::_x_lang::computed_value::T {
                        self._x_lang.clone()
                    }
                        /// Set line-height.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_line_height(&mut self, v: longhands::line_height::computed_value::T) {
                            self.line_height = v;
                        }
                        /// Set line-height from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_line_height_from(&mut self, other: &Self) {
                            self.line_height = other.line_height.clone();
                        }
                    /// Reset line-height from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_line_height(&mut self, other: &Self) {
                        self.copy_line_height_from(other)
                    }

                    /// Get the computed value for line-height.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_line_height(&self) -> longhands::line_height::computed_value::T {
                        self.line_height.clone()
                    }
                /// Computes a font hash in order to be able to cache fonts
                /// effectively in GFX and layout.
                pub fn compute_font_hash(&mut self) {
                    let mut hasher: FxHasher = Default::default();
                    self.font_weight.hash(&mut hasher);
                    self.font_stretch.hash(&mut hasher);
                    self.font_style.hash(&mut hasher);
                    self.font_family.hash(&mut hasher);
                    self.hash = hasher.finish()
                }
                /// Create a new Font with the initial values of all members.
                pub fn initial_values() -> Self {
                    Self {
                                font_family: longhands::font_family::get_initial_value(),
                                font_style: longhands::font_style::get_initial_value(),
                                font_variant_caps: longhands::font_variant_caps::get_initial_value(),
                                font_weight: longhands::font_weight::get_initial_value(),
                                font_size: longhands::font_size::get_initial_value(),
                                font_synthesis_weight: longhands::font_synthesis_weight::get_initial_value(),
                                font_stretch: longhands::font_stretch::get_initial_value(),
                                font_variation_settings: longhands::font_variation_settings::get_initial_value(),
                                font_language_override: longhands::font_language_override::get_initial_value(),
                                _x_lang: longhands::_x_lang::get_initial_value(),
                                line_height: longhands::line_height::get_initial_value(),
                        hash: 0,
                    }
                 }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The InheritedBox style struct.
        pub struct InheritedBox {
                    /// The visibility computed value.
                    pub visibility: longhands::visibility::computed_value::T,
                    /// The writing-mode computed value.
                    pub writing_mode: longhands::writing_mode::computed_value::T,
                    /// The direction computed value.
                    pub direction: longhands::direction::computed_value::T,
                    /// The image-rendering computed value.
                    pub image_rendering: longhands::image_rendering::computed_value::T,
        }

        impl InheritedBox {
                        /// Set visibility.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_visibility(&mut self, v: longhands::visibility::computed_value::T) {
                            self.visibility = v;
                        }
                        /// Set visibility from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_visibility_from(&mut self, other: &Self) {
                            self.visibility = other.visibility.clone();
                        }
                    /// Reset visibility from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_visibility(&mut self, other: &Self) {
                        self.copy_visibility_from(other)
                    }

                    /// Get the computed value for visibility.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_visibility(&self) -> longhands::visibility::computed_value::T {
                        self.visibility.clone()
                    }
                        /// Set writing-mode.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_writing_mode(&mut self, v: longhands::writing_mode::computed_value::T) {
                            self.writing_mode = v;
                        }
                        /// Set writing-mode from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_writing_mode_from(&mut self, other: &Self) {
                            self.writing_mode = other.writing_mode.clone();
                        }
                    /// Reset writing-mode from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_writing_mode(&mut self, other: &Self) {
                        self.copy_writing_mode_from(other)
                    }

                    /// Get the computed value for writing-mode.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_writing_mode(&self) -> longhands::writing_mode::computed_value::T {
                        self.writing_mode.clone()
                    }
                        /// Set direction.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_direction(&mut self, v: longhands::direction::computed_value::T) {
                            self.direction = v;
                        }
                        /// Set direction from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_direction_from(&mut self, other: &Self) {
                            self.direction = other.direction.clone();
                        }
                    /// Reset direction from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_direction(&mut self, other: &Self) {
                        self.copy_direction_from(other)
                    }

                    /// Get the computed value for direction.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_direction(&self) -> longhands::direction::computed_value::T {
                        self.direction.clone()
                    }
                        /// Set image-rendering.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_image_rendering(&mut self, v: longhands::image_rendering::computed_value::T) {
                            self.image_rendering = v;
                        }
                        /// Set image-rendering from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_image_rendering_from(&mut self, other: &Self) {
                            self.image_rendering = other.image_rendering.clone();
                        }
                    /// Reset image-rendering from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_image_rendering(&mut self, other: &Self) {
                        self.copy_image_rendering_from(other)
                    }

                    /// Get the computed value for image-rendering.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_image_rendering(&self) -> longhands::image_rendering::computed_value::T {
                        self.image_rendering.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The InheritedTable style struct.
        pub struct InheritedTable {
                    /// The border-collapse computed value.
                    pub border_collapse: longhands::border_collapse::computed_value::T,
                    /// The empty-cells computed value.
                    pub empty_cells: longhands::empty_cells::computed_value::T,
                    /// The caption-side computed value.
                    pub caption_side: longhands::caption_side::computed_value::T,
                    /// The border-spacing computed value.
                    pub border_spacing: longhands::border_spacing::computed_value::T,
        }

        impl InheritedTable {
                        /// Set border-collapse.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_collapse(&mut self, v: longhands::border_collapse::computed_value::T) {
                            self.border_collapse = v;
                        }
                        /// Set border-collapse from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_collapse_from(&mut self, other: &Self) {
                            self.border_collapse = other.border_collapse.clone();
                        }
                    /// Reset border-collapse from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_collapse(&mut self, other: &Self) {
                        self.copy_border_collapse_from(other)
                    }

                    /// Get the computed value for border-collapse.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_collapse(&self) -> longhands::border_collapse::computed_value::T {
                        self.border_collapse.clone()
                    }
                        /// Set empty-cells.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_empty_cells(&mut self, v: longhands::empty_cells::computed_value::T) {
                            self.empty_cells = v;
                        }
                        /// Set empty-cells from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_empty_cells_from(&mut self, other: &Self) {
                            self.empty_cells = other.empty_cells.clone();
                        }
                    /// Reset empty-cells from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_empty_cells(&mut self, other: &Self) {
                        self.copy_empty_cells_from(other)
                    }

                    /// Get the computed value for empty-cells.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_empty_cells(&self) -> longhands::empty_cells::computed_value::T {
                        self.empty_cells.clone()
                    }
                        /// Set caption-side.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_caption_side(&mut self, v: longhands::caption_side::computed_value::T) {
                            self.caption_side = v;
                        }
                        /// Set caption-side from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_caption_side_from(&mut self, other: &Self) {
                            self.caption_side = other.caption_side.clone();
                        }
                    /// Reset caption-side from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_caption_side(&mut self, other: &Self) {
                        self.copy_caption_side_from(other)
                    }

                    /// Get the computed value for caption-side.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_caption_side(&self) -> longhands::caption_side::computed_value::T {
                        self.caption_side.clone()
                    }
                        /// Set border-spacing.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_border_spacing(&mut self, v: longhands::border_spacing::computed_value::T) {
                            self.border_spacing = v;
                        }
                        /// Set border-spacing from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_border_spacing_from(&mut self, other: &Self) {
                            self.border_spacing = other.border_spacing.clone();
                        }
                    /// Reset border-spacing from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_border_spacing(&mut self, other: &Self) {
                        self.copy_border_spacing_from(other)
                    }

                    /// Get the computed value for border-spacing.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_border_spacing(&self) -> longhands::border_spacing::computed_value::T {
                        self.border_spacing.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The InheritedText style struct.
        pub struct InheritedText {
                    /// The color computed value.
                    pub color: longhands::color::computed_value::T,
                    /// The text-transform computed value.
                    pub text_transform: longhands::text_transform::computed_value::T,
                    /// The text-indent computed value.
                    pub text_indent: longhands::text_indent::computed_value::T,
                    /// The overflow-wrap computed value.
                    pub overflow_wrap: longhands::overflow_wrap::computed_value::T,
                    /// The word-break computed value.
                    pub word_break: longhands::word_break::computed_value::T,
                    /// The text-justify computed value.
                    pub text_justify: longhands::text_justify::computed_value::T,
                    /// The text-align-last computed value.
                    pub text_align_last: longhands::text_align_last::computed_value::T,
                    /// The text-align computed value.
                    pub text_align: longhands::text_align::computed_value::T,
                    /// The letter-spacing computed value.
                    pub letter_spacing: longhands::letter_spacing::computed_value::T,
                    /// The word-spacing computed value.
                    pub word_spacing: longhands::word_spacing::computed_value::T,
                    /// The white-space-collapse computed value.
                    pub white_space_collapse: longhands::white_space_collapse::computed_value::T,
                    /// The text-shadow computed value.
                    pub text_shadow: longhands::text_shadow::computed_value::T,
                    /// The text-rendering computed value.
                    pub text_rendering: longhands::text_rendering::computed_value::T,
                    /// The text-wrap-mode computed value.
                    pub text_wrap_mode: longhands::text_wrap_mode::computed_value::T,
        }

        impl InheritedText {
                        /// Set color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_color(&mut self, v: longhands::color::computed_value::T) {
                            self.color = v;
                        }
                        /// Set color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_color_from(&mut self, other: &Self) {
                            self.color = other.color.clone();
                        }
                    /// Reset color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_color(&mut self, other: &Self) {
                        self.copy_color_from(other)
                    }

                    /// Get the computed value for color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_color(&self) -> longhands::color::computed_value::T {
                        self.color.clone()
                    }
                        /// Set text-transform.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_transform(&mut self, v: longhands::text_transform::computed_value::T) {
                            self.text_transform = v;
                        }
                        /// Set text-transform from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_transform_from(&mut self, other: &Self) {
                            self.text_transform = other.text_transform.clone();
                        }
                    /// Reset text-transform from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_transform(&mut self, other: &Self) {
                        self.copy_text_transform_from(other)
                    }

                    /// Get the computed value for text-transform.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_transform(&self) -> longhands::text_transform::computed_value::T {
                        self.text_transform.clone()
                    }
                        /// Set text-indent.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_indent(&mut self, v: longhands::text_indent::computed_value::T) {
                            self.text_indent = v;
                        }
                        /// Set text-indent from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_indent_from(&mut self, other: &Self) {
                            self.text_indent = other.text_indent.clone();
                        }
                    /// Reset text-indent from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_indent(&mut self, other: &Self) {
                        self.copy_text_indent_from(other)
                    }

                    /// Get the computed value for text-indent.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_indent(&self) -> longhands::text_indent::computed_value::T {
                        self.text_indent.clone()
                    }
                        /// Set overflow-wrap.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_overflow_wrap(&mut self, v: longhands::overflow_wrap::computed_value::T) {
                            self.overflow_wrap = v;
                        }
                        /// Set overflow-wrap from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_overflow_wrap_from(&mut self, other: &Self) {
                            self.overflow_wrap = other.overflow_wrap.clone();
                        }
                    /// Reset overflow-wrap from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_overflow_wrap(&mut self, other: &Self) {
                        self.copy_overflow_wrap_from(other)
                    }

                    /// Get the computed value for overflow-wrap.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_overflow_wrap(&self) -> longhands::overflow_wrap::computed_value::T {
                        self.overflow_wrap.clone()
                    }
                        /// Set word-break.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_word_break(&mut self, v: longhands::word_break::computed_value::T) {
                            self.word_break = v;
                        }
                        /// Set word-break from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_word_break_from(&mut self, other: &Self) {
                            self.word_break = other.word_break.clone();
                        }
                    /// Reset word-break from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_word_break(&mut self, other: &Self) {
                        self.copy_word_break_from(other)
                    }

                    /// Get the computed value for word-break.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_word_break(&self) -> longhands::word_break::computed_value::T {
                        self.word_break.clone()
                    }
                        /// Set text-justify.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_justify(&mut self, v: longhands::text_justify::computed_value::T) {
                            self.text_justify = v;
                        }
                        /// Set text-justify from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_justify_from(&mut self, other: &Self) {
                            self.text_justify = other.text_justify.clone();
                        }
                    /// Reset text-justify from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_justify(&mut self, other: &Self) {
                        self.copy_text_justify_from(other)
                    }

                    /// Get the computed value for text-justify.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_justify(&self) -> longhands::text_justify::computed_value::T {
                        self.text_justify.clone()
                    }
                        /// Set text-align-last.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_align_last(&mut self, v: longhands::text_align_last::computed_value::T) {
                            self.text_align_last = v;
                        }
                        /// Set text-align-last from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_align_last_from(&mut self, other: &Self) {
                            self.text_align_last = other.text_align_last.clone();
                        }
                    /// Reset text-align-last from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_align_last(&mut self, other: &Self) {
                        self.copy_text_align_last_from(other)
                    }

                    /// Get the computed value for text-align-last.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_align_last(&self) -> longhands::text_align_last::computed_value::T {
                        self.text_align_last.clone()
                    }
                        /// Set text-align.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_align(&mut self, v: longhands::text_align::computed_value::T) {
                            self.text_align = v;
                        }
                        /// Set text-align from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_align_from(&mut self, other: &Self) {
                            self.text_align = other.text_align.clone();
                        }
                    /// Reset text-align from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_align(&mut self, other: &Self) {
                        self.copy_text_align_from(other)
                    }

                    /// Get the computed value for text-align.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_align(&self) -> longhands::text_align::computed_value::T {
                        self.text_align.clone()
                    }
                        /// Set letter-spacing.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_letter_spacing(&mut self, v: longhands::letter_spacing::computed_value::T) {
                            self.letter_spacing = v;
                        }
                        /// Set letter-spacing from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_letter_spacing_from(&mut self, other: &Self) {
                            self.letter_spacing = other.letter_spacing.clone();
                        }
                    /// Reset letter-spacing from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_letter_spacing(&mut self, other: &Self) {
                        self.copy_letter_spacing_from(other)
                    }

                    /// Get the computed value for letter-spacing.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_letter_spacing(&self) -> longhands::letter_spacing::computed_value::T {
                        self.letter_spacing.clone()
                    }
                        /// Set word-spacing.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_word_spacing(&mut self, v: longhands::word_spacing::computed_value::T) {
                            self.word_spacing = v;
                        }
                        /// Set word-spacing from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_word_spacing_from(&mut self, other: &Self) {
                            self.word_spacing = other.word_spacing.clone();
                        }
                    /// Reset word-spacing from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_word_spacing(&mut self, other: &Self) {
                        self.copy_word_spacing_from(other)
                    }

                    /// Get the computed value for word-spacing.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_word_spacing(&self) -> longhands::word_spacing::computed_value::T {
                        self.word_spacing.clone()
                    }
                        /// Set white-space-collapse.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_white_space_collapse(&mut self, v: longhands::white_space_collapse::computed_value::T) {
                            self.white_space_collapse = v;
                        }
                        /// Set white-space-collapse from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_white_space_collapse_from(&mut self, other: &Self) {
                            self.white_space_collapse = other.white_space_collapse.clone();
                        }
                    /// Reset white-space-collapse from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_white_space_collapse(&mut self, other: &Self) {
                        self.copy_white_space_collapse_from(other)
                    }

                    /// Get the computed value for white-space-collapse.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_white_space_collapse(&self) -> longhands::white_space_collapse::computed_value::T {
                        self.white_space_collapse.clone()
                    }
                        /// Set text-shadow.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_shadow(&mut self, v: longhands::text_shadow::computed_value::T) {
                            self.text_shadow = v;
                        }
                        /// Set text-shadow from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_shadow_from(&mut self, other: &Self) {
                            self.text_shadow = other.text_shadow.clone();
                        }
                    /// Reset text-shadow from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_shadow(&mut self, other: &Self) {
                        self.copy_text_shadow_from(other)
                    }

                    /// Get the computed value for text-shadow.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_shadow(&self) -> longhands::text_shadow::computed_value::T {
                        self.text_shadow.clone()
                    }
                        /// Set text-rendering.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_rendering(&mut self, v: longhands::text_rendering::computed_value::T) {
                            self.text_rendering = v;
                        }
                        /// Set text-rendering from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_rendering_from(&mut self, other: &Self) {
                            self.text_rendering = other.text_rendering.clone();
                        }
                    /// Reset text-rendering from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_rendering(&mut self, other: &Self) {
                        self.copy_text_rendering_from(other)
                    }

                    /// Get the computed value for text-rendering.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_rendering(&self) -> longhands::text_rendering::computed_value::T {
                        self.text_rendering.clone()
                    }
                        /// Set text-wrap-mode.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_wrap_mode(&mut self, v: longhands::text_wrap_mode::computed_value::T) {
                            self.text_wrap_mode = v;
                        }
                        /// Set text-wrap-mode from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_wrap_mode_from(&mut self, other: &Self) {
                            self.text_wrap_mode = other.text_wrap_mode.clone();
                        }
                    /// Reset text-wrap-mode from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_wrap_mode(&mut self, other: &Self) {
                        self.copy_text_wrap_mode_from(other)
                    }

                    /// Get the computed value for text-wrap-mode.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_wrap_mode(&self) -> longhands::text_wrap_mode::computed_value::T {
                        self.text_wrap_mode.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The InheritedUI style struct.
        pub struct InheritedUI {
                    /// The cursor computed value.
                    pub cursor: longhands::cursor::computed_value::T,
                    /// The pointer-events computed value.
                    pub pointer_events: longhands::pointer_events::computed_value::T,
                    /// The color-scheme computed value.
                    pub color_scheme: longhands::color_scheme::computed_value::T,
        }

        impl InheritedUI {
                        /// Set cursor.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_cursor(&mut self, v: longhands::cursor::computed_value::T) {
                            self.cursor = v;
                        }
                        /// Set cursor from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_cursor_from(&mut self, other: &Self) {
                            self.cursor = other.cursor.clone();
                        }
                    /// Reset cursor from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_cursor(&mut self, other: &Self) {
                        self.copy_cursor_from(other)
                    }

                    /// Get the computed value for cursor.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_cursor(&self) -> longhands::cursor::computed_value::T {
                        self.cursor.clone()
                    }
                        /// Set pointer-events.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_pointer_events(&mut self, v: longhands::pointer_events::computed_value::T) {
                            self.pointer_events = v;
                        }
                        /// Set pointer-events from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_pointer_events_from(&mut self, other: &Self) {
                            self.pointer_events = other.pointer_events.clone();
                        }
                    /// Reset pointer-events from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_pointer_events(&mut self, other: &Self) {
                        self.copy_pointer_events_from(other)
                    }

                    /// Get the computed value for pointer-events.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_pointer_events(&self) -> longhands::pointer_events::computed_value::T {
                        self.pointer_events.clone()
                    }
                        /// Set color-scheme.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_color_scheme(&mut self, v: longhands::color_scheme::computed_value::T) {
                            self.color_scheme = v;
                        }
                        /// Set color-scheme from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_color_scheme_from(&mut self, other: &Self) {
                            self.color_scheme = other.color_scheme.clone();
                        }
                    /// Reset color-scheme from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_color_scheme(&mut self, other: &Self) {
                        self.copy_color_scheme_from(other)
                    }

                    /// Get the computed value for color-scheme.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_color_scheme(&self) -> longhands::color_scheme::computed_value::T {
                        self.color_scheme.clone()
                    }
                /// Returns the ColorSchemeFlags corresponding to the value of `color-scheme`.
                #[inline]
                pub fn color_scheme_bits(&self) -> ColorSchemeFlags {
                    self.color_scheme.bits
                }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The List style struct.
        pub struct List {
                    /// The list-style-position computed value.
                    pub list_style_position: longhands::list_style_position::computed_value::T,
                    /// The list-style-type computed value.
                    pub list_style_type: longhands::list_style_type::computed_value::T,
                    /// The list-style-image computed value.
                    pub list_style_image: longhands::list_style_image::computed_value::T,
                    /// The quotes computed value.
                    pub quotes: longhands::quotes::computed_value::T,
        }

        impl List {
                        /// Set list-style-position.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_list_style_position(&mut self, v: longhands::list_style_position::computed_value::T) {
                            self.list_style_position = v;
                        }
                        /// Set list-style-position from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_list_style_position_from(&mut self, other: &Self) {
                            self.list_style_position = other.list_style_position.clone();
                        }
                    /// Reset list-style-position from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_list_style_position(&mut self, other: &Self) {
                        self.copy_list_style_position_from(other)
                    }

                    /// Get the computed value for list-style-position.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_list_style_position(&self) -> longhands::list_style_position::computed_value::T {
                        self.list_style_position.clone()
                    }
                        /// Set list-style-type.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_list_style_type(&mut self, v: longhands::list_style_type::computed_value::T) {
                            self.list_style_type = v;
                        }
                        /// Set list-style-type from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_list_style_type_from(&mut self, other: &Self) {
                            self.list_style_type = other.list_style_type.clone();
                        }
                    /// Reset list-style-type from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_list_style_type(&mut self, other: &Self) {
                        self.copy_list_style_type_from(other)
                    }

                    /// Get the computed value for list-style-type.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_list_style_type(&self) -> longhands::list_style_type::computed_value::T {
                        self.list_style_type.clone()
                    }
                        /// Set list-style-image.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_list_style_image(&mut self, v: longhands::list_style_image::computed_value::T) {
                            self.list_style_image = v;
                        }
                        /// Set list-style-image from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_list_style_image_from(&mut self, other: &Self) {
                            self.list_style_image = other.list_style_image.clone();
                        }
                    /// Reset list-style-image from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_list_style_image(&mut self, other: &Self) {
                        self.copy_list_style_image_from(other)
                    }

                    /// Get the computed value for list-style-image.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_list_style_image(&self) -> longhands::list_style_image::computed_value::T {
                        self.list_style_image.clone()
                    }
                        /// Set quotes.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_quotes(&mut self, v: longhands::quotes::computed_value::T) {
                            self.quotes = v;
                        }
                        /// Set quotes from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_quotes_from(&mut self, other: &Self) {
                            self.quotes = other.quotes.clone();
                        }
                    /// Reset quotes from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_quotes(&mut self, other: &Self) {
                        self.copy_quotes_from(other)
                    }

                    /// Get the computed value for quotes.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_quotes(&self) -> longhands::quotes::computed_value::T {
                        self.quotes.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Margin style struct.
        pub struct Margin {
                    /// The margin-top computed value.
                    pub margin_top: longhands::margin_top::computed_value::T,
                    /// The margin-right computed value.
                    pub margin_right: longhands::margin_right::computed_value::T,
                    /// The margin-bottom computed value.
                    pub margin_bottom: longhands::margin_bottom::computed_value::T,
                    /// The margin-left computed value.
                    pub margin_left: longhands::margin_left::computed_value::T,
                    /// The overflow-clip-margin computed value.
                    pub overflow_clip_margin: longhands::overflow_clip_margin::computed_value::T,
        }

        impl Margin {
                        /// Set margin-top.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_margin_top(&mut self, v: longhands::margin_top::computed_value::T) {
                            self.margin_top = v;
                        }
                        /// Set margin-top from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_margin_top_from(&mut self, other: &Self) {
                            self.margin_top = other.margin_top.clone();
                        }
                    /// Reset margin-top from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_margin_top(&mut self, other: &Self) {
                        self.copy_margin_top_from(other)
                    }

                    /// Get the computed value for margin-top.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_margin_top(&self) -> longhands::margin_top::computed_value::T {
                        self.margin_top.clone()
                    }
                        /// Set margin-right.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_margin_right(&mut self, v: longhands::margin_right::computed_value::T) {
                            self.margin_right = v;
                        }
                        /// Set margin-right from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_margin_right_from(&mut self, other: &Self) {
                            self.margin_right = other.margin_right.clone();
                        }
                    /// Reset margin-right from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_margin_right(&mut self, other: &Self) {
                        self.copy_margin_right_from(other)
                    }

                    /// Get the computed value for margin-right.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_margin_right(&self) -> longhands::margin_right::computed_value::T {
                        self.margin_right.clone()
                    }
                        /// Set margin-bottom.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_margin_bottom(&mut self, v: longhands::margin_bottom::computed_value::T) {
                            self.margin_bottom = v;
                        }
                        /// Set margin-bottom from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_margin_bottom_from(&mut self, other: &Self) {
                            self.margin_bottom = other.margin_bottom.clone();
                        }
                    /// Reset margin-bottom from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_margin_bottom(&mut self, other: &Self) {
                        self.copy_margin_bottom_from(other)
                    }

                    /// Get the computed value for margin-bottom.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_margin_bottom(&self) -> longhands::margin_bottom::computed_value::T {
                        self.margin_bottom.clone()
                    }
                        /// Set margin-left.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_margin_left(&mut self, v: longhands::margin_left::computed_value::T) {
                            self.margin_left = v;
                        }
                        /// Set margin-left from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_margin_left_from(&mut self, other: &Self) {
                            self.margin_left = other.margin_left.clone();
                        }
                    /// Reset margin-left from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_margin_left(&mut self, other: &Self) {
                        self.copy_margin_left_from(other)
                    }

                    /// Get the computed value for margin-left.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_margin_left(&self) -> longhands::margin_left::computed_value::T {
                        self.margin_left.clone()
                    }
                        /// Set overflow-clip-margin.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_overflow_clip_margin(&mut self, v: longhands::overflow_clip_margin::computed_value::T) {
                            self.overflow_clip_margin = v;
                        }
                        /// Set overflow-clip-margin from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_overflow_clip_margin_from(&mut self, other: &Self) {
                            self.overflow_clip_margin = other.overflow_clip_margin.clone();
                        }
                    /// Reset overflow-clip-margin from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_overflow_clip_margin(&mut self, other: &Self) {
                        self.copy_overflow_clip_margin_from(other)
                    }

                    /// Get the computed value for overflow-clip-margin.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_overflow_clip_margin(&self) -> longhands::overflow_clip_margin::computed_value::T {
                        self.overflow_clip_margin.clone()
                    }
                
        /// Gets the value of the longhand of `margin` on the `s` side`.
        pub fn get_margin(&self, s: PhysicalSide) -> &longhands::margin_top::computed_value::T {
            match s {
                PhysicalSide::Top => &self.margin_top,
                PhysicalSide::Right => &self.margin_right,
                PhysicalSide::Bottom => &self.margin_bottom,
                PhysicalSide::Left => &self.margin_left,
            }
        }
        /// Sets the value of the longhand of `margin` on the `s` side to `v`.
        pub fn set_margin(&mut self, s: PhysicalSide, v: longhands::margin_top::computed_value::T) {
            match s {
                PhysicalSide::Top => self.set_margin_top(v),
                PhysicalSide::Right => self.set_margin_right(v),
                PhysicalSide::Bottom => self.set_margin_bottom(v),
                PhysicalSide::Left => self.set_margin_left(v),
            }
        }
    
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Outline style struct.
        pub struct Outline {
                    /// The outline-color computed value.
                    pub outline_color: longhands::outline_color::computed_value::T,
                    /// The outline-style computed value.
                    pub outline_style: longhands::outline_style::computed_value::T,
                    /// The outline-width computed value.
                    pub outline_width: longhands::outline_width::computed_value::T,
                    /// The outline-offset computed value.
                    pub outline_offset: longhands::outline_offset::computed_value::T,
        }

        impl Outline {
                        /// Set outline-color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_outline_color(&mut self, v: longhands::outline_color::computed_value::T) {
                            self.outline_color = v;
                        }
                        /// Set outline-color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_outline_color_from(&mut self, other: &Self) {
                            self.outline_color = other.outline_color.clone();
                        }
                    /// Reset outline-color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_outline_color(&mut self, other: &Self) {
                        self.copy_outline_color_from(other)
                    }

                    /// Get the computed value for outline-color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_outline_color(&self) -> longhands::outline_color::computed_value::T {
                        self.outline_color.clone()
                    }
                        /// Set outline-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_outline_style(&mut self, v: longhands::outline_style::computed_value::T) {
                            self.outline_style = v;
                        }
                        /// Set outline-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_outline_style_from(&mut self, other: &Self) {
                            self.outline_style = other.outline_style.clone();
                        }
                    /// Reset outline-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_outline_style(&mut self, other: &Self) {
                        self.copy_outline_style_from(other)
                    }

                    /// Get the computed value for outline-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_outline_style(&self) -> longhands::outline_style::computed_value::T {
                        self.outline_style.clone()
                    }
                        /// Set outline-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_outline_width(&mut self, v: longhands::outline_width::computed_value::T) {
                            self.outline_width = v;
                        }
                        /// Set outline-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_outline_width_from(&mut self, other: &Self) {
                            self.outline_width = other.outline_width.clone();
                        }
                    /// Reset outline-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_outline_width(&mut self, other: &Self) {
                        self.copy_outline_width_from(other)
                    }

                    /// Get the computed value for outline-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_outline_width(&self) -> longhands::outline_width::computed_value::T {
                        self.outline_width.clone()
                    }
                        /// Set outline-offset.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_outline_offset(&mut self, v: longhands::outline_offset::computed_value::T) {
                            self.outline_offset = v;
                        }
                        /// Set outline-offset from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_outline_offset_from(&mut self, other: &Self) {
                            self.outline_offset = other.outline_offset.clone();
                        }
                    /// Reset outline-offset from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_outline_offset(&mut self, other: &Self) {
                        self.copy_outline_offset_from(other)
                    }

                    /// Get the computed value for outline-offset.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_outline_offset(&self) -> longhands::outline_offset::computed_value::T {
                        self.outline_offset.clone()
                    }
                /// Whether the outline-width property is non-zero.
                #[inline]
                pub fn outline_has_nonzero_width(&self) -> bool {
                    use crate::Zero;
                    !self.outline_width.is_zero()
                }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Padding style struct.
        pub struct Padding {
                    /// The padding-top computed value.
                    pub padding_top: longhands::padding_top::computed_value::T,
                    /// The padding-right computed value.
                    pub padding_right: longhands::padding_right::computed_value::T,
                    /// The padding-bottom computed value.
                    pub padding_bottom: longhands::padding_bottom::computed_value::T,
                    /// The padding-left computed value.
                    pub padding_left: longhands::padding_left::computed_value::T,
        }

        impl Padding {
                        /// Set padding-top.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_padding_top(&mut self, v: longhands::padding_top::computed_value::T) {
                            self.padding_top = v;
                        }
                        /// Set padding-top from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_padding_top_from(&mut self, other: &Self) {
                            self.padding_top = other.padding_top.clone();
                        }
                    /// Reset padding-top from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_padding_top(&mut self, other: &Self) {
                        self.copy_padding_top_from(other)
                    }

                    /// Get the computed value for padding-top.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_padding_top(&self) -> longhands::padding_top::computed_value::T {
                        self.padding_top.clone()
                    }
                        /// Set padding-right.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_padding_right(&mut self, v: longhands::padding_right::computed_value::T) {
                            self.padding_right = v;
                        }
                        /// Set padding-right from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_padding_right_from(&mut self, other: &Self) {
                            self.padding_right = other.padding_right.clone();
                        }
                    /// Reset padding-right from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_padding_right(&mut self, other: &Self) {
                        self.copy_padding_right_from(other)
                    }

                    /// Get the computed value for padding-right.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_padding_right(&self) -> longhands::padding_right::computed_value::T {
                        self.padding_right.clone()
                    }
                        /// Set padding-bottom.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_padding_bottom(&mut self, v: longhands::padding_bottom::computed_value::T) {
                            self.padding_bottom = v;
                        }
                        /// Set padding-bottom from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_padding_bottom_from(&mut self, other: &Self) {
                            self.padding_bottom = other.padding_bottom.clone();
                        }
                    /// Reset padding-bottom from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_padding_bottom(&mut self, other: &Self) {
                        self.copy_padding_bottom_from(other)
                    }

                    /// Get the computed value for padding-bottom.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_padding_bottom(&self) -> longhands::padding_bottom::computed_value::T {
                        self.padding_bottom.clone()
                    }
                        /// Set padding-left.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_padding_left(&mut self, v: longhands::padding_left::computed_value::T) {
                            self.padding_left = v;
                        }
                        /// Set padding-left from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_padding_left_from(&mut self, other: &Self) {
                            self.padding_left = other.padding_left.clone();
                        }
                    /// Reset padding-left from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_padding_left(&mut self, other: &Self) {
                        self.copy_padding_left_from(other)
                    }

                    /// Get the computed value for padding-left.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_padding_left(&self) -> longhands::padding_left::computed_value::T {
                        self.padding_left.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Position style struct.
        pub struct Position {
                    /// The top computed value.
                    pub top: longhands::top::computed_value::T,
                    /// The right computed value.
                    pub right: longhands::right::computed_value::T,
                    /// The bottom computed value.
                    pub bottom: longhands::bottom::computed_value::T,
                    /// The left computed value.
                    pub left: longhands::left::computed_value::T,
                    /// The z-index computed value.
                    pub z_index: longhands::z_index::computed_value::T,
                    /// The flex-direction computed value.
                    pub flex_direction: longhands::flex_direction::computed_value::T,
                    /// The flex-wrap computed value.
                    pub flex_wrap: longhands::flex_wrap::computed_value::T,
                    /// The justify-content computed value.
                    pub justify_content: longhands::justify_content::computed_value::T,
                    /// The align-content computed value.
                    pub align_content: longhands::align_content::computed_value::T,
                    /// The align-items computed value.
                    pub align_items: longhands::align_items::computed_value::T,
                    /// The justify-items computed value.
                    pub justify_items: longhands::justify_items::computed_value::T,
                    /// The flex-grow computed value.
                    pub flex_grow: longhands::flex_grow::computed_value::T,
                    /// The flex-shrink computed value.
                    pub flex_shrink: longhands::flex_shrink::computed_value::T,
                    /// The align-self computed value.
                    pub align_self: longhands::align_self::computed_value::T,
                    /// The justify-self computed value.
                    pub justify_self: longhands::justify_self::computed_value::T,
                    /// The order computed value.
                    pub order: longhands::order::computed_value::T,
                    /// The flex-basis computed value.
                    pub flex_basis: longhands::flex_basis::computed_value::T,
                    /// The height computed value.
                    pub height: longhands::height::computed_value::T,
                    /// The min-height computed value.
                    pub min_height: longhands::min_height::computed_value::T,
                    /// The max-height computed value.
                    pub max_height: longhands::max_height::computed_value::T,
                    /// The width computed value.
                    pub width: longhands::width::computed_value::T,
                    /// The min-width computed value.
                    pub min_width: longhands::min_width::computed_value::T,
                    /// The max-width computed value.
                    pub max_width: longhands::max_width::computed_value::T,
                    /// The position-area computed value.
                    pub position_area: longhands::position_area::computed_value::T,
                    /// The box-sizing computed value.
                    pub box_sizing: longhands::box_sizing::computed_value::T,
                    /// The object-fit computed value.
                    pub object_fit: longhands::object_fit::computed_value::T,
                    /// The object-position computed value.
                    pub object_position: longhands::object_position::computed_value::T,
                    /// The grid-row-start computed value.
                    pub grid_row_start: longhands::grid_row_start::computed_value::T,
                    /// The grid-row-end computed value.
                    pub grid_row_end: longhands::grid_row_end::computed_value::T,
                    /// The grid-auto-rows computed value.
                    pub grid_auto_rows: longhands::grid_auto_rows::computed_value::T,
                    /// The grid-template-rows computed value.
                    pub grid_template_rows: longhands::grid_template_rows::computed_value::T,
                    /// The grid-column-start computed value.
                    pub grid_column_start: longhands::grid_column_start::computed_value::T,
                    /// The grid-column-end computed value.
                    pub grid_column_end: longhands::grid_column_end::computed_value::T,
                    /// The grid-auto-columns computed value.
                    pub grid_auto_columns: longhands::grid_auto_columns::computed_value::T,
                    /// The grid-template-columns computed value.
                    pub grid_template_columns: longhands::grid_template_columns::computed_value::T,
                    /// The grid-auto-flow computed value.
                    pub grid_auto_flow: longhands::grid_auto_flow::computed_value::T,
                    /// The grid-template-areas computed value.
                    pub grid_template_areas: longhands::grid_template_areas::computed_value::T,
                    /// The column-gap computed value.
                    pub column_gap: longhands::column_gap::computed_value::T,
                    /// The row-gap computed value.
                    pub row_gap: longhands::row_gap::computed_value::T,
                    /// The aspect-ratio computed value.
                    pub aspect_ratio: longhands::aspect_ratio::computed_value::T,
        }

        impl Position {
                        /// Set top.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_top(&mut self, v: longhands::top::computed_value::T) {
                            self.top = v;
                        }
                        /// Set top from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_top_from(&mut self, other: &Self) {
                            self.top = other.top.clone();
                        }
                    /// Reset top from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_top(&mut self, other: &Self) {
                        self.copy_top_from(other)
                    }

                    /// Get the computed value for top.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_top(&self) -> longhands::top::computed_value::T {
                        self.top.clone()
                    }
                        /// Set right.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_right(&mut self, v: longhands::right::computed_value::T) {
                            self.right = v;
                        }
                        /// Set right from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_right_from(&mut self, other: &Self) {
                            self.right = other.right.clone();
                        }
                    /// Reset right from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_right(&mut self, other: &Self) {
                        self.copy_right_from(other)
                    }

                    /// Get the computed value for right.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_right(&self) -> longhands::right::computed_value::T {
                        self.right.clone()
                    }
                        /// Set bottom.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_bottom(&mut self, v: longhands::bottom::computed_value::T) {
                            self.bottom = v;
                        }
                        /// Set bottom from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_bottom_from(&mut self, other: &Self) {
                            self.bottom = other.bottom.clone();
                        }
                    /// Reset bottom from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_bottom(&mut self, other: &Self) {
                        self.copy_bottom_from(other)
                    }

                    /// Get the computed value for bottom.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_bottom(&self) -> longhands::bottom::computed_value::T {
                        self.bottom.clone()
                    }
                        /// Set left.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_left(&mut self, v: longhands::left::computed_value::T) {
                            self.left = v;
                        }
                        /// Set left from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_left_from(&mut self, other: &Self) {
                            self.left = other.left.clone();
                        }
                    /// Reset left from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_left(&mut self, other: &Self) {
                        self.copy_left_from(other)
                    }

                    /// Get the computed value for left.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_left(&self) -> longhands::left::computed_value::T {
                        self.left.clone()
                    }
                        /// Set z-index.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_z_index(&mut self, v: longhands::z_index::computed_value::T) {
                            self.z_index = v;
                        }
                        /// Set z-index from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_z_index_from(&mut self, other: &Self) {
                            self.z_index = other.z_index.clone();
                        }
                    /// Reset z-index from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_z_index(&mut self, other: &Self) {
                        self.copy_z_index_from(other)
                    }

                    /// Get the computed value for z-index.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_z_index(&self) -> longhands::z_index::computed_value::T {
                        self.z_index.clone()
                    }
                        /// Set flex-direction.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_flex_direction(&mut self, v: longhands::flex_direction::computed_value::T) {
                            self.flex_direction = v;
                        }
                        /// Set flex-direction from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_flex_direction_from(&mut self, other: &Self) {
                            self.flex_direction = other.flex_direction.clone();
                        }
                    /// Reset flex-direction from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_flex_direction(&mut self, other: &Self) {
                        self.copy_flex_direction_from(other)
                    }

                    /// Get the computed value for flex-direction.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_flex_direction(&self) -> longhands::flex_direction::computed_value::T {
                        self.flex_direction.clone()
                    }
                        /// Set flex-wrap.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_flex_wrap(&mut self, v: longhands::flex_wrap::computed_value::T) {
                            self.flex_wrap = v;
                        }
                        /// Set flex-wrap from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_flex_wrap_from(&mut self, other: &Self) {
                            self.flex_wrap = other.flex_wrap.clone();
                        }
                    /// Reset flex-wrap from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_flex_wrap(&mut self, other: &Self) {
                        self.copy_flex_wrap_from(other)
                    }

                    /// Get the computed value for flex-wrap.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_flex_wrap(&self) -> longhands::flex_wrap::computed_value::T {
                        self.flex_wrap.clone()
                    }
                        /// Set justify-content.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_justify_content(&mut self, v: longhands::justify_content::computed_value::T) {
                            self.justify_content = v;
                        }
                        /// Set justify-content from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_justify_content_from(&mut self, other: &Self) {
                            self.justify_content = other.justify_content.clone();
                        }
                    /// Reset justify-content from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_justify_content(&mut self, other: &Self) {
                        self.copy_justify_content_from(other)
                    }

                    /// Get the computed value for justify-content.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_justify_content(&self) -> longhands::justify_content::computed_value::T {
                        self.justify_content.clone()
                    }
                        /// Set align-content.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_align_content(&mut self, v: longhands::align_content::computed_value::T) {
                            self.align_content = v;
                        }
                        /// Set align-content from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_align_content_from(&mut self, other: &Self) {
                            self.align_content = other.align_content.clone();
                        }
                    /// Reset align-content from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_align_content(&mut self, other: &Self) {
                        self.copy_align_content_from(other)
                    }

                    /// Get the computed value for align-content.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_align_content(&self) -> longhands::align_content::computed_value::T {
                        self.align_content.clone()
                    }
                        /// Set align-items.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_align_items(&mut self, v: longhands::align_items::computed_value::T) {
                            self.align_items = v;
                        }
                        /// Set align-items from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_align_items_from(&mut self, other: &Self) {
                            self.align_items = other.align_items.clone();
                        }
                    /// Reset align-items from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_align_items(&mut self, other: &Self) {
                        self.copy_align_items_from(other)
                    }

                    /// Get the computed value for align-items.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_align_items(&self) -> longhands::align_items::computed_value::T {
                        self.align_items.clone()
                    }
                        /// Set justify-items.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_justify_items(&mut self, v: longhands::justify_items::computed_value::T) {
                            self.justify_items = v;
                        }
                        /// Set justify-items from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_justify_items_from(&mut self, other: &Self) {
                            self.justify_items = other.justify_items.clone();
                        }
                    /// Reset justify-items from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_justify_items(&mut self, other: &Self) {
                        self.copy_justify_items_from(other)
                    }

                    /// Get the computed value for justify-items.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_justify_items(&self) -> longhands::justify_items::computed_value::T {
                        self.justify_items.clone()
                    }
                        /// Set flex-grow.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_flex_grow(&mut self, v: longhands::flex_grow::computed_value::T) {
                            self.flex_grow = v;
                        }
                        /// Set flex-grow from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_flex_grow_from(&mut self, other: &Self) {
                            self.flex_grow = other.flex_grow.clone();
                        }
                    /// Reset flex-grow from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_flex_grow(&mut self, other: &Self) {
                        self.copy_flex_grow_from(other)
                    }

                    /// Get the computed value for flex-grow.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_flex_grow(&self) -> longhands::flex_grow::computed_value::T {
                        self.flex_grow.clone()
                    }
                        /// Set flex-shrink.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_flex_shrink(&mut self, v: longhands::flex_shrink::computed_value::T) {
                            self.flex_shrink = v;
                        }
                        /// Set flex-shrink from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_flex_shrink_from(&mut self, other: &Self) {
                            self.flex_shrink = other.flex_shrink.clone();
                        }
                    /// Reset flex-shrink from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_flex_shrink(&mut self, other: &Self) {
                        self.copy_flex_shrink_from(other)
                    }

                    /// Get the computed value for flex-shrink.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_flex_shrink(&self) -> longhands::flex_shrink::computed_value::T {
                        self.flex_shrink.clone()
                    }
                        /// Set align-self.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_align_self(&mut self, v: longhands::align_self::computed_value::T) {
                            self.align_self = v;
                        }
                        /// Set align-self from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_align_self_from(&mut self, other: &Self) {
                            self.align_self = other.align_self.clone();
                        }
                    /// Reset align-self from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_align_self(&mut self, other: &Self) {
                        self.copy_align_self_from(other)
                    }

                    /// Get the computed value for align-self.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_align_self(&self) -> longhands::align_self::computed_value::T {
                        self.align_self.clone()
                    }
                        /// Set justify-self.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_justify_self(&mut self, v: longhands::justify_self::computed_value::T) {
                            self.justify_self = v;
                        }
                        /// Set justify-self from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_justify_self_from(&mut self, other: &Self) {
                            self.justify_self = other.justify_self.clone();
                        }
                    /// Reset justify-self from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_justify_self(&mut self, other: &Self) {
                        self.copy_justify_self_from(other)
                    }

                    /// Get the computed value for justify-self.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_justify_self(&self) -> longhands::justify_self::computed_value::T {
                        self.justify_self.clone()
                    }
                        /// Set order.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_order(&mut self, v: longhands::order::computed_value::T) {
                            self.order = v;
                        }
                        /// Set order from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_order_from(&mut self, other: &Self) {
                            self.order = other.order.clone();
                        }
                    /// Reset order from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_order(&mut self, other: &Self) {
                        self.copy_order_from(other)
                    }

                    /// Get the computed value for order.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_order(&self) -> longhands::order::computed_value::T {
                        self.order.clone()
                    }
                        /// Set flex-basis.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_flex_basis(&mut self, v: longhands::flex_basis::computed_value::T) {
                            self.flex_basis = v;
                        }
                        /// Set flex-basis from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_flex_basis_from(&mut self, other: &Self) {
                            self.flex_basis = other.flex_basis.clone();
                        }
                    /// Reset flex-basis from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_flex_basis(&mut self, other: &Self) {
                        self.copy_flex_basis_from(other)
                    }

                    /// Get the computed value for flex-basis.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_flex_basis(&self) -> longhands::flex_basis::computed_value::T {
                        self.flex_basis.clone()
                    }
                        /// Set height.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_height(&mut self, v: longhands::height::computed_value::T) {
                            self.height = v;
                        }
                        /// Set height from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_height_from(&mut self, other: &Self) {
                            self.height = other.height.clone();
                        }
                    /// Reset height from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_height(&mut self, other: &Self) {
                        self.copy_height_from(other)
                    }

                    /// Get the computed value for height.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_height(&self) -> longhands::height::computed_value::T {
                        self.height.clone()
                    }
                        /// Set min-height.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_min_height(&mut self, v: longhands::min_height::computed_value::T) {
                            self.min_height = v;
                        }
                        /// Set min-height from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_min_height_from(&mut self, other: &Self) {
                            self.min_height = other.min_height.clone();
                        }
                    /// Reset min-height from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_min_height(&mut self, other: &Self) {
                        self.copy_min_height_from(other)
                    }

                    /// Get the computed value for min-height.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_min_height(&self) -> longhands::min_height::computed_value::T {
                        self.min_height.clone()
                    }
                        /// Set max-height.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_max_height(&mut self, v: longhands::max_height::computed_value::T) {
                            self.max_height = v;
                        }
                        /// Set max-height from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_max_height_from(&mut self, other: &Self) {
                            self.max_height = other.max_height.clone();
                        }
                    /// Reset max-height from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_max_height(&mut self, other: &Self) {
                        self.copy_max_height_from(other)
                    }

                    /// Get the computed value for max-height.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_max_height(&self) -> longhands::max_height::computed_value::T {
                        self.max_height.clone()
                    }
                        /// Set width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_width(&mut self, v: longhands::width::computed_value::T) {
                            self.width = v;
                        }
                        /// Set width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_width_from(&mut self, other: &Self) {
                            self.width = other.width.clone();
                        }
                    /// Reset width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_width(&mut self, other: &Self) {
                        self.copy_width_from(other)
                    }

                    /// Get the computed value for width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_width(&self) -> longhands::width::computed_value::T {
                        self.width.clone()
                    }
                        /// Set min-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_min_width(&mut self, v: longhands::min_width::computed_value::T) {
                            self.min_width = v;
                        }
                        /// Set min-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_min_width_from(&mut self, other: &Self) {
                            self.min_width = other.min_width.clone();
                        }
                    /// Reset min-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_min_width(&mut self, other: &Self) {
                        self.copy_min_width_from(other)
                    }

                    /// Get the computed value for min-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_min_width(&self) -> longhands::min_width::computed_value::T {
                        self.min_width.clone()
                    }
                        /// Set max-width.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_max_width(&mut self, v: longhands::max_width::computed_value::T) {
                            self.max_width = v;
                        }
                        /// Set max-width from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_max_width_from(&mut self, other: &Self) {
                            self.max_width = other.max_width.clone();
                        }
                    /// Reset max-width from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_max_width(&mut self, other: &Self) {
                        self.copy_max_width_from(other)
                    }

                    /// Get the computed value for max-width.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_max_width(&self) -> longhands::max_width::computed_value::T {
                        self.max_width.clone()
                    }
                        /// Set position-area.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_position_area(&mut self, v: longhands::position_area::computed_value::T) {
                            self.position_area = v;
                        }
                        /// Set position-area from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_position_area_from(&mut self, other: &Self) {
                            self.position_area = other.position_area.clone();
                        }
                    /// Reset position-area from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_position_area(&mut self, other: &Self) {
                        self.copy_position_area_from(other)
                    }

                    /// Get the computed value for position-area.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_position_area(&self) -> longhands::position_area::computed_value::T {
                        self.position_area.clone()
                    }
                        /// Set box-sizing.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_box_sizing(&mut self, v: longhands::box_sizing::computed_value::T) {
                            self.box_sizing = v;
                        }
                        /// Set box-sizing from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_box_sizing_from(&mut self, other: &Self) {
                            self.box_sizing = other.box_sizing.clone();
                        }
                    /// Reset box-sizing from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_box_sizing(&mut self, other: &Self) {
                        self.copy_box_sizing_from(other)
                    }

                    /// Get the computed value for box-sizing.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_box_sizing(&self) -> longhands::box_sizing::computed_value::T {
                        self.box_sizing.clone()
                    }
                        /// Set object-fit.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_object_fit(&mut self, v: longhands::object_fit::computed_value::T) {
                            self.object_fit = v;
                        }
                        /// Set object-fit from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_object_fit_from(&mut self, other: &Self) {
                            self.object_fit = other.object_fit.clone();
                        }
                    /// Reset object-fit from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_object_fit(&mut self, other: &Self) {
                        self.copy_object_fit_from(other)
                    }

                    /// Get the computed value for object-fit.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_object_fit(&self) -> longhands::object_fit::computed_value::T {
                        self.object_fit.clone()
                    }
                        /// Set object-position.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_object_position(&mut self, v: longhands::object_position::computed_value::T) {
                            self.object_position = v;
                        }
                        /// Set object-position from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_object_position_from(&mut self, other: &Self) {
                            self.object_position = other.object_position.clone();
                        }
                    /// Reset object-position from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_object_position(&mut self, other: &Self) {
                        self.copy_object_position_from(other)
                    }

                    /// Get the computed value for object-position.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_object_position(&self) -> longhands::object_position::computed_value::T {
                        self.object_position.clone()
                    }
                        /// Set grid-row-start.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_row_start(&mut self, v: longhands::grid_row_start::computed_value::T) {
                            self.grid_row_start = v;
                        }
                        /// Set grid-row-start from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_row_start_from(&mut self, other: &Self) {
                            self.grid_row_start = other.grid_row_start.clone();
                        }
                    /// Reset grid-row-start from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_row_start(&mut self, other: &Self) {
                        self.copy_grid_row_start_from(other)
                    }

                    /// Get the computed value for grid-row-start.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_row_start(&self) -> longhands::grid_row_start::computed_value::T {
                        self.grid_row_start.clone()
                    }
                        /// Set grid-row-end.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_row_end(&mut self, v: longhands::grid_row_end::computed_value::T) {
                            self.grid_row_end = v;
                        }
                        /// Set grid-row-end from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_row_end_from(&mut self, other: &Self) {
                            self.grid_row_end = other.grid_row_end.clone();
                        }
                    /// Reset grid-row-end from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_row_end(&mut self, other: &Self) {
                        self.copy_grid_row_end_from(other)
                    }

                    /// Get the computed value for grid-row-end.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_row_end(&self) -> longhands::grid_row_end::computed_value::T {
                        self.grid_row_end.clone()
                    }
                        /// Set grid-auto-rows.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_auto_rows(&mut self, v: longhands::grid_auto_rows::computed_value::T) {
                            self.grid_auto_rows = v;
                        }
                        /// Set grid-auto-rows from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_auto_rows_from(&mut self, other: &Self) {
                            self.grid_auto_rows = other.grid_auto_rows.clone();
                        }
                    /// Reset grid-auto-rows from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_auto_rows(&mut self, other: &Self) {
                        self.copy_grid_auto_rows_from(other)
                    }

                    /// Get the computed value for grid-auto-rows.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_auto_rows(&self) -> longhands::grid_auto_rows::computed_value::T {
                        self.grid_auto_rows.clone()
                    }
                        /// Set grid-template-rows.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_template_rows(&mut self, v: longhands::grid_template_rows::computed_value::T) {
                            self.grid_template_rows = v;
                        }
                        /// Set grid-template-rows from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_template_rows_from(&mut self, other: &Self) {
                            self.grid_template_rows = other.grid_template_rows.clone();
                        }
                    /// Reset grid-template-rows from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_template_rows(&mut self, other: &Self) {
                        self.copy_grid_template_rows_from(other)
                    }

                    /// Get the computed value for grid-template-rows.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_template_rows(&self) -> longhands::grid_template_rows::computed_value::T {
                        self.grid_template_rows.clone()
                    }
                        /// Set grid-column-start.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_column_start(&mut self, v: longhands::grid_column_start::computed_value::T) {
                            self.grid_column_start = v;
                        }
                        /// Set grid-column-start from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_column_start_from(&mut self, other: &Self) {
                            self.grid_column_start = other.grid_column_start.clone();
                        }
                    /// Reset grid-column-start from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_column_start(&mut self, other: &Self) {
                        self.copy_grid_column_start_from(other)
                    }

                    /// Get the computed value for grid-column-start.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_column_start(&self) -> longhands::grid_column_start::computed_value::T {
                        self.grid_column_start.clone()
                    }
                        /// Set grid-column-end.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_column_end(&mut self, v: longhands::grid_column_end::computed_value::T) {
                            self.grid_column_end = v;
                        }
                        /// Set grid-column-end from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_column_end_from(&mut self, other: &Self) {
                            self.grid_column_end = other.grid_column_end.clone();
                        }
                    /// Reset grid-column-end from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_column_end(&mut self, other: &Self) {
                        self.copy_grid_column_end_from(other)
                    }

                    /// Get the computed value for grid-column-end.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_column_end(&self) -> longhands::grid_column_end::computed_value::T {
                        self.grid_column_end.clone()
                    }
                        /// Set grid-auto-columns.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_auto_columns(&mut self, v: longhands::grid_auto_columns::computed_value::T) {
                            self.grid_auto_columns = v;
                        }
                        /// Set grid-auto-columns from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_auto_columns_from(&mut self, other: &Self) {
                            self.grid_auto_columns = other.grid_auto_columns.clone();
                        }
                    /// Reset grid-auto-columns from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_auto_columns(&mut self, other: &Self) {
                        self.copy_grid_auto_columns_from(other)
                    }

                    /// Get the computed value for grid-auto-columns.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_auto_columns(&self) -> longhands::grid_auto_columns::computed_value::T {
                        self.grid_auto_columns.clone()
                    }
                        /// Set grid-template-columns.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_template_columns(&mut self, v: longhands::grid_template_columns::computed_value::T) {
                            self.grid_template_columns = v;
                        }
                        /// Set grid-template-columns from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_template_columns_from(&mut self, other: &Self) {
                            self.grid_template_columns = other.grid_template_columns.clone();
                        }
                    /// Reset grid-template-columns from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_template_columns(&mut self, other: &Self) {
                        self.copy_grid_template_columns_from(other)
                    }

                    /// Get the computed value for grid-template-columns.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_template_columns(&self) -> longhands::grid_template_columns::computed_value::T {
                        self.grid_template_columns.clone()
                    }
                        /// Set grid-auto-flow.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_auto_flow(&mut self, v: longhands::grid_auto_flow::computed_value::T) {
                            self.grid_auto_flow = v;
                        }
                        /// Set grid-auto-flow from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_auto_flow_from(&mut self, other: &Self) {
                            self.grid_auto_flow = other.grid_auto_flow.clone();
                        }
                    /// Reset grid-auto-flow from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_auto_flow(&mut self, other: &Self) {
                        self.copy_grid_auto_flow_from(other)
                    }

                    /// Get the computed value for grid-auto-flow.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_auto_flow(&self) -> longhands::grid_auto_flow::computed_value::T {
                        self.grid_auto_flow.clone()
                    }
                        /// Set grid-template-areas.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_grid_template_areas(&mut self, v: longhands::grid_template_areas::computed_value::T) {
                            self.grid_template_areas = v;
                        }
                        /// Set grid-template-areas from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_grid_template_areas_from(&mut self, other: &Self) {
                            self.grid_template_areas = other.grid_template_areas.clone();
                        }
                    /// Reset grid-template-areas from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_grid_template_areas(&mut self, other: &Self) {
                        self.copy_grid_template_areas_from(other)
                    }

                    /// Get the computed value for grid-template-areas.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_grid_template_areas(&self) -> longhands::grid_template_areas::computed_value::T {
                        self.grid_template_areas.clone()
                    }
                        /// Set column-gap.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_column_gap(&mut self, v: longhands::column_gap::computed_value::T) {
                            self.column_gap = v;
                        }
                        /// Set column-gap from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_column_gap_from(&mut self, other: &Self) {
                            self.column_gap = other.column_gap.clone();
                        }
                    /// Reset column-gap from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_column_gap(&mut self, other: &Self) {
                        self.copy_column_gap_from(other)
                    }

                    /// Get the computed value for column-gap.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_column_gap(&self) -> longhands::column_gap::computed_value::T {
                        self.column_gap.clone()
                    }
                        /// Set row-gap.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_row_gap(&mut self, v: longhands::row_gap::computed_value::T) {
                            self.row_gap = v;
                        }
                        /// Set row-gap from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_row_gap_from(&mut self, other: &Self) {
                            self.row_gap = other.row_gap.clone();
                        }
                    /// Reset row-gap from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_row_gap(&mut self, other: &Self) {
                        self.copy_row_gap_from(other)
                    }

                    /// Get the computed value for row-gap.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_row_gap(&self) -> longhands::row_gap::computed_value::T {
                        self.row_gap.clone()
                    }
                        /// Set aspect-ratio.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_aspect_ratio(&mut self, v: longhands::aspect_ratio::computed_value::T) {
                            self.aspect_ratio = v;
                        }
                        /// Set aspect-ratio from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_aspect_ratio_from(&mut self, other: &Self) {
                            self.aspect_ratio = other.aspect_ratio.clone();
                        }
                    /// Reset aspect-ratio from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_aspect_ratio(&mut self, other: &Self) {
                        self.copy_aspect_ratio_from(other)
                    }

                    /// Get the computed value for aspect-ratio.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_aspect_ratio(&self) -> longhands::aspect_ratio::computed_value::T {
                        self.aspect_ratio.clone()
                    }
                
        /// Gets the value of the longhand of `inset` on the `s` side`.
        pub fn get_inset(&self, s: PhysicalSide) -> &longhands::top::computed_value::T {
            match s {
                PhysicalSide::Top => &self.top,
                PhysicalSide::Right => &self.right,
                PhysicalSide::Bottom => &self.bottom,
                PhysicalSide::Left => &self.left,
            }
        }
        /// Sets the value of the longhand of `inset` on the `s` side to `v`.
        pub fn set_inset(&mut self, s: PhysicalSide, v: longhands::top::computed_value::T) {
            match s {
                PhysicalSide::Top => self.set_top(v),
                PhysicalSide::Right => self.set_right(v),
                PhysicalSide::Bottom => self.set_bottom(v),
                PhysicalSide::Left => self.set_left(v),
            }
        }
    
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The SVG style struct.
        pub struct SVG {
                    /// The clip-path computed value.
                    pub clip_path: longhands::clip_path::computed_value::T,
                    /// The mask-image computed value.
                    pub mask_image: longhands::mask_image::computed_value::T,
        }

        impl SVG {
                        /// Set clip-path.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_clip_path(&mut self, v: longhands::clip_path::computed_value::T) {
                            self.clip_path = v;
                        }
                        /// Set clip-path from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_clip_path_from(&mut self, other: &Self) {
                            self.clip_path = other.clip_path.clone();
                        }
                    /// Reset clip-path from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_clip_path(&mut self, other: &Self) {
                        self.copy_clip_path_from(other)
                    }

                    /// Get the computed value for clip-path.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_clip_path(&self) -> longhands::clip_path::computed_value::T {
                        self.clip_path.clone()
                    }
                        /// Set mask-image.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_mask_image(&mut self, v: longhands::mask_image::computed_value::T) {
                            self.mask_image = v;
                        }
                        /// Set mask-image from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_mask_image_from(&mut self, other: &Self) {
                            self.mask_image = other.mask_image.clone();
                        }
                    /// Reset mask-image from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_mask_image(&mut self, other: &Self) {
                        self.copy_mask_image_from(other)
                    }

                    /// Get the computed value for mask-image.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_mask_image(&self) -> longhands::mask_image::computed_value::T {
                        self.mask_image.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Table style struct.
        pub struct Table {
                    /// The table-layout computed value.
                    pub table_layout: longhands::table_layout::computed_value::T,
        }

        impl Table {
                        /// Set table-layout.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_table_layout(&mut self, v: longhands::table_layout::computed_value::T) {
                            self.table_layout = v;
                        }
                        /// Set table-layout from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_table_layout_from(&mut self, other: &Self) {
                            self.table_layout = other.table_layout.clone();
                        }
                    /// Reset table-layout from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_table_layout(&mut self, other: &Self) {
                        self.copy_table_layout_from(other)
                    }

                    /// Get the computed value for table-layout.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_table_layout(&self) -> longhands::table_layout::computed_value::T {
                        self.table_layout.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The Text style struct.
        pub struct Text {
                    /// The text-overflow computed value.
                    pub text_overflow: longhands::text_overflow::computed_value::T,
                    /// The unicode-bidi computed value.
                    pub unicode_bidi: longhands::unicode_bidi::computed_value::T,
                    /// The text-decoration-line computed value.
                    pub text_decoration_line: longhands::text_decoration_line::computed_value::T,
                    /// The text-decoration-style computed value.
                    pub text_decoration_style: longhands::text_decoration_style::computed_value::T,
                    /// The text-decoration-color computed value.
                    pub text_decoration_color: longhands::text_decoration_color::computed_value::T,
        }

        impl Text {
                        /// Set text-overflow.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_overflow(&mut self, v: longhands::text_overflow::computed_value::T) {
                            self.text_overflow = v;
                        }
                        /// Set text-overflow from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_overflow_from(&mut self, other: &Self) {
                            self.text_overflow = other.text_overflow.clone();
                        }
                    /// Reset text-overflow from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_overflow(&mut self, other: &Self) {
                        self.copy_text_overflow_from(other)
                    }

                    /// Get the computed value for text-overflow.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_overflow(&self) -> longhands::text_overflow::computed_value::T {
                        self.text_overflow.clone()
                    }
                        /// Set unicode-bidi.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_unicode_bidi(&mut self, v: longhands::unicode_bidi::computed_value::T) {
                            self.unicode_bidi = v;
                        }
                        /// Set unicode-bidi from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_unicode_bidi_from(&mut self, other: &Self) {
                            self.unicode_bidi = other.unicode_bidi.clone();
                        }
                    /// Reset unicode-bidi from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_unicode_bidi(&mut self, other: &Self) {
                        self.copy_unicode_bidi_from(other)
                    }

                    /// Get the computed value for unicode-bidi.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_unicode_bidi(&self) -> longhands::unicode_bidi::computed_value::T {
                        self.unicode_bidi.clone()
                    }
                        /// Set text-decoration-line.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_decoration_line(&mut self, v: longhands::text_decoration_line::computed_value::T) {
                            self.text_decoration_line = v;
                        }
                        /// Set text-decoration-line from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_decoration_line_from(&mut self, other: &Self) {
                            self.text_decoration_line = other.text_decoration_line.clone();
                        }
                    /// Reset text-decoration-line from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_decoration_line(&mut self, other: &Self) {
                        self.copy_text_decoration_line_from(other)
                    }

                    /// Get the computed value for text-decoration-line.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_decoration_line(&self) -> longhands::text_decoration_line::computed_value::T {
                        self.text_decoration_line.clone()
                    }
                        /// Set text-decoration-style.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_decoration_style(&mut self, v: longhands::text_decoration_style::computed_value::T) {
                            self.text_decoration_style = v;
                        }
                        /// Set text-decoration-style from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_decoration_style_from(&mut self, other: &Self) {
                            self.text_decoration_style = other.text_decoration_style.clone();
                        }
                    /// Reset text-decoration-style from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_decoration_style(&mut self, other: &Self) {
                        self.copy_text_decoration_style_from(other)
                    }

                    /// Get the computed value for text-decoration-style.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_decoration_style(&self) -> longhands::text_decoration_style::computed_value::T {
                        self.text_decoration_style.clone()
                    }
                        /// Set text-decoration-color.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_text_decoration_color(&mut self, v: longhands::text_decoration_color::computed_value::T) {
                            self.text_decoration_color = v;
                        }
                        /// Set text-decoration-color from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_text_decoration_color_from(&mut self, other: &Self) {
                            self.text_decoration_color = other.text_decoration_color.clone();
                        }
                    /// Reset text-decoration-color from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_text_decoration_color(&mut self, other: &Self) {
                        self.copy_text_decoration_color_from(other)
                    }

                    /// Get the computed value for text-decoration-color.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_text_decoration_color(&self) -> longhands::text_decoration_color::computed_value::T {
                        self.text_decoration_color.clone()
                    }
        }

        #[derive(Clone, Debug, MallocSizeOf, PartialEq)]
        /// The UI style struct.
        pub struct UI {
                    /// The transition-duration computed value.
                    pub transition_duration: longhands::transition_duration::computed_value::T,
                    /// The transition-timing-function computed value.
                    pub transition_timing_function: longhands::transition_timing_function::computed_value::T,
                    /// The transition-property computed value.
                    pub transition_property: longhands::transition_property::computed_value::T,
                    /// The transition-delay computed value.
                    pub transition_delay: longhands::transition_delay::computed_value::T,
                    /// The transition-behavior computed value.
                    pub transition_behavior: longhands::transition_behavior::computed_value::T,
                    /// The animation-name computed value.
                    pub animation_name: longhands::animation_name::computed_value::T,
                    /// The animation-duration computed value.
                    pub animation_duration: longhands::animation_duration::computed_value::T,
                    /// The animation-timing-function computed value.
                    pub animation_timing_function: longhands::animation_timing_function::computed_value::T,
                    /// The animation-iteration-count computed value.
                    pub animation_iteration_count: longhands::animation_iteration_count::computed_value::T,
                    /// The animation-direction computed value.
                    pub animation_direction: longhands::animation_direction::computed_value::T,
                    /// The animation-play-state computed value.
                    pub animation_play_state: longhands::animation_play_state::computed_value::T,
                    /// The animation-fill-mode computed value.
                    pub animation_fill_mode: longhands::animation_fill_mode::computed_value::T,
                    /// The animation-composition computed value.
                    pub animation_composition: longhands::animation_composition::computed_value::T,
                    /// The animation-delay computed value.
                    pub animation_delay: longhands::animation_delay::computed_value::T,
                    /// The animation-timeline computed value.
                    pub animation_timeline: longhands::animation_timeline::computed_value::T,
                    /// The view-transition-name computed value.
                    pub view_transition_name: longhands::view_transition_name::computed_value::T,
                    /// The view-transition-class computed value.
                    pub view_transition_class: longhands::view_transition_class::computed_value::T,
        }

        impl UI {
                        /// Set transition-duration.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transition_duration(&mut self, v: longhands::transition_duration::computed_value::T) {
                            self.transition_duration = v;
                        }
                        /// Set transition-duration from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transition_duration_from(&mut self, other: &Self) {
                            self.transition_duration = other.transition_duration.clone();
                        }
                    /// Reset transition-duration from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transition_duration(&mut self, other: &Self) {
                        self.copy_transition_duration_from(other)
                    }

                    /// Get the computed value for transition-duration.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transition_duration(&self) -> longhands::transition_duration::computed_value::T {
                        self.transition_duration.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn transition_duration_count(&self) -> usize {
                        self.transition_duration.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn transition_duration_at(&self, index: usize)
                        -> longhands::transition_duration::computed_value::SingleComputedValue {
                        self.transition_duration.0[index].clone()
                    }
                        /// Set transition-timing-function.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transition_timing_function(&mut self, v: longhands::transition_timing_function::computed_value::T) {
                            self.transition_timing_function = v;
                        }
                        /// Set transition-timing-function from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transition_timing_function_from(&mut self, other: &Self) {
                            self.transition_timing_function = other.transition_timing_function.clone();
                        }
                    /// Reset transition-timing-function from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transition_timing_function(&mut self, other: &Self) {
                        self.copy_transition_timing_function_from(other)
                    }

                    /// Get the computed value for transition-timing-function.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transition_timing_function(&self) -> longhands::transition_timing_function::computed_value::T {
                        self.transition_timing_function.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn transition_timing_function_count(&self) -> usize {
                        self.transition_timing_function.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn transition_timing_function_at(&self, index: usize)
                        -> longhands::transition_timing_function::computed_value::SingleComputedValue {
                        self.transition_timing_function.0[index].clone()
                    }
                        /// Set transition-property.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transition_property(&mut self, v: longhands::transition_property::computed_value::T) {
                            self.transition_property = v;
                        }
                        /// Set transition-property from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transition_property_from(&mut self, other: &Self) {
                            self.transition_property = other.transition_property.clone();
                        }
                    /// Reset transition-property from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transition_property(&mut self, other: &Self) {
                        self.copy_transition_property_from(other)
                    }

                    /// Get the computed value for transition-property.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transition_property(&self) -> longhands::transition_property::computed_value::T {
                        self.transition_property.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn transition_property_count(&self) -> usize {
                        self.transition_property.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn transition_property_at(&self, index: usize)
                        -> longhands::transition_property::computed_value::SingleComputedValue {
                        self.transition_property.0[index].clone()
                    }
                        /// Set transition-delay.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transition_delay(&mut self, v: longhands::transition_delay::computed_value::T) {
                            self.transition_delay = v;
                        }
                        /// Set transition-delay from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transition_delay_from(&mut self, other: &Self) {
                            self.transition_delay = other.transition_delay.clone();
                        }
                    /// Reset transition-delay from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transition_delay(&mut self, other: &Self) {
                        self.copy_transition_delay_from(other)
                    }

                    /// Get the computed value for transition-delay.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transition_delay(&self) -> longhands::transition_delay::computed_value::T {
                        self.transition_delay.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn transition_delay_count(&self) -> usize {
                        self.transition_delay.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn transition_delay_at(&self, index: usize)
                        -> longhands::transition_delay::computed_value::SingleComputedValue {
                        self.transition_delay.0[index].clone()
                    }
                        /// Set transition-behavior.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_transition_behavior(&mut self, v: longhands::transition_behavior::computed_value::T) {
                            self.transition_behavior = v;
                        }
                        /// Set transition-behavior from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_transition_behavior_from(&mut self, other: &Self) {
                            self.transition_behavior = other.transition_behavior.clone();
                        }
                    /// Reset transition-behavior from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_transition_behavior(&mut self, other: &Self) {
                        self.copy_transition_behavior_from(other)
                    }

                    /// Get the computed value for transition-behavior.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_transition_behavior(&self) -> longhands::transition_behavior::computed_value::T {
                        self.transition_behavior.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn transition_behavior_count(&self) -> usize {
                        self.transition_behavior.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn transition_behavior_at(&self, index: usize)
                        -> longhands::transition_behavior::computed_value::SingleComputedValue {
                        self.transition_behavior.0[index].clone()
                    }
                        /// Set animation-name.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_name(&mut self, v: longhands::animation_name::computed_value::T) {
                            self.animation_name = v;
                        }
                        /// Set animation-name from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_name_from(&mut self, other: &Self) {
                            self.animation_name = other.animation_name.clone();
                        }
                    /// Reset animation-name from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_name(&mut self, other: &Self) {
                        self.copy_animation_name_from(other)
                    }

                    /// Get the computed value for animation-name.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_name(&self) -> longhands::animation_name::computed_value::T {
                        self.animation_name.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_name_count(&self) -> usize {
                        self.animation_name.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_name_at(&self, index: usize)
                        -> longhands::animation_name::computed_value::SingleComputedValue {
                        self.animation_name.0[index].clone()
                    }
                        /// Set animation-duration.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_duration(&mut self, v: longhands::animation_duration::computed_value::T) {
                            self.animation_duration = v;
                        }
                        /// Set animation-duration from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_duration_from(&mut self, other: &Self) {
                            self.animation_duration = other.animation_duration.clone();
                        }
                    /// Reset animation-duration from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_duration(&mut self, other: &Self) {
                        self.copy_animation_duration_from(other)
                    }

                    /// Get the computed value for animation-duration.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_duration(&self) -> longhands::animation_duration::computed_value::T {
                        self.animation_duration.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_duration_count(&self) -> usize {
                        self.animation_duration.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_duration_at(&self, index: usize)
                        -> longhands::animation_duration::computed_value::SingleComputedValue {
                        self.animation_duration.0[index].clone()
                    }
                        /// Set animation-timing-function.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_timing_function(&mut self, v: longhands::animation_timing_function::computed_value::T) {
                            self.animation_timing_function = v;
                        }
                        /// Set animation-timing-function from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_timing_function_from(&mut self, other: &Self) {
                            self.animation_timing_function = other.animation_timing_function.clone();
                        }
                    /// Reset animation-timing-function from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_timing_function(&mut self, other: &Self) {
                        self.copy_animation_timing_function_from(other)
                    }

                    /// Get the computed value for animation-timing-function.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_timing_function(&self) -> longhands::animation_timing_function::computed_value::T {
                        self.animation_timing_function.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_timing_function_count(&self) -> usize {
                        self.animation_timing_function.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_timing_function_at(&self, index: usize)
                        -> longhands::animation_timing_function::computed_value::SingleComputedValue {
                        self.animation_timing_function.0[index].clone()
                    }
                        /// Set animation-iteration-count.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_iteration_count(&mut self, v: longhands::animation_iteration_count::computed_value::T) {
                            self.animation_iteration_count = v;
                        }
                        /// Set animation-iteration-count from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_iteration_count_from(&mut self, other: &Self) {
                            self.animation_iteration_count = other.animation_iteration_count.clone();
                        }
                    /// Reset animation-iteration-count from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_iteration_count(&mut self, other: &Self) {
                        self.copy_animation_iteration_count_from(other)
                    }

                    /// Get the computed value for animation-iteration-count.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_iteration_count(&self) -> longhands::animation_iteration_count::computed_value::T {
                        self.animation_iteration_count.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_iteration_count_count(&self) -> usize {
                        self.animation_iteration_count.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_iteration_count_at(&self, index: usize)
                        -> longhands::animation_iteration_count::computed_value::SingleComputedValue {
                        self.animation_iteration_count.0[index].clone()
                    }
                        /// Set animation-direction.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_direction(&mut self, v: longhands::animation_direction::computed_value::T) {
                            self.animation_direction = v;
                        }
                        /// Set animation-direction from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_direction_from(&mut self, other: &Self) {
                            self.animation_direction = other.animation_direction.clone();
                        }
                    /// Reset animation-direction from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_direction(&mut self, other: &Self) {
                        self.copy_animation_direction_from(other)
                    }

                    /// Get the computed value for animation-direction.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_direction(&self) -> longhands::animation_direction::computed_value::T {
                        self.animation_direction.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_direction_count(&self) -> usize {
                        self.animation_direction.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_direction_at(&self, index: usize)
                        -> longhands::animation_direction::computed_value::SingleComputedValue {
                        self.animation_direction.0[index].clone()
                    }
                        /// Set animation-play-state.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_play_state(&mut self, v: longhands::animation_play_state::computed_value::T) {
                            self.animation_play_state = v;
                        }
                        /// Set animation-play-state from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_play_state_from(&mut self, other: &Self) {
                            self.animation_play_state = other.animation_play_state.clone();
                        }
                    /// Reset animation-play-state from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_play_state(&mut self, other: &Self) {
                        self.copy_animation_play_state_from(other)
                    }

                    /// Get the computed value for animation-play-state.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_play_state(&self) -> longhands::animation_play_state::computed_value::T {
                        self.animation_play_state.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_play_state_count(&self) -> usize {
                        self.animation_play_state.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_play_state_at(&self, index: usize)
                        -> longhands::animation_play_state::computed_value::SingleComputedValue {
                        self.animation_play_state.0[index].clone()
                    }
                        /// Set animation-fill-mode.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_fill_mode(&mut self, v: longhands::animation_fill_mode::computed_value::T) {
                            self.animation_fill_mode = v;
                        }
                        /// Set animation-fill-mode from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_fill_mode_from(&mut self, other: &Self) {
                            self.animation_fill_mode = other.animation_fill_mode.clone();
                        }
                    /// Reset animation-fill-mode from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_fill_mode(&mut self, other: &Self) {
                        self.copy_animation_fill_mode_from(other)
                    }

                    /// Get the computed value for animation-fill-mode.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_fill_mode(&self) -> longhands::animation_fill_mode::computed_value::T {
                        self.animation_fill_mode.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_fill_mode_count(&self) -> usize {
                        self.animation_fill_mode.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_fill_mode_at(&self, index: usize)
                        -> longhands::animation_fill_mode::computed_value::SingleComputedValue {
                        self.animation_fill_mode.0[index].clone()
                    }
                        /// Set animation-composition.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_composition(&mut self, v: longhands::animation_composition::computed_value::T) {
                            self.animation_composition = v;
                        }
                        /// Set animation-composition from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_composition_from(&mut self, other: &Self) {
                            self.animation_composition = other.animation_composition.clone();
                        }
                    /// Reset animation-composition from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_composition(&mut self, other: &Self) {
                        self.copy_animation_composition_from(other)
                    }

                    /// Get the computed value for animation-composition.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_composition(&self) -> longhands::animation_composition::computed_value::T {
                        self.animation_composition.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_composition_count(&self) -> usize {
                        self.animation_composition.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_composition_at(&self, index: usize)
                        -> longhands::animation_composition::computed_value::SingleComputedValue {
                        self.animation_composition.0[index].clone()
                    }
                        /// Set animation-delay.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_delay(&mut self, v: longhands::animation_delay::computed_value::T) {
                            self.animation_delay = v;
                        }
                        /// Set animation-delay from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_delay_from(&mut self, other: &Self) {
                            self.animation_delay = other.animation_delay.clone();
                        }
                    /// Reset animation-delay from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_delay(&mut self, other: &Self) {
                        self.copy_animation_delay_from(other)
                    }

                    /// Get the computed value for animation-delay.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_delay(&self) -> longhands::animation_delay::computed_value::T {
                        self.animation_delay.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_delay_count(&self) -> usize {
                        self.animation_delay.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_delay_at(&self, index: usize)
                        -> longhands::animation_delay::computed_value::SingleComputedValue {
                        self.animation_delay.0[index].clone()
                    }
                        /// Set animation-timeline.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_animation_timeline(&mut self, v: longhands::animation_timeline::computed_value::T) {
                            self.animation_timeline = v;
                        }
                        /// Set animation-timeline from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_animation_timeline_from(&mut self, other: &Self) {
                            self.animation_timeline = other.animation_timeline.clone();
                        }
                    /// Reset animation-timeline from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_animation_timeline(&mut self, other: &Self) {
                        self.copy_animation_timeline_from(other)
                    }

                    /// Get the computed value for animation-timeline.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_animation_timeline(&self) -> longhands::animation_timeline::computed_value::T {
                        self.animation_timeline.clone()
                    }
                    /// If this longhand is indexed, get the number of elements.
                    #[allow(non_snake_case)]
                    pub fn animation_timeline_count(&self) -> usize {
                        self.animation_timeline.0.len()
                    }

                    /// If this longhand is indexed, get the element at given
                    /// index.
                    #[allow(non_snake_case)]
                    pub fn animation_timeline_at(&self, index: usize)
                        -> longhands::animation_timeline::computed_value::SingleComputedValue {
                        self.animation_timeline.0[index].clone()
                    }
                        /// Set view-transition-name.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_view_transition_name(&mut self, v: longhands::view_transition_name::computed_value::T) {
                            self.view_transition_name = v;
                        }
                        /// Set view-transition-name from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_view_transition_name_from(&mut self, other: &Self) {
                            self.view_transition_name = other.view_transition_name.clone();
                        }
                    /// Reset view-transition-name from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_view_transition_name(&mut self, other: &Self) {
                        self.copy_view_transition_name_from(other)
                    }

                    /// Get the computed value for view-transition-name.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_view_transition_name(&self) -> longhands::view_transition_name::computed_value::T {
                        self.view_transition_name.clone()
                    }
                        /// Set view-transition-class.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn set_view_transition_class(&mut self, v: longhands::view_transition_class::computed_value::T) {
                            self.view_transition_class = v;
                        }
                        /// Set view-transition-class from other struct.
                        #[allow(non_snake_case)]
                        #[inline]
                        pub fn copy_view_transition_class_from(&mut self, other: &Self) {
                            self.view_transition_class = other.view_transition_class.clone();
                        }
                    /// Reset view-transition-class from the initial struct.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn reset_view_transition_class(&mut self, other: &Self) {
                        self.copy_view_transition_class_from(other)
                    }

                    /// Get the computed value for view-transition-class.
                    #[allow(non_snake_case)]
                    #[inline]
                    pub fn clone_view_transition_class(&self) -> longhands::view_transition_class::computed_value::T {
                        self.view_transition_class.clone()
                    }
        }

}

    impl style_structs::Background {

    }

    impl style_structs::Border {

    }

    impl style_structs::Box {

    }

    impl style_structs::Column {

            /// Whether this is a multicol style.
            #[cfg(feature = "servo")]
            pub fn is_multicol(&self) -> bool {
                !self.column_width.is_auto() || !self.column_count.is_auto()
            }
    }

    impl style_structs::Counters {

    }

    impl style_structs::Effects {

    }

    impl style_structs::Font {

    }

    impl style_structs::InheritedBox {

    }

    impl style_structs::InheritedTable {

    }

    impl style_structs::InheritedText {

    }

    impl style_structs::InheritedUI {

    }

    impl style_structs::List {

    }

    impl style_structs::Margin {

    }

    impl style_structs::Outline {

    }

    impl style_structs::Padding {

    }

    impl style_structs::Position {

    }

    impl style_structs::SVG {

    }

    impl style_structs::Table {

    }

    impl style_structs::Text {

    }

    impl style_structs::UI {
                /// Iterate over the values of transition-duration.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_duration_iter(&self) -> TransitionDurationIter<'_> {
                    TransitionDurationIter {
                        style_struct: self,
                        current: 0,
                        max: self.transition_duration_count(),
                    }
                }

                /// Get a value mod `index` for the property transition-duration.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_duration_mod(&self, index: usize)
                    -> longhands::transition_duration::computed_value::SingleComputedValue {
                    self.transition_duration_at(index % self.transition_duration_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_transition_duration(
                    &self,
                ) -> longhands::transition_duration::computed_value::T {
                    longhands::transition_duration::computed_value::List(
                        self.transition_duration_iter().collect()
                    )
                }
                /// Iterate over the values of transition-timing-function.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_timing_function_iter(&self) -> TransitionTimingFunctionIter<'_> {
                    TransitionTimingFunctionIter {
                        style_struct: self,
                        current: 0,
                        max: self.transition_timing_function_count(),
                    }
                }

                /// Get a value mod `index` for the property transition-timing-function.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_timing_function_mod(&self, index: usize)
                    -> longhands::transition_timing_function::computed_value::SingleComputedValue {
                    self.transition_timing_function_at(index % self.transition_timing_function_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_transition_timing_function(
                    &self,
                ) -> longhands::transition_timing_function::computed_value::T {
                    longhands::transition_timing_function::computed_value::List(
                        self.transition_timing_function_iter().collect()
                    )
                }
                /// Iterate over the values of transition-property.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_property_iter(&self) -> TransitionPropertyIter<'_> {
                    TransitionPropertyIter {
                        style_struct: self,
                        current: 0,
                        max: self.transition_property_count(),
                    }
                }

                /// Get a value mod `index` for the property transition-property.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_property_mod(&self, index: usize)
                    -> longhands::transition_property::computed_value::SingleComputedValue {
                    self.transition_property_at(index % self.transition_property_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_transition_property(
                    &self,
                ) -> longhands::transition_property::computed_value::T {
                    longhands::transition_property::computed_value::List(
                        self.transition_property_iter().collect()
                    )
                }
                /// Iterate over the values of transition-delay.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_delay_iter(&self) -> TransitionDelayIter<'_> {
                    TransitionDelayIter {
                        style_struct: self,
                        current: 0,
                        max: self.transition_delay_count(),
                    }
                }

                /// Get a value mod `index` for the property transition-delay.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_delay_mod(&self, index: usize)
                    -> longhands::transition_delay::computed_value::SingleComputedValue {
                    self.transition_delay_at(index % self.transition_delay_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_transition_delay(
                    &self,
                ) -> longhands::transition_delay::computed_value::T {
                    longhands::transition_delay::computed_value::List(
                        self.transition_delay_iter().collect()
                    )
                }
                /// Iterate over the values of transition-behavior.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_behavior_iter(&self) -> TransitionBehaviorIter<'_> {
                    TransitionBehaviorIter {
                        style_struct: self,
                        current: 0,
                        max: self.transition_behavior_count(),
                    }
                }

                /// Get a value mod `index` for the property transition-behavior.
                #[allow(non_snake_case)]
                #[inline]
                pub fn transition_behavior_mod(&self, index: usize)
                    -> longhands::transition_behavior::computed_value::SingleComputedValue {
                    self.transition_behavior_at(index % self.transition_behavior_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_transition_behavior(
                    &self,
                ) -> longhands::transition_behavior::computed_value::T {
                    longhands::transition_behavior::computed_value::List(
                        self.transition_behavior_iter().collect()
                    )
                }
                /// Iterate over the values of animation-name.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_name_iter(&self) -> AnimationNameIter<'_> {
                    AnimationNameIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_name_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-name.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_name_mod(&self, index: usize)
                    -> longhands::animation_name::computed_value::SingleComputedValue {
                    self.animation_name_at(index % self.animation_name_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_name(
                    &self,
                ) -> longhands::animation_name::computed_value::T {
                    longhands::animation_name::computed_value::List(
                        self.animation_name_iter().collect()
                    )
                }
                /// Iterate over the values of animation-duration.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_duration_iter(&self) -> AnimationDurationIter<'_> {
                    AnimationDurationIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_duration_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-duration.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_duration_mod(&self, index: usize)
                    -> longhands::animation_duration::computed_value::SingleComputedValue {
                    self.animation_duration_at(index % self.animation_duration_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_duration(
                    &self,
                ) -> longhands::animation_duration::computed_value::T {
                    longhands::animation_duration::computed_value::List(
                        self.animation_duration_iter().collect()
                    )
                }
                /// Iterate over the values of animation-timing-function.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_timing_function_iter(&self) -> AnimationTimingFunctionIter<'_> {
                    AnimationTimingFunctionIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_timing_function_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-timing-function.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_timing_function_mod(&self, index: usize)
                    -> longhands::animation_timing_function::computed_value::SingleComputedValue {
                    self.animation_timing_function_at(index % self.animation_timing_function_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_timing_function(
                    &self,
                ) -> longhands::animation_timing_function::computed_value::T {
                    longhands::animation_timing_function::computed_value::List(
                        self.animation_timing_function_iter().collect()
                    )
                }
                /// Iterate over the values of animation-iteration-count.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_iteration_count_iter(&self) -> AnimationIterationCountIter<'_> {
                    AnimationIterationCountIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_iteration_count_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-iteration-count.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_iteration_count_mod(&self, index: usize)
                    -> longhands::animation_iteration_count::computed_value::SingleComputedValue {
                    self.animation_iteration_count_at(index % self.animation_iteration_count_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_iteration_count(
                    &self,
                ) -> longhands::animation_iteration_count::computed_value::T {
                    longhands::animation_iteration_count::computed_value::List(
                        self.animation_iteration_count_iter().collect()
                    )
                }
                /// Iterate over the values of animation-direction.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_direction_iter(&self) -> AnimationDirectionIter<'_> {
                    AnimationDirectionIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_direction_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-direction.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_direction_mod(&self, index: usize)
                    -> longhands::animation_direction::computed_value::SingleComputedValue {
                    self.animation_direction_at(index % self.animation_direction_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_direction(
                    &self,
                ) -> longhands::animation_direction::computed_value::T {
                    longhands::animation_direction::computed_value::List(
                        self.animation_direction_iter().collect()
                    )
                }
                /// Iterate over the values of animation-play-state.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_play_state_iter(&self) -> AnimationPlayStateIter<'_> {
                    AnimationPlayStateIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_play_state_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-play-state.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_play_state_mod(&self, index: usize)
                    -> longhands::animation_play_state::computed_value::SingleComputedValue {
                    self.animation_play_state_at(index % self.animation_play_state_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_play_state(
                    &self,
                ) -> longhands::animation_play_state::computed_value::T {
                    longhands::animation_play_state::computed_value::List(
                        self.animation_play_state_iter().collect()
                    )
                }
                /// Iterate over the values of animation-fill-mode.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_fill_mode_iter(&self) -> AnimationFillModeIter<'_> {
                    AnimationFillModeIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_fill_mode_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-fill-mode.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_fill_mode_mod(&self, index: usize)
                    -> longhands::animation_fill_mode::computed_value::SingleComputedValue {
                    self.animation_fill_mode_at(index % self.animation_fill_mode_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_fill_mode(
                    &self,
                ) -> longhands::animation_fill_mode::computed_value::T {
                    longhands::animation_fill_mode::computed_value::List(
                        self.animation_fill_mode_iter().collect()
                    )
                }
                /// Iterate over the values of animation-composition.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_composition_iter(&self) -> AnimationCompositionIter<'_> {
                    AnimationCompositionIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_composition_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-composition.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_composition_mod(&self, index: usize)
                    -> longhands::animation_composition::computed_value::SingleComputedValue {
                    self.animation_composition_at(index % self.animation_composition_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_composition(
                    &self,
                ) -> longhands::animation_composition::computed_value::T {
                    longhands::animation_composition::computed_value::List(
                        self.animation_composition_iter().collect()
                    )
                }
                /// Iterate over the values of animation-delay.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_delay_iter(&self) -> AnimationDelayIter<'_> {
                    AnimationDelayIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_delay_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-delay.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_delay_mod(&self, index: usize)
                    -> longhands::animation_delay::computed_value::SingleComputedValue {
                    self.animation_delay_at(index % self.animation_delay_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_delay(
                    &self,
                ) -> longhands::animation_delay::computed_value::T {
                    longhands::animation_delay::computed_value::List(
                        self.animation_delay_iter().collect()
                    )
                }
                /// Iterate over the values of animation-timeline.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_timeline_iter(&self) -> AnimationTimelineIter<'_> {
                    AnimationTimelineIter {
                        style_struct: self,
                        current: 0,
                        max: self.animation_timeline_count(),
                    }
                }

                /// Get a value mod `index` for the property animation-timeline.
                #[allow(non_snake_case)]
                #[inline]
                pub fn animation_timeline_mod(&self, index: usize)
                    -> longhands::animation_timeline::computed_value::SingleComputedValue {
                    self.animation_timeline_at(index % self.animation_timeline_count())
                }

                /// Clone the computed value for the property.
                #[allow(non_snake_case)]
                #[inline]
                #[cfg(feature = "gecko")]
                pub fn clone_animation_timeline(
                    &self,
                ) -> longhands::animation_timeline::computed_value::T {
                    longhands::animation_timeline::computed_value::List(
                        self.animation_timeline_iter().collect()
                    )
                }

            /// Returns whether there is any animation specified with
            /// animation-name other than `none`.
            pub fn specifies_animations(&self) -> bool {
                self.animation_name_iter().any(|name| !name.is_none())
            }

            /// Returns whether there are any transitions specified.
            #[cfg(feature = "servo")]
            pub fn specifies_transitions(&self) -> bool {
                (0..self.transition_property_count()).any(|index| {
                    let combined_duration =
                        self.transition_duration_mod(index).seconds().max(0.) +
                        self.transition_delay_mod(index).seconds();
                    combined_duration > 0.
                })
            }

            /// Returns whether animation-timeline is initial value. We need this information to
            /// resolve animation-duration.
            #[cfg(feature = "servo")]
            pub fn has_initial_animation_timeline(&self) -> bool {
                self.animation_timeline_count() == 1 && self.animation_timeline_at(0).is_auto()
            }

            /// Returns whether there is any named progress timeline specified with
            /// scroll-timeline-name other than `none`.
            #[cfg(feature = "gecko")]
            pub fn specifies_scroll_timelines(&self) -> bool {
                self.scroll_timeline_name_iter().any(|name| !name.is_none())
            }

            /// Returns whether there is any named progress timeline specified with
            /// view-timeline-name other than `none`.
            #[cfg(feature = "gecko")]
            pub fn specifies_view_timelines(&self) -> bool {
                self.view_timeline_name_iter().any(|name| !name.is_none())
            }

            /// Returns true if animation properties are equal between styles, but without
            /// considering keyframe data and animation-timeline.
            #[cfg(feature = "servo")]
            pub fn animations_equals(&self, other: &Self) -> bool {
                self.animation_name_iter().eq(other.animation_name_iter()) &&
                self.animation_delay_iter().eq(other.animation_delay_iter()) &&
                self.animation_direction_iter().eq(other.animation_direction_iter()) &&
                self.animation_duration_iter().eq(other.animation_duration_iter()) &&
                self.animation_fill_mode_iter().eq(other.animation_fill_mode_iter()) &&
                self.animation_iteration_count_iter().eq(other.animation_iteration_count_iter()) &&
                self.animation_play_state_iter().eq(other.animation_play_state_iter()) &&
                self.animation_timing_function_iter().eq(other.animation_timing_function_iter())
            }

    }

            /// An iterator over the values of the transition-duration properties.
            pub struct TransitionDurationIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for TransitionDurationIter<'a> {
                type Item = longhands::transition_duration::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.transition_duration_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the transition-timing-function properties.
            pub struct TransitionTimingFunctionIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for TransitionTimingFunctionIter<'a> {
                type Item = longhands::transition_timing_function::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.transition_timing_function_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the transition-property properties.
            pub struct TransitionPropertyIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for TransitionPropertyIter<'a> {
                type Item = longhands::transition_property::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.transition_property_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the transition-delay properties.
            pub struct TransitionDelayIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for TransitionDelayIter<'a> {
                type Item = longhands::transition_delay::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.transition_delay_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the transition-behavior properties.
            pub struct TransitionBehaviorIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for TransitionBehaviorIter<'a> {
                type Item = longhands::transition_behavior::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.transition_behavior_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-name properties.
            pub struct AnimationNameIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationNameIter<'a> {
                type Item = longhands::animation_name::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_name_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-duration properties.
            pub struct AnimationDurationIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationDurationIter<'a> {
                type Item = longhands::animation_duration::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_duration_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-timing-function properties.
            pub struct AnimationTimingFunctionIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationTimingFunctionIter<'a> {
                type Item = longhands::animation_timing_function::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_timing_function_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-iteration-count properties.
            pub struct AnimationIterationCountIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationIterationCountIter<'a> {
                type Item = longhands::animation_iteration_count::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_iteration_count_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-direction properties.
            pub struct AnimationDirectionIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationDirectionIter<'a> {
                type Item = longhands::animation_direction::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_direction_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-play-state properties.
            pub struct AnimationPlayStateIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationPlayStateIter<'a> {
                type Item = longhands::animation_play_state::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_play_state_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-fill-mode properties.
            pub struct AnimationFillModeIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationFillModeIter<'a> {
                type Item = longhands::animation_fill_mode::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_fill_mode_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-composition properties.
            pub struct AnimationCompositionIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationCompositionIter<'a> {
                type Item = longhands::animation_composition::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_composition_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-delay properties.
            pub struct AnimationDelayIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationDelayIter<'a> {
                type Item = longhands::animation_delay::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_delay_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }
            /// An iterator over the values of the animation-timeline properties.
            pub struct AnimationTimelineIter<'a> {
                style_struct: &'a style_structs::UI,
                current: usize,
                max: usize,
            }

            impl<'a> Iterator for AnimationTimelineIter<'a> {
                type Item = longhands::animation_timeline::computed_value::SingleComputedValue;

                fn next(&mut self) -> Option<Self::Item> {
                    self.current += 1;
                    if self.current <= self.max {
                        Some(self.style_struct.animation_timeline_at(self.current - 1))
                    } else {
                        None
                    }
                }
            }


#[cfg(feature = "gecko")]
pub use super::gecko::{ComputedValues, ComputedValuesInner};

#[cfg(feature = "servo")]
#[cfg_attr(feature = "servo", derive(Clone, Debug))]
/// Actual data of ComputedValues, to match up with Gecko
pub struct ComputedValuesInner {
        background: Arc<style_structs::Background>,
        border: Arc<style_structs::Border>,
        box_: Arc<style_structs::Box>,
        column: Arc<style_structs::Column>,
        counters: Arc<style_structs::Counters>,
        effects: Arc<style_structs::Effects>,
        font: Arc<style_structs::Font>,
        inherited_box: Arc<style_structs::InheritedBox>,
        inherited_table: Arc<style_structs::InheritedTable>,
        inherited_text: Arc<style_structs::InheritedText>,
        inherited_ui: Arc<style_structs::InheritedUI>,
        list: Arc<style_structs::List>,
        margin: Arc<style_structs::Margin>,
        outline: Arc<style_structs::Outline>,
        padding: Arc<style_structs::Padding>,
        position: Arc<style_structs::Position>,
        svg: Arc<style_structs::SVG>,
        table: Arc<style_structs::Table>,
        text: Arc<style_structs::Text>,
        ui: Arc<style_structs::UI>,
    custom_properties: crate::custom_properties::ComputedCustomProperties,

    /// The effective zoom value.
    pub effective_zoom: computed::Zoom,

    /// A set of flags we use to store misc information regarding this style.
    pub flags: ComputedValueFlags,

    /// The writing mode of this computed values struct.
    pub writing_mode: WritingMode,

    /// The rule node representing the ordered list of rules matched for this
    /// node.  Can be None for default values and text nodes.  This is
    /// essentially an optimization to avoid referencing the root rule node.
    pub rules: Option<StrongRuleNode>,

    /// The element's computed values if visited, only computed if there's a
    /// relevant link for this element. A element's "relevant link" is the
    /// element being matched if it is a link or the nearest ancestor link.
    visited_style: Option<Arc<ComputedValues>>,
}

/// The struct that Servo uses to represent computed values.
///
/// This struct contains an immutable atomically-reference-counted pointer to
/// every kind of style struct.
///
/// When needed, the structs may be copied in order to get mutated.
#[cfg(feature = "servo")]
#[cfg_attr(feature = "servo", derive(Clone, Debug))]
pub struct ComputedValues {
    /// The actual computed values
    ///
    /// In Gecko the outer ComputedValues is actually a ComputedStyle, whereas
    /// ComputedValuesInner is the core set of computed values.
    ///
    /// We maintain this distinction in servo to reduce the amount of special
    /// casing.
    inner: ComputedValuesInner,

    /// The pseudo-element that we're using.
    pseudo: Option<PseudoElement>,
}

impl ComputedValues {
    /// Returns the pseudo-element that this style represents.
    #[cfg(feature = "servo")]
    pub fn pseudo(&self) -> Option<&PseudoElement> {
        self.pseudo.as_ref()
    }

    /// Returns true if this is the style for a pseudo-element.
    #[cfg(feature = "servo")]
    pub fn is_pseudo_style(&self) -> bool {
        self.pseudo().is_some()
    }

    /// Returns whether this style's display value is equal to contents.
    pub fn is_display_contents(&self) -> bool {
        self.clone_display().is_contents()
    }

    /// Gets a reference to the rule node. Panic if no rule node exists.
    pub fn rules(&self) -> &StrongRuleNode {
        self.rules.as_ref().unwrap()
    }

    /// Returns the visited rules, if applicable.
    pub fn visited_rules(&self) -> Option<&StrongRuleNode> {
        self.visited_style().and_then(|s| s.rules.as_ref())
    }

    /// Gets a reference to the custom properties map (if one exists).
    pub fn custom_properties(&self) -> &crate::custom_properties::ComputedCustomProperties {
        &self.custom_properties
    }

    /// Returns whether we have the same custom properties as another style.
    pub fn custom_properties_equal(&self, other: &Self) -> bool {
      self.custom_properties() == other.custom_properties()
    }

    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_align_items(
        &self,
    ) -> longhands::align_items::computed_value::T {
        self.get_position().clone_align_items()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_aspect_ratio(
        &self,
    ) -> longhands::aspect_ratio::computed_value::T {
        self.get_position().clone_aspect_ratio()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_backface_visibility(
        &self,
    ) -> longhands::backface_visibility::computed_value::T {
        self.get_box().clone_backface_visibility()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_baseline_source(
        &self,
    ) -> longhands::baseline_source::computed_value::T {
        self.get_box().clone_baseline_source()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_collapse(
        &self,
    ) -> longhands::border_collapse::computed_value::T {
        self.get_inherited_table().clone_border_collapse()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_image_repeat(
        &self,
    ) -> longhands::border_image_repeat::computed_value::T {
        self.get_border().clone_border_image_repeat()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_box_sizing(
        &self,
    ) -> longhands::box_sizing::computed_value::T {
        self.get_position().clone_box_sizing()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_caption_side(
        &self,
    ) -> longhands::caption_side::computed_value::T {
        self.get_inherited_table().clone_caption_side()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_clear(
        &self,
    ) -> longhands::clear::computed_value::T {
        self.get_box().clone_clear()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_column_count(
        &self,
    ) -> longhands::column_count::computed_value::T {
        self.get_column().clone_column_count()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_column_span(
        &self,
    ) -> longhands::column_span::computed_value::T {
        self.get_column().clone_column_span()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_contain(
        &self,
    ) -> longhands::contain::computed_value::T {
        self.get_box().clone_contain()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_container_type(
        &self,
    ) -> longhands::container_type::computed_value::T {
        self.get_box().clone_container_type()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_direction(
        &self,
    ) -> longhands::direction::computed_value::T {
        self.get_inherited_box().clone_direction()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_display(
        &self,
    ) -> longhands::display::computed_value::T {
        self.get_box().clone_display()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_empty_cells(
        &self,
    ) -> longhands::empty_cells::computed_value::T {
        self.get_inherited_table().clone_empty_cells()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_flex_direction(
        &self,
    ) -> longhands::flex_direction::computed_value::T {
        self.get_position().clone_flex_direction()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_flex_wrap(
        &self,
    ) -> longhands::flex_wrap::computed_value::T {
        self.get_position().clone_flex_wrap()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_float(
        &self,
    ) -> longhands::float::computed_value::T {
        self.get_box().clone_float()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_language_override(
        &self,
    ) -> longhands::font_language_override::computed_value::T {
        self.get_font().clone_font_language_override()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_stretch(
        &self,
    ) -> longhands::font_stretch::computed_value::T {
        self.get_font().clone_font_stretch()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_style(
        &self,
    ) -> longhands::font_style::computed_value::T {
        self.get_font().clone_font_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_synthesis_weight(
        &self,
    ) -> longhands::font_synthesis_weight::computed_value::T {
        self.get_font().clone_font_synthesis_weight()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_variant_caps(
        &self,
    ) -> longhands::font_variant_caps::computed_value::T {
        self.get_font().clone_font_variant_caps()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_weight(
        &self,
    ) -> longhands::font_weight::computed_value::T {
        self.get_font().clone_font_weight()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_auto_flow(
        &self,
    ) -> longhands::grid_auto_flow::computed_value::T {
        self.get_position().clone_grid_auto_flow()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_image_rendering(
        &self,
    ) -> longhands::image_rendering::computed_value::T {
        self.get_inherited_box().clone_image_rendering()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_isolation(
        &self,
    ) -> longhands::isolation::computed_value::T {
        self.get_box().clone_isolation()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_justify_items(
        &self,
    ) -> longhands::justify_items::computed_value::T {
        self.get_position().clone_justify_items()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_list_style_position(
        &self,
    ) -> longhands::list_style_position::computed_value::T {
        self.get_list().clone_list_style_position()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_list_style_type(
        &self,
    ) -> longhands::list_style_type::computed_value::T {
        self.get_list().clone_list_style_type()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_mix_blend_mode(
        &self,
    ) -> longhands::mix_blend_mode::computed_value::T {
        self.get_effects().clone_mix_blend_mode()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_object_fit(
        &self,
    ) -> longhands::object_fit::computed_value::T {
        self.get_position().clone_object_fit()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_opacity(
        &self,
    ) -> longhands::opacity::computed_value::T {
        self.get_effects().clone_opacity()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_order(
        &self,
    ) -> longhands::order::computed_value::T {
        self.get_position().clone_order()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_outline_style(
        &self,
    ) -> longhands::outline_style::computed_value::T {
        self.get_outline().clone_outline_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_overflow_wrap(
        &self,
    ) -> longhands::overflow_wrap::computed_value::T {
        self.get_inherited_text().clone_overflow_wrap()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_pointer_events(
        &self,
    ) -> longhands::pointer_events::computed_value::T {
        self.get_inherited_ui().clone_pointer_events()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_position(
        &self,
    ) -> longhands::position::computed_value::T {
        self.get_box().clone_position()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_position_area(
        &self,
    ) -> longhands::position_area::computed_value::T {
        self.get_position().clone_position_area()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone__servo_overflow_clip_box(
        &self,
    ) -> longhands::_servo_overflow_clip_box::computed_value::T {
        self.get_box().clone__servo_overflow_clip_box()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone__servo_top_layer(
        &self,
    ) -> longhands::_servo_top_layer::computed_value::T {
        self.get_box().clone__servo_top_layer()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_table_layout(
        &self,
    ) -> longhands::table_layout::computed_value::T {
        self.get_table().clone_table_layout()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_align(
        &self,
    ) -> longhands::text_align::computed_value::T {
        self.get_inherited_text().clone_text_align()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_align_last(
        &self,
    ) -> longhands::text_align_last::computed_value::T {
        self.get_inherited_text().clone_text_align_last()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_decoration_line(
        &self,
    ) -> longhands::text_decoration_line::computed_value::T {
        self.get_text().clone_text_decoration_line()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_decoration_style(
        &self,
    ) -> longhands::text_decoration_style::computed_value::T {
        self.get_text().clone_text_decoration_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_justify(
        &self,
    ) -> longhands::text_justify::computed_value::T {
        self.get_inherited_text().clone_text_justify()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_rendering(
        &self,
    ) -> longhands::text_rendering::computed_value::T {
        self.get_inherited_text().clone_text_rendering()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_transform(
        &self,
    ) -> longhands::text_transform::computed_value::T {
        self.get_inherited_text().clone_text_transform()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_wrap_mode(
        &self,
    ) -> longhands::text_wrap_mode::computed_value::T {
        self.get_inherited_text().clone_text_wrap_mode()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transform_style(
        &self,
    ) -> longhands::transform_style::computed_value::T {
        self.get_box().clone_transform_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_unicode_bidi(
        &self,
    ) -> longhands::unicode_bidi::computed_value::T {
        self.get_text().clone_unicode_bidi()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_visibility(
        &self,
    ) -> longhands::visibility::computed_value::T {
        self.get_inherited_box().clone_visibility()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_white_space_collapse(
        &self,
    ) -> longhands::white_space_collapse::computed_value::T {
        self.get_inherited_text().clone_white_space_collapse()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_word_break(
        &self,
    ) -> longhands::word_break::computed_value::T {
        self.get_inherited_text().clone_word_break()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_writing_mode(
        &self,
    ) -> longhands::writing_mode::computed_value::T {
        self.get_inherited_box().clone_writing_mode()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_z_index(
        &self,
    ) -> longhands::z_index::computed_value::T {
        self.get_position().clone_z_index()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_zoom(
        &self,
    ) -> longhands::zoom::computed_value::T {
        self.get_box().clone_zoom()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_align_content(
        &self,
    ) -> longhands::align_content::computed_value::T {
        self.get_position().clone_align_content()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_justify_content(
        &self,
    ) -> longhands::justify_content::computed_value::T {
        self.get_position().clone_justify_content()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_flex_grow(
        &self,
    ) -> longhands::flex_grow::computed_value::T {
        self.get_position().clone_flex_grow()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_flex_shrink(
        &self,
    ) -> longhands::flex_shrink::computed_value::T {
        self.get_position().clone_flex_shrink()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_align_self(
        &self,
    ) -> longhands::align_self::computed_value::T {
        self.get_position().clone_align_self()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_justify_self(
        &self,
    ) -> longhands::justify_self::computed_value::T {
        self.get_position().clone_justify_self()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_overflow_x(
        &self,
    ) -> longhands::overflow_x::computed_value::T {
        self.get_box().clone_overflow_x()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_overflow_y(
        &self,
    ) -> longhands::overflow_y::computed_value::T {
        self.get_box().clone_overflow_y()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_bottom_style(
        &self,
    ) -> longhands::border_bottom_style::computed_value::T {
        self.get_border().clone_border_bottom_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_left_style(
        &self,
    ) -> longhands::border_left_style::computed_value::T {
        self.get_border().clone_border_left_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_right_style(
        &self,
    ) -> longhands::border_right_style::computed_value::T {
        self.get_border().clone_border_right_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_top_style(
        &self,
    ) -> longhands::border_top_style::computed_value::T {
        self.get_border().clone_border_top_style()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_composition(
        &self,
    ) -> longhands::animation_composition::computed_value::T {
        self.get_ui().clone_animation_composition()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_delay(
        &self,
    ) -> longhands::animation_delay::computed_value::T {
        self.get_ui().clone_animation_delay()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_direction(
        &self,
    ) -> longhands::animation_direction::computed_value::T {
        self.get_ui().clone_animation_direction()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_duration(
        &self,
    ) -> longhands::animation_duration::computed_value::T {
        self.get_ui().clone_animation_duration()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_fill_mode(
        &self,
    ) -> longhands::animation_fill_mode::computed_value::T {
        self.get_ui().clone_animation_fill_mode()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_iteration_count(
        &self,
    ) -> longhands::animation_iteration_count::computed_value::T {
        self.get_ui().clone_animation_iteration_count()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_name(
        &self,
    ) -> longhands::animation_name::computed_value::T {
        self.get_ui().clone_animation_name()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_play_state(
        &self,
    ) -> longhands::animation_play_state::computed_value::T {
        self.get_ui().clone_animation_play_state()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_timeline(
        &self,
    ) -> longhands::animation_timeline::computed_value::T {
        self.get_ui().clone_animation_timeline()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_animation_timing_function(
        &self,
    ) -> longhands::animation_timing_function::computed_value::T {
        self.get_ui().clone_animation_timing_function()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_backdrop_filter(
        &self,
    ) -> longhands::backdrop_filter::computed_value::T {
        self.get_effects().clone_backdrop_filter()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_attachment(
        &self,
    ) -> longhands::background_attachment::computed_value::T {
        self.get_background().clone_background_attachment()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_clip(
        &self,
    ) -> longhands::background_clip::computed_value::T {
        self.get_background().clone_background_clip()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_image(
        &self,
    ) -> longhands::background_image::computed_value::T {
        self.get_background().clone_background_image()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_origin(
        &self,
    ) -> longhands::background_origin::computed_value::T {
        self.get_background().clone_background_origin()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_position_x(
        &self,
    ) -> longhands::background_position_x::computed_value::T {
        self.get_background().clone_background_position_x()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_position_y(
        &self,
    ) -> longhands::background_position_y::computed_value::T {
        self.get_background().clone_background_position_y()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_repeat(
        &self,
    ) -> longhands::background_repeat::computed_value::T {
        self.get_background().clone_background_repeat()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_size(
        &self,
    ) -> longhands::background_size::computed_value::T {
        self.get_background().clone_background_size()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_image_outset(
        &self,
    ) -> longhands::border_image_outset::computed_value::T {
        self.get_border().clone_border_image_outset()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_image_slice(
        &self,
    ) -> longhands::border_image_slice::computed_value::T {
        self.get_border().clone_border_image_slice()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_image_width(
        &self,
    ) -> longhands::border_image_width::computed_value::T {
        self.get_border().clone_border_image_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_spacing(
        &self,
    ) -> longhands::border_spacing::computed_value::T {
        self.get_inherited_table().clone_border_spacing()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_box_shadow(
        &self,
    ) -> longhands::box_shadow::computed_value::T {
        self.get_effects().clone_box_shadow()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_clip(
        &self,
    ) -> longhands::clip::computed_value::T {
        self.get_effects().clone_clip()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_clip_path(
        &self,
    ) -> longhands::clip_path::computed_value::T {
        self.get_svg().clone_clip_path()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_color(
        &self,
    ) -> longhands::color::computed_value::T {
        self.get_inherited_text().clone_color()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_color_scheme(
        &self,
    ) -> longhands::color_scheme::computed_value::T {
        self.get_inherited_ui().clone_color_scheme()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_column_width(
        &self,
    ) -> longhands::column_width::computed_value::T {
        self.get_column().clone_column_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_container_name(
        &self,
    ) -> longhands::container_name::computed_value::T {
        self.get_box().clone_container_name()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_content(
        &self,
    ) -> longhands::content::computed_value::T {
        self.get_counters().clone_content()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_counter_increment(
        &self,
    ) -> longhands::counter_increment::computed_value::T {
        self.get_counters().clone_counter_increment()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_counter_reset(
        &self,
    ) -> longhands::counter_reset::computed_value::T {
        self.get_counters().clone_counter_reset()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_cursor(
        &self,
    ) -> longhands::cursor::computed_value::T {
        self.get_inherited_ui().clone_cursor()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_filter(
        &self,
    ) -> longhands::filter::computed_value::T {
        self.get_effects().clone_filter()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_flex_basis(
        &self,
    ) -> longhands::flex_basis::computed_value::T {
        self.get_position().clone_flex_basis()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_family(
        &self,
    ) -> longhands::font_family::computed_value::T {
        self.get_font().clone_font_family()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_size(
        &self,
    ) -> longhands::font_size::computed_value::T {
        self.get_font().clone_font_size()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_font_variation_settings(
        &self,
    ) -> longhands::font_variation_settings::computed_value::T {
        self.get_font().clone_font_variation_settings()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_template_areas(
        &self,
    ) -> longhands::grid_template_areas::computed_value::T {
        self.get_position().clone_grid_template_areas()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_letter_spacing(
        &self,
    ) -> longhands::letter_spacing::computed_value::T {
        self.get_inherited_text().clone_letter_spacing()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_line_height(
        &self,
    ) -> longhands::line_height::computed_value::T {
        self.get_font().clone_line_height()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_mask_image(
        &self,
    ) -> longhands::mask_image::computed_value::T {
        self.get_svg().clone_mask_image()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_offset_path(
        &self,
    ) -> longhands::offset_path::computed_value::T {
        self.get_box().clone_offset_path()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_outline_offset(
        &self,
    ) -> longhands::outline_offset::computed_value::T {
        self.get_outline().clone_outline_offset()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_overflow_clip_margin(
        &self,
    ) -> longhands::overflow_clip_margin::computed_value::T {
        self.get_margin().clone_overflow_clip_margin()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_perspective(
        &self,
    ) -> longhands::perspective::computed_value::T {
        self.get_box().clone_perspective()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_quotes(
        &self,
    ) -> longhands::quotes::computed_value::T {
        self.get_list().clone_quotes()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_rotate(
        &self,
    ) -> longhands::rotate::computed_value::T {
        self.get_box().clone_rotate()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_scale(
        &self,
    ) -> longhands::scale::computed_value::T {
        self.get_box().clone_scale()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_indent(
        &self,
    ) -> longhands::text_indent::computed_value::T {
        self.get_inherited_text().clone_text_indent()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_overflow(
        &self,
    ) -> longhands::text_overflow::computed_value::T {
        self.get_text().clone_text_overflow()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_shadow(
        &self,
    ) -> longhands::text_shadow::computed_value::T {
        self.get_inherited_text().clone_text_shadow()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transform(
        &self,
    ) -> longhands::transform::computed_value::T {
        self.get_box().clone_transform()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transform_origin(
        &self,
    ) -> longhands::transform_origin::computed_value::T {
        self.get_box().clone_transform_origin()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transition_behavior(
        &self,
    ) -> longhands::transition_behavior::computed_value::T {
        self.get_ui().clone_transition_behavior()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transition_delay(
        &self,
    ) -> longhands::transition_delay::computed_value::T {
        self.get_ui().clone_transition_delay()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transition_duration(
        &self,
    ) -> longhands::transition_duration::computed_value::T {
        self.get_ui().clone_transition_duration()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transition_property(
        &self,
    ) -> longhands::transition_property::computed_value::T {
        self.get_ui().clone_transition_property()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_transition_timing_function(
        &self,
    ) -> longhands::transition_timing_function::computed_value::T {
        self.get_ui().clone_transition_timing_function()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_translate(
        &self,
    ) -> longhands::translate::computed_value::T {
        self.get_box().clone_translate()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_vertical_align(
        &self,
    ) -> longhands::vertical_align::computed_value::T {
        self.get_box().clone_vertical_align()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_view_transition_class(
        &self,
    ) -> longhands::view_transition_class::computed_value::T {
        self.get_ui().clone_view_transition_class()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_view_transition_name(
        &self,
    ) -> longhands::view_transition_name::computed_value::T {
        self.get_ui().clone_view_transition_name()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_will_change(
        &self,
    ) -> longhands::will_change::computed_value::T {
        self.get_box().clone_will_change()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_word_spacing(
        &self,
    ) -> longhands::word_spacing::computed_value::T {
        self.get_inherited_text().clone_word_spacing()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone__x_lang(
        &self,
    ) -> longhands::_x_lang::computed_value::T {
        self.get_font().clone__x_lang()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_object_position(
        &self,
    ) -> longhands::object_position::computed_value::T {
        self.get_position().clone_object_position()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_perspective_origin(
        &self,
    ) -> longhands::perspective_origin::computed_value::T {
        self.get_box().clone_perspective_origin()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_template_columns(
        &self,
    ) -> longhands::grid_template_columns::computed_value::T {
        self.get_position().clone_grid_template_columns()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_template_rows(
        &self,
    ) -> longhands::grid_template_rows::computed_value::T {
        self.get_position().clone_grid_template_rows()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_image_source(
        &self,
    ) -> longhands::border_image_source::computed_value::T {
        self.get_border().clone_border_image_source()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_list_style_image(
        &self,
    ) -> longhands::list_style_image::computed_value::T {
        self.get_list().clone_list_style_image()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_auto_columns(
        &self,
    ) -> longhands::grid_auto_columns::computed_value::T {
        self.get_position().clone_grid_auto_columns()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_auto_rows(
        &self,
    ) -> longhands::grid_auto_rows::computed_value::T {
        self.get_position().clone_grid_auto_rows()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_column_gap(
        &self,
    ) -> longhands::column_gap::computed_value::T {
        self.get_position().clone_column_gap()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_row_gap(
        &self,
    ) -> longhands::row_gap::computed_value::T {
        self.get_position().clone_row_gap()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_column_end(
        &self,
    ) -> longhands::grid_column_end::computed_value::T {
        self.get_position().clone_grid_column_end()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_column_start(
        &self,
    ) -> longhands::grid_column_start::computed_value::T {
        self.get_position().clone_grid_column_start()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_row_end(
        &self,
    ) -> longhands::grid_row_end::computed_value::T {
        self.get_position().clone_grid_row_end()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_grid_row_start(
        &self,
    ) -> longhands::grid_row_start::computed_value::T {
        self.get_position().clone_grid_row_start()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_max_height(
        &self,
    ) -> longhands::max_height::computed_value::T {
        self.get_position().clone_max_height()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_max_width(
        &self,
    ) -> longhands::max_width::computed_value::T {
        self.get_position().clone_max_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_bottom_left_radius(
        &self,
    ) -> longhands::border_bottom_left_radius::computed_value::T {
        self.get_border().clone_border_bottom_left_radius()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_bottom_right_radius(
        &self,
    ) -> longhands::border_bottom_right_radius::computed_value::T {
        self.get_border().clone_border_bottom_right_radius()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_top_left_radius(
        &self,
    ) -> longhands::border_top_left_radius::computed_value::T {
        self.get_border().clone_border_top_left_radius()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_top_right_radius(
        &self,
    ) -> longhands::border_top_right_radius::computed_value::T {
        self.get_border().clone_border_top_right_radius()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_bottom(
        &self,
    ) -> longhands::bottom::computed_value::T {
        self.get_position().clone_bottom()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_left(
        &self,
    ) -> longhands::left::computed_value::T {
        self.get_position().clone_left()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_right(
        &self,
    ) -> longhands::right::computed_value::T {
        self.get_position().clone_right()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_top(
        &self,
    ) -> longhands::top::computed_value::T {
        self.get_position().clone_top()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_margin_bottom(
        &self,
    ) -> longhands::margin_bottom::computed_value::T {
        self.get_margin().clone_margin_bottom()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_margin_left(
        &self,
    ) -> longhands::margin_left::computed_value::T {
        self.get_margin().clone_margin_left()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_margin_right(
        &self,
    ) -> longhands::margin_right::computed_value::T {
        self.get_margin().clone_margin_right()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_margin_top(
        &self,
    ) -> longhands::margin_top::computed_value::T {
        self.get_margin().clone_margin_top()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_padding_bottom(
        &self,
    ) -> longhands::padding_bottom::computed_value::T {
        self.get_padding().clone_padding_bottom()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_padding_left(
        &self,
    ) -> longhands::padding_left::computed_value::T {
        self.get_padding().clone_padding_left()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_padding_right(
        &self,
    ) -> longhands::padding_right::computed_value::T {
        self.get_padding().clone_padding_right()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_padding_top(
        &self,
    ) -> longhands::padding_top::computed_value::T {
        self.get_padding().clone_padding_top()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_height(
        &self,
    ) -> longhands::height::computed_value::T {
        self.get_position().clone_height()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_min_height(
        &self,
    ) -> longhands::min_height::computed_value::T {
        self.get_position().clone_min_height()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_min_width(
        &self,
    ) -> longhands::min_width::computed_value::T {
        self.get_position().clone_min_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_width(
        &self,
    ) -> longhands::width::computed_value::T {
        self.get_position().clone_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_bottom_width(
        &self,
    ) -> longhands::border_bottom_width::computed_value::T {
        self.get_border().clone_border_bottom_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_left_width(
        &self,
    ) -> longhands::border_left_width::computed_value::T {
        self.get_border().clone_border_left_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_right_width(
        &self,
    ) -> longhands::border_right_width::computed_value::T {
        self.get_border().clone_border_right_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_top_width(
        &self,
    ) -> longhands::border_top_width::computed_value::T {
        self.get_border().clone_border_top_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_outline_width(
        &self,
    ) -> longhands::outline_width::computed_value::T {
        self.get_outline().clone_outline_width()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_background_color(
        &self,
    ) -> longhands::background_color::computed_value::T {
        self.get_background().clone_background_color()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_bottom_color(
        &self,
    ) -> longhands::border_bottom_color::computed_value::T {
        self.get_border().clone_border_bottom_color()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_left_color(
        &self,
    ) -> longhands::border_left_color::computed_value::T {
        self.get_border().clone_border_left_color()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_right_color(
        &self,
    ) -> longhands::border_right_color::computed_value::T {
        self.get_border().clone_border_right_color()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_border_top_color(
        &self,
    ) -> longhands::border_top_color::computed_value::T {
        self.get_border().clone_border_top_color()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_outline_color(
        &self,
    ) -> longhands::outline_color::computed_value::T {
        self.get_outline().clone_outline_color()
    }
    /// Gets the computed value of a given property.
    #[inline(always)]
    #[allow(non_snake_case)]
    pub fn clone_text_decoration_color(
        &self,
    ) -> longhands::text_decoration_color::computed_value::T {
        self.get_text().clone_text_decoration_color()
    }

    /// Writes the (resolved or computed) value of the given longhand as a string in `dest`.
    ///
    /// TODO(emilio): We should move all the special resolution from
    /// nsComputedDOMStyle to ToResolvedValue instead.
    pub fn computed_or_resolved_value(
        &self,
        property_id: LonghandId,
        context: Option<&resolved::Context>,
        dest: &mut CssStringWriter,
    ) -> fmt::Result {
        use crate::values::resolved::ToResolvedValue;
        let mut dest = CssWriter::new(dest);
        let property_id = property_id.to_physical(self.writing_mode);
        match property_id {
            
            LonghandId::AlignItems => {
                let value = match property_id {
                    LonghandId::AlignItems => self.clone_align_items(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AspectRatio => {
                let value = match property_id {
                    LonghandId::AspectRatio => self.clone_aspect_ratio(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackfaceVisibility => {
                let value = match property_id {
                    LonghandId::BackfaceVisibility => self.clone_backface_visibility(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BaselineSource => {
                let value = match property_id {
                    LonghandId::BaselineSource => self.clone_baseline_source(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderCollapse => {
                let value = match property_id {
                    LonghandId::BorderCollapse => self.clone_border_collapse(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderImageRepeat => {
                let value = match property_id {
                    LonghandId::BorderImageRepeat => self.clone_border_image_repeat(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BoxSizing => {
                let value = match property_id {
                    LonghandId::BoxSizing => self.clone_box_sizing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::CaptionSide => {
                let value = match property_id {
                    LonghandId::CaptionSide => self.clone_caption_side(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Clear => {
                let value = match property_id {
                    LonghandId::Clear => self.clone_clear(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ColumnCount => {
                let value = match property_id {
                    LonghandId::ColumnCount => self.clone_column_count(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ColumnSpan => {
                let value = match property_id {
                    LonghandId::ColumnSpan => self.clone_column_span(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Contain => {
                let value = match property_id {
                    LonghandId::Contain => self.clone_contain(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ContainerType => {
                let value = match property_id {
                    LonghandId::ContainerType => self.clone_container_type(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Direction => {
                let value = match property_id {
                    LonghandId::Direction => self.clone_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Display => {
                let value = match property_id {
                    LonghandId::Display => self.clone_display(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::EmptyCells => {
                let value = match property_id {
                    LonghandId::EmptyCells => self.clone_empty_cells(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FlexDirection => {
                let value = match property_id {
                    LonghandId::FlexDirection => self.clone_flex_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FlexWrap => {
                let value = match property_id {
                    LonghandId::FlexWrap => self.clone_flex_wrap(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Float => {
                let value = match property_id {
                    LonghandId::Float => self.clone_float(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontLanguageOverride => {
                let value = match property_id {
                    LonghandId::FontLanguageOverride => self.clone_font_language_override(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontStretch => {
                let value = match property_id {
                    LonghandId::FontStretch => self.clone_font_stretch(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontStyle => {
                let value = match property_id {
                    LonghandId::FontStyle => self.clone_font_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontSynthesisWeight => {
                let value = match property_id {
                    LonghandId::FontSynthesisWeight => self.clone_font_synthesis_weight(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontVariantCaps => {
                let value = match property_id {
                    LonghandId::FontVariantCaps => self.clone_font_variant_caps(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontWeight => {
                let value = match property_id {
                    LonghandId::FontWeight => self.clone_font_weight(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::GridAutoFlow => {
                let value = match property_id {
                    LonghandId::GridAutoFlow => self.clone_grid_auto_flow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ImageRendering => {
                let value = match property_id {
                    LonghandId::ImageRendering => self.clone_image_rendering(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Isolation => {
                let value = match property_id {
                    LonghandId::Isolation => self.clone_isolation(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::JustifyItems => {
                let value = match property_id {
                    LonghandId::JustifyItems => self.clone_justify_items(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ListStylePosition => {
                let value = match property_id {
                    LonghandId::ListStylePosition => self.clone_list_style_position(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ListStyleType => {
                let value = match property_id {
                    LonghandId::ListStyleType => self.clone_list_style_type(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::MixBlendMode => {
                let value = match property_id {
                    LonghandId::MixBlendMode => self.clone_mix_blend_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ObjectFit => {
                let value = match property_id {
                    LonghandId::ObjectFit => self.clone_object_fit(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Opacity => {
                let value = match property_id {
                    LonghandId::Opacity => self.clone_opacity(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Order => {
                let value = match property_id {
                    LonghandId::Order => self.clone_order(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::OutlineStyle => {
                let value = match property_id {
                    LonghandId::OutlineStyle => self.clone_outline_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::OverflowWrap => {
                let value = match property_id {
                    LonghandId::OverflowWrap => self.clone_overflow_wrap(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::PointerEvents => {
                let value = match property_id {
                    LonghandId::PointerEvents => self.clone_pointer_events(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Position => {
                let value = match property_id {
                    LonghandId::Position => self.clone_position(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::PositionArea => {
                let value = match property_id {
                    LonghandId::PositionArea => self.clone_position_area(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ServoOverflowClipBox => {
                let value = match property_id {
                    LonghandId::ServoOverflowClipBox => self.clone__servo_overflow_clip_box(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ServoTopLayer => {
                let value = match property_id {
                    LonghandId::ServoTopLayer => self.clone__servo_top_layer(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TableLayout => {
                let value = match property_id {
                    LonghandId::TableLayout => self.clone_table_layout(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextAlign => {
                let value = match property_id {
                    LonghandId::TextAlign => self.clone_text_align(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextAlignLast => {
                let value = match property_id {
                    LonghandId::TextAlignLast => self.clone_text_align_last(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextDecorationLine => {
                let value = match property_id {
                    LonghandId::TextDecorationLine => self.clone_text_decoration_line(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextDecorationStyle => {
                let value = match property_id {
                    LonghandId::TextDecorationStyle => self.clone_text_decoration_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextJustify => {
                let value = match property_id {
                    LonghandId::TextJustify => self.clone_text_justify(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextRendering => {
                let value = match property_id {
                    LonghandId::TextRendering => self.clone_text_rendering(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextTransform => {
                let value = match property_id {
                    LonghandId::TextTransform => self.clone_text_transform(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextWrapMode => {
                let value = match property_id {
                    LonghandId::TextWrapMode => self.clone_text_wrap_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TransformStyle => {
                let value = match property_id {
                    LonghandId::TransformStyle => self.clone_transform_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::UnicodeBidi => {
                let value = match property_id {
                    LonghandId::UnicodeBidi => self.clone_unicode_bidi(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Visibility => {
                let value = match property_id {
                    LonghandId::Visibility => self.clone_visibility(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::WhiteSpaceCollapse => {
                let value = match property_id {
                    LonghandId::WhiteSpaceCollapse => self.clone_white_space_collapse(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::WordBreak => {
                let value = match property_id {
                    LonghandId::WordBreak => self.clone_word_break(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::WritingMode => {
                let value = match property_id {
                    LonghandId::WritingMode => self.clone_writing_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ZIndex => {
                let value = match property_id {
                    LonghandId::ZIndex => self.clone_z_index(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Zoom => {
                let value = match property_id {
                    LonghandId::Zoom => self.clone_zoom(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AlignContent |
LonghandId::JustifyContent => {
                let value = match property_id {
                    LonghandId::AlignContent => self.clone_align_content(),
                    LonghandId::JustifyContent => self.clone_justify_content(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FlexGrow |
LonghandId::FlexShrink => {
                let value = match property_id {
                    LonghandId::FlexGrow => self.clone_flex_grow(),
                    LonghandId::FlexShrink => self.clone_flex_shrink(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AlignSelf |
LonghandId::JustifySelf => {
                let value = match property_id {
                    LonghandId::AlignSelf => self.clone_align_self(),
                    LonghandId::JustifySelf => self.clone_justify_self(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::OverflowBlock |
LonghandId::OverflowInline |
LonghandId::OverflowX |
LonghandId::OverflowY => {
                let value = match property_id {
                    LonghandId::OverflowX => self.clone_overflow_x(),
                    LonghandId::OverflowY => self.clone_overflow_y(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderBlockEndStyle |
LonghandId::BorderBlockStartStyle |
LonghandId::BorderBottomStyle |
LonghandId::BorderInlineEndStyle |
LonghandId::BorderInlineStartStyle |
LonghandId::BorderLeftStyle |
LonghandId::BorderRightStyle |
LonghandId::BorderTopStyle => {
                let value = match property_id {
                    LonghandId::BorderBottomStyle => self.clone_border_bottom_style(),
                    LonghandId::BorderLeftStyle => self.clone_border_left_style(),
                    LonghandId::BorderRightStyle => self.clone_border_right_style(),
                    LonghandId::BorderTopStyle => self.clone_border_top_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationComposition => {
                let value = match property_id {
                    LonghandId::AnimationComposition => self.clone_animation_composition(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationDelay => {
                let value = match property_id {
                    LonghandId::AnimationDelay => self.clone_animation_delay(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationDirection => {
                let value = match property_id {
                    LonghandId::AnimationDirection => self.clone_animation_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationDuration => {
                let value = match property_id {
                    LonghandId::AnimationDuration => self.clone_animation_duration(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationFillMode => {
                let value = match property_id {
                    LonghandId::AnimationFillMode => self.clone_animation_fill_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationIterationCount => {
                let value = match property_id {
                    LonghandId::AnimationIterationCount => self.clone_animation_iteration_count(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationName => {
                let value = match property_id {
                    LonghandId::AnimationName => self.clone_animation_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationPlayState => {
                let value = match property_id {
                    LonghandId::AnimationPlayState => self.clone_animation_play_state(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationTimeline => {
                let value = match property_id {
                    LonghandId::AnimationTimeline => self.clone_animation_timeline(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::AnimationTimingFunction => {
                let value = match property_id {
                    LonghandId::AnimationTimingFunction => self.clone_animation_timing_function(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackdropFilter => {
                let value = match property_id {
                    LonghandId::BackdropFilter => self.clone_backdrop_filter(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundAttachment => {
                let value = match property_id {
                    LonghandId::BackgroundAttachment => self.clone_background_attachment(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundClip => {
                let value = match property_id {
                    LonghandId::BackgroundClip => self.clone_background_clip(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundImage => {
                let value = match property_id {
                    LonghandId::BackgroundImage => self.clone_background_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundOrigin => {
                let value = match property_id {
                    LonghandId::BackgroundOrigin => self.clone_background_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundPositionX => {
                let value = match property_id {
                    LonghandId::BackgroundPositionX => self.clone_background_position_x(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundPositionY => {
                let value = match property_id {
                    LonghandId::BackgroundPositionY => self.clone_background_position_y(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundRepeat => {
                let value = match property_id {
                    LonghandId::BackgroundRepeat => self.clone_background_repeat(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundSize => {
                let value = match property_id {
                    LonghandId::BackgroundSize => self.clone_background_size(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderImageOutset => {
                let value = match property_id {
                    LonghandId::BorderImageOutset => self.clone_border_image_outset(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderImageSlice => {
                let value = match property_id {
                    LonghandId::BorderImageSlice => self.clone_border_image_slice(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderImageWidth => {
                let value = match property_id {
                    LonghandId::BorderImageWidth => self.clone_border_image_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderSpacing => {
                let value = match property_id {
                    LonghandId::BorderSpacing => self.clone_border_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BoxShadow => {
                let value = match property_id {
                    LonghandId::BoxShadow => self.clone_box_shadow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Clip => {
                let value = match property_id {
                    LonghandId::Clip => self.clone_clip(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ClipPath => {
                let value = match property_id {
                    LonghandId::ClipPath => self.clone_clip_path(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Color => {
                let value = match property_id {
                    LonghandId::Color => self.clone_color(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ColorScheme => {
                let value = match property_id {
                    LonghandId::ColorScheme => self.clone_color_scheme(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ColumnWidth => {
                let value = match property_id {
                    LonghandId::ColumnWidth => self.clone_column_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ContainerName => {
                let value = match property_id {
                    LonghandId::ContainerName => self.clone_container_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Content => {
                let value = match property_id {
                    LonghandId::Content => self.clone_content(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::CounterIncrement => {
                let value = match property_id {
                    LonghandId::CounterIncrement => self.clone_counter_increment(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::CounterReset => {
                let value = match property_id {
                    LonghandId::CounterReset => self.clone_counter_reset(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Cursor => {
                let value = match property_id {
                    LonghandId::Cursor => self.clone_cursor(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Filter => {
                let value = match property_id {
                    LonghandId::Filter => self.clone_filter(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FlexBasis => {
                let value = match property_id {
                    LonghandId::FlexBasis => self.clone_flex_basis(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontFamily => {
                let value = match property_id {
                    LonghandId::FontFamily => self.clone_font_family(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontSize => {
                let value = match property_id {
                    LonghandId::FontSize => self.clone_font_size(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::FontVariationSettings => {
                let value = match property_id {
                    LonghandId::FontVariationSettings => self.clone_font_variation_settings(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::GridTemplateAreas => {
                let value = match property_id {
                    LonghandId::GridTemplateAreas => self.clone_grid_template_areas(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::LetterSpacing => {
                let value = match property_id {
                    LonghandId::LetterSpacing => self.clone_letter_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::LineHeight => {
                let value = match property_id {
                    LonghandId::LineHeight => self.clone_line_height(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::MaskImage => {
                let value = match property_id {
                    LonghandId::MaskImage => self.clone_mask_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::OffsetPath => {
                let value = match property_id {
                    LonghandId::OffsetPath => self.clone_offset_path(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::OutlineOffset => {
                let value = match property_id {
                    LonghandId::OutlineOffset => self.clone_outline_offset(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::OverflowClipMargin => {
                let value = match property_id {
                    LonghandId::OverflowClipMargin => self.clone_overflow_clip_margin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Perspective => {
                let value = match property_id {
                    LonghandId::Perspective => self.clone_perspective(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Quotes => {
                let value = match property_id {
                    LonghandId::Quotes => self.clone_quotes(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Rotate => {
                let value = match property_id {
                    LonghandId::Rotate => self.clone_rotate(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Scale => {
                let value = match property_id {
                    LonghandId::Scale => self.clone_scale(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextIndent => {
                let value = match property_id {
                    LonghandId::TextIndent => self.clone_text_indent(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextOverflow => {
                let value = match property_id {
                    LonghandId::TextOverflow => self.clone_text_overflow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TextShadow => {
                let value = match property_id {
                    LonghandId::TextShadow => self.clone_text_shadow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Transform => {
                let value = match property_id {
                    LonghandId::Transform => self.clone_transform(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TransformOrigin => {
                let value = match property_id {
                    LonghandId::TransformOrigin => self.clone_transform_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TransitionBehavior => {
                let value = match property_id {
                    LonghandId::TransitionBehavior => self.clone_transition_behavior(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TransitionDelay => {
                let value = match property_id {
                    LonghandId::TransitionDelay => self.clone_transition_delay(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TransitionDuration => {
                let value = match property_id {
                    LonghandId::TransitionDuration => self.clone_transition_duration(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TransitionProperty => {
                let value = match property_id {
                    LonghandId::TransitionProperty => self.clone_transition_property(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::TransitionTimingFunction => {
                let value = match property_id {
                    LonghandId::TransitionTimingFunction => self.clone_transition_timing_function(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Translate => {
                let value = match property_id {
                    LonghandId::Translate => self.clone_translate(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::VerticalAlign => {
                let value = match property_id {
                    LonghandId::VerticalAlign => self.clone_vertical_align(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ViewTransitionClass => {
                let value = match property_id {
                    LonghandId::ViewTransitionClass => self.clone_view_transition_class(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ViewTransitionName => {
                let value = match property_id {
                    LonghandId::ViewTransitionName => self.clone_view_transition_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::WillChange => {
                let value = match property_id {
                    LonghandId::WillChange => self.clone_will_change(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::WordSpacing => {
                let value = match property_id {
                    LonghandId::WordSpacing => self.clone_word_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::XLang => {
                let value = match property_id {
                    LonghandId::XLang => self.clone__x_lang(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ObjectPosition |
LonghandId::PerspectiveOrigin => {
                let value = match property_id {
                    LonghandId::ObjectPosition => self.clone_object_position(),
                    LonghandId::PerspectiveOrigin => self.clone_perspective_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::GridTemplateColumns |
LonghandId::GridTemplateRows => {
                let value = match property_id {
                    LonghandId::GridTemplateColumns => self.clone_grid_template_columns(),
                    LonghandId::GridTemplateRows => self.clone_grid_template_rows(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderImageSource |
LonghandId::ListStyleImage => {
                let value = match property_id {
                    LonghandId::BorderImageSource => self.clone_border_image_source(),
                    LonghandId::ListStyleImage => self.clone_list_style_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::GridAutoColumns |
LonghandId::GridAutoRows => {
                let value = match property_id {
                    LonghandId::GridAutoColumns => self.clone_grid_auto_columns(),
                    LonghandId::GridAutoRows => self.clone_grid_auto_rows(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::ColumnGap |
LonghandId::RowGap => {
                let value = match property_id {
                    LonghandId::ColumnGap => self.clone_column_gap(),
                    LonghandId::RowGap => self.clone_row_gap(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::GridColumnEnd |
LonghandId::GridColumnStart |
LonghandId::GridRowEnd |
LonghandId::GridRowStart => {
                let value = match property_id {
                    LonghandId::GridColumnEnd => self.clone_grid_column_end(),
                    LonghandId::GridColumnStart => self.clone_grid_column_start(),
                    LonghandId::GridRowEnd => self.clone_grid_row_end(),
                    LonghandId::GridRowStart => self.clone_grid_row_start(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::MaxBlockSize |
LonghandId::MaxHeight |
LonghandId::MaxInlineSize |
LonghandId::MaxWidth => {
                let value = match property_id {
                    LonghandId::MaxHeight => self.clone_max_height(),
                    LonghandId::MaxWidth => self.clone_max_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderBottomLeftRadius |
LonghandId::BorderBottomRightRadius |
LonghandId::BorderEndEndRadius |
LonghandId::BorderEndStartRadius |
LonghandId::BorderStartEndRadius |
LonghandId::BorderStartStartRadius |
LonghandId::BorderTopLeftRadius |
LonghandId::BorderTopRightRadius => {
                let value = match property_id {
                    LonghandId::BorderBottomLeftRadius => self.clone_border_bottom_left_radius(),
                    LonghandId::BorderBottomRightRadius => self.clone_border_bottom_right_radius(),
                    LonghandId::BorderTopLeftRadius => self.clone_border_top_left_radius(),
                    LonghandId::BorderTopRightRadius => self.clone_border_top_right_radius(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::Bottom |
LonghandId::InsetBlockEnd |
LonghandId::InsetBlockStart |
LonghandId::InsetInlineEnd |
LonghandId::InsetInlineStart |
LonghandId::Left |
LonghandId::Right |
LonghandId::Top => {
                let value = match property_id {
                    LonghandId::Bottom => self.clone_bottom(),
                    LonghandId::Left => self.clone_left(),
                    LonghandId::Right => self.clone_right(),
                    LonghandId::Top => self.clone_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::MarginBlockEnd |
LonghandId::MarginBlockStart |
LonghandId::MarginBottom |
LonghandId::MarginInlineEnd |
LonghandId::MarginInlineStart |
LonghandId::MarginLeft |
LonghandId::MarginRight |
LonghandId::MarginTop => {
                let value = match property_id {
                    LonghandId::MarginBottom => self.clone_margin_bottom(),
                    LonghandId::MarginLeft => self.clone_margin_left(),
                    LonghandId::MarginRight => self.clone_margin_right(),
                    LonghandId::MarginTop => self.clone_margin_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::PaddingBlockEnd |
LonghandId::PaddingBlockStart |
LonghandId::PaddingBottom |
LonghandId::PaddingInlineEnd |
LonghandId::PaddingInlineStart |
LonghandId::PaddingLeft |
LonghandId::PaddingRight |
LonghandId::PaddingTop => {
                let value = match property_id {
                    LonghandId::PaddingBottom => self.clone_padding_bottom(),
                    LonghandId::PaddingLeft => self.clone_padding_left(),
                    LonghandId::PaddingRight => self.clone_padding_right(),
                    LonghandId::PaddingTop => self.clone_padding_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BlockSize |
LonghandId::Height |
LonghandId::InlineSize |
LonghandId::MinBlockSize |
LonghandId::MinHeight |
LonghandId::MinInlineSize |
LonghandId::MinWidth |
LonghandId::Width => {
                let value = match property_id {
                    LonghandId::Height => self.clone_height(),
                    LonghandId::MinHeight => self.clone_min_height(),
                    LonghandId::MinWidth => self.clone_min_width(),
                    LonghandId::Width => self.clone_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BorderBlockEndWidth |
LonghandId::BorderBlockStartWidth |
LonghandId::BorderBottomWidth |
LonghandId::BorderInlineEndWidth |
LonghandId::BorderInlineStartWidth |
LonghandId::BorderLeftWidth |
LonghandId::BorderRightWidth |
LonghandId::BorderTopWidth |
LonghandId::OutlineWidth => {
                let value = match property_id {
                    LonghandId::BorderBottomWidth => self.clone_border_bottom_width(),
                    LonghandId::BorderLeftWidth => self.clone_border_left_width(),
                    LonghandId::BorderRightWidth => self.clone_border_right_width(),
                    LonghandId::BorderTopWidth => self.clone_border_top_width(),
                    LonghandId::OutlineWidth => self.clone_outline_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
            
            LonghandId::BackgroundColor |
LonghandId::BorderBlockEndColor |
LonghandId::BorderBlockStartColor |
LonghandId::BorderBottomColor |
LonghandId::BorderInlineEndColor |
LonghandId::BorderInlineStartColor |
LonghandId::BorderLeftColor |
LonghandId::BorderRightColor |
LonghandId::BorderTopColor |
LonghandId::OutlineColor |
LonghandId::TextDecorationColor => {
                let value = match property_id {
                    LonghandId::BackgroundColor => self.clone_background_color(),
                    LonghandId::BorderBottomColor => self.clone_border_bottom_color(),
                    LonghandId::BorderLeftColor => self.clone_border_left_color(),
                    LonghandId::BorderRightColor => self.clone_border_right_color(),
                    LonghandId::BorderTopColor => self.clone_border_top_color(),
                    LonghandId::OutlineColor => self.clone_outline_color(),
                    LonghandId::TextDecorationColor => self.clone_text_decoration_color(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    value.to_resolved_value(c).to_css(&mut dest)
                } else {
                    value.to_css(&mut dest)
                }
            }
        }
    }

    /// Returns the computed value of the given longhand as a strongly-typed
    /// `TypedValue`, if supported.
    pub fn computed_typed_value(
        &self,
        property_id: LonghandId,
    ) -> Option<TypedValue> {
        let property_id = property_id.to_physical(self.writing_mode);
        match property_id {
            
            LonghandId::AlignItems => {
                let value = match property_id {
                    LonghandId::AlignItems => self.clone_align_items(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AspectRatio => {
                let value = match property_id {
                    LonghandId::AspectRatio => self.clone_aspect_ratio(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackfaceVisibility => {
                let value = match property_id {
                    LonghandId::BackfaceVisibility => self.clone_backface_visibility(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BaselineSource => {
                let value = match property_id {
                    LonghandId::BaselineSource => self.clone_baseline_source(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderCollapse => {
                let value = match property_id {
                    LonghandId::BorderCollapse => self.clone_border_collapse(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderImageRepeat => {
                let value = match property_id {
                    LonghandId::BorderImageRepeat => self.clone_border_image_repeat(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BoxSizing => {
                let value = match property_id {
                    LonghandId::BoxSizing => self.clone_box_sizing(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::CaptionSide => {
                let value = match property_id {
                    LonghandId::CaptionSide => self.clone_caption_side(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Clear => {
                let value = match property_id {
                    LonghandId::Clear => self.clone_clear(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ColumnCount => {
                let value = match property_id {
                    LonghandId::ColumnCount => self.clone_column_count(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ColumnSpan => {
                let value = match property_id {
                    LonghandId::ColumnSpan => self.clone_column_span(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Contain => {
                let value = match property_id {
                    LonghandId::Contain => self.clone_contain(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ContainerType => {
                let value = match property_id {
                    LonghandId::ContainerType => self.clone_container_type(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Direction => {
                let value = match property_id {
                    LonghandId::Direction => self.clone_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Display => {
                let value = match property_id {
                    LonghandId::Display => self.clone_display(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::EmptyCells => {
                let value = match property_id {
                    LonghandId::EmptyCells => self.clone_empty_cells(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FlexDirection => {
                let value = match property_id {
                    LonghandId::FlexDirection => self.clone_flex_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FlexWrap => {
                let value = match property_id {
                    LonghandId::FlexWrap => self.clone_flex_wrap(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Float => {
                let value = match property_id {
                    LonghandId::Float => self.clone_float(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontLanguageOverride => {
                let value = match property_id {
                    LonghandId::FontLanguageOverride => self.clone_font_language_override(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontStretch => {
                let value = match property_id {
                    LonghandId::FontStretch => self.clone_font_stretch(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontStyle => {
                let value = match property_id {
                    LonghandId::FontStyle => self.clone_font_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontSynthesisWeight => {
                let value = match property_id {
                    LonghandId::FontSynthesisWeight => self.clone_font_synthesis_weight(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontVariantCaps => {
                let value = match property_id {
                    LonghandId::FontVariantCaps => self.clone_font_variant_caps(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontWeight => {
                let value = match property_id {
                    LonghandId::FontWeight => self.clone_font_weight(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::GridAutoFlow => {
                let value = match property_id {
                    LonghandId::GridAutoFlow => self.clone_grid_auto_flow(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ImageRendering => {
                let value = match property_id {
                    LonghandId::ImageRendering => self.clone_image_rendering(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Isolation => {
                let value = match property_id {
                    LonghandId::Isolation => self.clone_isolation(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::JustifyItems => {
                let value = match property_id {
                    LonghandId::JustifyItems => self.clone_justify_items(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ListStylePosition => {
                let value = match property_id {
                    LonghandId::ListStylePosition => self.clone_list_style_position(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ListStyleType => {
                let value = match property_id {
                    LonghandId::ListStyleType => self.clone_list_style_type(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::MixBlendMode => {
                let value = match property_id {
                    LonghandId::MixBlendMode => self.clone_mix_blend_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ObjectFit => {
                let value = match property_id {
                    LonghandId::ObjectFit => self.clone_object_fit(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Opacity => {
                let value = match property_id {
                    LonghandId::Opacity => self.clone_opacity(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Order => {
                let value = match property_id {
                    LonghandId::Order => self.clone_order(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::OutlineStyle => {
                let value = match property_id {
                    LonghandId::OutlineStyle => self.clone_outline_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::OverflowWrap => {
                let value = match property_id {
                    LonghandId::OverflowWrap => self.clone_overflow_wrap(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::PointerEvents => {
                let value = match property_id {
                    LonghandId::PointerEvents => self.clone_pointer_events(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Position => {
                let value = match property_id {
                    LonghandId::Position => self.clone_position(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::PositionArea => {
                let value = match property_id {
                    LonghandId::PositionArea => self.clone_position_area(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ServoOverflowClipBox => {
                let value = match property_id {
                    LonghandId::ServoOverflowClipBox => self.clone__servo_overflow_clip_box(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ServoTopLayer => {
                let value = match property_id {
                    LonghandId::ServoTopLayer => self.clone__servo_top_layer(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TableLayout => {
                let value = match property_id {
                    LonghandId::TableLayout => self.clone_table_layout(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextAlign => {
                let value = match property_id {
                    LonghandId::TextAlign => self.clone_text_align(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextAlignLast => {
                let value = match property_id {
                    LonghandId::TextAlignLast => self.clone_text_align_last(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextDecorationLine => {
                let value = match property_id {
                    LonghandId::TextDecorationLine => self.clone_text_decoration_line(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextDecorationStyle => {
                let value = match property_id {
                    LonghandId::TextDecorationStyle => self.clone_text_decoration_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextJustify => {
                let value = match property_id {
                    LonghandId::TextJustify => self.clone_text_justify(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextRendering => {
                let value = match property_id {
                    LonghandId::TextRendering => self.clone_text_rendering(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextTransform => {
                let value = match property_id {
                    LonghandId::TextTransform => self.clone_text_transform(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextWrapMode => {
                let value = match property_id {
                    LonghandId::TextWrapMode => self.clone_text_wrap_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TransformStyle => {
                let value = match property_id {
                    LonghandId::TransformStyle => self.clone_transform_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::UnicodeBidi => {
                let value = match property_id {
                    LonghandId::UnicodeBidi => self.clone_unicode_bidi(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Visibility => {
                let value = match property_id {
                    LonghandId::Visibility => self.clone_visibility(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::WhiteSpaceCollapse => {
                let value = match property_id {
                    LonghandId::WhiteSpaceCollapse => self.clone_white_space_collapse(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::WordBreak => {
                let value = match property_id {
                    LonghandId::WordBreak => self.clone_word_break(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::WritingMode => {
                let value = match property_id {
                    LonghandId::WritingMode => self.clone_writing_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ZIndex => {
                let value = match property_id {
                    LonghandId::ZIndex => self.clone_z_index(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Zoom => {
                let value = match property_id {
                    LonghandId::Zoom => self.clone_zoom(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AlignContent |
LonghandId::JustifyContent => {
                let value = match property_id {
                    LonghandId::AlignContent => self.clone_align_content(),
                    LonghandId::JustifyContent => self.clone_justify_content(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FlexGrow |
LonghandId::FlexShrink => {
                let value = match property_id {
                    LonghandId::FlexGrow => self.clone_flex_grow(),
                    LonghandId::FlexShrink => self.clone_flex_shrink(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AlignSelf |
LonghandId::JustifySelf => {
                let value = match property_id {
                    LonghandId::AlignSelf => self.clone_align_self(),
                    LonghandId::JustifySelf => self.clone_justify_self(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::OverflowBlock |
LonghandId::OverflowInline |
LonghandId::OverflowX |
LonghandId::OverflowY => {
                let value = match property_id {
                    LonghandId::OverflowX => self.clone_overflow_x(),
                    LonghandId::OverflowY => self.clone_overflow_y(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderBlockEndStyle |
LonghandId::BorderBlockStartStyle |
LonghandId::BorderBottomStyle |
LonghandId::BorderInlineEndStyle |
LonghandId::BorderInlineStartStyle |
LonghandId::BorderLeftStyle |
LonghandId::BorderRightStyle |
LonghandId::BorderTopStyle => {
                let value = match property_id {
                    LonghandId::BorderBottomStyle => self.clone_border_bottom_style(),
                    LonghandId::BorderLeftStyle => self.clone_border_left_style(),
                    LonghandId::BorderRightStyle => self.clone_border_right_style(),
                    LonghandId::BorderTopStyle => self.clone_border_top_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationComposition => {
                let value = match property_id {
                    LonghandId::AnimationComposition => self.clone_animation_composition(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationDelay => {
                let value = match property_id {
                    LonghandId::AnimationDelay => self.clone_animation_delay(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationDirection => {
                let value = match property_id {
                    LonghandId::AnimationDirection => self.clone_animation_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationDuration => {
                let value = match property_id {
                    LonghandId::AnimationDuration => self.clone_animation_duration(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationFillMode => {
                let value = match property_id {
                    LonghandId::AnimationFillMode => self.clone_animation_fill_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationIterationCount => {
                let value = match property_id {
                    LonghandId::AnimationIterationCount => self.clone_animation_iteration_count(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationName => {
                let value = match property_id {
                    LonghandId::AnimationName => self.clone_animation_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationPlayState => {
                let value = match property_id {
                    LonghandId::AnimationPlayState => self.clone_animation_play_state(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationTimeline => {
                let value = match property_id {
                    LonghandId::AnimationTimeline => self.clone_animation_timeline(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::AnimationTimingFunction => {
                let value = match property_id {
                    LonghandId::AnimationTimingFunction => self.clone_animation_timing_function(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackdropFilter => {
                let value = match property_id {
                    LonghandId::BackdropFilter => self.clone_backdrop_filter(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundAttachment => {
                let value = match property_id {
                    LonghandId::BackgroundAttachment => self.clone_background_attachment(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundClip => {
                let value = match property_id {
                    LonghandId::BackgroundClip => self.clone_background_clip(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundImage => {
                let value = match property_id {
                    LonghandId::BackgroundImage => self.clone_background_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundOrigin => {
                let value = match property_id {
                    LonghandId::BackgroundOrigin => self.clone_background_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundPositionX => {
                let value = match property_id {
                    LonghandId::BackgroundPositionX => self.clone_background_position_x(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundPositionY => {
                let value = match property_id {
                    LonghandId::BackgroundPositionY => self.clone_background_position_y(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundRepeat => {
                let value = match property_id {
                    LonghandId::BackgroundRepeat => self.clone_background_repeat(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundSize => {
                let value = match property_id {
                    LonghandId::BackgroundSize => self.clone_background_size(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderImageOutset => {
                let value = match property_id {
                    LonghandId::BorderImageOutset => self.clone_border_image_outset(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderImageSlice => {
                let value = match property_id {
                    LonghandId::BorderImageSlice => self.clone_border_image_slice(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderImageWidth => {
                let value = match property_id {
                    LonghandId::BorderImageWidth => self.clone_border_image_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderSpacing => {
                let value = match property_id {
                    LonghandId::BorderSpacing => self.clone_border_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BoxShadow => {
                let value = match property_id {
                    LonghandId::BoxShadow => self.clone_box_shadow(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Clip => {
                let value = match property_id {
                    LonghandId::Clip => self.clone_clip(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ClipPath => {
                let value = match property_id {
                    LonghandId::ClipPath => self.clone_clip_path(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Color => {
                let value = match property_id {
                    LonghandId::Color => self.clone_color(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ColorScheme => {
                let value = match property_id {
                    LonghandId::ColorScheme => self.clone_color_scheme(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ColumnWidth => {
                let value = match property_id {
                    LonghandId::ColumnWidth => self.clone_column_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ContainerName => {
                let value = match property_id {
                    LonghandId::ContainerName => self.clone_container_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Content => {
                let value = match property_id {
                    LonghandId::Content => self.clone_content(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::CounterIncrement => {
                let value = match property_id {
                    LonghandId::CounterIncrement => self.clone_counter_increment(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::CounterReset => {
                let value = match property_id {
                    LonghandId::CounterReset => self.clone_counter_reset(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Cursor => {
                let value = match property_id {
                    LonghandId::Cursor => self.clone_cursor(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Filter => {
                let value = match property_id {
                    LonghandId::Filter => self.clone_filter(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FlexBasis => {
                let value = match property_id {
                    LonghandId::FlexBasis => self.clone_flex_basis(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontFamily => {
                let value = match property_id {
                    LonghandId::FontFamily => self.clone_font_family(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontSize => {
                let value = match property_id {
                    LonghandId::FontSize => self.clone_font_size(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::FontVariationSettings => {
                let value = match property_id {
                    LonghandId::FontVariationSettings => self.clone_font_variation_settings(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::GridTemplateAreas => {
                let value = match property_id {
                    LonghandId::GridTemplateAreas => self.clone_grid_template_areas(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::LetterSpacing => {
                let value = match property_id {
                    LonghandId::LetterSpacing => self.clone_letter_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::LineHeight => {
                let value = match property_id {
                    LonghandId::LineHeight => self.clone_line_height(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::MaskImage => {
                let value = match property_id {
                    LonghandId::MaskImage => self.clone_mask_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::OffsetPath => {
                let value = match property_id {
                    LonghandId::OffsetPath => self.clone_offset_path(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::OutlineOffset => {
                let value = match property_id {
                    LonghandId::OutlineOffset => self.clone_outline_offset(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::OverflowClipMargin => {
                let value = match property_id {
                    LonghandId::OverflowClipMargin => self.clone_overflow_clip_margin(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Perspective => {
                let value = match property_id {
                    LonghandId::Perspective => self.clone_perspective(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Quotes => {
                let value = match property_id {
                    LonghandId::Quotes => self.clone_quotes(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Rotate => {
                let value = match property_id {
                    LonghandId::Rotate => self.clone_rotate(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Scale => {
                let value = match property_id {
                    LonghandId::Scale => self.clone_scale(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextIndent => {
                let value = match property_id {
                    LonghandId::TextIndent => self.clone_text_indent(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextOverflow => {
                let value = match property_id {
                    LonghandId::TextOverflow => self.clone_text_overflow(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TextShadow => {
                let value = match property_id {
                    LonghandId::TextShadow => self.clone_text_shadow(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Transform => {
                let value = match property_id {
                    LonghandId::Transform => self.clone_transform(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TransformOrigin => {
                let value = match property_id {
                    LonghandId::TransformOrigin => self.clone_transform_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TransitionBehavior => {
                let value = match property_id {
                    LonghandId::TransitionBehavior => self.clone_transition_behavior(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TransitionDelay => {
                let value = match property_id {
                    LonghandId::TransitionDelay => self.clone_transition_delay(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TransitionDuration => {
                let value = match property_id {
                    LonghandId::TransitionDuration => self.clone_transition_duration(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TransitionProperty => {
                let value = match property_id {
                    LonghandId::TransitionProperty => self.clone_transition_property(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::TransitionTimingFunction => {
                let value = match property_id {
                    LonghandId::TransitionTimingFunction => self.clone_transition_timing_function(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Translate => {
                let value = match property_id {
                    LonghandId::Translate => self.clone_translate(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::VerticalAlign => {
                let value = match property_id {
                    LonghandId::VerticalAlign => self.clone_vertical_align(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ViewTransitionClass => {
                let value = match property_id {
                    LonghandId::ViewTransitionClass => self.clone_view_transition_class(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ViewTransitionName => {
                let value = match property_id {
                    LonghandId::ViewTransitionName => self.clone_view_transition_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::WillChange => {
                let value = match property_id {
                    LonghandId::WillChange => self.clone_will_change(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::WordSpacing => {
                let value = match property_id {
                    LonghandId::WordSpacing => self.clone_word_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::XLang => {
                let value = match property_id {
                    LonghandId::XLang => self.clone__x_lang(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ObjectPosition |
LonghandId::PerspectiveOrigin => {
                let value = match property_id {
                    LonghandId::ObjectPosition => self.clone_object_position(),
                    LonghandId::PerspectiveOrigin => self.clone_perspective_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::GridTemplateColumns |
LonghandId::GridTemplateRows => {
                let value = match property_id {
                    LonghandId::GridTemplateColumns => self.clone_grid_template_columns(),
                    LonghandId::GridTemplateRows => self.clone_grid_template_rows(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderImageSource |
LonghandId::ListStyleImage => {
                let value = match property_id {
                    LonghandId::BorderImageSource => self.clone_border_image_source(),
                    LonghandId::ListStyleImage => self.clone_list_style_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::GridAutoColumns |
LonghandId::GridAutoRows => {
                let value = match property_id {
                    LonghandId::GridAutoColumns => self.clone_grid_auto_columns(),
                    LonghandId::GridAutoRows => self.clone_grid_auto_rows(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::ColumnGap |
LonghandId::RowGap => {
                let value = match property_id {
                    LonghandId::ColumnGap => self.clone_column_gap(),
                    LonghandId::RowGap => self.clone_row_gap(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::GridColumnEnd |
LonghandId::GridColumnStart |
LonghandId::GridRowEnd |
LonghandId::GridRowStart => {
                let value = match property_id {
                    LonghandId::GridColumnEnd => self.clone_grid_column_end(),
                    LonghandId::GridColumnStart => self.clone_grid_column_start(),
                    LonghandId::GridRowEnd => self.clone_grid_row_end(),
                    LonghandId::GridRowStart => self.clone_grid_row_start(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::MaxBlockSize |
LonghandId::MaxHeight |
LonghandId::MaxInlineSize |
LonghandId::MaxWidth => {
                let value = match property_id {
                    LonghandId::MaxHeight => self.clone_max_height(),
                    LonghandId::MaxWidth => self.clone_max_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderBottomLeftRadius |
LonghandId::BorderBottomRightRadius |
LonghandId::BorderEndEndRadius |
LonghandId::BorderEndStartRadius |
LonghandId::BorderStartEndRadius |
LonghandId::BorderStartStartRadius |
LonghandId::BorderTopLeftRadius |
LonghandId::BorderTopRightRadius => {
                let value = match property_id {
                    LonghandId::BorderBottomLeftRadius => self.clone_border_bottom_left_radius(),
                    LonghandId::BorderBottomRightRadius => self.clone_border_bottom_right_radius(),
                    LonghandId::BorderTopLeftRadius => self.clone_border_top_left_radius(),
                    LonghandId::BorderTopRightRadius => self.clone_border_top_right_radius(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::Bottom |
LonghandId::InsetBlockEnd |
LonghandId::InsetBlockStart |
LonghandId::InsetInlineEnd |
LonghandId::InsetInlineStart |
LonghandId::Left |
LonghandId::Right |
LonghandId::Top => {
                let value = match property_id {
                    LonghandId::Bottom => self.clone_bottom(),
                    LonghandId::Left => self.clone_left(),
                    LonghandId::Right => self.clone_right(),
                    LonghandId::Top => self.clone_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::MarginBlockEnd |
LonghandId::MarginBlockStart |
LonghandId::MarginBottom |
LonghandId::MarginInlineEnd |
LonghandId::MarginInlineStart |
LonghandId::MarginLeft |
LonghandId::MarginRight |
LonghandId::MarginTop => {
                let value = match property_id {
                    LonghandId::MarginBottom => self.clone_margin_bottom(),
                    LonghandId::MarginLeft => self.clone_margin_left(),
                    LonghandId::MarginRight => self.clone_margin_right(),
                    LonghandId::MarginTop => self.clone_margin_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::PaddingBlockEnd |
LonghandId::PaddingBlockStart |
LonghandId::PaddingBottom |
LonghandId::PaddingInlineEnd |
LonghandId::PaddingInlineStart |
LonghandId::PaddingLeft |
LonghandId::PaddingRight |
LonghandId::PaddingTop => {
                let value = match property_id {
                    LonghandId::PaddingBottom => self.clone_padding_bottom(),
                    LonghandId::PaddingLeft => self.clone_padding_left(),
                    LonghandId::PaddingRight => self.clone_padding_right(),
                    LonghandId::PaddingTop => self.clone_padding_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BlockSize |
LonghandId::Height |
LonghandId::InlineSize |
LonghandId::MinBlockSize |
LonghandId::MinHeight |
LonghandId::MinInlineSize |
LonghandId::MinWidth |
LonghandId::Width => {
                let value = match property_id {
                    LonghandId::Height => self.clone_height(),
                    LonghandId::MinHeight => self.clone_min_height(),
                    LonghandId::MinWidth => self.clone_min_width(),
                    LonghandId::Width => self.clone_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BorderBlockEndWidth |
LonghandId::BorderBlockStartWidth |
LonghandId::BorderBottomWidth |
LonghandId::BorderInlineEndWidth |
LonghandId::BorderInlineStartWidth |
LonghandId::BorderLeftWidth |
LonghandId::BorderRightWidth |
LonghandId::BorderTopWidth |
LonghandId::OutlineWidth => {
                let value = match property_id {
                    LonghandId::BorderBottomWidth => self.clone_border_bottom_width(),
                    LonghandId::BorderLeftWidth => self.clone_border_left_width(),
                    LonghandId::BorderRightWidth => self.clone_border_right_width(),
                    LonghandId::BorderTopWidth => self.clone_border_top_width(),
                    LonghandId::OutlineWidth => self.clone_outline_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
            
            LonghandId::BackgroundColor |
LonghandId::BorderBlockEndColor |
LonghandId::BorderBlockStartColor |
LonghandId::BorderBottomColor |
LonghandId::BorderInlineEndColor |
LonghandId::BorderInlineStartColor |
LonghandId::BorderLeftColor |
LonghandId::BorderRightColor |
LonghandId::BorderTopColor |
LonghandId::OutlineColor |
LonghandId::TextDecorationColor => {
                let value = match property_id {
                    LonghandId::BackgroundColor => self.clone_background_color(),
                    LonghandId::BorderBottomColor => self.clone_border_bottom_color(),
                    LonghandId::BorderLeftColor => self.clone_border_left_color(),
                    LonghandId::BorderRightColor => self.clone_border_right_color(),
                    LonghandId::BorderTopColor => self.clone_border_top_color(),
                    LonghandId::OutlineColor => self.clone_outline_color(),
                    LonghandId::TextDecorationColor => self.clone_text_decoration_color(),
                    _ => unsafe { debug_unreachable!() },
                };
                value.to_typed()
            }
        }
    }

    /// Returns the given longhand's resolved value as a property declaration.
    pub fn computed_or_resolved_declaration(
        &self,
        property_id: LonghandId,
        context: Option<&resolved::Context>,
    ) -> PropertyDeclaration {
        use crate::values::resolved::ToResolvedValue;
        use crate::values::computed::ToComputedValue;
        let physical_property_id = property_id.to_physical(self.writing_mode);
        match physical_property_id {
            
            LonghandId::AlignItems => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AlignItems => self.clone_align_items(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AlignItems(specified)
            }
            
            LonghandId::AspectRatio => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AspectRatio => self.clone_aspect_ratio(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AspectRatio(specified)
            }
            
            LonghandId::BackfaceVisibility => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackfaceVisibility => self.clone_backface_visibility(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackfaceVisibility(specified)
            }
            
            LonghandId::BaselineSource => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BaselineSource => self.clone_baseline_source(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BaselineSource(specified)
            }
            
            LonghandId::BorderCollapse => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderCollapse => self.clone_border_collapse(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BorderCollapse(specified)
            }
            
            LonghandId::BorderImageRepeat => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderImageRepeat => self.clone_border_image_repeat(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BorderImageRepeat(specified)
            }
            
            LonghandId::BoxSizing => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BoxSizing => self.clone_box_sizing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BoxSizing(specified)
            }
            
            LonghandId::CaptionSide => {
                let mut computed_value = match physical_property_id {
                    LonghandId::CaptionSide => self.clone_caption_side(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::CaptionSide(specified)
            }
            
            LonghandId::Clear => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Clear => self.clone_clear(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Clear(specified)
            }
            
            LonghandId::ColumnCount => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ColumnCount => self.clone_column_count(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ColumnCount(specified)
            }
            
            LonghandId::ColumnSpan => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ColumnSpan => self.clone_column_span(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ColumnSpan(specified)
            }
            
            LonghandId::Contain => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Contain => self.clone_contain(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Contain(specified)
            }
            
            LonghandId::ContainerType => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ContainerType => self.clone_container_type(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ContainerType(specified)
            }
            
            LonghandId::Direction => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Direction => self.clone_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Direction(specified)
            }
            
            LonghandId::Display => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Display => self.clone_display(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Display(specified)
            }
            
            LonghandId::EmptyCells => {
                let mut computed_value = match physical_property_id {
                    LonghandId::EmptyCells => self.clone_empty_cells(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::EmptyCells(specified)
            }
            
            LonghandId::FlexDirection => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FlexDirection => self.clone_flex_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FlexDirection(specified)
            }
            
            LonghandId::FlexWrap => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FlexWrap => self.clone_flex_wrap(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FlexWrap(specified)
            }
            
            LonghandId::Float => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Float => self.clone_float(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Float(specified)
            }
            
            LonghandId::FontLanguageOverride => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontLanguageOverride => self.clone_font_language_override(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontLanguageOverride(specified)
            }
            
            LonghandId::FontStretch => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontStretch => self.clone_font_stretch(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontStretch(specified)
            }
            
            LonghandId::FontStyle => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontStyle => self.clone_font_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontStyle(specified)
            }
            
            LonghandId::FontSynthesisWeight => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontSynthesisWeight => self.clone_font_synthesis_weight(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontSynthesisWeight(specified)
            }
            
            LonghandId::FontVariantCaps => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontVariantCaps => self.clone_font_variant_caps(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontVariantCaps(specified)
            }
            
            LonghandId::FontWeight => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontWeight => self.clone_font_weight(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontWeight(specified)
            }
            
            LonghandId::GridAutoFlow => {
                let mut computed_value = match physical_property_id {
                    LonghandId::GridAutoFlow => self.clone_grid_auto_flow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::GridAutoFlow(specified)
            }
            
            LonghandId::ImageRendering => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ImageRendering => self.clone_image_rendering(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ImageRendering(specified)
            }
            
            LonghandId::Isolation => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Isolation => self.clone_isolation(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Isolation(specified)
            }
            
            LonghandId::JustifyItems => {
                let mut computed_value = match physical_property_id {
                    LonghandId::JustifyItems => self.clone_justify_items(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::JustifyItems(specified)
            }
            
            LonghandId::ListStylePosition => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ListStylePosition => self.clone_list_style_position(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ListStylePosition(specified)
            }
            
            LonghandId::ListStyleType => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ListStyleType => self.clone_list_style_type(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ListStyleType(specified)
            }
            
            LonghandId::MixBlendMode => {
                let mut computed_value = match physical_property_id {
                    LonghandId::MixBlendMode => self.clone_mix_blend_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::MixBlendMode(specified)
            }
            
            LonghandId::ObjectFit => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ObjectFit => self.clone_object_fit(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ObjectFit(specified)
            }
            
            LonghandId::Opacity => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Opacity => self.clone_opacity(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Opacity(specified)
            }
            
            LonghandId::Order => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Order => self.clone_order(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Order(specified)
            }
            
            LonghandId::OutlineStyle => {
                let mut computed_value = match physical_property_id {
                    LonghandId::OutlineStyle => self.clone_outline_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::OutlineStyle(specified)
            }
            
            LonghandId::OverflowWrap => {
                let mut computed_value = match physical_property_id {
                    LonghandId::OverflowWrap => self.clone_overflow_wrap(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::OverflowWrap(specified)
            }
            
            LonghandId::PointerEvents => {
                let mut computed_value = match physical_property_id {
                    LonghandId::PointerEvents => self.clone_pointer_events(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::PointerEvents(specified)
            }
            
            LonghandId::Position => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Position => self.clone_position(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Position(specified)
            }
            
            LonghandId::PositionArea => {
                let mut computed_value = match physical_property_id {
                    LonghandId::PositionArea => self.clone_position_area(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::PositionArea(specified)
            }
            
            LonghandId::ServoOverflowClipBox => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ServoOverflowClipBox => self.clone__servo_overflow_clip_box(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ServoOverflowClipBox(specified)
            }
            
            LonghandId::ServoTopLayer => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ServoTopLayer => self.clone__servo_top_layer(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ServoTopLayer(specified)
            }
            
            LonghandId::TableLayout => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TableLayout => self.clone_table_layout(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TableLayout(specified)
            }
            
            LonghandId::TextAlign => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextAlign => self.clone_text_align(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextAlign(specified)
            }
            
            LonghandId::TextAlignLast => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextAlignLast => self.clone_text_align_last(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextAlignLast(specified)
            }
            
            LonghandId::TextDecorationLine => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextDecorationLine => self.clone_text_decoration_line(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextDecorationLine(specified)
            }
            
            LonghandId::TextDecorationStyle => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextDecorationStyle => self.clone_text_decoration_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextDecorationStyle(specified)
            }
            
            LonghandId::TextJustify => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextJustify => self.clone_text_justify(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextJustify(specified)
            }
            
            LonghandId::TextRendering => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextRendering => self.clone_text_rendering(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextRendering(specified)
            }
            
            LonghandId::TextTransform => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextTransform => self.clone_text_transform(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextTransform(specified)
            }
            
            LonghandId::TextWrapMode => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextWrapMode => self.clone_text_wrap_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextWrapMode(specified)
            }
            
            LonghandId::TransformStyle => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TransformStyle => self.clone_transform_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TransformStyle(specified)
            }
            
            LonghandId::UnicodeBidi => {
                let mut computed_value = match physical_property_id {
                    LonghandId::UnicodeBidi => self.clone_unicode_bidi(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::UnicodeBidi(specified)
            }
            
            LonghandId::Visibility => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Visibility => self.clone_visibility(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Visibility(specified)
            }
            
            LonghandId::WhiteSpaceCollapse => {
                let mut computed_value = match physical_property_id {
                    LonghandId::WhiteSpaceCollapse => self.clone_white_space_collapse(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::WhiteSpaceCollapse(specified)
            }
            
            LonghandId::WordBreak => {
                let mut computed_value = match physical_property_id {
                    LonghandId::WordBreak => self.clone_word_break(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::WordBreak(specified)
            }
            
            LonghandId::WritingMode => {
                let mut computed_value = match physical_property_id {
                    LonghandId::WritingMode => self.clone_writing_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::WritingMode(specified)
            }
            
            LonghandId::ZIndex => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ZIndex => self.clone_z_index(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ZIndex(specified)
            }
            
            LonghandId::Zoom => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Zoom => self.clone_zoom(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Zoom(specified)
            }
            
            LonghandId::AlignContent |
LonghandId::JustifyContent => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AlignContent => self.clone_align_content(),
                    LonghandId::JustifyContent => self.clone_justify_content(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::ContentDistribution>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::FlexGrow |
LonghandId::FlexShrink => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FlexGrow => self.clone_flex_grow(),
                    LonghandId::FlexShrink => self.clone_flex_shrink(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeNumber>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::AlignSelf |
LonghandId::JustifySelf => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AlignSelf => self.clone_align_self(),
                    LonghandId::JustifySelf => self.clone_justify_self(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::SelfAlignment>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::OverflowBlock |
LonghandId::OverflowInline |
LonghandId::OverflowX |
LonghandId::OverflowY => {
                let mut computed_value = match physical_property_id {
                    LonghandId::OverflowX => self.clone_overflow_x(),
                    LonghandId::OverflowY => self.clone_overflow_y(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Overflow>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::BorderBlockEndStyle |
LonghandId::BorderBlockStartStyle |
LonghandId::BorderBottomStyle |
LonghandId::BorderInlineEndStyle |
LonghandId::BorderInlineStartStyle |
LonghandId::BorderLeftStyle |
LonghandId::BorderRightStyle |
LonghandId::BorderTopStyle => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderBottomStyle => self.clone_border_bottom_style(),
                    LonghandId::BorderLeftStyle => self.clone_border_left_style(),
                    LonghandId::BorderRightStyle => self.clone_border_right_style(),
                    LonghandId::BorderTopStyle => self.clone_border_top_style(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::BorderStyle>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::AnimationComposition => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationComposition => self.clone_animation_composition(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationComposition(specified)
            }
            
            LonghandId::AnimationDelay => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationDelay => self.clone_animation_delay(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationDelay(specified)
            }
            
            LonghandId::AnimationDirection => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationDirection => self.clone_animation_direction(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationDirection(specified)
            }
            
            LonghandId::AnimationDuration => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationDuration => self.clone_animation_duration(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationDuration(specified)
            }
            
            LonghandId::AnimationFillMode => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationFillMode => self.clone_animation_fill_mode(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationFillMode(specified)
            }
            
            LonghandId::AnimationIterationCount => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationIterationCount => self.clone_animation_iteration_count(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationIterationCount(specified)
            }
            
            LonghandId::AnimationName => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationName => self.clone_animation_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationName(specified)
            }
            
            LonghandId::AnimationPlayState => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationPlayState => self.clone_animation_play_state(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationPlayState(specified)
            }
            
            LonghandId::AnimationTimeline => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationTimeline => self.clone_animation_timeline(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationTimeline(specified)
            }
            
            LonghandId::AnimationTimingFunction => {
                let mut computed_value = match physical_property_id {
                    LonghandId::AnimationTimingFunction => self.clone_animation_timing_function(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::AnimationTimingFunction(specified)
            }
            
            LonghandId::BackdropFilter => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackdropFilter => self.clone_backdrop_filter(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackdropFilter(specified)
            }
            
            LonghandId::BackgroundAttachment => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundAttachment => self.clone_background_attachment(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundAttachment(specified)
            }
            
            LonghandId::BackgroundClip => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundClip => self.clone_background_clip(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundClip(specified)
            }
            
            LonghandId::BackgroundImage => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundImage => self.clone_background_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundImage(specified)
            }
            
            LonghandId::BackgroundOrigin => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundOrigin => self.clone_background_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundOrigin(specified)
            }
            
            LonghandId::BackgroundPositionX => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundPositionX => self.clone_background_position_x(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundPositionX(specified)
            }
            
            LonghandId::BackgroundPositionY => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundPositionY => self.clone_background_position_y(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundPositionY(specified)
            }
            
            LonghandId::BackgroundRepeat => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundRepeat => self.clone_background_repeat(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundRepeat(specified)
            }
            
            LonghandId::BackgroundSize => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundSize => self.clone_background_size(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BackgroundSize(specified)
            }
            
            LonghandId::BorderImageOutset => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderImageOutset => self.clone_border_image_outset(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::BorderImageOutset(specified)
            }
            
            LonghandId::BorderImageSlice => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderImageSlice => self.clone_border_image_slice(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::BorderImageSlice(specified)
            }
            
            LonghandId::BorderImageWidth => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderImageWidth => self.clone_border_image_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::BorderImageWidth(specified)
            }
            
            LonghandId::BorderSpacing => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderSpacing => self.clone_border_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::BorderSpacing(specified)
            }
            
            LonghandId::BoxShadow => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BoxShadow => self.clone_box_shadow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::BoxShadow(specified)
            }
            
            LonghandId::Clip => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Clip => self.clone_clip(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::Clip(specified)
            }
            
            LonghandId::ClipPath => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ClipPath => self.clone_clip_path(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ClipPath(specified)
            }
            
            LonghandId::Color => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Color => self.clone_color(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Color(specified)
            }
            
            LonghandId::ColorScheme => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ColorScheme => self.clone_color_scheme(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ColorScheme(specified)
            }
            
            LonghandId::ColumnWidth => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ColumnWidth => self.clone_column_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ColumnWidth(specified)
            }
            
            LonghandId::ContainerName => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ContainerName => self.clone_container_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ContainerName(specified)
            }
            
            LonghandId::Content => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Content => self.clone_content(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Content(specified)
            }
            
            LonghandId::CounterIncrement => {
                let mut computed_value = match physical_property_id {
                    LonghandId::CounterIncrement => self.clone_counter_increment(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::CounterIncrement(specified)
            }
            
            LonghandId::CounterReset => {
                let mut computed_value = match physical_property_id {
                    LonghandId::CounterReset => self.clone_counter_reset(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::CounterReset(specified)
            }
            
            LonghandId::Cursor => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Cursor => self.clone_cursor(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Cursor(specified)
            }
            
            LonghandId::Filter => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Filter => self.clone_filter(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Filter(specified)
            }
            
            LonghandId::FlexBasis => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FlexBasis => self.clone_flex_basis(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::FlexBasis(specified)
            }
            
            LonghandId::FontFamily => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontFamily => self.clone_font_family(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontFamily(specified)
            }
            
            LonghandId::FontSize => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontSize => self.clone_font_size(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontSize(specified)
            }
            
            LonghandId::FontVariationSettings => {
                let mut computed_value = match physical_property_id {
                    LonghandId::FontVariationSettings => self.clone_font_variation_settings(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::FontVariationSettings(specified)
            }
            
            LonghandId::GridTemplateAreas => {
                let mut computed_value = match physical_property_id {
                    LonghandId::GridTemplateAreas => self.clone_grid_template_areas(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::GridTemplateAreas(specified)
            }
            
            LonghandId::LetterSpacing => {
                let mut computed_value = match physical_property_id {
                    LonghandId::LetterSpacing => self.clone_letter_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::LetterSpacing(specified)
            }
            
            LonghandId::LineHeight => {
                let mut computed_value = match physical_property_id {
                    LonghandId::LineHeight => self.clone_line_height(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::LineHeight(specified)
            }
            
            LonghandId::MaskImage => {
                let mut computed_value = match physical_property_id {
                    LonghandId::MaskImage => self.clone_mask_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::MaskImage(specified)
            }
            
            LonghandId::OffsetPath => {
                let mut computed_value = match physical_property_id {
                    LonghandId::OffsetPath => self.clone_offset_path(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::OffsetPath(specified)
            }
            
            LonghandId::OutlineOffset => {
                let mut computed_value = match physical_property_id {
                    LonghandId::OutlineOffset => self.clone_outline_offset(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::OutlineOffset(specified)
            }
            
            LonghandId::OverflowClipMargin => {
                let mut computed_value = match physical_property_id {
                    LonghandId::OverflowClipMargin => self.clone_overflow_clip_margin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::OverflowClipMargin(specified)
            }
            
            LonghandId::Perspective => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Perspective => self.clone_perspective(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Perspective(specified)
            }
            
            LonghandId::Quotes => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Quotes => self.clone_quotes(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Quotes(specified)
            }
            
            LonghandId::Rotate => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Rotate => self.clone_rotate(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::Rotate(specified)
            }
            
            LonghandId::Scale => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Scale => self.clone_scale(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::Scale(specified)
            }
            
            LonghandId::TextIndent => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextIndent => self.clone_text_indent(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextIndent(specified)
            }
            
            LonghandId::TextOverflow => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextOverflow => self.clone_text_overflow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::TextOverflow(specified)
            }
            
            LonghandId::TextShadow => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TextShadow => self.clone_text_shadow(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TextShadow(specified)
            }
            
            LonghandId::Transform => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Transform => self.clone_transform(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::Transform(specified)
            }
            
            LonghandId::TransformOrigin => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TransformOrigin => self.clone_transform_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::TransformOrigin(specified)
            }
            
            LonghandId::TransitionBehavior => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TransitionBehavior => self.clone_transition_behavior(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TransitionBehavior(specified)
            }
            
            LonghandId::TransitionDelay => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TransitionDelay => self.clone_transition_delay(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TransitionDelay(specified)
            }
            
            LonghandId::TransitionDuration => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TransitionDuration => self.clone_transition_duration(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TransitionDuration(specified)
            }
            
            LonghandId::TransitionProperty => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TransitionProperty => self.clone_transition_property(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TransitionProperty(specified)
            }
            
            LonghandId::TransitionTimingFunction => {
                let mut computed_value = match physical_property_id {
                    LonghandId::TransitionTimingFunction => self.clone_transition_timing_function(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::TransitionTimingFunction(specified)
            }
            
            LonghandId::Translate => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Translate => self.clone_translate(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                PropertyDeclaration::Translate(specified)
            }
            
            LonghandId::VerticalAlign => {
                let mut computed_value = match physical_property_id {
                    LonghandId::VerticalAlign => self.clone_vertical_align(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::VerticalAlign(specified)
            }
            
            LonghandId::ViewTransitionClass => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ViewTransitionClass => self.clone_view_transition_class(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ViewTransitionClass(specified)
            }
            
            LonghandId::ViewTransitionName => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ViewTransitionName => self.clone_view_transition_name(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::ViewTransitionName(specified)
            }
            
            LonghandId::WillChange => {
                let mut computed_value = match physical_property_id {
                    LonghandId::WillChange => self.clone_will_change(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::WillChange(specified)
            }
            
            LonghandId::WordSpacing => {
                let mut computed_value = match physical_property_id {
                    LonghandId::WordSpacing => self.clone_word_spacing(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::WordSpacing(specified)
            }
            
            LonghandId::XLang => {
                let mut computed_value = match physical_property_id {
                    LonghandId::XLang => self.clone__x_lang(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                PropertyDeclaration::XLang(specified)
            }
            
            LonghandId::ObjectPosition |
LonghandId::PerspectiveOrigin => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ObjectPosition => self.clone_object_position(),
                    LonghandId::PerspectiveOrigin => self.clone_perspective_origin(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<Box<crate::values::specified::Position>>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::GridTemplateColumns |
LonghandId::GridTemplateRows => {
                let mut computed_value = match physical_property_id {
                    LonghandId::GridTemplateColumns => self.clone_grid_template_columns(),
                    LonghandId::GridTemplateRows => self.clone_grid_template_rows(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::GridTemplateComponent>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::BorderImageSource |
LonghandId::ListStyleImage => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderImageSource => self.clone_border_image_source(),
                    LonghandId::ListStyleImage => self.clone_list_style_image(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Image>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::GridAutoColumns |
LonghandId::GridAutoRows => {
                let mut computed_value = match physical_property_id {
                    LonghandId::GridAutoColumns => self.clone_grid_auto_columns(),
                    LonghandId::GridAutoRows => self.clone_grid_auto_rows(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::ImplicitGridTracks>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::ColumnGap |
LonghandId::RowGap => {
                let mut computed_value = match physical_property_id {
                    LonghandId::ColumnGap => self.clone_column_gap(),
                    LonghandId::RowGap => self.clone_row_gap(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::length::NonNegativeLengthPercentageOrNormal>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::GridColumnEnd |
LonghandId::GridColumnStart |
LonghandId::GridRowEnd |
LonghandId::GridRowStart => {
                let mut computed_value = match physical_property_id {
                    LonghandId::GridColumnEnd => self.clone_grid_column_end(),
                    LonghandId::GridColumnStart => self.clone_grid_column_start(),
                    LonghandId::GridRowEnd => self.clone_grid_row_end(),
                    LonghandId::GridRowStart => self.clone_grid_row_start(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::GridLine>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::MaxBlockSize |
LonghandId::MaxHeight |
LonghandId::MaxInlineSize |
LonghandId::MaxWidth => {
                let mut computed_value = match physical_property_id {
                    LonghandId::MaxHeight => self.clone_max_height(),
                    LonghandId::MaxWidth => self.clone_max_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::MaxSize>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::BorderBottomLeftRadius |
LonghandId::BorderBottomRightRadius |
LonghandId::BorderEndEndRadius |
LonghandId::BorderEndStartRadius |
LonghandId::BorderStartEndRadius |
LonghandId::BorderStartStartRadius |
LonghandId::BorderTopLeftRadius |
LonghandId::BorderTopRightRadius => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderBottomLeftRadius => self.clone_border_bottom_left_radius(),
                    LonghandId::BorderBottomRightRadius => self.clone_border_bottom_right_radius(),
                    LonghandId::BorderTopLeftRadius => self.clone_border_top_left_radius(),
                    LonghandId::BorderTopRightRadius => self.clone_border_top_right_radius(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                let specified = Box::new(specified);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<Box<crate::values::specified::BorderCornerRadius>>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::Bottom |
LonghandId::InsetBlockEnd |
LonghandId::InsetBlockStart |
LonghandId::InsetInlineEnd |
LonghandId::InsetInlineStart |
LonghandId::Left |
LonghandId::Right |
LonghandId::Top => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Bottom => self.clone_bottom(),
                    LonghandId::Left => self.clone_left(),
                    LonghandId::Right => self.clone_right(),
                    LonghandId::Top => self.clone_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Inset>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::MarginBlockEnd |
LonghandId::MarginBlockStart |
LonghandId::MarginBottom |
LonghandId::MarginInlineEnd |
LonghandId::MarginInlineStart |
LonghandId::MarginLeft |
LonghandId::MarginRight |
LonghandId::MarginTop => {
                let mut computed_value = match physical_property_id {
                    LonghandId::MarginBottom => self.clone_margin_bottom(),
                    LonghandId::MarginLeft => self.clone_margin_left(),
                    LonghandId::MarginRight => self.clone_margin_right(),
                    LonghandId::MarginTop => self.clone_margin_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Margin>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::PaddingBlockEnd |
LonghandId::PaddingBlockStart |
LonghandId::PaddingBottom |
LonghandId::PaddingInlineEnd |
LonghandId::PaddingInlineStart |
LonghandId::PaddingLeft |
LonghandId::PaddingRight |
LonghandId::PaddingTop => {
                let mut computed_value = match physical_property_id {
                    LonghandId::PaddingBottom => self.clone_padding_bottom(),
                    LonghandId::PaddingLeft => self.clone_padding_left(),
                    LonghandId::PaddingRight => self.clone_padding_right(),
                    LonghandId::PaddingTop => self.clone_padding_top(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::NonNegativeLengthPercentage>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::BlockSize |
LonghandId::Height |
LonghandId::InlineSize |
LonghandId::MinBlockSize |
LonghandId::MinHeight |
LonghandId::MinInlineSize |
LonghandId::MinWidth |
LonghandId::Width => {
                let mut computed_value = match physical_property_id {
                    LonghandId::Height => self.clone_height(),
                    LonghandId::MinHeight => self.clone_min_height(),
                    LonghandId::MinWidth => self.clone_min_width(),
                    LonghandId::Width => self.clone_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Size>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::BorderBlockEndWidth |
LonghandId::BorderBlockStartWidth |
LonghandId::BorderBottomWidth |
LonghandId::BorderInlineEndWidth |
LonghandId::BorderInlineStartWidth |
LonghandId::BorderLeftWidth |
LonghandId::BorderRightWidth |
LonghandId::BorderTopWidth |
LonghandId::OutlineWidth => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BorderBottomWidth => self.clone_border_bottom_width(),
                    LonghandId::BorderLeftWidth => self.clone_border_left_width(),
                    LonghandId::BorderRightWidth => self.clone_border_right_width(),
                    LonghandId::BorderTopWidth => self.clone_border_top_width(),
                    LonghandId::OutlineWidth => self.clone_outline_width(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::BorderSideWidth>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
            
            LonghandId::BackgroundColor |
LonghandId::BorderBlockEndColor |
LonghandId::BorderBlockStartColor |
LonghandId::BorderBottomColor |
LonghandId::BorderInlineEndColor |
LonghandId::BorderInlineStartColor |
LonghandId::BorderLeftColor |
LonghandId::BorderRightColor |
LonghandId::BorderTopColor |
LonghandId::OutlineColor |
LonghandId::TextDecorationColor => {
                let mut computed_value = match physical_property_id {
                    LonghandId::BackgroundColor => self.clone_background_color(),
                    LonghandId::BorderBottomColor => self.clone_border_bottom_color(),
                    LonghandId::BorderLeftColor => self.clone_border_left_color(),
                    LonghandId::BorderRightColor => self.clone_border_right_color(),
                    LonghandId::BorderTopColor => self.clone_border_top_color(),
                    LonghandId::OutlineColor => self.clone_outline_color(),
                    LonghandId::TextDecorationColor => self.clone_text_decoration_color(),
                    _ => unsafe { debug_unreachable!() },
                };
                if let Some(c) = context {
                    let resolved = computed_value.to_resolved_value(c);
                    computed_value = ToResolvedValue::from_resolved_value(resolved);
                }
                let specified = ToComputedValue::from_computed_value(&computed_value);
                unsafe {
                    let mut out = mem::MaybeUninit::uninit();
                    ptr::write(
                        out.as_mut_ptr() as *mut PropertyDeclarationVariantRepr<crate::values::specified::Color>,
                        PropertyDeclarationVariantRepr {
                            tag: property_id as u16,
                            value: specified,
                        },
                    );
                    out.assume_init()
                }
            }
        }
    }

    /// Resolves the currentColor keyword.
    ///
    /// Any color value from computed values (except for the 'color' property
    /// itself) should go through this method.
    ///
    /// Usage example:
    /// let top_color =
    ///   style.resolve_color(&style.get_border().clone_border_top_color());
    #[inline]
    pub fn resolve_color(&self, color: &computed::Color) -> crate::color::AbsoluteColor {
        let current_color = self.get_inherited_text().clone_color();
        color.resolve_to_absolute(&current_color)
    }

    /// Returns which longhand properties have different values in the two
    /// ComputedValues.
    #[cfg(feature = "gecko_debug")]
    pub fn differing_properties(&self, other: &ComputedValues) -> LonghandIdSet {
        let mut set = LonghandIdSet::new();
        if self.clone_align_items() != other.clone_align_items() {
            set.insert(LonghandId::AlignItems);
        }
        if self.clone_aspect_ratio() != other.clone_aspect_ratio() {
            set.insert(LonghandId::AspectRatio);
        }
        if self.clone_backface_visibility() != other.clone_backface_visibility() {
            set.insert(LonghandId::BackfaceVisibility);
        }
        if self.clone_baseline_source() != other.clone_baseline_source() {
            set.insert(LonghandId::BaselineSource);
        }
        if self.clone_border_collapse() != other.clone_border_collapse() {
            set.insert(LonghandId::BorderCollapse);
        }
        if self.clone_border_image_repeat() != other.clone_border_image_repeat() {
            set.insert(LonghandId::BorderImageRepeat);
        }
        if self.clone_box_sizing() != other.clone_box_sizing() {
            set.insert(LonghandId::BoxSizing);
        }
        if self.clone_caption_side() != other.clone_caption_side() {
            set.insert(LonghandId::CaptionSide);
        }
        if self.clone_clear() != other.clone_clear() {
            set.insert(LonghandId::Clear);
        }
        if self.clone_column_count() != other.clone_column_count() {
            set.insert(LonghandId::ColumnCount);
        }
        if self.clone_column_span() != other.clone_column_span() {
            set.insert(LonghandId::ColumnSpan);
        }
        if self.clone_contain() != other.clone_contain() {
            set.insert(LonghandId::Contain);
        }
        if self.clone_container_type() != other.clone_container_type() {
            set.insert(LonghandId::ContainerType);
        }
        if self.clone_direction() != other.clone_direction() {
            set.insert(LonghandId::Direction);
        }
        if self.clone_display() != other.clone_display() {
            set.insert(LonghandId::Display);
        }
        if self.clone_empty_cells() != other.clone_empty_cells() {
            set.insert(LonghandId::EmptyCells);
        }
        if self.clone_flex_direction() != other.clone_flex_direction() {
            set.insert(LonghandId::FlexDirection);
        }
        if self.clone_flex_wrap() != other.clone_flex_wrap() {
            set.insert(LonghandId::FlexWrap);
        }
        if self.clone_float() != other.clone_float() {
            set.insert(LonghandId::Float);
        }
        if self.clone_font_language_override() != other.clone_font_language_override() {
            set.insert(LonghandId::FontLanguageOverride);
        }
        if self.clone_font_stretch() != other.clone_font_stretch() {
            set.insert(LonghandId::FontStretch);
        }
        if self.clone_font_style() != other.clone_font_style() {
            set.insert(LonghandId::FontStyle);
        }
        if self.clone_font_synthesis_weight() != other.clone_font_synthesis_weight() {
            set.insert(LonghandId::FontSynthesisWeight);
        }
        if self.clone_font_variant_caps() != other.clone_font_variant_caps() {
            set.insert(LonghandId::FontVariantCaps);
        }
        if self.clone_font_weight() != other.clone_font_weight() {
            set.insert(LonghandId::FontWeight);
        }
        if self.clone_grid_auto_flow() != other.clone_grid_auto_flow() {
            set.insert(LonghandId::GridAutoFlow);
        }
        if self.clone_image_rendering() != other.clone_image_rendering() {
            set.insert(LonghandId::ImageRendering);
        }
        if self.clone_isolation() != other.clone_isolation() {
            set.insert(LonghandId::Isolation);
        }
        if self.clone_justify_items() != other.clone_justify_items() {
            set.insert(LonghandId::JustifyItems);
        }
        if self.clone_list_style_position() != other.clone_list_style_position() {
            set.insert(LonghandId::ListStylePosition);
        }
        if self.clone_list_style_type() != other.clone_list_style_type() {
            set.insert(LonghandId::ListStyleType);
        }
        if self.clone_mix_blend_mode() != other.clone_mix_blend_mode() {
            set.insert(LonghandId::MixBlendMode);
        }
        if self.clone_object_fit() != other.clone_object_fit() {
            set.insert(LonghandId::ObjectFit);
        }
        if self.clone_opacity() != other.clone_opacity() {
            set.insert(LonghandId::Opacity);
        }
        if self.clone_order() != other.clone_order() {
            set.insert(LonghandId::Order);
        }
        if self.clone_outline_style() != other.clone_outline_style() {
            set.insert(LonghandId::OutlineStyle);
        }
        if self.clone_overflow_wrap() != other.clone_overflow_wrap() {
            set.insert(LonghandId::OverflowWrap);
        }
        if self.clone_pointer_events() != other.clone_pointer_events() {
            set.insert(LonghandId::PointerEvents);
        }
        if self.clone_position() != other.clone_position() {
            set.insert(LonghandId::Position);
        }
        if self.clone_position_area() != other.clone_position_area() {
            set.insert(LonghandId::PositionArea);
        }
        if self.clone__servo_overflow_clip_box() != other.clone__servo_overflow_clip_box() {
            set.insert(LonghandId::ServoOverflowClipBox);
        }
        if self.clone__servo_top_layer() != other.clone__servo_top_layer() {
            set.insert(LonghandId::ServoTopLayer);
        }
        if self.clone_table_layout() != other.clone_table_layout() {
            set.insert(LonghandId::TableLayout);
        }
        if self.clone_text_align() != other.clone_text_align() {
            set.insert(LonghandId::TextAlign);
        }
        if self.clone_text_align_last() != other.clone_text_align_last() {
            set.insert(LonghandId::TextAlignLast);
        }
        if self.clone_text_decoration_line() != other.clone_text_decoration_line() {
            set.insert(LonghandId::TextDecorationLine);
        }
        if self.clone_text_decoration_style() != other.clone_text_decoration_style() {
            set.insert(LonghandId::TextDecorationStyle);
        }
        if self.clone_text_justify() != other.clone_text_justify() {
            set.insert(LonghandId::TextJustify);
        }
        if self.clone_text_rendering() != other.clone_text_rendering() {
            set.insert(LonghandId::TextRendering);
        }
        if self.clone_text_transform() != other.clone_text_transform() {
            set.insert(LonghandId::TextTransform);
        }
        if self.clone_text_wrap_mode() != other.clone_text_wrap_mode() {
            set.insert(LonghandId::TextWrapMode);
        }
        if self.clone_transform_style() != other.clone_transform_style() {
            set.insert(LonghandId::TransformStyle);
        }
        if self.clone_unicode_bidi() != other.clone_unicode_bidi() {
            set.insert(LonghandId::UnicodeBidi);
        }
        if self.clone_visibility() != other.clone_visibility() {
            set.insert(LonghandId::Visibility);
        }
        if self.clone_white_space_collapse() != other.clone_white_space_collapse() {
            set.insert(LonghandId::WhiteSpaceCollapse);
        }
        if self.clone_word_break() != other.clone_word_break() {
            set.insert(LonghandId::WordBreak);
        }
        if self.clone_writing_mode() != other.clone_writing_mode() {
            set.insert(LonghandId::WritingMode);
        }
        if self.clone_z_index() != other.clone_z_index() {
            set.insert(LonghandId::ZIndex);
        }
        if self.clone_zoom() != other.clone_zoom() {
            set.insert(LonghandId::Zoom);
        }
        if self.clone_align_content() != other.clone_align_content() {
            set.insert(LonghandId::AlignContent);
        }
        if self.clone_justify_content() != other.clone_justify_content() {
            set.insert(LonghandId::JustifyContent);
        }
        if self.clone_flex_grow() != other.clone_flex_grow() {
            set.insert(LonghandId::FlexGrow);
        }
        if self.clone_flex_shrink() != other.clone_flex_shrink() {
            set.insert(LonghandId::FlexShrink);
        }
        if self.clone_align_self() != other.clone_align_self() {
            set.insert(LonghandId::AlignSelf);
        }
        if self.clone_justify_self() != other.clone_justify_self() {
            set.insert(LonghandId::JustifySelf);
        }
        if self.clone_overflow_x() != other.clone_overflow_x() {
            set.insert(LonghandId::OverflowX);
        }
        if self.clone_overflow_y() != other.clone_overflow_y() {
            set.insert(LonghandId::OverflowY);
        }
        if self.clone_border_bottom_style() != other.clone_border_bottom_style() {
            set.insert(LonghandId::BorderBottomStyle);
        }
        if self.clone_border_left_style() != other.clone_border_left_style() {
            set.insert(LonghandId::BorderLeftStyle);
        }
        if self.clone_border_right_style() != other.clone_border_right_style() {
            set.insert(LonghandId::BorderRightStyle);
        }
        if self.clone_border_top_style() != other.clone_border_top_style() {
            set.insert(LonghandId::BorderTopStyle);
        }
        if self.clone_animation_composition() != other.clone_animation_composition() {
            set.insert(LonghandId::AnimationComposition);
        }
        if self.clone_animation_delay() != other.clone_animation_delay() {
            set.insert(LonghandId::AnimationDelay);
        }
        if self.clone_animation_direction() != other.clone_animation_direction() {
            set.insert(LonghandId::AnimationDirection);
        }
        if self.clone_animation_duration() != other.clone_animation_duration() {
            set.insert(LonghandId::AnimationDuration);
        }
        if self.clone_animation_fill_mode() != other.clone_animation_fill_mode() {
            set.insert(LonghandId::AnimationFillMode);
        }
        if self.clone_animation_iteration_count() != other.clone_animation_iteration_count() {
            set.insert(LonghandId::AnimationIterationCount);
        }
        if self.clone_animation_name() != other.clone_animation_name() {
            set.insert(LonghandId::AnimationName);
        }
        if self.clone_animation_play_state() != other.clone_animation_play_state() {
            set.insert(LonghandId::AnimationPlayState);
        }
        if self.clone_animation_timeline() != other.clone_animation_timeline() {
            set.insert(LonghandId::AnimationTimeline);
        }
        if self.clone_animation_timing_function() != other.clone_animation_timing_function() {
            set.insert(LonghandId::AnimationTimingFunction);
        }
        if self.clone_backdrop_filter() != other.clone_backdrop_filter() {
            set.insert(LonghandId::BackdropFilter);
        }
        if self.clone_background_attachment() != other.clone_background_attachment() {
            set.insert(LonghandId::BackgroundAttachment);
        }
        if self.clone_background_clip() != other.clone_background_clip() {
            set.insert(LonghandId::BackgroundClip);
        }
        if self.clone_background_image() != other.clone_background_image() {
            set.insert(LonghandId::BackgroundImage);
        }
        if self.clone_background_origin() != other.clone_background_origin() {
            set.insert(LonghandId::BackgroundOrigin);
        }
        if self.clone_background_position_x() != other.clone_background_position_x() {
            set.insert(LonghandId::BackgroundPositionX);
        }
        if self.clone_background_position_y() != other.clone_background_position_y() {
            set.insert(LonghandId::BackgroundPositionY);
        }
        if self.clone_background_repeat() != other.clone_background_repeat() {
            set.insert(LonghandId::BackgroundRepeat);
        }
        if self.clone_background_size() != other.clone_background_size() {
            set.insert(LonghandId::BackgroundSize);
        }
        if self.clone_border_image_outset() != other.clone_border_image_outset() {
            set.insert(LonghandId::BorderImageOutset);
        }
        if self.clone_border_image_slice() != other.clone_border_image_slice() {
            set.insert(LonghandId::BorderImageSlice);
        }
        if self.clone_border_image_width() != other.clone_border_image_width() {
            set.insert(LonghandId::BorderImageWidth);
        }
        if self.clone_border_spacing() != other.clone_border_spacing() {
            set.insert(LonghandId::BorderSpacing);
        }
        if self.clone_box_shadow() != other.clone_box_shadow() {
            set.insert(LonghandId::BoxShadow);
        }
        if self.clone_clip() != other.clone_clip() {
            set.insert(LonghandId::Clip);
        }
        if self.clone_clip_path() != other.clone_clip_path() {
            set.insert(LonghandId::ClipPath);
        }
        if self.clone_color() != other.clone_color() {
            set.insert(LonghandId::Color);
        }
        if self.clone_color_scheme() != other.clone_color_scheme() {
            set.insert(LonghandId::ColorScheme);
        }
        if self.clone_column_width() != other.clone_column_width() {
            set.insert(LonghandId::ColumnWidth);
        }
        if self.clone_container_name() != other.clone_container_name() {
            set.insert(LonghandId::ContainerName);
        }
        if self.clone_content() != other.clone_content() {
            set.insert(LonghandId::Content);
        }
        if self.clone_counter_increment() != other.clone_counter_increment() {
            set.insert(LonghandId::CounterIncrement);
        }
        if self.clone_counter_reset() != other.clone_counter_reset() {
            set.insert(LonghandId::CounterReset);
        }
        if self.clone_cursor() != other.clone_cursor() {
            set.insert(LonghandId::Cursor);
        }
        if self.clone_filter() != other.clone_filter() {
            set.insert(LonghandId::Filter);
        }
        if self.clone_flex_basis() != other.clone_flex_basis() {
            set.insert(LonghandId::FlexBasis);
        }
        if self.clone_font_family() != other.clone_font_family() {
            set.insert(LonghandId::FontFamily);
        }
        if self.clone_font_size() != other.clone_font_size() {
            set.insert(LonghandId::FontSize);
        }
        if self.clone_font_variation_settings() != other.clone_font_variation_settings() {
            set.insert(LonghandId::FontVariationSettings);
        }
        if self.clone_grid_template_areas() != other.clone_grid_template_areas() {
            set.insert(LonghandId::GridTemplateAreas);
        }
        if self.clone_letter_spacing() != other.clone_letter_spacing() {
            set.insert(LonghandId::LetterSpacing);
        }
        if self.clone_line_height() != other.clone_line_height() {
            set.insert(LonghandId::LineHeight);
        }
        if self.clone_mask_image() != other.clone_mask_image() {
            set.insert(LonghandId::MaskImage);
        }
        if self.clone_offset_path() != other.clone_offset_path() {
            set.insert(LonghandId::OffsetPath);
        }
        if self.clone_outline_offset() != other.clone_outline_offset() {
            set.insert(LonghandId::OutlineOffset);
        }
        if self.clone_overflow_clip_margin() != other.clone_overflow_clip_margin() {
            set.insert(LonghandId::OverflowClipMargin);
        }
        if self.clone_perspective() != other.clone_perspective() {
            set.insert(LonghandId::Perspective);
        }
        if self.clone_quotes() != other.clone_quotes() {
            set.insert(LonghandId::Quotes);
        }
        if self.clone_rotate() != other.clone_rotate() {
            set.insert(LonghandId::Rotate);
        }
        if self.clone_scale() != other.clone_scale() {
            set.insert(LonghandId::Scale);
        }
        if self.clone_text_indent() != other.clone_text_indent() {
            set.insert(LonghandId::TextIndent);
        }
        if self.clone_text_overflow() != other.clone_text_overflow() {
            set.insert(LonghandId::TextOverflow);
        }
        if self.clone_text_shadow() != other.clone_text_shadow() {
            set.insert(LonghandId::TextShadow);
        }
        if self.clone_transform() != other.clone_transform() {
            set.insert(LonghandId::Transform);
        }
        if self.clone_transform_origin() != other.clone_transform_origin() {
            set.insert(LonghandId::TransformOrigin);
        }
        if self.clone_transition_behavior() != other.clone_transition_behavior() {
            set.insert(LonghandId::TransitionBehavior);
        }
        if self.clone_transition_delay() != other.clone_transition_delay() {
            set.insert(LonghandId::TransitionDelay);
        }
        if self.clone_transition_duration() != other.clone_transition_duration() {
            set.insert(LonghandId::TransitionDuration);
        }
        if self.clone_transition_property() != other.clone_transition_property() {
            set.insert(LonghandId::TransitionProperty);
        }
        if self.clone_transition_timing_function() != other.clone_transition_timing_function() {
            set.insert(LonghandId::TransitionTimingFunction);
        }
        if self.clone_translate() != other.clone_translate() {
            set.insert(LonghandId::Translate);
        }
        if self.clone_vertical_align() != other.clone_vertical_align() {
            set.insert(LonghandId::VerticalAlign);
        }
        if self.clone_view_transition_class() != other.clone_view_transition_class() {
            set.insert(LonghandId::ViewTransitionClass);
        }
        if self.clone_view_transition_name() != other.clone_view_transition_name() {
            set.insert(LonghandId::ViewTransitionName);
        }
        if self.clone_will_change() != other.clone_will_change() {
            set.insert(LonghandId::WillChange);
        }
        if self.clone_word_spacing() != other.clone_word_spacing() {
            set.insert(LonghandId::WordSpacing);
        }
        if self.clone__x_lang() != other.clone__x_lang() {
            set.insert(LonghandId::XLang);
        }
        if self.clone_object_position() != other.clone_object_position() {
            set.insert(LonghandId::ObjectPosition);
        }
        if self.clone_perspective_origin() != other.clone_perspective_origin() {
            set.insert(LonghandId::PerspectiveOrigin);
        }
        if self.clone_grid_template_columns() != other.clone_grid_template_columns() {
            set.insert(LonghandId::GridTemplateColumns);
        }
        if self.clone_grid_template_rows() != other.clone_grid_template_rows() {
            set.insert(LonghandId::GridTemplateRows);
        }
        if self.clone_border_image_source() != other.clone_border_image_source() {
            set.insert(LonghandId::BorderImageSource);
        }
        if self.clone_list_style_image() != other.clone_list_style_image() {
            set.insert(LonghandId::ListStyleImage);
        }
        if self.clone_grid_auto_columns() != other.clone_grid_auto_columns() {
            set.insert(LonghandId::GridAutoColumns);
        }
        if self.clone_grid_auto_rows() != other.clone_grid_auto_rows() {
            set.insert(LonghandId::GridAutoRows);
        }
        if self.clone_column_gap() != other.clone_column_gap() {
            set.insert(LonghandId::ColumnGap);
        }
        if self.clone_row_gap() != other.clone_row_gap() {
            set.insert(LonghandId::RowGap);
        }
        if self.clone_grid_column_end() != other.clone_grid_column_end() {
            set.insert(LonghandId::GridColumnEnd);
        }
        if self.clone_grid_column_start() != other.clone_grid_column_start() {
            set.insert(LonghandId::GridColumnStart);
        }
        if self.clone_grid_row_end() != other.clone_grid_row_end() {
            set.insert(LonghandId::GridRowEnd);
        }
        if self.clone_grid_row_start() != other.clone_grid_row_start() {
            set.insert(LonghandId::GridRowStart);
        }
        if self.clone_max_height() != other.clone_max_height() {
            set.insert(LonghandId::MaxHeight);
        }
        if self.clone_max_width() != other.clone_max_width() {
            set.insert(LonghandId::MaxWidth);
        }
        if self.clone_border_bottom_left_radius() != other.clone_border_bottom_left_radius() {
            set.insert(LonghandId::BorderBottomLeftRadius);
        }
        if self.clone_border_bottom_right_radius() != other.clone_border_bottom_right_radius() {
            set.insert(LonghandId::BorderBottomRightRadius);
        }
        if self.clone_border_top_left_radius() != other.clone_border_top_left_radius() {
            set.insert(LonghandId::BorderTopLeftRadius);
        }
        if self.clone_border_top_right_radius() != other.clone_border_top_right_radius() {
            set.insert(LonghandId::BorderTopRightRadius);
        }
        if self.clone_bottom() != other.clone_bottom() {
            set.insert(LonghandId::Bottom);
        }
        if self.clone_left() != other.clone_left() {
            set.insert(LonghandId::Left);
        }
        if self.clone_right() != other.clone_right() {
            set.insert(LonghandId::Right);
        }
        if self.clone_top() != other.clone_top() {
            set.insert(LonghandId::Top);
        }
        if self.clone_margin_bottom() != other.clone_margin_bottom() {
            set.insert(LonghandId::MarginBottom);
        }
        if self.clone_margin_left() != other.clone_margin_left() {
            set.insert(LonghandId::MarginLeft);
        }
        if self.clone_margin_right() != other.clone_margin_right() {
            set.insert(LonghandId::MarginRight);
        }
        if self.clone_margin_top() != other.clone_margin_top() {
            set.insert(LonghandId::MarginTop);
        }
        if self.clone_padding_bottom() != other.clone_padding_bottom() {
            set.insert(LonghandId::PaddingBottom);
        }
        if self.clone_padding_left() != other.clone_padding_left() {
            set.insert(LonghandId::PaddingLeft);
        }
        if self.clone_padding_right() != other.clone_padding_right() {
            set.insert(LonghandId::PaddingRight);
        }
        if self.clone_padding_top() != other.clone_padding_top() {
            set.insert(LonghandId::PaddingTop);
        }
        if self.clone_height() != other.clone_height() {
            set.insert(LonghandId::Height);
        }
        if self.clone_min_height() != other.clone_min_height() {
            set.insert(LonghandId::MinHeight);
        }
        if self.clone_min_width() != other.clone_min_width() {
            set.insert(LonghandId::MinWidth);
        }
        if self.clone_width() != other.clone_width() {
            set.insert(LonghandId::Width);
        }
        if self.clone_border_bottom_width() != other.clone_border_bottom_width() {
            set.insert(LonghandId::BorderBottomWidth);
        }
        if self.clone_border_left_width() != other.clone_border_left_width() {
            set.insert(LonghandId::BorderLeftWidth);
        }
        if self.clone_border_right_width() != other.clone_border_right_width() {
            set.insert(LonghandId::BorderRightWidth);
        }
        if self.clone_border_top_width() != other.clone_border_top_width() {
            set.insert(LonghandId::BorderTopWidth);
        }
        if self.clone_outline_width() != other.clone_outline_width() {
            set.insert(LonghandId::OutlineWidth);
        }
        if self.clone_background_color() != other.clone_background_color() {
            set.insert(LonghandId::BackgroundColor);
        }
        if self.clone_border_bottom_color() != other.clone_border_bottom_color() {
            set.insert(LonghandId::BorderBottomColor);
        }
        if self.clone_border_left_color() != other.clone_border_left_color() {
            set.insert(LonghandId::BorderLeftColor);
        }
        if self.clone_border_right_color() != other.clone_border_right_color() {
            set.insert(LonghandId::BorderRightColor);
        }
        if self.clone_border_top_color() != other.clone_border_top_color() {
            set.insert(LonghandId::BorderTopColor);
        }
        if self.clone_outline_color() != other.clone_outline_color() {
            set.insert(LonghandId::OutlineColor);
        }
        if self.clone_text_decoration_color() != other.clone_text_decoration_color() {
            set.insert(LonghandId::TextDecorationColor);
        }
        set
    }

    /// Create a `TransitionPropertyIterator` for this styles transition properties.
    pub fn transition_properties<'a>(
        &'a self
    ) -> animated_properties::TransitionPropertyIterator<'a> {
        animated_properties::TransitionPropertyIterator::from_style(self)
    }
}

#[cfg(feature = "servo")]
impl ComputedValues {
    /// Create a new refcounted `ComputedValues`
    pub fn new(
        pseudo: Option<&PseudoElement>,
        custom_properties: crate::custom_properties::ComputedCustomProperties,
        writing_mode: WritingMode,
        effective_zoom: computed::Zoom,
        flags: ComputedValueFlags,
        rules: Option<StrongRuleNode>,
        visited_style: Option<Arc<ComputedValues>>,
        background: Arc<style_structs::Background>,
        border: Arc<style_structs::Border>,
        box_: Arc<style_structs::Box>,
        column: Arc<style_structs::Column>,
        counters: Arc<style_structs::Counters>,
        effects: Arc<style_structs::Effects>,
        font: Arc<style_structs::Font>,
        inherited_box: Arc<style_structs::InheritedBox>,
        inherited_table: Arc<style_structs::InheritedTable>,
        inherited_text: Arc<style_structs::InheritedText>,
        inherited_ui: Arc<style_structs::InheritedUI>,
        list: Arc<style_structs::List>,
        margin: Arc<style_structs::Margin>,
        outline: Arc<style_structs::Outline>,
        padding: Arc<style_structs::Padding>,
        position: Arc<style_structs::Position>,
        svg: Arc<style_structs::SVG>,
        table: Arc<style_structs::Table>,
        text: Arc<style_structs::Text>,
        ui: Arc<style_structs::UI>,
    ) -> Arc<Self> {
        Arc::new(Self {
            inner: ComputedValuesInner {
                custom_properties,
                writing_mode,
                rules,
                visited_style,
                effective_zoom,
                flags,
                background,
                border,
                box_,
                column,
                counters,
                effects,
                font,
                inherited_box,
                inherited_table,
                inherited_text,
                inherited_ui,
                list,
                margin,
                outline,
                padding,
                position,
                svg,
                table,
                text,
                ui,
            },
            pseudo: pseudo.cloned(),
        })
    }

    /// Get the initial computed values.
    pub fn initial_values_with_font_override(default_font: super::style_structs::Font) -> Arc<Self> {
        use crate::computed_value_flags::ComputedValueFlags;
        use servo_arc::Arc;
        use super::{ComputedValues, ComputedValuesInner, longhands, style_structs};

        Arc::new(ComputedValues {
            inner: ComputedValuesInner {

                    background: Arc::new(style_structs::Background {
                                background_color: longhands::background_color::get_initial_value(),
                                background_image: longhands::background_image::get_initial_value(),
                                background_position_x: longhands::background_position_x::get_initial_value(),
                                background_position_y: longhands::background_position_y::get_initial_value(),
                                background_repeat: longhands::background_repeat::get_initial_value(),
                                background_attachment: longhands::background_attachment::get_initial_value(),
                                background_clip: longhands::background_clip::get_initial_value(),
                                background_origin: longhands::background_origin::get_initial_value(),
                                background_size: longhands::background_size::get_initial_value(),
                    }),

                    border: Arc::new(style_structs::Border {
                                border_top_color: longhands::border_top_color::get_initial_value(),
                                border_top_style: longhands::border_top_style::get_initial_value(),
                                border_top_width: longhands::border_top_width::get_initial_value(),
                                border_right_color: longhands::border_right_color::get_initial_value(),
                                border_right_style: longhands::border_right_style::get_initial_value(),
                                border_right_width: longhands::border_right_width::get_initial_value(),
                                border_bottom_color: longhands::border_bottom_color::get_initial_value(),
                                border_bottom_style: longhands::border_bottom_style::get_initial_value(),
                                border_bottom_width: longhands::border_bottom_width::get_initial_value(),
                                border_left_color: longhands::border_left_color::get_initial_value(),
                                border_left_style: longhands::border_left_style::get_initial_value(),
                                border_left_width: longhands::border_left_width::get_initial_value(),
                                border_top_left_radius: longhands::border_top_left_radius::get_initial_value(),
                                border_top_right_radius: longhands::border_top_right_radius::get_initial_value(),
                                border_bottom_right_radius: longhands::border_bottom_right_radius::get_initial_value(),
                                border_bottom_left_radius: longhands::border_bottom_left_radius::get_initial_value(),
                                border_image_source: longhands::border_image_source::get_initial_value(),
                                border_image_outset: longhands::border_image_outset::get_initial_value(),
                                border_image_repeat: longhands::border_image_repeat::get_initial_value(),
                                border_image_width: longhands::border_image_width::get_initial_value(),
                                border_image_slice: longhands::border_image_slice::get_initial_value(),
                    }),

                    box_: Arc::new(style_structs::Box {
                                display: longhands::display::get_initial_value(),
                                _servo_top_layer: longhands::_servo_top_layer::get_initial_value(),
                                position: longhands::position::get_initial_value(),
                                float: longhands::float::get_initial_value(),
                                clear: longhands::clear::get_initial_value(),
                                vertical_align: longhands::vertical_align::get_initial_value(),
                                baseline_source: longhands::baseline_source::get_initial_value(),
                                _servo_overflow_clip_box: longhands::_servo_overflow_clip_box::get_initial_value(),
                                overflow_y: longhands::overflow_y::get_initial_value(),
                                overflow_x: longhands::overflow_x::get_initial_value(),
                                transform: longhands::transform::get_initial_value(),
                                rotate: longhands::rotate::get_initial_value(),
                                scale: longhands::scale::get_initial_value(),
                                translate: longhands::translate::get_initial_value(),
                                offset_path: longhands::offset_path::get_initial_value(),
                                isolation: longhands::isolation::get_initial_value(),
                                perspective: longhands::perspective::get_initial_value(),
                                perspective_origin: longhands::perspective_origin::get_initial_value(),
                                backface_visibility: longhands::backface_visibility::get_initial_value(),
                                transform_style: longhands::transform_style::get_initial_value(),
                                transform_origin: longhands::transform_origin::get_initial_value(),
                                contain: longhands::contain::get_initial_value(),
                                container_type: longhands::container_type::get_initial_value(),
                                container_name: longhands::container_name::get_initial_value(),
                                will_change: longhands::will_change::get_initial_value(),
                                zoom: longhands::zoom::get_initial_value(),
                            original_display: longhands::display::get_initial_value(),
                    }),

                    column: Arc::new(style_structs::Column {
                                column_width: longhands::column_width::get_initial_value(),
                                column_count: longhands::column_count::get_initial_value(),
                                column_span: longhands::column_span::get_initial_value(),
                    }),

                    counters: Arc::new(style_structs::Counters {
                                content: longhands::content::get_initial_value(),
                                counter_increment: longhands::counter_increment::get_initial_value(),
                                counter_reset: longhands::counter_reset::get_initial_value(),
                    }),

                    effects: Arc::new(style_structs::Effects {
                                opacity: longhands::opacity::get_initial_value(),
                                box_shadow: longhands::box_shadow::get_initial_value(),
                                clip: longhands::clip::get_initial_value(),
                                filter: longhands::filter::get_initial_value(),
                                backdrop_filter: longhands::backdrop_filter::get_initial_value(),
                                mix_blend_mode: longhands::mix_blend_mode::get_initial_value(),
                    }),
                        font: Arc::new(default_font),
                    
                    inherited_box: Arc::new(style_structs::InheritedBox {
                                visibility: longhands::visibility::get_initial_value(),
                                writing_mode: longhands::writing_mode::get_initial_value(),
                                direction: longhands::direction::get_initial_value(),
                                image_rendering: longhands::image_rendering::get_initial_value(),
                    }),

                    inherited_table: Arc::new(style_structs::InheritedTable {
                                border_collapse: longhands::border_collapse::get_initial_value(),
                                empty_cells: longhands::empty_cells::get_initial_value(),
                                caption_side: longhands::caption_side::get_initial_value(),
                                border_spacing: longhands::border_spacing::get_initial_value(),
                    }),

                    inherited_text: Arc::new(style_structs::InheritedText {
                                color: longhands::color::get_initial_value(),
                                text_transform: longhands::text_transform::get_initial_value(),
                                text_indent: longhands::text_indent::get_initial_value(),
                                overflow_wrap: longhands::overflow_wrap::get_initial_value(),
                                word_break: longhands::word_break::get_initial_value(),
                                text_justify: longhands::text_justify::get_initial_value(),
                                text_align_last: longhands::text_align_last::get_initial_value(),
                                text_align: longhands::text_align::get_initial_value(),
                                letter_spacing: longhands::letter_spacing::get_initial_value(),
                                word_spacing: longhands::word_spacing::get_initial_value(),
                                white_space_collapse: longhands::white_space_collapse::get_initial_value(),
                                text_shadow: longhands::text_shadow::get_initial_value(),
                                text_rendering: longhands::text_rendering::get_initial_value(),
                                text_wrap_mode: longhands::text_wrap_mode::get_initial_value(),
                    }),

                    inherited_ui: Arc::new(style_structs::InheritedUI {
                                cursor: longhands::cursor::get_initial_value(),
                                pointer_events: longhands::pointer_events::get_initial_value(),
                                color_scheme: longhands::color_scheme::get_initial_value(),
                    }),

                    list: Arc::new(style_structs::List {
                                list_style_position: longhands::list_style_position::get_initial_value(),
                                list_style_type: longhands::list_style_type::get_initial_value(),
                                list_style_image: longhands::list_style_image::get_initial_value(),
                                quotes: longhands::quotes::get_initial_value(),
                    }),

                    margin: Arc::new(style_structs::Margin {
                                margin_top: longhands::margin_top::get_initial_value(),
                                margin_right: longhands::margin_right::get_initial_value(),
                                margin_bottom: longhands::margin_bottom::get_initial_value(),
                                margin_left: longhands::margin_left::get_initial_value(),
                                overflow_clip_margin: longhands::overflow_clip_margin::get_initial_value(),
                    }),

                    outline: Arc::new(style_structs::Outline {
                                outline_color: longhands::outline_color::get_initial_value(),
                                outline_style: longhands::outline_style::get_initial_value(),
                                outline_width: longhands::outline_width::get_initial_value(),
                                outline_offset: longhands::outline_offset::get_initial_value(),
                    }),

                    padding: Arc::new(style_structs::Padding {
                                padding_top: longhands::padding_top::get_initial_value(),
                                padding_right: longhands::padding_right::get_initial_value(),
                                padding_bottom: longhands::padding_bottom::get_initial_value(),
                                padding_left: longhands::padding_left::get_initial_value(),
                    }),

                    position: Arc::new(style_structs::Position {
                                top: longhands::top::get_initial_value(),
                                right: longhands::right::get_initial_value(),
                                bottom: longhands::bottom::get_initial_value(),
                                left: longhands::left::get_initial_value(),
                                z_index: longhands::z_index::get_initial_value(),
                                flex_direction: longhands::flex_direction::get_initial_value(),
                                flex_wrap: longhands::flex_wrap::get_initial_value(),
                                justify_content: longhands::justify_content::get_initial_value(),
                                align_content: longhands::align_content::get_initial_value(),
                                align_items: longhands::align_items::get_initial_value(),
                                justify_items: longhands::justify_items::get_initial_value(),
                                flex_grow: longhands::flex_grow::get_initial_value(),
                                flex_shrink: longhands::flex_shrink::get_initial_value(),
                                align_self: longhands::align_self::get_initial_value(),
                                justify_self: longhands::justify_self::get_initial_value(),
                                order: longhands::order::get_initial_value(),
                                flex_basis: longhands::flex_basis::get_initial_value(),
                                height: longhands::height::get_initial_value(),
                                min_height: longhands::min_height::get_initial_value(),
                                max_height: longhands::max_height::get_initial_value(),
                                width: longhands::width::get_initial_value(),
                                min_width: longhands::min_width::get_initial_value(),
                                max_width: longhands::max_width::get_initial_value(),
                                position_area: longhands::position_area::get_initial_value(),
                                box_sizing: longhands::box_sizing::get_initial_value(),
                                object_fit: longhands::object_fit::get_initial_value(),
                                object_position: longhands::object_position::get_initial_value(),
                                grid_row_start: longhands::grid_row_start::get_initial_value(),
                                grid_row_end: longhands::grid_row_end::get_initial_value(),
                                grid_auto_rows: longhands::grid_auto_rows::get_initial_value(),
                                grid_template_rows: longhands::grid_template_rows::get_initial_value(),
                                grid_column_start: longhands::grid_column_start::get_initial_value(),
                                grid_column_end: longhands::grid_column_end::get_initial_value(),
                                grid_auto_columns: longhands::grid_auto_columns::get_initial_value(),
                                grid_template_columns: longhands::grid_template_columns::get_initial_value(),
                                grid_auto_flow: longhands::grid_auto_flow::get_initial_value(),
                                grid_template_areas: longhands::grid_template_areas::get_initial_value(),
                                column_gap: longhands::column_gap::get_initial_value(),
                                row_gap: longhands::row_gap::get_initial_value(),
                                aspect_ratio: longhands::aspect_ratio::get_initial_value(),
                    }),

                    svg: Arc::new(style_structs::SVG {
                                clip_path: longhands::clip_path::get_initial_value(),
                                mask_image: longhands::mask_image::get_initial_value(),
                    }),

                    table: Arc::new(style_structs::Table {
                                table_layout: longhands::table_layout::get_initial_value(),
                    }),

                    text: Arc::new(style_structs::Text {
                                text_overflow: longhands::text_overflow::get_initial_value(),
                                unicode_bidi: longhands::unicode_bidi::get_initial_value(),
                                text_decoration_line: longhands::text_decoration_line::get_initial_value(),
                                text_decoration_style: longhands::text_decoration_style::get_initial_value(),
                                text_decoration_color: longhands::text_decoration_color::get_initial_value(),
                    }),

                    ui: Arc::new(style_structs::UI {
                                transition_duration: longhands::transition_duration::get_initial_value(),
                                transition_timing_function: longhands::transition_timing_function::get_initial_value(),
                                transition_property: longhands::transition_property::get_initial_value(),
                                transition_delay: longhands::transition_delay::get_initial_value(),
                                transition_behavior: longhands::transition_behavior::get_initial_value(),
                                animation_name: longhands::animation_name::get_initial_value(),
                                animation_duration: longhands::animation_duration::get_initial_value(),
                                animation_timing_function: longhands::animation_timing_function::get_initial_value(),
                                animation_iteration_count: longhands::animation_iteration_count::get_initial_value(),
                                animation_direction: longhands::animation_direction::get_initial_value(),
                                animation_play_state: longhands::animation_play_state::get_initial_value(),
                                animation_fill_mode: longhands::animation_fill_mode::get_initial_value(),
                                animation_composition: longhands::animation_composition::get_initial_value(),
                                animation_delay: longhands::animation_delay::get_initial_value(),
                                animation_timeline: longhands::animation_timeline::get_initial_value(),
                                view_transition_name: longhands::view_transition_name::get_initial_value(),
                                view_transition_class: longhands::view_transition_class::get_initial_value(),
                    }),
                custom_properties: crate::custom_properties::ComputedCustomProperties::default(),
                writing_mode: WritingMode::empty(),
                rules: None,
                visited_style: None,
                effective_zoom: crate::values::computed::Zoom::ONE,
                flags: ComputedValueFlags::empty(),
            },
            pseudo: None,
        })
    }

    /// Converts the computed values to an Arc<> from a reference.
    pub fn to_arc(&self) -> Arc<Self> {
        // SAFETY: We're guaranteed to be allocated as an Arc<> since the
        // functions above are the only ones that create ComputedValues
        // instances in Servo (and that must be the case since ComputedValues'
        // member is private).
        unsafe { Arc::from_raw_addrefed(self) }
    }

    /// Serializes the computed value of this property as a string.
    pub fn computed_value_to_string(&self, property: PropertyDeclarationId) -> String {
        match property {
            PropertyDeclarationId::Longhand(id) => {
                let context = resolved::Context {
                    style: self,
                    for_property: id.into(),
                };
                let mut s = String::new();
                self.computed_or_resolved_value(
                    id,
                    Some(&context),
                    &mut s
                ).unwrap();
                s
            }
            PropertyDeclarationId::Custom(name) => {
                // FIXME(bug 1869476): This should use a stylist to determine
                // whether the name corresponds to an inherited custom property
                // and then choose the inherited/non_inherited map accordingly.
                let p = &self.custom_properties;
                let value = p
                    .inherited
                    .get(name)
                    .or_else(|| p.non_inherited.get(name));
                value.map_or(String::new(), |value| value.to_css_string())
            }
        }
    }
}

#[cfg(feature = "servo")]
impl ops::Deref for ComputedValues {
    type Target = ComputedValuesInner;
    fn deref(&self) -> &ComputedValuesInner {
        &self.inner
    }
}

#[cfg(feature = "servo")]
impl ops::DerefMut for ComputedValues {
    fn deref_mut(&mut self) -> &mut ComputedValuesInner {
        &mut self.inner
    }
}

#[cfg(feature = "servo")]
impl ComputedValuesInner {
    /// Returns the visited style, if any.
    pub fn visited_style(&self) -> Option<&ComputedValues> {
        self.visited_style.as_deref()
    }

        /// Clone the Background struct.
        #[inline]
        pub fn clone_background(&self) -> Arc<style_structs::Background> {
            self.background.clone()
        }

        /// Get a immutable reference to the Background struct.
        #[inline]
        pub fn get_background(&self) -> &style_structs::Background {
            &self.background
        }

        /// Get a mutable reference to the Background struct.
        #[inline]
        pub fn mutate_background(&mut self) -> &mut style_structs::Background {
            Arc::make_mut(&mut self.background)
        }
        /// Clone the Border struct.
        #[inline]
        pub fn clone_border(&self) -> Arc<style_structs::Border> {
            self.border.clone()
        }

        /// Get a immutable reference to the Border struct.
        #[inline]
        pub fn get_border(&self) -> &style_structs::Border {
            &self.border
        }

        /// Get a mutable reference to the Border struct.
        #[inline]
        pub fn mutate_border(&mut self) -> &mut style_structs::Border {
            Arc::make_mut(&mut self.border)
        }
        /// Clone the Box struct.
        #[inline]
        pub fn clone_box(&self) -> Arc<style_structs::Box> {
            self.box_.clone()
        }

        /// Get a immutable reference to the Box struct.
        #[inline]
        pub fn get_box(&self) -> &style_structs::Box {
            &self.box_
        }

        /// Get a mutable reference to the Box struct.
        #[inline]
        pub fn mutate_box(&mut self) -> &mut style_structs::Box {
            Arc::make_mut(&mut self.box_)
        }
        /// Clone the Column struct.
        #[inline]
        pub fn clone_column(&self) -> Arc<style_structs::Column> {
            self.column.clone()
        }

        /// Get a immutable reference to the Column struct.
        #[inline]
        pub fn get_column(&self) -> &style_structs::Column {
            &self.column
        }

        /// Get a mutable reference to the Column struct.
        #[inline]
        pub fn mutate_column(&mut self) -> &mut style_structs::Column {
            Arc::make_mut(&mut self.column)
        }
        /// Clone the Counters struct.
        #[inline]
        pub fn clone_counters(&self) -> Arc<style_structs::Counters> {
            self.counters.clone()
        }

        /// Get a immutable reference to the Counters struct.
        #[inline]
        pub fn get_counters(&self) -> &style_structs::Counters {
            &self.counters
        }

        /// Get a mutable reference to the Counters struct.
        #[inline]
        pub fn mutate_counters(&mut self) -> &mut style_structs::Counters {
            Arc::make_mut(&mut self.counters)
        }
        /// Clone the Effects struct.
        #[inline]
        pub fn clone_effects(&self) -> Arc<style_structs::Effects> {
            self.effects.clone()
        }

        /// Get a immutable reference to the Effects struct.
        #[inline]
        pub fn get_effects(&self) -> &style_structs::Effects {
            &self.effects
        }

        /// Get a mutable reference to the Effects struct.
        #[inline]
        pub fn mutate_effects(&mut self) -> &mut style_structs::Effects {
            Arc::make_mut(&mut self.effects)
        }
        /// Clone the Font struct.
        #[inline]
        pub fn clone_font(&self) -> Arc<style_structs::Font> {
            self.font.clone()
        }

        /// Get a immutable reference to the Font struct.
        #[inline]
        pub fn get_font(&self) -> &style_structs::Font {
            &self.font
        }

        /// Get a mutable reference to the Font struct.
        #[inline]
        pub fn mutate_font(&mut self) -> &mut style_structs::Font {
            Arc::make_mut(&mut self.font)
        }
        /// Clone the InheritedBox struct.
        #[inline]
        pub fn clone_inherited_box(&self) -> Arc<style_structs::InheritedBox> {
            self.inherited_box.clone()
        }

        /// Get a immutable reference to the InheritedBox struct.
        #[inline]
        pub fn get_inherited_box(&self) -> &style_structs::InheritedBox {
            &self.inherited_box
        }

        /// Get a mutable reference to the InheritedBox struct.
        #[inline]
        pub fn mutate_inherited_box(&mut self) -> &mut style_structs::InheritedBox {
            Arc::make_mut(&mut self.inherited_box)
        }
        /// Clone the InheritedTable struct.
        #[inline]
        pub fn clone_inherited_table(&self) -> Arc<style_structs::InheritedTable> {
            self.inherited_table.clone()
        }

        /// Get a immutable reference to the InheritedTable struct.
        #[inline]
        pub fn get_inherited_table(&self) -> &style_structs::InheritedTable {
            &self.inherited_table
        }

        /// Get a mutable reference to the InheritedTable struct.
        #[inline]
        pub fn mutate_inherited_table(&mut self) -> &mut style_structs::InheritedTable {
            Arc::make_mut(&mut self.inherited_table)
        }
        /// Clone the InheritedText struct.
        #[inline]
        pub fn clone_inherited_text(&self) -> Arc<style_structs::InheritedText> {
            self.inherited_text.clone()
        }

        /// Get a immutable reference to the InheritedText struct.
        #[inline]
        pub fn get_inherited_text(&self) -> &style_structs::InheritedText {
            &self.inherited_text
        }

        /// Get a mutable reference to the InheritedText struct.
        #[inline]
        pub fn mutate_inherited_text(&mut self) -> &mut style_structs::InheritedText {
            Arc::make_mut(&mut self.inherited_text)
        }
        /// Clone the InheritedUI struct.
        #[inline]
        pub fn clone_inherited_ui(&self) -> Arc<style_structs::InheritedUI> {
            self.inherited_ui.clone()
        }

        /// Get a immutable reference to the InheritedUI struct.
        #[inline]
        pub fn get_inherited_ui(&self) -> &style_structs::InheritedUI {
            &self.inherited_ui
        }

        /// Get a mutable reference to the InheritedUI struct.
        #[inline]
        pub fn mutate_inherited_ui(&mut self) -> &mut style_structs::InheritedUI {
            Arc::make_mut(&mut self.inherited_ui)
        }
        /// Clone the List struct.
        #[inline]
        pub fn clone_list(&self) -> Arc<style_structs::List> {
            self.list.clone()
        }

        /// Get a immutable reference to the List struct.
        #[inline]
        pub fn get_list(&self) -> &style_structs::List {
            &self.list
        }

        /// Get a mutable reference to the List struct.
        #[inline]
        pub fn mutate_list(&mut self) -> &mut style_structs::List {
            Arc::make_mut(&mut self.list)
        }
        /// Clone the Margin struct.
        #[inline]
        pub fn clone_margin(&self) -> Arc<style_structs::Margin> {
            self.margin.clone()
        }

        /// Get a immutable reference to the Margin struct.
        #[inline]
        pub fn get_margin(&self) -> &style_structs::Margin {
            &self.margin
        }

        /// Get a mutable reference to the Margin struct.
        #[inline]
        pub fn mutate_margin(&mut self) -> &mut style_structs::Margin {
            Arc::make_mut(&mut self.margin)
        }
        /// Clone the Outline struct.
        #[inline]
        pub fn clone_outline(&self) -> Arc<style_structs::Outline> {
            self.outline.clone()
        }

        /// Get a immutable reference to the Outline struct.
        #[inline]
        pub fn get_outline(&self) -> &style_structs::Outline {
            &self.outline
        }

        /// Get a mutable reference to the Outline struct.
        #[inline]
        pub fn mutate_outline(&mut self) -> &mut style_structs::Outline {
            Arc::make_mut(&mut self.outline)
        }
        /// Clone the Padding struct.
        #[inline]
        pub fn clone_padding(&self) -> Arc<style_structs::Padding> {
            self.padding.clone()
        }

        /// Get a immutable reference to the Padding struct.
        #[inline]
        pub fn get_padding(&self) -> &style_structs::Padding {
            &self.padding
        }

        /// Get a mutable reference to the Padding struct.
        #[inline]
        pub fn mutate_padding(&mut self) -> &mut style_structs::Padding {
            Arc::make_mut(&mut self.padding)
        }
        /// Clone the Position struct.
        #[inline]
        pub fn clone_position(&self) -> Arc<style_structs::Position> {
            self.position.clone()
        }

        /// Get a immutable reference to the Position struct.
        #[inline]
        pub fn get_position(&self) -> &style_structs::Position {
            &self.position
        }

        /// Get a mutable reference to the Position struct.
        #[inline]
        pub fn mutate_position(&mut self) -> &mut style_structs::Position {
            Arc::make_mut(&mut self.position)
        }
        /// Clone the SVG struct.
        #[inline]
        pub fn clone_svg(&self) -> Arc<style_structs::SVG> {
            self.svg.clone()
        }

        /// Get a immutable reference to the SVG struct.
        #[inline]
        pub fn get_svg(&self) -> &style_structs::SVG {
            &self.svg
        }

        /// Get a mutable reference to the SVG struct.
        #[inline]
        pub fn mutate_svg(&mut self) -> &mut style_structs::SVG {
            Arc::make_mut(&mut self.svg)
        }
        /// Clone the Table struct.
        #[inline]
        pub fn clone_table(&self) -> Arc<style_structs::Table> {
            self.table.clone()
        }

        /// Get a immutable reference to the Table struct.
        #[inline]
        pub fn get_table(&self) -> &style_structs::Table {
            &self.table
        }

        /// Get a mutable reference to the Table struct.
        #[inline]
        pub fn mutate_table(&mut self) -> &mut style_structs::Table {
            Arc::make_mut(&mut self.table)
        }
        /// Clone the Text struct.
        #[inline]
        pub fn clone_text(&self) -> Arc<style_structs::Text> {
            self.text.clone()
        }

        /// Get a immutable reference to the Text struct.
        #[inline]
        pub fn get_text(&self) -> &style_structs::Text {
            &self.text
        }

        /// Get a mutable reference to the Text struct.
        #[inline]
        pub fn mutate_text(&mut self) -> &mut style_structs::Text {
            Arc::make_mut(&mut self.text)
        }
        /// Clone the UI struct.
        #[inline]
        pub fn clone_ui(&self) -> Arc<style_structs::UI> {
            self.ui.clone()
        }

        /// Get a immutable reference to the UI struct.
        #[inline]
        pub fn get_ui(&self) -> &style_structs::UI {
            &self.ui
        }

        /// Get a mutable reference to the UI struct.
        #[inline]
        pub fn mutate_ui(&mut self) -> &mut style_structs::UI {
            Arc::make_mut(&mut self.ui)
        }

    /// Gets a reference to the rule node. Panic if no rule node exists.
    pub fn rules(&self) -> &StrongRuleNode {
        self.rules.as_ref().unwrap()
    }

    #[inline]
    /// Returns whether the "content" property for the given style is completely
    /// ineffective, and would yield an empty `::before` or `::after`
    /// pseudo-element.
    pub fn ineffective_content_property(&self) -> bool {
        use crate::values::generics::counters::Content;
        match self.get_counters().content {
            Content::Normal | Content::None => true,
            Content::Items(ref items) => items.items.is_empty()
        }
    }

    /// Whether the current style or any of its ancestors is multicolumn.
    #[inline]
    pub fn can_be_fragmented(&self) -> bool {
        self.flags.contains(ComputedValueFlags::CAN_BE_FRAGMENTED)
    }

    /// Whether the current style is multicolumn.
    #[inline]
    pub fn is_multicol(&self) -> bool {
        self.get_column().is_multicol()
    }

    /// Get the logical computed inline size.
    #[inline]
    pub fn content_inline_size(&self) -> &computed::Size {
        let position_style = self.get_position();
        if self.writing_mode.is_vertical() {
            &position_style.height
        } else {
            &position_style.width
        }
    }

    /// Get the logical computed block size.
    #[inline]
    pub fn content_block_size(&self) -> &computed::Size {
        let position_style = self.get_position();
        if self.writing_mode.is_vertical() { &position_style.width } else { &position_style.height }
    }

    /// Get the logical computed min inline size.
    #[inline]
    pub fn min_inline_size(&self) -> &computed::Size {
        let position_style = self.get_position();
        if self.writing_mode.is_vertical() { &position_style.min_height } else { &position_style.min_width }
    }

    /// Get the logical computed min block size.
    #[inline]
    pub fn min_block_size(&self) -> &computed::Size {
        let position_style = self.get_position();
        if self.writing_mode.is_vertical() { &position_style.min_width } else { &position_style.min_height }
    }

    /// Get the logical computed max inline size.
    #[inline]
    pub fn max_inline_size(&self) -> &computed::MaxSize {
        let position_style = self.get_position();
        if self.writing_mode.is_vertical() { &position_style.max_height } else { &position_style.max_width }
    }

    /// Get the logical computed max block size.
    #[inline]
    pub fn max_block_size(&self) -> &computed::MaxSize {
        let position_style = self.get_position();
        if self.writing_mode.is_vertical() { &position_style.max_width } else { &position_style.max_height }
    }

    /// Get the logical computed padding for this writing mode.
    #[inline]
    pub fn logical_padding(&self) -> LogicalMargin<&computed::LengthPercentage> {
        let padding_style = self.get_padding();
        LogicalMargin::from_physical(self.writing_mode, SideOffsets2D::new(
            &padding_style.padding_top.0,
            &padding_style.padding_right.0,
            &padding_style.padding_bottom.0,
            &padding_style.padding_left.0,
        ))
    }

    /// Get the logical border width
    #[inline]
    pub fn border_width_for_writing_mode(&self, writing_mode: WritingMode) -> LogicalMargin<Au> {
        let border_style = self.get_border();
        LogicalMargin::from_physical(writing_mode, SideOffsets2D::new(
            Au::from(border_style.border_top_width),
            Au::from(border_style.border_right_width),
            Au::from(border_style.border_bottom_width),
            Au::from(border_style.border_left_width),
        ))
    }

    /// Gets the logical computed border widths for this style.
    #[inline]
    pub fn logical_border_width(&self) -> LogicalMargin<Au> {
        self.border_width_for_writing_mode(self.writing_mode)
    }

    /// Gets the logical computed margin from this style.
    #[inline]
    pub fn logical_margin(&self) -> LogicalMargin<&computed::Margin> {
        let margin_style = self.get_margin();
        LogicalMargin::from_physical(self.writing_mode, SideOffsets2D::new(
            &margin_style.margin_top,
            &margin_style.margin_right,
            &margin_style.margin_bottom,
            &margin_style.margin_left,
        ))
    }

    /// Gets the logical position from this style.
    #[inline]
    pub fn logical_position(&self) -> LogicalMargin<&computed::Inset> {
        // FIXME(SimonSapin): should be the writing mode of the containing block, maybe?
        let position_style = self.get_position();
        LogicalMargin::from_physical(self.writing_mode, SideOffsets2D::new(
            &position_style.top,
            &position_style.right,
            &position_style.bottom,
            &position_style.left,
        ))
    }

    /// Return true if the effects force the transform style to be Flat
    pub fn overrides_transform_style(&self) -> bool {
        use crate::computed_values::mix_blend_mode::T as MixBlendMode;

        let effects = self.get_effects();
        // TODO(gw): Add clip-path, isolation, mask-image, mask-border-source when supported.
        effects.opacity < 1.0 ||
           !effects.filter.0.is_empty() ||
           !effects.clip.is_auto() ||
           effects.mix_blend_mode != MixBlendMode::Normal
    }

    /// <https://drafts.csswg.org/css-transforms/#grouping-property-values>
    pub fn get_used_transform_style(&self) -> computed_values::transform_style::T {
        use crate::computed_values::transform_style::T as TransformStyle;

        let box_ = self.get_box();

        if self.overrides_transform_style() {
            TransformStyle::Flat
        } else {
            // Return the computed value if not overridden by the above exceptions
            box_.transform_style
        }
    }
}

/// A reference to a style struct of the parent, or our own style struct.
pub enum StyleStructRef<'a, T: 'static> {
    /// A borrowed struct from the parent, for example, for inheriting style.
    Borrowed(&'a T),
    /// An owned struct, that we've already mutated.
    Owned(UniqueArc<T>),
    /// Temporarily vacated, will panic if accessed
    Vacated,
}

impl<'a, T: 'a> StyleStructRef<'a, T>
where
    T: Clone,
{
    /// Ensure a mutable reference of this value exists, either cloning the
    /// borrowed value, or returning the owned one.
    pub fn mutate(&mut self) -> &mut T {
        if let StyleStructRef::Borrowed(v) = *self {
            *self = StyleStructRef::Owned(UniqueArc::new(v.clone()));
        }

        match *self {
            StyleStructRef::Owned(ref mut v) => v,
            StyleStructRef::Borrowed(..) => unreachable!(),
            StyleStructRef::Vacated => panic!("Accessed vacated style struct")
        }
    }

    /// Whether this is pointer-equal to the struct we're going to copy the
    /// value from.
    ///
    /// This is used to avoid allocations when people write stuff like `font:
    /// inherit` or such `all: initial`.
    #[inline]
    pub fn ptr_eq(&self, struct_to_copy_from: &T) -> bool {
        match *self {
            StyleStructRef::Owned(..) => false,
            StyleStructRef::Borrowed(s) => {
                s as *const T == struct_to_copy_from as *const T
            }
            StyleStructRef::Vacated => panic!("Accessed vacated style struct")
        }
    }

    /// Extract a unique Arc from this struct, vacating it.
    ///
    /// The vacated state is a transient one, please put the Arc back
    /// when done via `put()`. This function is to be used to separate
    /// the struct being mutated from the computed context
    pub fn take(&mut self) -> UniqueArc<T> {
        use std::mem::replace;
        let inner = replace(self, StyleStructRef::Vacated);

        match inner {
            StyleStructRef::Owned(arc) => arc,
            StyleStructRef::Borrowed(s) => UniqueArc::new(s.clone()),
            StyleStructRef::Vacated => panic!("Accessed vacated style struct"),
        }
    }

    /// Replace vacated ref with an arc
    pub fn put(&mut self, arc: UniqueArc<T>) {
        debug_assert!(matches!(*self, StyleStructRef::Vacated));
        *self = StyleStructRef::Owned(arc);
    }

    /// Get a mutable reference to the owned struct, or `None` if the struct
    /// hasn't been mutated.
    pub fn get_if_mutated(&mut self) -> Option<&mut T> {
        match *self {
            StyleStructRef::Owned(ref mut v) => Some(v),
            StyleStructRef::Borrowed(..) => None,
            StyleStructRef::Vacated => panic!("Accessed vacated style struct")
        }
    }

    /// Returns an `Arc` to the internal struct, constructing one if
    /// appropriate.
    pub fn build(self) -> Arc<T> {
        match self {
            StyleStructRef::Owned(v) => v.shareable(),
            // SAFETY: We know all style structs are arc-allocated.
            StyleStructRef::Borrowed(v) => unsafe { Arc::from_raw_addrefed(v) },
            StyleStructRef::Vacated => panic!("Accessed vacated style struct")
        }
    }
}

impl<'a, T: 'a> ops::Deref for StyleStructRef<'a, T> {
    type Target = T;

    fn deref(&self) -> &T {
        match *self {
            StyleStructRef::Owned(ref v) => &**v,
            StyleStructRef::Borrowed(v) => v,
            StyleStructRef::Vacated => panic!("Accessed vacated style struct")
        }
    }
}

/// A type used to compute a struct with minimal overhead.
///
/// This allows holding references to the parent/default computed values without
/// actually cloning them, until we either build the style, or mutate the
/// inherited value.
pub struct StyleBuilder<'a> {
    /// The device we're using to compute style.
    ///
    /// This provides access to viewport unit ratios, etc.
    pub device: &'a Device,

    /// The stylist we're using to compute style except for media queries.
    /// device is used in media queries instead.
    pub stylist: Option<&'a Stylist>,

    /// The style we're inheriting from.
    ///
    /// This is effectively
    /// `parent_style.unwrap_or(device.default_computed_values())`.
    inherited_style: &'a ComputedValues,

    /// The style we're getting reset structs from.
    reset_style: &'a ComputedValues,

    /// The rule node representing the ordered list of rules matched for this
    /// node.
    pub rules: Option<StrongRuleNode>,

    /// The computed custom properties.
    pub custom_properties: crate::custom_properties::ComputedCustomProperties,

    /// Non-custom properties that are considered invalid at compute time
    /// due to cyclic dependencies with custom properties.
    /// e.g. `--foo: 1em; font-size: var(--foo)` where `--foo` is registered.
    pub invalid_non_custom_properties: LonghandIdSet,

    /// The pseudo-element this style will represent.
    pub pseudo: Option<&'a PseudoElement>,

    /// Whether we have mutated any reset structs since the the last time
    /// `clear_modified_reset` was called.  This is used to tell whether the
    /// `StyleAdjuster` did any work.
    modified_reset: bool,

    /// Whether this is the style for the root element.
    pub is_root_element: bool,

    /// The writing mode flags.
    ///
    /// TODO(emilio): Make private.
    pub writing_mode: WritingMode,

    /// The color-scheme bits. Needed because they may otherwise be different between visited and
    /// unvisited colors.
    pub color_scheme: ColorSchemeFlags,

    /// The effective zoom.
    pub effective_zoom: computed::Zoom,

    /// The effective zoom for inheritance (the "specified" zoom on this element).
    pub effective_zoom_for_inheritance: computed::Zoom,

    /// Flags for the computed value.
    pub flags: Cell<ComputedValueFlags>,

    /// The element's style if visited, only computed if there's a relevant link
    /// for this element.  A element's "relevant link" is the element being
    /// matched if it is a link or the nearest ancestor link.
    pub visited_style: Option<Arc<ComputedValues>>,
        background: StyleStructRef<'a, style_structs::Background>,
        border: StyleStructRef<'a, style_structs::Border>,
        box_: StyleStructRef<'a, style_structs::Box>,
        column: StyleStructRef<'a, style_structs::Column>,
        counters: StyleStructRef<'a, style_structs::Counters>,
        effects: StyleStructRef<'a, style_structs::Effects>,
        font: StyleStructRef<'a, style_structs::Font>,
        inherited_box: StyleStructRef<'a, style_structs::InheritedBox>,
        inherited_table: StyleStructRef<'a, style_structs::InheritedTable>,
        inherited_text: StyleStructRef<'a, style_structs::InheritedText>,
        inherited_ui: StyleStructRef<'a, style_structs::InheritedUI>,
        list: StyleStructRef<'a, style_structs::List>,
        margin: StyleStructRef<'a, style_structs::Margin>,
        outline: StyleStructRef<'a, style_structs::Outline>,
        padding: StyleStructRef<'a, style_structs::Padding>,
        position: StyleStructRef<'a, style_structs::Position>,
        svg: StyleStructRef<'a, style_structs::SVG>,
        table: StyleStructRef<'a, style_structs::Table>,
        text: StyleStructRef<'a, style_structs::Text>,
        ui: StyleStructRef<'a, style_structs::UI>,
}

impl<'a> StyleBuilder<'a> {
    /// Trivially construct a `StyleBuilder`.
    pub fn new(
        device: &'a Device,
        stylist: Option<&'a Stylist>,
        parent_style: Option<&'a ComputedValues>,
        pseudo: Option<&'a PseudoElement>,
        rules: Option<StrongRuleNode>,
        is_root_element: bool,
    ) -> Self {
        let reset_style = device.default_computed_values();
        let inherited_style = parent_style.unwrap_or(reset_style);

        let flags = inherited_style.flags.inherited();
        Self {
            device,
            stylist,
            inherited_style,
            reset_style,
            pseudo,
            rules,
            modified_reset: false,
            is_root_element,
            custom_properties: crate::custom_properties::ComputedCustomProperties::default(),
            invalid_non_custom_properties: LonghandIdSet::default(),
            writing_mode: inherited_style.writing_mode,
            effective_zoom: inherited_style.effective_zoom,
            effective_zoom_for_inheritance: computed::Zoom::ONE,
            color_scheme: inherited_style.get_inherited_ui().color_scheme_bits(),
            flags: Cell::new(flags),
            visited_style: None,
            background: StyleStructRef::Borrowed(reset_style.get_background()),
            border: StyleStructRef::Borrowed(reset_style.get_border()),
            box_: StyleStructRef::Borrowed(reset_style.get_box()),
            column: StyleStructRef::Borrowed(reset_style.get_column()),
            counters: StyleStructRef::Borrowed(reset_style.get_counters()),
            effects: StyleStructRef::Borrowed(reset_style.get_effects()),
            font: StyleStructRef::Borrowed(inherited_style.get_font()),
            inherited_box: StyleStructRef::Borrowed(inherited_style.get_inherited_box()),
            inherited_table: StyleStructRef::Borrowed(inherited_style.get_inherited_table()),
            inherited_text: StyleStructRef::Borrowed(inherited_style.get_inherited_text()),
            inherited_ui: StyleStructRef::Borrowed(inherited_style.get_inherited_ui()),
            list: StyleStructRef::Borrowed(inherited_style.get_list()),
            margin: StyleStructRef::Borrowed(reset_style.get_margin()),
            outline: StyleStructRef::Borrowed(reset_style.get_outline()),
            padding: StyleStructRef::Borrowed(reset_style.get_padding()),
            position: StyleStructRef::Borrowed(reset_style.get_position()),
            svg: StyleStructRef::Borrowed(reset_style.get_svg()),
            table: StyleStructRef::Borrowed(reset_style.get_table()),
            text: StyleStructRef::Borrowed(reset_style.get_text()),
            ui: StyleStructRef::Borrowed(reset_style.get_ui()),
        }
    }

    /// NOTE(emilio): This is done so we can compute relative units with respect
    /// to the parent style, but all the early properties / writing-mode / etc
    /// are already set to the right ones on the kid.
    ///
    /// Do _not_ actually call this to construct a style, this should mostly be
    /// used for animations.
    pub fn for_animation(
        device: &'a Device,
        stylist: Option<&'a Stylist>,
        style_to_derive_from: &'a ComputedValues,
        parent_style: Option<&'a ComputedValues>,
    ) -> Self {
        let reset_style = device.default_computed_values();
        let inherited_style = parent_style.unwrap_or(reset_style);
        Self {
            device,
            stylist,
            inherited_style,
            reset_style,
            pseudo: None,
            modified_reset: false,
            is_root_element: false,
            rules: None,
            custom_properties: style_to_derive_from.custom_properties().clone(),
            invalid_non_custom_properties: LonghandIdSet::default(),
            writing_mode: style_to_derive_from.writing_mode,
            effective_zoom: style_to_derive_from.effective_zoom,
            effective_zoom_for_inheritance: Self::zoom_for_inheritance(style_to_derive_from.get_box().clone_zoom(), inherited_style),
            color_scheme: style_to_derive_from.get_inherited_ui().color_scheme_bits(),
            flags: Cell::new(style_to_derive_from.flags),
            visited_style: None,
            background: StyleStructRef::Borrowed(
                style_to_derive_from.get_background()
            ),
            border: StyleStructRef::Borrowed(
                style_to_derive_from.get_border()
            ),
            box_: StyleStructRef::Borrowed(
                style_to_derive_from.get_box()
            ),
            column: StyleStructRef::Borrowed(
                style_to_derive_from.get_column()
            ),
            counters: StyleStructRef::Borrowed(
                style_to_derive_from.get_counters()
            ),
            effects: StyleStructRef::Borrowed(
                style_to_derive_from.get_effects()
            ),
            font: StyleStructRef::Borrowed(
                style_to_derive_from.get_font()
            ),
            inherited_box: StyleStructRef::Borrowed(
                style_to_derive_from.get_inherited_box()
            ),
            inherited_table: StyleStructRef::Borrowed(
                style_to_derive_from.get_inherited_table()
            ),
            inherited_text: StyleStructRef::Borrowed(
                style_to_derive_from.get_inherited_text()
            ),
            inherited_ui: StyleStructRef::Borrowed(
                style_to_derive_from.get_inherited_ui()
            ),
            list: StyleStructRef::Borrowed(
                style_to_derive_from.get_list()
            ),
            margin: StyleStructRef::Borrowed(
                style_to_derive_from.get_margin()
            ),
            outline: StyleStructRef::Borrowed(
                style_to_derive_from.get_outline()
            ),
            padding: StyleStructRef::Borrowed(
                style_to_derive_from.get_padding()
            ),
            position: StyleStructRef::Borrowed(
                style_to_derive_from.get_position()
            ),
            svg: StyleStructRef::Borrowed(
                style_to_derive_from.get_svg()
            ),
            table: StyleStructRef::Borrowed(
                style_to_derive_from.get_table()
            ),
            text: StyleStructRef::Borrowed(
                style_to_derive_from.get_text()
            ),
            ui: StyleStructRef::Borrowed(
                style_to_derive_from.get_ui()
            ),
        }
    }

    /// Copy the reset properties from `style`.
    pub fn copy_reset_from(&mut self, style: &'a ComputedValues) {
        self.background =
            StyleStructRef::Borrowed(style.get_background());
        self.border =
            StyleStructRef::Borrowed(style.get_border());
        self.box_ =
            StyleStructRef::Borrowed(style.get_box());
        self.column =
            StyleStructRef::Borrowed(style.get_column());
        self.counters =
            StyleStructRef::Borrowed(style.get_counters());
        self.effects =
            StyleStructRef::Borrowed(style.get_effects());
        self.margin =
            StyleStructRef::Borrowed(style.get_margin());
        self.outline =
            StyleStructRef::Borrowed(style.get_outline());
        self.padding =
            StyleStructRef::Borrowed(style.get_padding());
        self.position =
            StyleStructRef::Borrowed(style.get_position());
        self.svg =
            StyleStructRef::Borrowed(style.get_svg());
        self.table =
            StyleStructRef::Borrowed(style.get_table());
        self.text =
            StyleStructRef::Borrowed(style.get_text());
        self.ui =
            StyleStructRef::Borrowed(style.get_ui());
    }

    /// Inherit `align_items` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_align_items(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_align_items_from(inherited_struct);
    }

    /// Set the `align_items` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_align_items(
        &mut self,
        value: longhands::align_items::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_align_items(
                value,
            );
    }
    /// Inherit `aspect_ratio` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_aspect_ratio(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_aspect_ratio_from(inherited_struct);
    }

    /// Set the `aspect_ratio` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_aspect_ratio(
        &mut self,
        value: longhands::aspect_ratio::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_aspect_ratio(
                value,
            );
    }
    /// Inherit `backface_visibility` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_backface_visibility(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_backface_visibility_from(inherited_struct);
    }

    /// Set the `backface_visibility` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_backface_visibility(
        &mut self,
        value: longhands::backface_visibility::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_backface_visibility(
                value,
            );
    }
    /// Inherit `baseline_source` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_baseline_source(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_baseline_source_from(inherited_struct);
    }

    /// Set the `baseline_source` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_baseline_source(
        &mut self,
        value: longhands::baseline_source::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_baseline_source(
                value,
            );
    }
    /// Reset `border_collapse` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_border_collapse(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_table();

        if self.inherited_table.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_table.mutate()
            .reset_border_collapse(reset_struct);
    }

    /// Set the `border_collapse` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_collapse(
        &mut self,
        value: longhands::border_collapse::computed_value::T
    ) {

        self.inherited_table.mutate()
            .set_border_collapse(
                value,
            );
    }
    /// Inherit `border_image_repeat` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_image_repeat(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_image_repeat_from(inherited_struct);
    }

    /// Set the `border_image_repeat` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_image_repeat(
        &mut self,
        value: longhands::border_image_repeat::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_image_repeat(
                value,
            );
    }
    /// Inherit `box_sizing` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_box_sizing(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_box_sizing_from(inherited_struct);
    }

    /// Set the `box_sizing` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_box_sizing(
        &mut self,
        value: longhands::box_sizing::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_box_sizing(
                value,
            );
    }
    /// Reset `caption_side` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_caption_side(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_table();

        if self.inherited_table.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_table.mutate()
            .reset_caption_side(reset_struct);
    }

    /// Set the `caption_side` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_caption_side(
        &mut self,
        value: longhands::caption_side::computed_value::T
    ) {

        self.inherited_table.mutate()
            .set_caption_side(
                value,
            );
    }
    /// Inherit `clear` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_clear(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_clear_from(inherited_struct);
    }

    /// Set the `clear` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_clear(
        &mut self,
        value: longhands::clear::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_clear(
                value,
            );
    }
    /// Inherit `column_count` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_column_count(&mut self) {
        let inherited_struct =
            self.inherited_style.get_column();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.column.ptr_eq(inherited_struct) {
            return;
        }

        self.column.mutate()
            .copy_column_count_from(inherited_struct);
    }

    /// Set the `column_count` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_column_count(
        &mut self,
        value: longhands::column_count::computed_value::T
    ) {
        self.modified_reset = true;

        self.column.mutate()
            .set_column_count(
                value,
            );
    }
    /// Inherit `column_span` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_column_span(&mut self) {
        let inherited_struct =
            self.inherited_style.get_column();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.column.ptr_eq(inherited_struct) {
            return;
        }

        self.column.mutate()
            .copy_column_span_from(inherited_struct);
    }

    /// Set the `column_span` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_column_span(
        &mut self,
        value: longhands::column_span::computed_value::T
    ) {
        self.modified_reset = true;

        self.column.mutate()
            .set_column_span(
                value,
            );
    }
    /// Inherit `contain` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_contain(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_contain_from(inherited_struct);
    }

    /// Set the `contain` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_contain(
        &mut self,
        value: longhands::contain::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_contain(
                value,
            );
    }
    /// Inherit `container_type` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_container_type(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_container_type_from(inherited_struct);
    }

    /// Set the `container_type` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_container_type(
        &mut self,
        value: longhands::container_type::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_container_type(
                value,
            );
    }
    /// Reset `direction` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_direction(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_box();

        if self.inherited_box.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_box.mutate()
            .reset_direction(reset_struct);
    }

    /// Set the `direction` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_direction(
        &mut self,
        value: longhands::direction::computed_value::T
    ) {

        self.inherited_box.mutate()
            .set_direction(
                value,
            );
    }
    /// Inherit `display` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_display(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);


        self.add_flags(ComputedValueFlags::DISPLAY_DEPENDS_ON_INHERITED_STYLE);

        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_display_from(inherited_struct);
    }

    /// Set the `display` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_display(
        &mut self,
        value: longhands::display::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_display(
                value,
            );
    }
    /// Reset `empty_cells` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_empty_cells(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_table();

        if self.inherited_table.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_table.mutate()
            .reset_empty_cells(reset_struct);
    }

    /// Set the `empty_cells` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_empty_cells(
        &mut self,
        value: longhands::empty_cells::computed_value::T
    ) {

        self.inherited_table.mutate()
            .set_empty_cells(
                value,
            );
    }
    /// Inherit `flex_direction` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_flex_direction(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_flex_direction_from(inherited_struct);
    }

    /// Set the `flex_direction` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_flex_direction(
        &mut self,
        value: longhands::flex_direction::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_flex_direction(
                value,
            );
    }
    /// Inherit `flex_wrap` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_flex_wrap(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_flex_wrap_from(inherited_struct);
    }

    /// Set the `flex_wrap` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_flex_wrap(
        &mut self,
        value: longhands::flex_wrap::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_flex_wrap(
                value,
            );
    }
    /// Inherit `float` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_float(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_float_from(inherited_struct);
    }

    /// Set the `float` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_float(
        &mut self,
        value: longhands::float::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_float(
                value,
            );
    }
    /// Reset `font_language_override` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_language_override(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_language_override(reset_struct);
    }

    /// Set the `font_language_override` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_language_override(
        &mut self,
        value: longhands::font_language_override::computed_value::T
    ) {

        self.font.mutate()
            .set_font_language_override(
                value,
            );
    }
    /// Reset `font_stretch` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_stretch(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_stretch(reset_struct);
    }

    /// Set the `font_stretch` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_stretch(
        &mut self,
        value: longhands::font_stretch::computed_value::T
    ) {

        self.font.mutate()
            .set_font_stretch(
                value,
            );
    }
    /// Reset `font_style` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_style(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_style(reset_struct);
    }

    /// Set the `font_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_style(
        &mut self,
        value: longhands::font_style::computed_value::T
    ) {

        self.font.mutate()
            .set_font_style(
                value,
            );
    }
    /// Reset `font_synthesis_weight` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_synthesis_weight(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_synthesis_weight(reset_struct);
    }

    /// Set the `font_synthesis_weight` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_synthesis_weight(
        &mut self,
        value: longhands::font_synthesis_weight::computed_value::T
    ) {

        self.font.mutate()
            .set_font_synthesis_weight(
                value,
            );
    }
    /// Reset `font_variant_caps` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_variant_caps(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_variant_caps(reset_struct);
    }

    /// Set the `font_variant_caps` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_variant_caps(
        &mut self,
        value: longhands::font_variant_caps::computed_value::T
    ) {

        self.font.mutate()
            .set_font_variant_caps(
                value,
            );
    }
    /// Reset `font_weight` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_weight(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_weight(reset_struct);
    }

    /// Set the `font_weight` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_weight(
        &mut self,
        value: longhands::font_weight::computed_value::T
    ) {

        self.font.mutate()
            .set_font_weight(
                value,
            );
    }
    /// Inherit `grid_auto_flow` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_auto_flow(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_auto_flow_from(inherited_struct);
    }

    /// Set the `grid_auto_flow` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_auto_flow(
        &mut self,
        value: longhands::grid_auto_flow::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_auto_flow(
                value,
            );
    }
    /// Reset `image_rendering` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_image_rendering(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_box();

        if self.inherited_box.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_box.mutate()
            .reset_image_rendering(reset_struct);
    }

    /// Set the `image_rendering` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_image_rendering(
        &mut self,
        value: longhands::image_rendering::computed_value::T
    ) {

        self.inherited_box.mutate()
            .set_image_rendering(
                value,
            );
    }
    /// Inherit `isolation` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_isolation(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_isolation_from(inherited_struct);
    }

    /// Set the `isolation` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_isolation(
        &mut self,
        value: longhands::isolation::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_isolation(
                value,
            );
    }
    /// Inherit `justify_items` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_justify_items(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_justify_items_from(inherited_struct);
    }

    /// Set the `justify_items` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_justify_items(
        &mut self,
        value: longhands::justify_items::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_justify_items(
                value,
            );
    }
    /// Reset `list_style_position` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_list_style_position(&mut self) {
        let reset_struct =
            self.reset_style.get_list();

        if self.list.ptr_eq(reset_struct) {
            return;
        }

        self.list.mutate()
            .reset_list_style_position(reset_struct);
    }

    /// Set the `list_style_position` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_list_style_position(
        &mut self,
        value: longhands::list_style_position::computed_value::T
    ) {

        self.list.mutate()
            .set_list_style_position(
                value,
            );
    }
    /// Reset `list_style_type` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_list_style_type(&mut self) {
        let reset_struct =
            self.reset_style.get_list();

        if self.list.ptr_eq(reset_struct) {
            return;
        }

        self.list.mutate()
            .reset_list_style_type(reset_struct);
    }

    /// Set the `list_style_type` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_list_style_type(
        &mut self,
        value: longhands::list_style_type::computed_value::T
    ) {

        self.list.mutate()
            .set_list_style_type(
                value,
            );
    }
    /// Inherit `mix_blend_mode` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_mix_blend_mode(&mut self) {
        let inherited_struct =
            self.inherited_style.get_effects();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.effects.ptr_eq(inherited_struct) {
            return;
        }

        self.effects.mutate()
            .copy_mix_blend_mode_from(inherited_struct);
    }

    /// Set the `mix_blend_mode` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_mix_blend_mode(
        &mut self,
        value: longhands::mix_blend_mode::computed_value::T
    ) {
        self.modified_reset = true;

        self.effects.mutate()
            .set_mix_blend_mode(
                value,
            );
    }
    /// Inherit `object_fit` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_object_fit(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_object_fit_from(inherited_struct);
    }

    /// Set the `object_fit` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_object_fit(
        &mut self,
        value: longhands::object_fit::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_object_fit(
                value,
            );
    }
    /// Inherit `opacity` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_opacity(&mut self) {
        let inherited_struct =
            self.inherited_style.get_effects();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.effects.ptr_eq(inherited_struct) {
            return;
        }

        self.effects.mutate()
            .copy_opacity_from(inherited_struct);
    }

    /// Set the `opacity` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_opacity(
        &mut self,
        value: longhands::opacity::computed_value::T
    ) {
        self.modified_reset = true;

        self.effects.mutate()
            .set_opacity(
                value,
            );
    }
    /// Inherit `order` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_order(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_order_from(inherited_struct);
    }

    /// Set the `order` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_order(
        &mut self,
        value: longhands::order::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_order(
                value,
            );
    }
    /// Inherit `outline_style` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_outline_style(&mut self) {
        let inherited_struct =
            self.inherited_style.get_outline();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.outline.ptr_eq(inherited_struct) {
            return;
        }

        self.outline.mutate()
            .copy_outline_style_from(inherited_struct);
    }

    /// Set the `outline_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_outline_style(
        &mut self,
        value: longhands::outline_style::computed_value::T
    ) {
        self.modified_reset = true;

        self.outline.mutate()
            .set_outline_style(
                value,
            );
    }
    /// Reset `overflow_wrap` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_overflow_wrap(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_overflow_wrap(reset_struct);
    }

    /// Set the `overflow_wrap` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_overflow_wrap(
        &mut self,
        value: longhands::overflow_wrap::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_overflow_wrap(
                value,
            );
    }
    /// Reset `pointer_events` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_pointer_events(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_ui();

        if self.inherited_ui.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_ui.mutate()
            .reset_pointer_events(reset_struct);
    }

    /// Set the `pointer_events` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_pointer_events(
        &mut self,
        value: longhands::pointer_events::computed_value::T
    ) {

        self.inherited_ui.mutate()
            .set_pointer_events(
                value,
            );
    }
    /// Inherit `position` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_position(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_position_from(inherited_struct);
    }

    /// Set the `position` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_position(
        &mut self,
        value: longhands::position::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_position(
                value,
            );
    }
    /// Inherit `position_area` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_position_area(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_position_area_from(inherited_struct);
    }

    /// Set the `position_area` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_position_area(
        &mut self,
        value: longhands::position_area::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_position_area(
                value,
            );
    }
    /// Inherit `_servo_overflow_clip_box` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit__servo_overflow_clip_box(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy__servo_overflow_clip_box_from(inherited_struct);
    }

    /// Set the `_servo_overflow_clip_box` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set__servo_overflow_clip_box(
        &mut self,
        value: longhands::_servo_overflow_clip_box::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set__servo_overflow_clip_box(
                value,
            );
    }
    /// Inherit `_servo_top_layer` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit__servo_top_layer(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy__servo_top_layer_from(inherited_struct);
    }

    /// Set the `_servo_top_layer` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set__servo_top_layer(
        &mut self,
        value: longhands::_servo_top_layer::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set__servo_top_layer(
                value,
            );
    }
    /// Inherit `table_layout` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_table_layout(&mut self) {
        let inherited_struct =
            self.inherited_style.get_table();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.table.ptr_eq(inherited_struct) {
            return;
        }

        self.table.mutate()
            .copy_table_layout_from(inherited_struct);
    }

    /// Set the `table_layout` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_table_layout(
        &mut self,
        value: longhands::table_layout::computed_value::T
    ) {
        self.modified_reset = true;

        self.table.mutate()
            .set_table_layout(
                value,
            );
    }
    /// Reset `text_align` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_align(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_align(reset_struct);
    }

    /// Set the `text_align` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_align(
        &mut self,
        value: longhands::text_align::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_align(
                value,
            );
    }
    /// Reset `text_align_last` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_align_last(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_align_last(reset_struct);
    }

    /// Set the `text_align_last` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_align_last(
        &mut self,
        value: longhands::text_align_last::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_align_last(
                value,
            );
    }
    /// Inherit `text_decoration_line` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_text_decoration_line(&mut self) {
        let inherited_struct =
            self.inherited_style.get_text();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.text.ptr_eq(inherited_struct) {
            return;
        }

        self.text.mutate()
            .copy_text_decoration_line_from(inherited_struct);
    }

    /// Set the `text_decoration_line` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_decoration_line(
        &mut self,
        value: longhands::text_decoration_line::computed_value::T
    ) {
        self.modified_reset = true;

        self.text.mutate()
            .set_text_decoration_line(
                value,
            );
    }
    /// Inherit `text_decoration_style` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_text_decoration_style(&mut self) {
        let inherited_struct =
            self.inherited_style.get_text();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.text.ptr_eq(inherited_struct) {
            return;
        }

        self.text.mutate()
            .copy_text_decoration_style_from(inherited_struct);
    }

    /// Set the `text_decoration_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_decoration_style(
        &mut self,
        value: longhands::text_decoration_style::computed_value::T
    ) {
        self.modified_reset = true;

        self.text.mutate()
            .set_text_decoration_style(
                value,
            );
    }
    /// Reset `text_justify` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_justify(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_justify(reset_struct);
    }

    /// Set the `text_justify` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_justify(
        &mut self,
        value: longhands::text_justify::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_justify(
                value,
            );
    }
    /// Reset `text_rendering` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_rendering(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_rendering(reset_struct);
    }

    /// Set the `text_rendering` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_rendering(
        &mut self,
        value: longhands::text_rendering::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_rendering(
                value,
            );
    }
    /// Reset `text_transform` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_transform(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_transform(reset_struct);
    }

    /// Set the `text_transform` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_transform(
        &mut self,
        value: longhands::text_transform::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_transform(
                value,
            );
    }
    /// Reset `text_wrap_mode` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_wrap_mode(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_wrap_mode(reset_struct);
    }

    /// Set the `text_wrap_mode` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_wrap_mode(
        &mut self,
        value: longhands::text_wrap_mode::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_wrap_mode(
                value,
            );
    }
    /// Inherit `transform_style` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transform_style(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_transform_style_from(inherited_struct);
    }

    /// Set the `transform_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transform_style(
        &mut self,
        value: longhands::transform_style::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_transform_style(
                value,
            );
    }
    /// Inherit `unicode_bidi` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_unicode_bidi(&mut self) {
        let inherited_struct =
            self.inherited_style.get_text();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.text.ptr_eq(inherited_struct) {
            return;
        }

        self.text.mutate()
            .copy_unicode_bidi_from(inherited_struct);
    }

    /// Set the `unicode_bidi` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_unicode_bidi(
        &mut self,
        value: longhands::unicode_bidi::computed_value::T
    ) {
        self.modified_reset = true;

        self.text.mutate()
            .set_unicode_bidi(
                value,
            );
    }
    /// Reset `visibility` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_visibility(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_box();

        if self.inherited_box.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_box.mutate()
            .reset_visibility(reset_struct);
    }

    /// Set the `visibility` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_visibility(
        &mut self,
        value: longhands::visibility::computed_value::T
    ) {

        self.inherited_box.mutate()
            .set_visibility(
                value,
            );
    }
    /// Reset `white_space_collapse` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_white_space_collapse(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_white_space_collapse(reset_struct);
    }

    /// Set the `white_space_collapse` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_white_space_collapse(
        &mut self,
        value: longhands::white_space_collapse::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_white_space_collapse(
                value,
            );
    }
    /// Reset `word_break` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_word_break(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_word_break(reset_struct);
    }

    /// Set the `word_break` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_word_break(
        &mut self,
        value: longhands::word_break::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_word_break(
                value,
            );
    }
    /// Reset `writing_mode` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_writing_mode(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_box();

        if self.inherited_box.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_box.mutate()
            .reset_writing_mode(reset_struct);
    }

    /// Set the `writing_mode` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_writing_mode(
        &mut self,
        value: longhands::writing_mode::computed_value::T
    ) {

        self.inherited_box.mutate()
            .set_writing_mode(
                value,
            );
    }
    /// Inherit `z_index` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_z_index(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_z_index_from(inherited_struct);
    }

    /// Set the `z_index` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_z_index(
        &mut self,
        value: longhands::z_index::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_z_index(
                value,
            );
    }
    /// Inherit `zoom` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_zoom(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_zoom_from(inherited_struct);
    }

    /// Set the `zoom` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_zoom(
        &mut self,
        value: longhands::zoom::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_zoom(
                value,
            );
    }
    /// Inherit `align_content` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_align_content(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_align_content_from(inherited_struct);
    }

    /// Set the `align_content` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_align_content(
        &mut self,
        value: longhands::align_content::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_align_content(
                value,
            );
    }
    /// Inherit `justify_content` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_justify_content(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_justify_content_from(inherited_struct);
    }

    /// Set the `justify_content` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_justify_content(
        &mut self,
        value: longhands::justify_content::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_justify_content(
                value,
            );
    }
    /// Inherit `flex_grow` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_flex_grow(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_flex_grow_from(inherited_struct);
    }

    /// Set the `flex_grow` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_flex_grow(
        &mut self,
        value: longhands::flex_grow::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_flex_grow(
                value,
            );
    }
    /// Inherit `flex_shrink` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_flex_shrink(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_flex_shrink_from(inherited_struct);
    }

    /// Set the `flex_shrink` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_flex_shrink(
        &mut self,
        value: longhands::flex_shrink::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_flex_shrink(
                value,
            );
    }
    /// Inherit `align_self` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_align_self(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_align_self_from(inherited_struct);
    }

    /// Set the `align_self` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_align_self(
        &mut self,
        value: longhands::align_self::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_align_self(
                value,
            );
    }
    /// Inherit `justify_self` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_justify_self(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_justify_self_from(inherited_struct);
    }

    /// Set the `justify_self` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_justify_self(
        &mut self,
        value: longhands::justify_self::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_justify_self(
                value,
            );
    }
    /// Inherit `overflow_x` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_overflow_x(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_overflow_x_from(inherited_struct);
    }

    /// Set the `overflow_x` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_overflow_x(
        &mut self,
        value: longhands::overflow_x::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_overflow_x(
                value,
            );
    }
    /// Inherit `overflow_y` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_overflow_y(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_overflow_y_from(inherited_struct);
    }

    /// Set the `overflow_y` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_overflow_y(
        &mut self,
        value: longhands::overflow_y::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_overflow_y(
                value,
            );
    }
    /// Inherit `border_bottom_style` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_bottom_style(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_bottom_style_from(inherited_struct);
    }

    /// Set the `border_bottom_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_bottom_style(
        &mut self,
        value: longhands::border_bottom_style::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_bottom_style(
                value,
            );
    }
    /// Inherit `border_left_style` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_left_style(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_left_style_from(inherited_struct);
    }

    /// Set the `border_left_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_left_style(
        &mut self,
        value: longhands::border_left_style::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_left_style(
                value,
            );
    }
    /// Inherit `border_right_style` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_right_style(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_right_style_from(inherited_struct);
    }

    /// Set the `border_right_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_right_style(
        &mut self,
        value: longhands::border_right_style::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_right_style(
                value,
            );
    }
    /// Inherit `border_top_style` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_top_style(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_top_style_from(inherited_struct);
    }

    /// Set the `border_top_style` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_top_style(
        &mut self,
        value: longhands::border_top_style::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_top_style(
                value,
            );
    }
    /// Inherit `animation_composition` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_composition(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_composition_from(inherited_struct);
    }

    /// Set the `animation_composition` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_composition(
        &mut self,
        value: longhands::animation_composition::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_composition(
                value,
            );
    }
    /// Inherit `animation_delay` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_delay(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_delay_from(inherited_struct);
    }

    /// Set the `animation_delay` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_delay(
        &mut self,
        value: longhands::animation_delay::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_delay(
                value,
            );
    }
    /// Inherit `animation_direction` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_direction(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_direction_from(inherited_struct);
    }

    /// Set the `animation_direction` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_direction(
        &mut self,
        value: longhands::animation_direction::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_direction(
                value,
            );
    }
    /// Inherit `animation_duration` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_duration(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_duration_from(inherited_struct);
    }

    /// Set the `animation_duration` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_duration(
        &mut self,
        value: longhands::animation_duration::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_duration(
                value,
            );
    }
    /// Inherit `animation_fill_mode` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_fill_mode(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_fill_mode_from(inherited_struct);
    }

    /// Set the `animation_fill_mode` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_fill_mode(
        &mut self,
        value: longhands::animation_fill_mode::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_fill_mode(
                value,
            );
    }
    /// Inherit `animation_iteration_count` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_iteration_count(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_iteration_count_from(inherited_struct);
    }

    /// Set the `animation_iteration_count` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_iteration_count(
        &mut self,
        value: longhands::animation_iteration_count::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_iteration_count(
                value,
            );
    }
    /// Inherit `animation_name` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_name(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_name_from(inherited_struct);
    }

    /// Set the `animation_name` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_name(
        &mut self,
        value: longhands::animation_name::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_name(
                value,
            );
    }
    /// Inherit `animation_play_state` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_play_state(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_play_state_from(inherited_struct);
    }

    /// Set the `animation_play_state` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_play_state(
        &mut self,
        value: longhands::animation_play_state::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_play_state(
                value,
            );
    }
    /// Inherit `animation_timeline` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_timeline(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_timeline_from(inherited_struct);
    }

    /// Set the `animation_timeline` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_timeline(
        &mut self,
        value: longhands::animation_timeline::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_timeline(
                value,
            );
    }
    /// Inherit `animation_timing_function` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_animation_timing_function(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_animation_timing_function_from(inherited_struct);
    }

    /// Set the `animation_timing_function` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_animation_timing_function(
        &mut self,
        value: longhands::animation_timing_function::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_animation_timing_function(
                value,
            );
    }
    /// Inherit `backdrop_filter` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_backdrop_filter(&mut self) {
        let inherited_struct =
            self.inherited_style.get_effects();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.effects.ptr_eq(inherited_struct) {
            return;
        }

        self.effects.mutate()
            .copy_backdrop_filter_from(inherited_struct);
    }

    /// Set the `backdrop_filter` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_backdrop_filter(
        &mut self,
        value: longhands::backdrop_filter::computed_value::T
    ) {
        self.modified_reset = true;

        self.effects.mutate()
            .set_backdrop_filter(
                value,
            );
    }
    /// Inherit `background_attachment` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_attachment(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_attachment_from(inherited_struct);
    }

    /// Set the `background_attachment` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_attachment(
        &mut self,
        value: longhands::background_attachment::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_attachment(
                value,
            );
    }
    /// Inherit `background_clip` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_clip(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_clip_from(inherited_struct);
    }

    /// Set the `background_clip` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_clip(
        &mut self,
        value: longhands::background_clip::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_clip(
                value,
            );
    }
    /// Inherit `background_image` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_image(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_image_from(inherited_struct);
    }

    /// Set the `background_image` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_image(
        &mut self,
        value: longhands::background_image::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_image(
                value,
            );
    }
    /// Inherit `background_origin` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_origin(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_origin_from(inherited_struct);
    }

    /// Set the `background_origin` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_origin(
        &mut self,
        value: longhands::background_origin::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_origin(
                value,
            );
    }
    /// Inherit `background_position_x` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_position_x(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_position_x_from(inherited_struct);
    }

    /// Set the `background_position_x` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_position_x(
        &mut self,
        value: longhands::background_position_x::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_position_x(
                value,
            );
    }
    /// Inherit `background_position_y` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_position_y(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_position_y_from(inherited_struct);
    }

    /// Set the `background_position_y` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_position_y(
        &mut self,
        value: longhands::background_position_y::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_position_y(
                value,
            );
    }
    /// Inherit `background_repeat` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_repeat(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_repeat_from(inherited_struct);
    }

    /// Set the `background_repeat` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_repeat(
        &mut self,
        value: longhands::background_repeat::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_repeat(
                value,
            );
    }
    /// Inherit `background_size` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_size(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_size_from(inherited_struct);
    }

    /// Set the `background_size` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_size(
        &mut self,
        value: longhands::background_size::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_size(
                value,
            );
    }
    /// Inherit `border_image_outset` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_image_outset(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_image_outset_from(inherited_struct);
    }

    /// Set the `border_image_outset` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_image_outset(
        &mut self,
        value: longhands::border_image_outset::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_image_outset(
                value,
            );
    }
    /// Inherit `border_image_slice` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_image_slice(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_image_slice_from(inherited_struct);
    }

    /// Set the `border_image_slice` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_image_slice(
        &mut self,
        value: longhands::border_image_slice::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_image_slice(
                value,
            );
    }
    /// Inherit `border_image_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_image_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_image_width_from(inherited_struct);
    }

    /// Set the `border_image_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_image_width(
        &mut self,
        value: longhands::border_image_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_image_width(
                value,
            );
    }
    /// Reset `border_spacing` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_border_spacing(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_table();

        if self.inherited_table.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_table.mutate()
            .reset_border_spacing(reset_struct);
    }

    /// Set the `border_spacing` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_spacing(
        &mut self,
        value: longhands::border_spacing::computed_value::T
    ) {

        self.inherited_table.mutate()
            .set_border_spacing(
                value,
            );
    }
    /// Inherit `box_shadow` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_box_shadow(&mut self) {
        let inherited_struct =
            self.inherited_style.get_effects();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.effects.ptr_eq(inherited_struct) {
            return;
        }

        self.effects.mutate()
            .copy_box_shadow_from(inherited_struct);
    }

    /// Set the `box_shadow` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_box_shadow(
        &mut self,
        value: longhands::box_shadow::computed_value::T
    ) {
        self.modified_reset = true;

        self.effects.mutate()
            .set_box_shadow(
                value,
            );
    }
    /// Inherit `clip` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_clip(&mut self) {
        let inherited_struct =
            self.inherited_style.get_effects();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.effects.ptr_eq(inherited_struct) {
            return;
        }

        self.effects.mutate()
            .copy_clip_from(inherited_struct);
    }

    /// Set the `clip` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_clip(
        &mut self,
        value: longhands::clip::computed_value::T
    ) {
        self.modified_reset = true;

        self.effects.mutate()
            .set_clip(
                value,
            );
    }
    /// Inherit `clip_path` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_clip_path(&mut self) {
        let inherited_struct =
            self.inherited_style.get_svg();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.svg.ptr_eq(inherited_struct) {
            return;
        }

        self.svg.mutate()
            .copy_clip_path_from(inherited_struct);
    }

    /// Set the `clip_path` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_clip_path(
        &mut self,
        value: longhands::clip_path::computed_value::T
    ) {
        self.modified_reset = true;

        self.svg.mutate()
            .set_clip_path(
                value,
            );
    }
    /// Reset `color` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_color(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_color(reset_struct);
    }

    /// Set the `color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_color(
        &mut self,
        value: longhands::color::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_color(
                value,
            );
    }
    /// Reset `color_scheme` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_color_scheme(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_ui();

        if self.inherited_ui.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_ui.mutate()
            .reset_color_scheme(reset_struct);
    }

    /// Set the `color_scheme` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_color_scheme(
        &mut self,
        value: longhands::color_scheme::computed_value::T
    ) {

        self.inherited_ui.mutate()
            .set_color_scheme(
                value,
            );
    }
    /// Inherit `column_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_column_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_column();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.column.ptr_eq(inherited_struct) {
            return;
        }

        self.column.mutate()
            .copy_column_width_from(inherited_struct);
    }

    /// Set the `column_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_column_width(
        &mut self,
        value: longhands::column_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.column.mutate()
            .set_column_width(
                value,
            );
    }
    /// Inherit `container_name` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_container_name(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_container_name_from(inherited_struct);
    }

    /// Set the `container_name` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_container_name(
        &mut self,
        value: longhands::container_name::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_container_name(
                value,
            );
    }
    /// Inherit `content` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_content(&mut self) {
        let inherited_struct =
            self.inherited_style.get_counters();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);

        self.add_flags(ComputedValueFlags::CONTENT_DEPENDS_ON_INHERITED_STYLE);


        if self.counters.ptr_eq(inherited_struct) {
            return;
        }

        self.counters.mutate()
            .copy_content_from(inherited_struct);
    }

    /// Set the `content` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_content(
        &mut self,
        value: longhands::content::computed_value::T
    ) {
        self.modified_reset = true;

        self.counters.mutate()
            .set_content(
                value,
            );
    }
    /// Inherit `counter_increment` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_counter_increment(&mut self) {
        let inherited_struct =
            self.inherited_style.get_counters();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.counters.ptr_eq(inherited_struct) {
            return;
        }

        self.counters.mutate()
            .copy_counter_increment_from(inherited_struct);
    }

    /// Set the `counter_increment` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_counter_increment(
        &mut self,
        value: longhands::counter_increment::computed_value::T
    ) {
        self.modified_reset = true;

        self.counters.mutate()
            .set_counter_increment(
                value,
            );
    }
    /// Inherit `counter_reset` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_counter_reset(&mut self) {
        let inherited_struct =
            self.inherited_style.get_counters();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.counters.ptr_eq(inherited_struct) {
            return;
        }

        self.counters.mutate()
            .copy_counter_reset_from(inherited_struct);
    }

    /// Set the `counter_reset` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_counter_reset(
        &mut self,
        value: longhands::counter_reset::computed_value::T
    ) {
        self.modified_reset = true;

        self.counters.mutate()
            .set_counter_reset(
                value,
            );
    }
    /// Reset `cursor` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_cursor(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_ui();

        if self.inherited_ui.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_ui.mutate()
            .reset_cursor(reset_struct);
    }

    /// Set the `cursor` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_cursor(
        &mut self,
        value: longhands::cursor::computed_value::T
    ) {

        self.inherited_ui.mutate()
            .set_cursor(
                value,
            );
    }
    /// Inherit `filter` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_filter(&mut self) {
        let inherited_struct =
            self.inherited_style.get_effects();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.effects.ptr_eq(inherited_struct) {
            return;
        }

        self.effects.mutate()
            .copy_filter_from(inherited_struct);
    }

    /// Set the `filter` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_filter(
        &mut self,
        value: longhands::filter::computed_value::T
    ) {
        self.modified_reset = true;

        self.effects.mutate()
            .set_filter(
                value,
            );
    }
    /// Inherit `flex_basis` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_flex_basis(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_flex_basis_from(inherited_struct);
    }

    /// Set the `flex_basis` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_flex_basis(
        &mut self,
        value: longhands::flex_basis::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_flex_basis(
                value,
            );
    }
    /// Reset `font_family` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_family(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_family(reset_struct);
    }

    /// Set the `font_family` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_family(
        &mut self,
        value: longhands::font_family::computed_value::T
    ) {

        self.font.mutate()
            .set_font_family(
                value,
            );
    }
    /// Reset `font_size` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_size(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_size(reset_struct);
    }

    /// Set the `font_size` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_size(
        &mut self,
        value: longhands::font_size::computed_value::T
    ) {

        self.font.mutate()
            .set_font_size(
                value,
            );
    }
    /// Reset `font_variation_settings` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_font_variation_settings(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_font_variation_settings(reset_struct);
    }

    /// Set the `font_variation_settings` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_font_variation_settings(
        &mut self,
        value: longhands::font_variation_settings::computed_value::T
    ) {

        self.font.mutate()
            .set_font_variation_settings(
                value,
            );
    }
    /// Inherit `grid_template_areas` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_template_areas(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_template_areas_from(inherited_struct);
    }

    /// Set the `grid_template_areas` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_template_areas(
        &mut self,
        value: longhands::grid_template_areas::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_template_areas(
                value,
            );
    }
    /// Reset `letter_spacing` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_letter_spacing(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_letter_spacing(reset_struct);
    }

    /// Set the `letter_spacing` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_letter_spacing(
        &mut self,
        value: longhands::letter_spacing::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_letter_spacing(
                value,
            );
    }
    /// Reset `line_height` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_line_height(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset_line_height(reset_struct);
    }

    /// Set the `line_height` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_line_height(
        &mut self,
        value: longhands::line_height::computed_value::T
    ) {

        self.font.mutate()
            .set_line_height(
                value,
            );
    }
    /// Inherit `mask_image` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_mask_image(&mut self) {
        let inherited_struct =
            self.inherited_style.get_svg();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.svg.ptr_eq(inherited_struct) {
            return;
        }

        self.svg.mutate()
            .copy_mask_image_from(inherited_struct);
    }

    /// Set the `mask_image` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_mask_image(
        &mut self,
        value: longhands::mask_image::computed_value::T
    ) {
        self.modified_reset = true;

        self.svg.mutate()
            .set_mask_image(
                value,
            );
    }
    /// Inherit `offset_path` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_offset_path(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_offset_path_from(inherited_struct);
    }

    /// Set the `offset_path` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_offset_path(
        &mut self,
        value: longhands::offset_path::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_offset_path(
                value,
            );
    }
    /// Inherit `outline_offset` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_outline_offset(&mut self) {
        let inherited_struct =
            self.inherited_style.get_outline();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.outline.ptr_eq(inherited_struct) {
            return;
        }

        self.outline.mutate()
            .copy_outline_offset_from(inherited_struct);
    }

    /// Set the `outline_offset` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_outline_offset(
        &mut self,
        value: longhands::outline_offset::computed_value::T
    ) {
        self.modified_reset = true;

        self.outline.mutate()
            .set_outline_offset(
                value,
            );
    }
    /// Inherit `overflow_clip_margin` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_overflow_clip_margin(&mut self) {
        let inherited_struct =
            self.inherited_style.get_margin();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.margin.ptr_eq(inherited_struct) {
            return;
        }

        self.margin.mutate()
            .copy_overflow_clip_margin_from(inherited_struct);
    }

    /// Set the `overflow_clip_margin` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_overflow_clip_margin(
        &mut self,
        value: longhands::overflow_clip_margin::computed_value::T
    ) {
        self.modified_reset = true;

        self.margin.mutate()
            .set_overflow_clip_margin(
                value,
            );
    }
    /// Inherit `perspective` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_perspective(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_perspective_from(inherited_struct);
    }

    /// Set the `perspective` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_perspective(
        &mut self,
        value: longhands::perspective::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_perspective(
                value,
            );
    }
    /// Reset `quotes` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_quotes(&mut self) {
        let reset_struct =
            self.reset_style.get_list();

        if self.list.ptr_eq(reset_struct) {
            return;
        }

        self.list.mutate()
            .reset_quotes(reset_struct);
    }

    /// Set the `quotes` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_quotes(
        &mut self,
        value: longhands::quotes::computed_value::T
    ) {

        self.list.mutate()
            .set_quotes(
                value,
            );
    }
    /// Inherit `rotate` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_rotate(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_rotate_from(inherited_struct);
    }

    /// Set the `rotate` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_rotate(
        &mut self,
        value: longhands::rotate::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_rotate(
                value,
            );
    }
    /// Inherit `scale` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_scale(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_scale_from(inherited_struct);
    }

    /// Set the `scale` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_scale(
        &mut self,
        value: longhands::scale::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_scale(
                value,
            );
    }
    /// Reset `text_indent` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_indent(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_indent(reset_struct);
    }

    /// Set the `text_indent` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_indent(
        &mut self,
        value: longhands::text_indent::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_indent(
                value,
            );
    }
    /// Inherit `text_overflow` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_text_overflow(&mut self) {
        let inherited_struct =
            self.inherited_style.get_text();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.text.ptr_eq(inherited_struct) {
            return;
        }

        self.text.mutate()
            .copy_text_overflow_from(inherited_struct);
    }

    /// Set the `text_overflow` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_overflow(
        &mut self,
        value: longhands::text_overflow::computed_value::T
    ) {
        self.modified_reset = true;

        self.text.mutate()
            .set_text_overflow(
                value,
            );
    }
    /// Reset `text_shadow` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_text_shadow(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_text_shadow(reset_struct);
    }

    /// Set the `text_shadow` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_shadow(
        &mut self,
        value: longhands::text_shadow::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_text_shadow(
                value,
            );
    }
    /// Inherit `transform` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transform(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_transform_from(inherited_struct);
    }

    /// Set the `transform` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transform(
        &mut self,
        value: longhands::transform::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_transform(
                value,
            );
    }
    /// Inherit `transform_origin` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transform_origin(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_transform_origin_from(inherited_struct);
    }

    /// Set the `transform_origin` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transform_origin(
        &mut self,
        value: longhands::transform_origin::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_transform_origin(
                value,
            );
    }
    /// Inherit `transition_behavior` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transition_behavior(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_transition_behavior_from(inherited_struct);
    }

    /// Set the `transition_behavior` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transition_behavior(
        &mut self,
        value: longhands::transition_behavior::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_transition_behavior(
                value,
            );
    }
    /// Inherit `transition_delay` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transition_delay(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_transition_delay_from(inherited_struct);
    }

    /// Set the `transition_delay` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transition_delay(
        &mut self,
        value: longhands::transition_delay::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_transition_delay(
                value,
            );
    }
    /// Inherit `transition_duration` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transition_duration(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_transition_duration_from(inherited_struct);
    }

    /// Set the `transition_duration` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transition_duration(
        &mut self,
        value: longhands::transition_duration::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_transition_duration(
                value,
            );
    }
    /// Inherit `transition_property` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transition_property(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_transition_property_from(inherited_struct);
    }

    /// Set the `transition_property` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transition_property(
        &mut self,
        value: longhands::transition_property::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_transition_property(
                value,
            );
    }
    /// Inherit `transition_timing_function` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_transition_timing_function(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_transition_timing_function_from(inherited_struct);
    }

    /// Set the `transition_timing_function` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_transition_timing_function(
        &mut self,
        value: longhands::transition_timing_function::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_transition_timing_function(
                value,
            );
    }
    /// Inherit `translate` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_translate(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_translate_from(inherited_struct);
    }

    /// Set the `translate` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_translate(
        &mut self,
        value: longhands::translate::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_translate(
                value,
            );
    }
    /// Inherit `vertical_align` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_vertical_align(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_vertical_align_from(inherited_struct);
    }

    /// Set the `vertical_align` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_vertical_align(
        &mut self,
        value: longhands::vertical_align::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_vertical_align(
                value,
            );
    }
    /// Inherit `view_transition_class` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_view_transition_class(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_view_transition_class_from(inherited_struct);
    }

    /// Set the `view_transition_class` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_view_transition_class(
        &mut self,
        value: longhands::view_transition_class::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_view_transition_class(
                value,
            );
    }
    /// Inherit `view_transition_name` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_view_transition_name(&mut self) {
        let inherited_struct =
            self.inherited_style.get_ui();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.ui.ptr_eq(inherited_struct) {
            return;
        }

        self.ui.mutate()
            .copy_view_transition_name_from(inherited_struct);
    }

    /// Set the `view_transition_name` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_view_transition_name(
        &mut self,
        value: longhands::view_transition_name::computed_value::T
    ) {
        self.modified_reset = true;

        self.ui.mutate()
            .set_view_transition_name(
                value,
            );
    }
    /// Inherit `will_change` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_will_change(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_will_change_from(inherited_struct);
    }

    /// Set the `will_change` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_will_change(
        &mut self,
        value: longhands::will_change::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_will_change(
                value,
            );
    }
    /// Reset `word_spacing` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_word_spacing(&mut self) {
        let reset_struct =
            self.reset_style.get_inherited_text();

        if self.inherited_text.ptr_eq(reset_struct) {
            return;
        }

        self.inherited_text.mutate()
            .reset_word_spacing(reset_struct);
    }

    /// Set the `word_spacing` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_word_spacing(
        &mut self,
        value: longhands::word_spacing::computed_value::T
    ) {

        self.inherited_text.mutate()
            .set_word_spacing(
                value,
            );
    }
    /// Reset `_x_lang` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset__x_lang(&mut self) {
        let reset_struct =
            self.reset_style.get_font();

        if self.font.ptr_eq(reset_struct) {
            return;
        }

        self.font.mutate()
            .reset__x_lang(reset_struct);
    }

    /// Set the `_x_lang` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set__x_lang(
        &mut self,
        value: longhands::_x_lang::computed_value::T
    ) {

        self.font.mutate()
            .set__x_lang(
                value,
            );
    }
    /// Inherit `object_position` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_object_position(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_object_position_from(inherited_struct);
    }

    /// Set the `object_position` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_object_position(
        &mut self,
        value: longhands::object_position::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_object_position(
                value,
            );
    }
    /// Inherit `perspective_origin` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_perspective_origin(&mut self) {
        let inherited_struct =
            self.inherited_style.get_box();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.box_.ptr_eq(inherited_struct) {
            return;
        }

        self.box_.mutate()
            .copy_perspective_origin_from(inherited_struct);
    }

    /// Set the `perspective_origin` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_perspective_origin(
        &mut self,
        value: longhands::perspective_origin::computed_value::T
    ) {
        self.modified_reset = true;

        self.box_.mutate()
            .set_perspective_origin(
                value,
            );
    }
    /// Inherit `grid_template_columns` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_template_columns(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_template_columns_from(inherited_struct);
    }

    /// Set the `grid_template_columns` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_template_columns(
        &mut self,
        value: longhands::grid_template_columns::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_template_columns(
                value,
            );
    }
    /// Inherit `grid_template_rows` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_template_rows(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_template_rows_from(inherited_struct);
    }

    /// Set the `grid_template_rows` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_template_rows(
        &mut self,
        value: longhands::grid_template_rows::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_template_rows(
                value,
            );
    }
    /// Inherit `border_image_source` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_image_source(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_image_source_from(inherited_struct);
    }

    /// Set the `border_image_source` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_image_source(
        &mut self,
        value: longhands::border_image_source::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_image_source(
                value,
            );
    }
    /// Reset `list_style_image` to the initial value.
    #[allow(non_snake_case)]
    pub fn reset_list_style_image(&mut self) {
        let reset_struct =
            self.reset_style.get_list();

        if self.list.ptr_eq(reset_struct) {
            return;
        }

        self.list.mutate()
            .reset_list_style_image(reset_struct);
    }

    /// Set the `list_style_image` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_list_style_image(
        &mut self,
        value: longhands::list_style_image::computed_value::T
    ) {

        self.list.mutate()
            .set_list_style_image(
                value,
            );
    }
    /// Inherit `grid_auto_columns` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_auto_columns(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_auto_columns_from(inherited_struct);
    }

    /// Set the `grid_auto_columns` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_auto_columns(
        &mut self,
        value: longhands::grid_auto_columns::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_auto_columns(
                value,
            );
    }
    /// Inherit `grid_auto_rows` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_auto_rows(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_auto_rows_from(inherited_struct);
    }

    /// Set the `grid_auto_rows` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_auto_rows(
        &mut self,
        value: longhands::grid_auto_rows::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_auto_rows(
                value,
            );
    }
    /// Inherit `column_gap` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_column_gap(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_column_gap_from(inherited_struct);
    }

    /// Set the `column_gap` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_column_gap(
        &mut self,
        value: longhands::column_gap::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_column_gap(
                value,
            );
    }
    /// Inherit `row_gap` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_row_gap(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_row_gap_from(inherited_struct);
    }

    /// Set the `row_gap` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_row_gap(
        &mut self,
        value: longhands::row_gap::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_row_gap(
                value,
            );
    }
    /// Inherit `grid_column_end` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_column_end(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_column_end_from(inherited_struct);
    }

    /// Set the `grid_column_end` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_column_end(
        &mut self,
        value: longhands::grid_column_end::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_column_end(
                value,
            );
    }
    /// Inherit `grid_column_start` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_column_start(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_column_start_from(inherited_struct);
    }

    /// Set the `grid_column_start` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_column_start(
        &mut self,
        value: longhands::grid_column_start::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_column_start(
                value,
            );
    }
    /// Inherit `grid_row_end` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_row_end(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_row_end_from(inherited_struct);
    }

    /// Set the `grid_row_end` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_row_end(
        &mut self,
        value: longhands::grid_row_end::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_row_end(
                value,
            );
    }
    /// Inherit `grid_row_start` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_grid_row_start(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_grid_row_start_from(inherited_struct);
    }

    /// Set the `grid_row_start` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_grid_row_start(
        &mut self,
        value: longhands::grid_row_start::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_grid_row_start(
                value,
            );
    }
    /// Inherit `max_height` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_max_height(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_max_height_from(inherited_struct);
    }

    /// Set the `max_height` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_max_height(
        &mut self,
        value: longhands::max_height::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_max_height(
                value,
            );
    }
    /// Inherit `max_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_max_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_max_width_from(inherited_struct);
    }

    /// Set the `max_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_max_width(
        &mut self,
        value: longhands::max_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_max_width(
                value,
            );
    }
    /// Inherit `border_bottom_left_radius` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_bottom_left_radius(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_bottom_left_radius_from(inherited_struct);
    }

    /// Set the `border_bottom_left_radius` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_bottom_left_radius(
        &mut self,
        value: longhands::border_bottom_left_radius::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_bottom_left_radius(
                value,
            );
    }
    /// Inherit `border_bottom_right_radius` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_bottom_right_radius(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_bottom_right_radius_from(inherited_struct);
    }

    /// Set the `border_bottom_right_radius` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_bottom_right_radius(
        &mut self,
        value: longhands::border_bottom_right_radius::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_bottom_right_radius(
                value,
            );
    }
    /// Inherit `border_top_left_radius` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_top_left_radius(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_top_left_radius_from(inherited_struct);
    }

    /// Set the `border_top_left_radius` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_top_left_radius(
        &mut self,
        value: longhands::border_top_left_radius::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_top_left_radius(
                value,
            );
    }
    /// Inherit `border_top_right_radius` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_top_right_radius(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_top_right_radius_from(inherited_struct);
    }

    /// Set the `border_top_right_radius` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_top_right_radius(
        &mut self,
        value: longhands::border_top_right_radius::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_top_right_radius(
                value,
            );
    }
    /// Inherit `bottom` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_bottom(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_bottom_from(inherited_struct);
    }

    /// Set the `bottom` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_bottom(
        &mut self,
        value: longhands::bottom::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_bottom(
                value,
            );
    }
    /// Inherit `left` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_left(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_left_from(inherited_struct);
    }

    /// Set the `left` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_left(
        &mut self,
        value: longhands::left::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_left(
                value,
            );
    }
    /// Inherit `right` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_right(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_right_from(inherited_struct);
    }

    /// Set the `right` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_right(
        &mut self,
        value: longhands::right::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_right(
                value,
            );
    }
    /// Inherit `top` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_top(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_top_from(inherited_struct);
    }

    /// Set the `top` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_top(
        &mut self,
        value: longhands::top::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_top(
                value,
            );
    }
    /// Inherit `margin_bottom` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_margin_bottom(&mut self) {
        let inherited_struct =
            self.inherited_style.get_margin();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.margin.ptr_eq(inherited_struct) {
            return;
        }

        self.margin.mutate()
            .copy_margin_bottom_from(inherited_struct);
    }

    /// Set the `margin_bottom` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_margin_bottom(
        &mut self,
        value: longhands::margin_bottom::computed_value::T
    ) {
        self.modified_reset = true;

        self.margin.mutate()
            .set_margin_bottom(
                value,
            );
    }
    /// Inherit `margin_left` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_margin_left(&mut self) {
        let inherited_struct =
            self.inherited_style.get_margin();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.margin.ptr_eq(inherited_struct) {
            return;
        }

        self.margin.mutate()
            .copy_margin_left_from(inherited_struct);
    }

    /// Set the `margin_left` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_margin_left(
        &mut self,
        value: longhands::margin_left::computed_value::T
    ) {
        self.modified_reset = true;

        self.margin.mutate()
            .set_margin_left(
                value,
            );
    }
    /// Inherit `margin_right` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_margin_right(&mut self) {
        let inherited_struct =
            self.inherited_style.get_margin();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.margin.ptr_eq(inherited_struct) {
            return;
        }

        self.margin.mutate()
            .copy_margin_right_from(inherited_struct);
    }

    /// Set the `margin_right` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_margin_right(
        &mut self,
        value: longhands::margin_right::computed_value::T
    ) {
        self.modified_reset = true;

        self.margin.mutate()
            .set_margin_right(
                value,
            );
    }
    /// Inherit `margin_top` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_margin_top(&mut self) {
        let inherited_struct =
            self.inherited_style.get_margin();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.margin.ptr_eq(inherited_struct) {
            return;
        }

        self.margin.mutate()
            .copy_margin_top_from(inherited_struct);
    }

    /// Set the `margin_top` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_margin_top(
        &mut self,
        value: longhands::margin_top::computed_value::T
    ) {
        self.modified_reset = true;

        self.margin.mutate()
            .set_margin_top(
                value,
            );
    }
    /// Inherit `padding_bottom` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_padding_bottom(&mut self) {
        let inherited_struct =
            self.inherited_style.get_padding();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.padding.ptr_eq(inherited_struct) {
            return;
        }

        self.padding.mutate()
            .copy_padding_bottom_from(inherited_struct);
    }

    /// Set the `padding_bottom` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_padding_bottom(
        &mut self,
        value: longhands::padding_bottom::computed_value::T
    ) {
        self.modified_reset = true;

        self.padding.mutate()
            .set_padding_bottom(
                value,
            );
    }
    /// Inherit `padding_left` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_padding_left(&mut self) {
        let inherited_struct =
            self.inherited_style.get_padding();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.padding.ptr_eq(inherited_struct) {
            return;
        }

        self.padding.mutate()
            .copy_padding_left_from(inherited_struct);
    }

    /// Set the `padding_left` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_padding_left(
        &mut self,
        value: longhands::padding_left::computed_value::T
    ) {
        self.modified_reset = true;

        self.padding.mutate()
            .set_padding_left(
                value,
            );
    }
    /// Inherit `padding_right` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_padding_right(&mut self) {
        let inherited_struct =
            self.inherited_style.get_padding();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.padding.ptr_eq(inherited_struct) {
            return;
        }

        self.padding.mutate()
            .copy_padding_right_from(inherited_struct);
    }

    /// Set the `padding_right` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_padding_right(
        &mut self,
        value: longhands::padding_right::computed_value::T
    ) {
        self.modified_reset = true;

        self.padding.mutate()
            .set_padding_right(
                value,
            );
    }
    /// Inherit `padding_top` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_padding_top(&mut self) {
        let inherited_struct =
            self.inherited_style.get_padding();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.padding.ptr_eq(inherited_struct) {
            return;
        }

        self.padding.mutate()
            .copy_padding_top_from(inherited_struct);
    }

    /// Set the `padding_top` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_padding_top(
        &mut self,
        value: longhands::padding_top::computed_value::T
    ) {
        self.modified_reset = true;

        self.padding.mutate()
            .set_padding_top(
                value,
            );
    }
    /// Inherit `height` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_height(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_height_from(inherited_struct);
    }

    /// Set the `height` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_height(
        &mut self,
        value: longhands::height::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_height(
                value,
            );
    }
    /// Inherit `min_height` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_min_height(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_min_height_from(inherited_struct);
    }

    /// Set the `min_height` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_min_height(
        &mut self,
        value: longhands::min_height::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_min_height(
                value,
            );
    }
    /// Inherit `min_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_min_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_min_width_from(inherited_struct);
    }

    /// Set the `min_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_min_width(
        &mut self,
        value: longhands::min_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_min_width(
                value,
            );
    }
    /// Inherit `width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_position();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.position.ptr_eq(inherited_struct) {
            return;
        }

        self.position.mutate()
            .copy_width_from(inherited_struct);
    }

    /// Set the `width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_width(
        &mut self,
        value: longhands::width::computed_value::T
    ) {
        self.modified_reset = true;

        self.position.mutate()
            .set_width(
                value,
            );
    }
    /// Inherit `border_bottom_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_bottom_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_bottom_width_from(inherited_struct);
    }

    /// Set the `border_bottom_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_bottom_width(
        &mut self,
        value: longhands::border_bottom_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_bottom_width(
                value,
            );
    }
    /// Inherit `border_left_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_left_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_left_width_from(inherited_struct);
    }

    /// Set the `border_left_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_left_width(
        &mut self,
        value: longhands::border_left_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_left_width(
                value,
            );
    }
    /// Inherit `border_right_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_right_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_right_width_from(inherited_struct);
    }

    /// Set the `border_right_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_right_width(
        &mut self,
        value: longhands::border_right_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_right_width(
                value,
            );
    }
    /// Inherit `border_top_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_top_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_top_width_from(inherited_struct);
    }

    /// Set the `border_top_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_top_width(
        &mut self,
        value: longhands::border_top_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_top_width(
                value,
            );
    }
    /// Inherit `outline_width` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_outline_width(&mut self) {
        let inherited_struct =
            self.inherited_style.get_outline();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.outline.ptr_eq(inherited_struct) {
            return;
        }

        self.outline.mutate()
            .copy_outline_width_from(inherited_struct);
    }

    /// Set the `outline_width` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_outline_width(
        &mut self,
        value: longhands::outline_width::computed_value::T
    ) {
        self.modified_reset = true;

        self.outline.mutate()
            .set_outline_width(
                value,
            );
    }
    /// Inherit `background_color` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_background_color(&mut self) {
        let inherited_struct =
            self.inherited_style.get_background();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.background.ptr_eq(inherited_struct) {
            return;
        }

        self.background.mutate()
            .copy_background_color_from(inherited_struct);
    }

    /// Set the `background_color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_background_color(
        &mut self,
        value: longhands::background_color::computed_value::T
    ) {
        self.modified_reset = true;

        self.background.mutate()
            .set_background_color(
                value,
            );
    }
    /// Inherit `border_bottom_color` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_bottom_color(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_bottom_color_from(inherited_struct);
    }

    /// Set the `border_bottom_color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_bottom_color(
        &mut self,
        value: longhands::border_bottom_color::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_bottom_color(
                value,
            );
    }
    /// Inherit `border_left_color` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_left_color(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_left_color_from(inherited_struct);
    }

    /// Set the `border_left_color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_left_color(
        &mut self,
        value: longhands::border_left_color::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_left_color(
                value,
            );
    }
    /// Inherit `border_right_color` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_right_color(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_right_color_from(inherited_struct);
    }

    /// Set the `border_right_color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_right_color(
        &mut self,
        value: longhands::border_right_color::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_right_color(
                value,
            );
    }
    /// Inherit `border_top_color` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_border_top_color(&mut self) {
        let inherited_struct =
            self.inherited_style.get_border();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.border.ptr_eq(inherited_struct) {
            return;
        }

        self.border.mutate()
            .copy_border_top_color_from(inherited_struct);
    }

    /// Set the `border_top_color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_border_top_color(
        &mut self,
        value: longhands::border_top_color::computed_value::T
    ) {
        self.modified_reset = true;

        self.border.mutate()
            .set_border_top_color(
                value,
            );
    }
    /// Inherit `outline_color` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_outline_color(&mut self) {
        let inherited_struct =
            self.inherited_style.get_outline();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.outline.ptr_eq(inherited_struct) {
            return;
        }

        self.outline.mutate()
            .copy_outline_color_from(inherited_struct);
    }

    /// Set the `outline_color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_outline_color(
        &mut self,
        value: longhands::outline_color::computed_value::T
    ) {
        self.modified_reset = true;

        self.outline.mutate()
            .set_outline_color(
                value,
            );
    }
    /// Inherit `text_decoration_color` from our parent style.
    #[allow(non_snake_case)]
    pub fn inherit_text_decoration_color(&mut self) {
        let inherited_struct =
            self.inherited_style.get_text();

        self.modified_reset = true;
        self.add_flags(ComputedValueFlags::INHERITS_RESET_STYLE);



        if self.text.ptr_eq(inherited_struct) {
            return;
        }

        self.text.mutate()
            .copy_text_decoration_color_from(inherited_struct);
    }

    /// Set the `text_decoration_color` to the computed value `value`.
    #[allow(non_snake_case)]
    pub fn set_text_decoration_color(
        &mut self,
        value: longhands::text_decoration_color::computed_value::T
    ) {
        self.modified_reset = true;

        self.text.mutate()
            .set_text_decoration_color(
                value,
            );
    }
    

    /// Inherits style from the parent element, accounting for the default
    /// computed values that need to be provided as well.
    pub fn for_inheritance(
        device: &'a Device,
        stylist: Option<&'a Stylist>,
        parent: Option<&'a ComputedValues>,
        pseudo: Option<&'a PseudoElement>,
    ) -> Self {
        // Rebuild the visited style from the parent, ensuring that it will also
        // not have rules.  This matches the unvisited style that will be
        // produced by this builder.  This assumes that the caller doesn't need
        // to adjust or process visited style, so we can just build visited
        // style here for simplicity.
        let visited_style = parent.and_then(|parent| {
            parent.visited_style().map(|style| {
                Self::for_inheritance(
                    device,
                    stylist,
                    Some(style),
                    pseudo,
                ).build()
            })
        });
        let custom_properties = if let Some(p) = parent { p.custom_properties().clone() } else { crate::custom_properties::ComputedCustomProperties::default() };
        let mut ret = Self::new(
            device,
            stylist,
            parent,
            pseudo,
            /* rules = */ None,
            /* is_root_element = */ false,
        );
        ret.custom_properties = custom_properties;
        ret.visited_style = visited_style;
        ret
    }

    /// Returns whether we have a visited style.
    pub fn has_visited_style(&self) -> bool {
        self.visited_style.is_some()
    }

    /// Returns whether we're a pseudo-elements style.
    pub fn is_pseudo_element(&self) -> bool {
        self.pseudo.map_or(false, |p| !p.is_anon_box())
    }

    /// Returns the style we're getting reset properties from.
    pub fn default_style(&self) -> &'a ComputedValues {
        self.reset_style
    }

        /// Gets an immutable view of the current `Background` style.
        pub fn get_background(&self) -> &style_structs::Background {
            &self.background
        }

        /// Gets a mutable view of the current `Background` style.
        pub fn mutate_background(&mut self) -> &mut style_structs::Background {
            self.modified_reset = true;
            self.background.mutate()
        }

        /// Gets a mutable view of the current `Background` style.
        pub fn take_background(&mut self) -> UniqueArc<style_structs::Background> {
            self.modified_reset = true;
            self.background.take()
        }

        /// Gets a mutable view of the current `Background` style.
        pub fn put_background(&mut self, s: UniqueArc<style_structs::Background>) {
            self.background.put(s)
        }

        /// Gets a mutable view of the current `Background` style,
        /// only if it's been mutated before.
        pub fn get_background_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Background> {
            self.background.get_if_mutated()
        }

        /// Reset the current `Background` style to its default value.
        pub fn reset_background_struct(&mut self) {
            self.background =
                StyleStructRef::Borrowed(self.reset_style.get_background());
        }
        /// Gets an immutable view of the current `Border` style.
        pub fn get_border(&self) -> &style_structs::Border {
            &self.border
        }

        /// Gets a mutable view of the current `Border` style.
        pub fn mutate_border(&mut self) -> &mut style_structs::Border {
            self.modified_reset = true;
            self.border.mutate()
        }

        /// Gets a mutable view of the current `Border` style.
        pub fn take_border(&mut self) -> UniqueArc<style_structs::Border> {
            self.modified_reset = true;
            self.border.take()
        }

        /// Gets a mutable view of the current `Border` style.
        pub fn put_border(&mut self, s: UniqueArc<style_structs::Border>) {
            self.border.put(s)
        }

        /// Gets a mutable view of the current `Border` style,
        /// only if it's been mutated before.
        pub fn get_border_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Border> {
            self.border.get_if_mutated()
        }

        /// Reset the current `Border` style to its default value.
        pub fn reset_border_struct(&mut self) {
            self.border =
                StyleStructRef::Borrowed(self.reset_style.get_border());
        }
        /// Gets an immutable view of the current `Box` style.
        pub fn get_box(&self) -> &style_structs::Box {
            &self.box_
        }

        /// Gets a mutable view of the current `Box` style.
        pub fn mutate_box(&mut self) -> &mut style_structs::Box {
            self.modified_reset = true;
            self.box_.mutate()
        }

        /// Gets a mutable view of the current `Box` style.
        pub fn take_box(&mut self) -> UniqueArc<style_structs::Box> {
            self.modified_reset = true;
            self.box_.take()
        }

        /// Gets a mutable view of the current `Box` style.
        pub fn put_box(&mut self, s: UniqueArc<style_structs::Box>) {
            self.box_.put(s)
        }

        /// Gets a mutable view of the current `Box` style,
        /// only if it's been mutated before.
        pub fn get_box_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Box> {
            self.box_.get_if_mutated()
        }

        /// Reset the current `Box` style to its default value.
        pub fn reset_box_struct(&mut self) {
            self.box_ =
                StyleStructRef::Borrowed(self.reset_style.get_box());
        }
        /// Gets an immutable view of the current `Column` style.
        pub fn get_column(&self) -> &style_structs::Column {
            &self.column
        }

        /// Gets a mutable view of the current `Column` style.
        pub fn mutate_column(&mut self) -> &mut style_structs::Column {
            self.modified_reset = true;
            self.column.mutate()
        }

        /// Gets a mutable view of the current `Column` style.
        pub fn take_column(&mut self) -> UniqueArc<style_structs::Column> {
            self.modified_reset = true;
            self.column.take()
        }

        /// Gets a mutable view of the current `Column` style.
        pub fn put_column(&mut self, s: UniqueArc<style_structs::Column>) {
            self.column.put(s)
        }

        /// Gets a mutable view of the current `Column` style,
        /// only if it's been mutated before.
        pub fn get_column_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Column> {
            self.column.get_if_mutated()
        }

        /// Reset the current `Column` style to its default value.
        pub fn reset_column_struct(&mut self) {
            self.column =
                StyleStructRef::Borrowed(self.reset_style.get_column());
        }
        /// Gets an immutable view of the current `Counters` style.
        pub fn get_counters(&self) -> &style_structs::Counters {
            &self.counters
        }

        /// Gets a mutable view of the current `Counters` style.
        pub fn mutate_counters(&mut self) -> &mut style_structs::Counters {
            self.modified_reset = true;
            self.counters.mutate()
        }

        /// Gets a mutable view of the current `Counters` style.
        pub fn take_counters(&mut self) -> UniqueArc<style_structs::Counters> {
            self.modified_reset = true;
            self.counters.take()
        }

        /// Gets a mutable view of the current `Counters` style.
        pub fn put_counters(&mut self, s: UniqueArc<style_structs::Counters>) {
            self.counters.put(s)
        }

        /// Gets a mutable view of the current `Counters` style,
        /// only if it's been mutated before.
        pub fn get_counters_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Counters> {
            self.counters.get_if_mutated()
        }

        /// Reset the current `Counters` style to its default value.
        pub fn reset_counters_struct(&mut self) {
            self.counters =
                StyleStructRef::Borrowed(self.reset_style.get_counters());
        }
        /// Gets an immutable view of the current `Effects` style.
        pub fn get_effects(&self) -> &style_structs::Effects {
            &self.effects
        }

        /// Gets a mutable view of the current `Effects` style.
        pub fn mutate_effects(&mut self) -> &mut style_structs::Effects {
            self.modified_reset = true;
            self.effects.mutate()
        }

        /// Gets a mutable view of the current `Effects` style.
        pub fn take_effects(&mut self) -> UniqueArc<style_structs::Effects> {
            self.modified_reset = true;
            self.effects.take()
        }

        /// Gets a mutable view of the current `Effects` style.
        pub fn put_effects(&mut self, s: UniqueArc<style_structs::Effects>) {
            self.effects.put(s)
        }

        /// Gets a mutable view of the current `Effects` style,
        /// only if it's been mutated before.
        pub fn get_effects_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Effects> {
            self.effects.get_if_mutated()
        }

        /// Reset the current `Effects` style to its default value.
        pub fn reset_effects_struct(&mut self) {
            self.effects =
                StyleStructRef::Borrowed(self.reset_style.get_effects());
        }
        /// Gets an immutable view of the current `Font` style.
        pub fn get_font(&self) -> &style_structs::Font {
            &self.font
        }

        /// Gets a mutable view of the current `Font` style.
        pub fn mutate_font(&mut self) -> &mut style_structs::Font {
            self.font.mutate()
        }

        /// Gets a mutable view of the current `Font` style.
        pub fn take_font(&mut self) -> UniqueArc<style_structs::Font> {
            self.font.take()
        }

        /// Gets a mutable view of the current `Font` style.
        pub fn put_font(&mut self, s: UniqueArc<style_structs::Font>) {
            self.font.put(s)
        }

        /// Gets a mutable view of the current `Font` style,
        /// only if it's been mutated before.
        pub fn get_font_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Font> {
            self.font.get_if_mutated()
        }

        /// Reset the current `Font` style to its default value.
        pub fn reset_font_struct(&mut self) {
            self.font =
                StyleStructRef::Borrowed(self.reset_style.get_font());
        }
        /// Gets an immutable view of the current `InheritedBox` style.
        pub fn get_inherited_box(&self) -> &style_structs::InheritedBox {
            &self.inherited_box
        }

        /// Gets a mutable view of the current `InheritedBox` style.
        pub fn mutate_inherited_box(&mut self) -> &mut style_structs::InheritedBox {
            self.inherited_box.mutate()
        }

        /// Gets a mutable view of the current `InheritedBox` style.
        pub fn take_inherited_box(&mut self) -> UniqueArc<style_structs::InheritedBox> {
            self.inherited_box.take()
        }

        /// Gets a mutable view of the current `InheritedBox` style.
        pub fn put_inherited_box(&mut self, s: UniqueArc<style_structs::InheritedBox>) {
            self.inherited_box.put(s)
        }

        /// Gets a mutable view of the current `InheritedBox` style,
        /// only if it's been mutated before.
        pub fn get_inherited_box_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::InheritedBox> {
            self.inherited_box.get_if_mutated()
        }

        /// Reset the current `InheritedBox` style to its default value.
        pub fn reset_inherited_box_struct(&mut self) {
            self.inherited_box =
                StyleStructRef::Borrowed(self.reset_style.get_inherited_box());
        }
        /// Gets an immutable view of the current `InheritedTable` style.
        pub fn get_inherited_table(&self) -> &style_structs::InheritedTable {
            &self.inherited_table
        }

        /// Gets a mutable view of the current `InheritedTable` style.
        pub fn mutate_inherited_table(&mut self) -> &mut style_structs::InheritedTable {
            self.inherited_table.mutate()
        }

        /// Gets a mutable view of the current `InheritedTable` style.
        pub fn take_inherited_table(&mut self) -> UniqueArc<style_structs::InheritedTable> {
            self.inherited_table.take()
        }

        /// Gets a mutable view of the current `InheritedTable` style.
        pub fn put_inherited_table(&mut self, s: UniqueArc<style_structs::InheritedTable>) {
            self.inherited_table.put(s)
        }

        /// Gets a mutable view of the current `InheritedTable` style,
        /// only if it's been mutated before.
        pub fn get_inherited_table_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::InheritedTable> {
            self.inherited_table.get_if_mutated()
        }

        /// Reset the current `InheritedTable` style to its default value.
        pub fn reset_inherited_table_struct(&mut self) {
            self.inherited_table =
                StyleStructRef::Borrowed(self.reset_style.get_inherited_table());
        }
        /// Gets an immutable view of the current `InheritedText` style.
        pub fn get_inherited_text(&self) -> &style_structs::InheritedText {
            &self.inherited_text
        }

        /// Gets a mutable view of the current `InheritedText` style.
        pub fn mutate_inherited_text(&mut self) -> &mut style_structs::InheritedText {
            self.inherited_text.mutate()
        }

        /// Gets a mutable view of the current `InheritedText` style.
        pub fn take_inherited_text(&mut self) -> UniqueArc<style_structs::InheritedText> {
            self.inherited_text.take()
        }

        /// Gets a mutable view of the current `InheritedText` style.
        pub fn put_inherited_text(&mut self, s: UniqueArc<style_structs::InheritedText>) {
            self.inherited_text.put(s)
        }

        /// Gets a mutable view of the current `InheritedText` style,
        /// only if it's been mutated before.
        pub fn get_inherited_text_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::InheritedText> {
            self.inherited_text.get_if_mutated()
        }

        /// Reset the current `InheritedText` style to its default value.
        pub fn reset_inherited_text_struct(&mut self) {
            self.inherited_text =
                StyleStructRef::Borrowed(self.reset_style.get_inherited_text());
        }
        /// Gets an immutable view of the current `InheritedUI` style.
        pub fn get_inherited_ui(&self) -> &style_structs::InheritedUI {
            &self.inherited_ui
        }

        /// Gets a mutable view of the current `InheritedUI` style.
        pub fn mutate_inherited_ui(&mut self) -> &mut style_structs::InheritedUI {
            self.inherited_ui.mutate()
        }

        /// Gets a mutable view of the current `InheritedUI` style.
        pub fn take_inherited_ui(&mut self) -> UniqueArc<style_structs::InheritedUI> {
            self.inherited_ui.take()
        }

        /// Gets a mutable view of the current `InheritedUI` style.
        pub fn put_inherited_ui(&mut self, s: UniqueArc<style_structs::InheritedUI>) {
            self.inherited_ui.put(s)
        }

        /// Gets a mutable view of the current `InheritedUI` style,
        /// only if it's been mutated before.
        pub fn get_inherited_ui_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::InheritedUI> {
            self.inherited_ui.get_if_mutated()
        }

        /// Reset the current `InheritedUI` style to its default value.
        pub fn reset_inherited_ui_struct(&mut self) {
            self.inherited_ui =
                StyleStructRef::Borrowed(self.reset_style.get_inherited_ui());
        }
        /// Gets an immutable view of the current `List` style.
        pub fn get_list(&self) -> &style_structs::List {
            &self.list
        }

        /// Gets a mutable view of the current `List` style.
        pub fn mutate_list(&mut self) -> &mut style_structs::List {
            self.list.mutate()
        }

        /// Gets a mutable view of the current `List` style.
        pub fn take_list(&mut self) -> UniqueArc<style_structs::List> {
            self.list.take()
        }

        /// Gets a mutable view of the current `List` style.
        pub fn put_list(&mut self, s: UniqueArc<style_structs::List>) {
            self.list.put(s)
        }

        /// Gets a mutable view of the current `List` style,
        /// only if it's been mutated before.
        pub fn get_list_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::List> {
            self.list.get_if_mutated()
        }

        /// Reset the current `List` style to its default value.
        pub fn reset_list_struct(&mut self) {
            self.list =
                StyleStructRef::Borrowed(self.reset_style.get_list());
        }
        /// Gets an immutable view of the current `Margin` style.
        pub fn get_margin(&self) -> &style_structs::Margin {
            &self.margin
        }

        /// Gets a mutable view of the current `Margin` style.
        pub fn mutate_margin(&mut self) -> &mut style_structs::Margin {
            self.modified_reset = true;
            self.margin.mutate()
        }

        /// Gets a mutable view of the current `Margin` style.
        pub fn take_margin(&mut self) -> UniqueArc<style_structs::Margin> {
            self.modified_reset = true;
            self.margin.take()
        }

        /// Gets a mutable view of the current `Margin` style.
        pub fn put_margin(&mut self, s: UniqueArc<style_structs::Margin>) {
            self.margin.put(s)
        }

        /// Gets a mutable view of the current `Margin` style,
        /// only if it's been mutated before.
        pub fn get_margin_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Margin> {
            self.margin.get_if_mutated()
        }

        /// Reset the current `Margin` style to its default value.
        pub fn reset_margin_struct(&mut self) {
            self.margin =
                StyleStructRef::Borrowed(self.reset_style.get_margin());
        }
        /// Gets an immutable view of the current `Outline` style.
        pub fn get_outline(&self) -> &style_structs::Outline {
            &self.outline
        }

        /// Gets a mutable view of the current `Outline` style.
        pub fn mutate_outline(&mut self) -> &mut style_structs::Outline {
            self.modified_reset = true;
            self.outline.mutate()
        }

        /// Gets a mutable view of the current `Outline` style.
        pub fn take_outline(&mut self) -> UniqueArc<style_structs::Outline> {
            self.modified_reset = true;
            self.outline.take()
        }

        /// Gets a mutable view of the current `Outline` style.
        pub fn put_outline(&mut self, s: UniqueArc<style_structs::Outline>) {
            self.outline.put(s)
        }

        /// Gets a mutable view of the current `Outline` style,
        /// only if it's been mutated before.
        pub fn get_outline_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Outline> {
            self.outline.get_if_mutated()
        }

        /// Reset the current `Outline` style to its default value.
        pub fn reset_outline_struct(&mut self) {
            self.outline =
                StyleStructRef::Borrowed(self.reset_style.get_outline());
        }
        /// Gets an immutable view of the current `Padding` style.
        pub fn get_padding(&self) -> &style_structs::Padding {
            &self.padding
        }

        /// Gets a mutable view of the current `Padding` style.
        pub fn mutate_padding(&mut self) -> &mut style_structs::Padding {
            self.modified_reset = true;
            self.padding.mutate()
        }

        /// Gets a mutable view of the current `Padding` style.
        pub fn take_padding(&mut self) -> UniqueArc<style_structs::Padding> {
            self.modified_reset = true;
            self.padding.take()
        }

        /// Gets a mutable view of the current `Padding` style.
        pub fn put_padding(&mut self, s: UniqueArc<style_structs::Padding>) {
            self.padding.put(s)
        }

        /// Gets a mutable view of the current `Padding` style,
        /// only if it's been mutated before.
        pub fn get_padding_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Padding> {
            self.padding.get_if_mutated()
        }

        /// Reset the current `Padding` style to its default value.
        pub fn reset_padding_struct(&mut self) {
            self.padding =
                StyleStructRef::Borrowed(self.reset_style.get_padding());
        }
        /// Gets an immutable view of the current `Position` style.
        pub fn get_position(&self) -> &style_structs::Position {
            &self.position
        }

        /// Gets a mutable view of the current `Position` style.
        pub fn mutate_position(&mut self) -> &mut style_structs::Position {
            self.modified_reset = true;
            self.position.mutate()
        }

        /// Gets a mutable view of the current `Position` style.
        pub fn take_position(&mut self) -> UniqueArc<style_structs::Position> {
            self.modified_reset = true;
            self.position.take()
        }

        /// Gets a mutable view of the current `Position` style.
        pub fn put_position(&mut self, s: UniqueArc<style_structs::Position>) {
            self.position.put(s)
        }

        /// Gets a mutable view of the current `Position` style,
        /// only if it's been mutated before.
        pub fn get_position_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Position> {
            self.position.get_if_mutated()
        }

        /// Reset the current `Position` style to its default value.
        pub fn reset_position_struct(&mut self) {
            self.position =
                StyleStructRef::Borrowed(self.reset_style.get_position());
        }
        /// Gets an immutable view of the current `SVG` style.
        pub fn get_svg(&self) -> &style_structs::SVG {
            &self.svg
        }

        /// Gets a mutable view of the current `SVG` style.
        pub fn mutate_svg(&mut self) -> &mut style_structs::SVG {
            self.modified_reset = true;
            self.svg.mutate()
        }

        /// Gets a mutable view of the current `SVG` style.
        pub fn take_svg(&mut self) -> UniqueArc<style_structs::SVG> {
            self.modified_reset = true;
            self.svg.take()
        }

        /// Gets a mutable view of the current `SVG` style.
        pub fn put_svg(&mut self, s: UniqueArc<style_structs::SVG>) {
            self.svg.put(s)
        }

        /// Gets a mutable view of the current `SVG` style,
        /// only if it's been mutated before.
        pub fn get_svg_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::SVG> {
            self.svg.get_if_mutated()
        }

        /// Reset the current `SVG` style to its default value.
        pub fn reset_svg_struct(&mut self) {
            self.svg =
                StyleStructRef::Borrowed(self.reset_style.get_svg());
        }
        /// Gets an immutable view of the current `Table` style.
        pub fn get_table(&self) -> &style_structs::Table {
            &self.table
        }

        /// Gets a mutable view of the current `Table` style.
        pub fn mutate_table(&mut self) -> &mut style_structs::Table {
            self.modified_reset = true;
            self.table.mutate()
        }

        /// Gets a mutable view of the current `Table` style.
        pub fn take_table(&mut self) -> UniqueArc<style_structs::Table> {
            self.modified_reset = true;
            self.table.take()
        }

        /// Gets a mutable view of the current `Table` style.
        pub fn put_table(&mut self, s: UniqueArc<style_structs::Table>) {
            self.table.put(s)
        }

        /// Gets a mutable view of the current `Table` style,
        /// only if it's been mutated before.
        pub fn get_table_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Table> {
            self.table.get_if_mutated()
        }

        /// Reset the current `Table` style to its default value.
        pub fn reset_table_struct(&mut self) {
            self.table =
                StyleStructRef::Borrowed(self.reset_style.get_table());
        }
        /// Gets an immutable view of the current `Text` style.
        pub fn get_text(&self) -> &style_structs::Text {
            &self.text
        }

        /// Gets a mutable view of the current `Text` style.
        pub fn mutate_text(&mut self) -> &mut style_structs::Text {
            self.modified_reset = true;
            self.text.mutate()
        }

        /// Gets a mutable view of the current `Text` style.
        pub fn take_text(&mut self) -> UniqueArc<style_structs::Text> {
            self.modified_reset = true;
            self.text.take()
        }

        /// Gets a mutable view of the current `Text` style.
        pub fn put_text(&mut self, s: UniqueArc<style_structs::Text>) {
            self.text.put(s)
        }

        /// Gets a mutable view of the current `Text` style,
        /// only if it's been mutated before.
        pub fn get_text_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::Text> {
            self.text.get_if_mutated()
        }

        /// Reset the current `Text` style to its default value.
        pub fn reset_text_struct(&mut self) {
            self.text =
                StyleStructRef::Borrowed(self.reset_style.get_text());
        }
        /// Gets an immutable view of the current `UI` style.
        pub fn get_ui(&self) -> &style_structs::UI {
            &self.ui
        }

        /// Gets a mutable view of the current `UI` style.
        pub fn mutate_ui(&mut self) -> &mut style_structs::UI {
            self.modified_reset = true;
            self.ui.mutate()
        }

        /// Gets a mutable view of the current `UI` style.
        pub fn take_ui(&mut self) -> UniqueArc<style_structs::UI> {
            self.modified_reset = true;
            self.ui.take()
        }

        /// Gets a mutable view of the current `UI` style.
        pub fn put_ui(&mut self, s: UniqueArc<style_structs::UI>) {
            self.ui.put(s)
        }

        /// Gets a mutable view of the current `UI` style,
        /// only if it's been mutated before.
        pub fn get_ui_if_mutated(&mut self)
                                                         -> Option<&mut style_structs::UI> {
            self.ui.get_if_mutated()
        }

        /// Reset the current `UI` style to its default value.
        pub fn reset_ui_struct(&mut self) {
            self.ui =
                StyleStructRef::Borrowed(self.reset_style.get_ui());
        }
    

    /// Returns whether this computed style represents a floated object.
    pub fn is_floating(&self) -> bool {
        self.get_box().clone_float().is_floating()
    }

    /// Returns whether this computed style represents an absolutely-positioned
    /// object.
    pub fn is_absolutely_positioned(&self) -> bool {
        self.get_box().clone_position().is_absolutely_positioned()
    }

    /// Whether this style has a top-layer style.
    #[cfg(feature = "servo")]
    pub fn in_top_layer(&self) -> bool {
        matches!(self.get_box().clone__servo_top_layer(),
                 longhands::_servo_top_layer::computed_value::T::Top)
    }

    /// Whether this style has a top-layer style.
    #[cfg(feature = "gecko")]
    pub fn in_top_layer(&self) -> bool {
        matches!(self.get_box().clone__moz_top_layer(),
                 longhands::_moz_top_layer::computed_value::T::Auto)
    }

    /// Clears the "have any reset structs been modified" flag.
    pub fn clear_modified_reset(&mut self) {
        self.modified_reset = false;
    }

    /// Returns whether we have mutated any reset structs since the the last
    /// time `clear_modified_reset` was called.
    pub fn modified_reset(&self) -> bool {
        self.modified_reset
    }

    /// Return the current flags.
    #[inline]
    pub fn flags(&self) -> ComputedValueFlags {
        self.flags.get()
    }

    /// Add a flag to the current builder.
    #[inline]
    pub fn add_flags(&self, flag: ComputedValueFlags) {
        let flags = self.flags() | flag;
        self.flags.set(flags);
    }

    /// Removes a flag to the current builder.
    #[inline]
    pub fn remove_flags(&self, flag: ComputedValueFlags) {
        let flags = self.flags() & !flag;
        self.flags.set(flags);
    }

    /// Turns this `StyleBuilder` into a proper `ComputedValues` instance.
    pub fn build(self) -> Arc<ComputedValues> {
        ComputedValues::new(
            self.pseudo,
            self.custom_properties,
            self.writing_mode,
            self.effective_zoom,
            self.flags.get(),
            self.rules,
            self.visited_style,
            self.background.build(),
            self.border.build(),
            self.box_.build(),
            self.column.build(),
            self.counters.build(),
            self.effects.build(),
            self.font.build(),
            self.inherited_box.build(),
            self.inherited_table.build(),
            self.inherited_text.build(),
            self.inherited_ui.build(),
            self.list.build(),
            self.margin.build(),
            self.outline.build(),
            self.padding.build(),
            self.position.build(),
            self.svg.build(),
            self.table.build(),
            self.text.build(),
            self.ui.build(),
        )
    }

    /// Get the custom properties map if necessary.
    pub fn custom_properties(&self) -> &crate::custom_properties::ComputedCustomProperties {
        &self.custom_properties
    }


    /// Get the inherited custom properties map.
    pub fn inherited_custom_properties(&self) -> &crate::custom_properties::ComputedCustomProperties {
        &self.inherited_style.custom_properties
    }

    /// Access to various information about our inherited styles.  We don't
    /// expose an inherited ComputedValues directly, because in the
    /// ::first-line case some of the inherited information needs to come from
    /// one ComputedValues instance and some from a different one.

    /// Inherited writing-mode.
    pub fn inherited_writing_mode(&self) -> &WritingMode {
        &self.inherited_style.writing_mode
    }

    /// The effective zoom value that we should multiply absolute lengths by.
    pub fn effective_zoom(&self) -> computed::Zoom {
        self.effective_zoom
    }

    /// The zoom specified on this element.
    pub fn specified_zoom(&self) -> computed::Zoom {
        self.get_box().clone_zoom()
    }

    /// Computes effective_zoom and effective_zoom_for_inheritance based on the current style
    /// information.
    pub fn recompute_effective_zooms(&mut self) {
        let specified = self.specified_zoom();
        self.effective_zoom = self.inherited_style.effective_zoom.compute_effective(specified);
        self.effective_zoom_for_inheritance = Self::zoom_for_inheritance(specified, self.inherited_style);
    }

    fn zoom_for_inheritance(specified: computed::Zoom, inherited_style: &ComputedValues) -> computed::Zoom {
        if specified.is_document() {
            // If our inherited effective zoom has derived to zero, there's not much we can do.
            // This value is not exposed to content anyways (it's used for scrollbars and to avoid
            // zoom affecting canvas).
            inherited_style.effective_zoom.inverted().unwrap_or(computed::Zoom::ONE)
        } else {
            specified
        }
    }

    /// The computed value flags of our parent.
    #[inline]
    pub fn get_parent_flags(&self) -> ComputedValueFlags {
        self.inherited_style.flags
    }

    /// Calculate the line height, given the currently resolved line-height and font.
    pub fn calc_line_height(
        &self,
        device: &Device,
        line_height_base: LineHeightBase,
        writing_mode: WritingMode,
    ) -> computed::NonNegativeLength {
        use crate::computed_value_flags::ComputedValueFlags;
        let (font, flag) = match line_height_base {
            LineHeightBase::CurrentStyle => (
                self.get_font(),
                ComputedValueFlags::DEPENDS_ON_SELF_FONT_METRICS,
            ),
            LineHeightBase::InheritedStyle => (
                self.get_parent_font(),
                ComputedValueFlags::DEPENDS_ON_INHERITED_FONT_METRICS,
            ),
        };
        let line_height = font.clone_line_height();
        if matches!(line_height, computed::LineHeight::Normal) {
            self.add_flags(flag);
        }
        let lh = device.calc_line_height(&font, writing_mode, None);
        if line_height_base == LineHeightBase::InheritedStyle {
            // Apply our own zoom if our style source is the parent style.
            computed::NonNegativeLength::new(self.effective_zoom_for_inheritance.zoom(lh.px()))
        } else {
            lh
        }
    }

    /// And access to inherited style structs.
        /// Gets our inherited `Background`.  We don't name these
        /// accessors `inherited_background` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_background`
        /// instead.
        pub fn get_parent_background(&self) -> &style_structs::Background {
            self.inherited_style.get_background()
        }
        /// Gets our inherited `Border`.  We don't name these
        /// accessors `inherited_border` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_border`
        /// instead.
        pub fn get_parent_border(&self) -> &style_structs::Border {
            self.inherited_style.get_border()
        }
        /// Gets our inherited `Box`.  We don't name these
        /// accessors `inherited_box` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_box`
        /// instead.
        pub fn get_parent_box(&self) -> &style_structs::Box {
            self.inherited_style.get_box()
        }
        /// Gets our inherited `Column`.  We don't name these
        /// accessors `inherited_column` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_column`
        /// instead.
        pub fn get_parent_column(&self) -> &style_structs::Column {
            self.inherited_style.get_column()
        }
        /// Gets our inherited `Counters`.  We don't name these
        /// accessors `inherited_counters` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_counters`
        /// instead.
        pub fn get_parent_counters(&self) -> &style_structs::Counters {
            self.inherited_style.get_counters()
        }
        /// Gets our inherited `Effects`.  We don't name these
        /// accessors `inherited_effects` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_effects`
        /// instead.
        pub fn get_parent_effects(&self) -> &style_structs::Effects {
            self.inherited_style.get_effects()
        }
        /// Gets our inherited `Font`.  We don't name these
        /// accessors `inherited_font` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_font`
        /// instead.
        pub fn get_parent_font(&self) -> &style_structs::Font {
            self.inherited_style.get_font()
        }
        /// Gets our inherited `InheritedBox`.  We don't name these
        /// accessors `inherited_inherited_box` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_inherited_box`
        /// instead.
        pub fn get_parent_inherited_box(&self) -> &style_structs::InheritedBox {
            self.inherited_style.get_inherited_box()
        }
        /// Gets our inherited `InheritedTable`.  We don't name these
        /// accessors `inherited_inherited_table` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_inherited_table`
        /// instead.
        pub fn get_parent_inherited_table(&self) -> &style_structs::InheritedTable {
            self.inherited_style.get_inherited_table()
        }
        /// Gets our inherited `InheritedText`.  We don't name these
        /// accessors `inherited_inherited_text` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_inherited_text`
        /// instead.
        pub fn get_parent_inherited_text(&self) -> &style_structs::InheritedText {
            self.inherited_style.get_inherited_text()
        }
        /// Gets our inherited `InheritedUI`.  We don't name these
        /// accessors `inherited_inherited_ui` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_inherited_ui`
        /// instead.
        pub fn get_parent_inherited_ui(&self) -> &style_structs::InheritedUI {
            self.inherited_style.get_inherited_ui()
        }
        /// Gets our inherited `List`.  We don't name these
        /// accessors `inherited_list` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_list`
        /// instead.
        pub fn get_parent_list(&self) -> &style_structs::List {
            self.inherited_style.get_list()
        }
        /// Gets our inherited `Margin`.  We don't name these
        /// accessors `inherited_margin` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_margin`
        /// instead.
        pub fn get_parent_margin(&self) -> &style_structs::Margin {
            self.inherited_style.get_margin()
        }
        /// Gets our inherited `Outline`.  We don't name these
        /// accessors `inherited_outline` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_outline`
        /// instead.
        pub fn get_parent_outline(&self) -> &style_structs::Outline {
            self.inherited_style.get_outline()
        }
        /// Gets our inherited `Padding`.  We don't name these
        /// accessors `inherited_padding` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_padding`
        /// instead.
        pub fn get_parent_padding(&self) -> &style_structs::Padding {
            self.inherited_style.get_padding()
        }
        /// Gets our inherited `Position`.  We don't name these
        /// accessors `inherited_position` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_position`
        /// instead.
        pub fn get_parent_position(&self) -> &style_structs::Position {
            self.inherited_style.get_position()
        }
        /// Gets our inherited `SVG`.  We don't name these
        /// accessors `inherited_svg` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_svg`
        /// instead.
        pub fn get_parent_svg(&self) -> &style_structs::SVG {
            self.inherited_style.get_svg()
        }
        /// Gets our inherited `Table`.  We don't name these
        /// accessors `inherited_table` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_table`
        /// instead.
        pub fn get_parent_table(&self) -> &style_structs::Table {
            self.inherited_style.get_table()
        }
        /// Gets our inherited `Text`.  We don't name these
        /// accessors `inherited_text` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_text`
        /// instead.
        pub fn get_parent_text(&self) -> &style_structs::Text {
            self.inherited_style.get_text()
        }
        /// Gets our inherited `UI`.  We don't name these
        /// accessors `inherited_ui` because we already
        /// have things like "box" vs "inherited_box" as struct names.  Do the
        /// next-best thing and call them `parent_ui`
        /// instead.
        pub fn get_parent_ui(&self) -> &style_structs::UI {
            self.inherited_style.get_ui()
        }
}

/// A per-longhand function that performs the CSS cascade for that longhand.
pub type CascadePropertyFn =
    unsafe extern "Rust" fn(
        declaration: &PropertyDeclaration,
        context: &mut computed::Context,
    );

/// A per-longhand array of functions to perform the CSS cascade on each of
/// them, effectively doing virtual dispatch.
pub static CASCADE_PROPERTY: [CascadePropertyFn; 222] = [
        longhands::align_items::cascade_property,
        longhands::aspect_ratio::cascade_property,
        longhands::backface_visibility::cascade_property,
        longhands::baseline_source::cascade_property,
        longhands::border_collapse::cascade_property,
        longhands::border_image_repeat::cascade_property,
        longhands::box_sizing::cascade_property,
        longhands::caption_side::cascade_property,
        longhands::clear::cascade_property,
        longhands::column_count::cascade_property,
        longhands::column_span::cascade_property,
        longhands::contain::cascade_property,
        longhands::container_type::cascade_property,
        longhands::direction::cascade_property,
        longhands::display::cascade_property,
        longhands::empty_cells::cascade_property,
        longhands::flex_direction::cascade_property,
        longhands::flex_wrap::cascade_property,
        longhands::float::cascade_property,
        longhands::font_language_override::cascade_property,
        longhands::font_stretch::cascade_property,
        longhands::font_style::cascade_property,
        longhands::font_synthesis_weight::cascade_property,
        longhands::font_variant_caps::cascade_property,
        longhands::font_weight::cascade_property,
        longhands::grid_auto_flow::cascade_property,
        longhands::image_rendering::cascade_property,
        longhands::isolation::cascade_property,
        longhands::justify_items::cascade_property,
        longhands::list_style_position::cascade_property,
        longhands::list_style_type::cascade_property,
        longhands::mix_blend_mode::cascade_property,
        longhands::object_fit::cascade_property,
        longhands::opacity::cascade_property,
        longhands::order::cascade_property,
        longhands::outline_style::cascade_property,
        longhands::overflow_wrap::cascade_property,
        longhands::pointer_events::cascade_property,
        longhands::position::cascade_property,
        longhands::position_area::cascade_property,
        longhands::_servo_overflow_clip_box::cascade_property,
        longhands::_servo_top_layer::cascade_property,
        longhands::table_layout::cascade_property,
        longhands::text_align::cascade_property,
        longhands::text_align_last::cascade_property,
        longhands::text_decoration_line::cascade_property,
        longhands::text_decoration_style::cascade_property,
        longhands::text_justify::cascade_property,
        longhands::text_rendering::cascade_property,
        longhands::text_transform::cascade_property,
        longhands::text_wrap_mode::cascade_property,
        longhands::transform_style::cascade_property,
        longhands::unicode_bidi::cascade_property,
        longhands::visibility::cascade_property,
        longhands::white_space_collapse::cascade_property,
        longhands::word_break::cascade_property,
        longhands::writing_mode::cascade_property,
        longhands::z_index::cascade_property,
        longhands::zoom::cascade_property,
        longhands::align_content::cascade_property,
        longhands::justify_content::cascade_property,
        longhands::flex_grow::cascade_property,
        longhands::flex_shrink::cascade_property,
        longhands::align_self::cascade_property,
        longhands::justify_self::cascade_property,
        longhands::overflow_block::cascade_property,
        longhands::overflow_inline::cascade_property,
        longhands::overflow_x::cascade_property,
        longhands::overflow_y::cascade_property,
        longhands::border_block_end_style::cascade_property,
        longhands::border_block_start_style::cascade_property,
        longhands::border_bottom_style::cascade_property,
        longhands::border_inline_end_style::cascade_property,
        longhands::border_inline_start_style::cascade_property,
        longhands::border_left_style::cascade_property,
        longhands::border_right_style::cascade_property,
        longhands::border_top_style::cascade_property,
        longhands::animation_composition::cascade_property,
        longhands::animation_delay::cascade_property,
        longhands::animation_direction::cascade_property,
        longhands::animation_duration::cascade_property,
        longhands::animation_fill_mode::cascade_property,
        longhands::animation_iteration_count::cascade_property,
        longhands::animation_name::cascade_property,
        longhands::animation_play_state::cascade_property,
        longhands::animation_timeline::cascade_property,
        longhands::animation_timing_function::cascade_property,
        longhands::backdrop_filter::cascade_property,
        longhands::background_attachment::cascade_property,
        longhands::background_clip::cascade_property,
        longhands::background_image::cascade_property,
        longhands::background_origin::cascade_property,
        longhands::background_position_x::cascade_property,
        longhands::background_position_y::cascade_property,
        longhands::background_repeat::cascade_property,
        longhands::background_size::cascade_property,
        longhands::border_image_outset::cascade_property,
        longhands::border_image_slice::cascade_property,
        longhands::border_image_width::cascade_property,
        longhands::border_spacing::cascade_property,
        longhands::box_shadow::cascade_property,
        longhands::clip::cascade_property,
        longhands::clip_path::cascade_property,
        longhands::color::cascade_property,
        longhands::color_scheme::cascade_property,
        longhands::column_width::cascade_property,
        longhands::container_name::cascade_property,
        longhands::content::cascade_property,
        longhands::counter_increment::cascade_property,
        longhands::counter_reset::cascade_property,
        longhands::cursor::cascade_property,
        longhands::filter::cascade_property,
        longhands::flex_basis::cascade_property,
        longhands::font_family::cascade_property,
        longhands::font_size::cascade_property,
        longhands::font_variation_settings::cascade_property,
        longhands::grid_template_areas::cascade_property,
        longhands::letter_spacing::cascade_property,
        longhands::line_height::cascade_property,
        longhands::mask_image::cascade_property,
        longhands::offset_path::cascade_property,
        longhands::outline_offset::cascade_property,
        longhands::overflow_clip_margin::cascade_property,
        longhands::perspective::cascade_property,
        longhands::quotes::cascade_property,
        longhands::rotate::cascade_property,
        longhands::scale::cascade_property,
        longhands::text_indent::cascade_property,
        longhands::text_overflow::cascade_property,
        longhands::text_shadow::cascade_property,
        longhands::transform::cascade_property,
        longhands::transform_origin::cascade_property,
        longhands::transition_behavior::cascade_property,
        longhands::transition_delay::cascade_property,
        longhands::transition_duration::cascade_property,
        longhands::transition_property::cascade_property,
        longhands::transition_timing_function::cascade_property,
        longhands::translate::cascade_property,
        longhands::vertical_align::cascade_property,
        longhands::view_transition_class::cascade_property,
        longhands::view_transition_name::cascade_property,
        longhands::will_change::cascade_property,
        longhands::word_spacing::cascade_property,
        longhands::_x_lang::cascade_property,
        longhands::object_position::cascade_property,
        longhands::perspective_origin::cascade_property,
        longhands::grid_template_columns::cascade_property,
        longhands::grid_template_rows::cascade_property,
        longhands::border_image_source::cascade_property,
        longhands::list_style_image::cascade_property,
        longhands::grid_auto_columns::cascade_property,
        longhands::grid_auto_rows::cascade_property,
        longhands::column_gap::cascade_property,
        longhands::row_gap::cascade_property,
        longhands::grid_column_end::cascade_property,
        longhands::grid_column_start::cascade_property,
        longhands::grid_row_end::cascade_property,
        longhands::grid_row_start::cascade_property,
        longhands::max_block_size::cascade_property,
        longhands::max_height::cascade_property,
        longhands::max_inline_size::cascade_property,
        longhands::max_width::cascade_property,
        longhands::border_bottom_left_radius::cascade_property,
        longhands::border_bottom_right_radius::cascade_property,
        longhands::border_end_end_radius::cascade_property,
        longhands::border_end_start_radius::cascade_property,
        longhands::border_start_end_radius::cascade_property,
        longhands::border_start_start_radius::cascade_property,
        longhands::border_top_left_radius::cascade_property,
        longhands::border_top_right_radius::cascade_property,
        longhands::bottom::cascade_property,
        longhands::inset_block_end::cascade_property,
        longhands::inset_block_start::cascade_property,
        longhands::inset_inline_end::cascade_property,
        longhands::inset_inline_start::cascade_property,
        longhands::left::cascade_property,
        longhands::right::cascade_property,
        longhands::top::cascade_property,
        longhands::margin_block_end::cascade_property,
        longhands::margin_block_start::cascade_property,
        longhands::margin_bottom::cascade_property,
        longhands::margin_inline_end::cascade_property,
        longhands::margin_inline_start::cascade_property,
        longhands::margin_left::cascade_property,
        longhands::margin_right::cascade_property,
        longhands::margin_top::cascade_property,
        longhands::padding_block_end::cascade_property,
        longhands::padding_block_start::cascade_property,
        longhands::padding_bottom::cascade_property,
        longhands::padding_inline_end::cascade_property,
        longhands::padding_inline_start::cascade_property,
        longhands::padding_left::cascade_property,
        longhands::padding_right::cascade_property,
        longhands::padding_top::cascade_property,
        longhands::block_size::cascade_property,
        longhands::height::cascade_property,
        longhands::inline_size::cascade_property,
        longhands::min_block_size::cascade_property,
        longhands::min_height::cascade_property,
        longhands::min_inline_size::cascade_property,
        longhands::min_width::cascade_property,
        longhands::width::cascade_property,
        longhands::border_block_end_width::cascade_property,
        longhands::border_block_start_width::cascade_property,
        longhands::border_bottom_width::cascade_property,
        longhands::border_inline_end_width::cascade_property,
        longhands::border_inline_start_width::cascade_property,
        longhands::border_left_width::cascade_property,
        longhands::border_right_width::cascade_property,
        longhands::border_top_width::cascade_property,
        longhands::outline_width::cascade_property,
        longhands::background_color::cascade_property,
        longhands::border_block_end_color::cascade_property,
        longhands::border_block_start_color::cascade_property,
        longhands::border_bottom_color::cascade_property,
        longhands::border_inline_end_color::cascade_property,
        longhands::border_inline_start_color::cascade_property,
        longhands::border_left_color::cascade_property,
        longhands::border_right_color::cascade_property,
        longhands::border_top_color::cascade_property,
        longhands::outline_color::cascade_property,
        longhands::text_decoration_color::cascade_property,
];

/// See StyleAdjuster::adjust_for_border_width.
pub fn adjust_border_width(style: &mut StyleBuilder) {
        // Like calling to_computed_value, which wouldn't type check.
        if style.get_border().clone_border_top_style().none_or_hidden() &&
           style.get_border().border_top_has_nonzero_width() {
            style.set_border_top_width(Au(0));
        }
        // Like calling to_computed_value, which wouldn't type check.
        if style.get_border().clone_border_right_style().none_or_hidden() &&
           style.get_border().border_right_has_nonzero_width() {
            style.set_border_right_width(Au(0));
        }
        // Like calling to_computed_value, which wouldn't type check.
        if style.get_border().clone_border_bottom_style().none_or_hidden() &&
           style.get_border().border_bottom_has_nonzero_width() {
            style.set_border_bottom_width(Au(0));
        }
        // Like calling to_computed_value, which wouldn't type check.
        if style.get_border().clone_border_left_style().none_or_hidden() &&
           style.get_border().border_left_has_nonzero_width() {
            style.set_border_left_width(Au(0));
        }
}

/// An identifier for a given alias property.
#[derive(Clone, Copy, Eq, PartialEq, MallocSizeOf)]
#[repr(u16)]
pub enum AliasId {
        /// word-wrap
        WordWrap = 0,
        /// grid-column-gap
        GridColumnGap = 1,
        /// grid-row-gap
        GridRowGap = 2,
        /// grid-gap
        GridGap = 3,
}

impl fmt::Debug for AliasId {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let name = NonCustomPropertyId::from(*self).name();
        formatter.write_str(name)
    }
}

impl AliasId {
    /// Returns the property we're aliasing, as a longhand or a shorthand.
    #[inline]
    pub fn aliased_property(self) -> NonCustomPropertyId {
        static MAP: [NonCustomPropertyId; 4] = [
            NonCustomPropertyId::from_longhand(LonghandId::OverflowWrap),
            NonCustomPropertyId::from_longhand(LonghandId::ColumnGap),
            NonCustomPropertyId::from_longhand(LonghandId::RowGap),
            
            NonCustomPropertyId::from_shorthand(ShorthandId::Gap),
        ];
        MAP[self as usize]
    }
}

/// Call the given macro with tokens like this for each longhand and shorthand properties
/// that is enabled in content:
///
/// ```
/// [CamelCaseName, SetCamelCaseName, PropertyId::Longhand(LonghandId::CamelCaseName)],
/// ```
///
/// NOTE(emilio): Callers are responsible to deal with prefs.
#[macro_export]
macro_rules! css_properties_accessors {
    ($macro_name: ident) => {
        $macro_name! {
                                [Align_items, SetAlign_items,
                                 PropertyId::NonCustom(LonghandId::AlignItems.into())],
                            [AlignItems, SetAlignItems,
                             PropertyId::NonCustom(LonghandId::AlignItems.into())],
                                [Aspect_ratio, SetAspect_ratio,
                                 PropertyId::NonCustom(LonghandId::AspectRatio.into())],
                            [AspectRatio, SetAspectRatio,
                             PropertyId::NonCustom(LonghandId::AspectRatio.into())],
                                [Backface_visibility, SetBackface_visibility,
                                 PropertyId::NonCustom(LonghandId::BackfaceVisibility.into())],
                            [BackfaceVisibility, SetBackfaceVisibility,
                             PropertyId::NonCustom(LonghandId::BackfaceVisibility.into())],
                                [Baseline_source, SetBaseline_source,
                                 PropertyId::NonCustom(LonghandId::BaselineSource.into())],
                            [BaselineSource, SetBaselineSource,
                             PropertyId::NonCustom(LonghandId::BaselineSource.into())],
                                [Border_collapse, SetBorder_collapse,
                                 PropertyId::NonCustom(LonghandId::BorderCollapse.into())],
                            [BorderCollapse, SetBorderCollapse,
                             PropertyId::NonCustom(LonghandId::BorderCollapse.into())],
                                [Border_image_repeat, SetBorder_image_repeat,
                                 PropertyId::NonCustom(LonghandId::BorderImageRepeat.into())],
                            [BorderImageRepeat, SetBorderImageRepeat,
                             PropertyId::NonCustom(LonghandId::BorderImageRepeat.into())],
                                [Box_sizing, SetBox_sizing,
                                 PropertyId::NonCustom(LonghandId::BoxSizing.into())],
                            [BoxSizing, SetBoxSizing,
                             PropertyId::NonCustom(LonghandId::BoxSizing.into())],
                                [Caption_side, SetCaption_side,
                                 PropertyId::NonCustom(LonghandId::CaptionSide.into())],
                            [CaptionSide, SetCaptionSide,
                             PropertyId::NonCustom(LonghandId::CaptionSide.into())],
                            [Clear, SetClear,
                             PropertyId::NonCustom(LonghandId::Clear.into())],
                                [Column_count, SetColumn_count,
                                 PropertyId::NonCustom(LonghandId::ColumnCount.into())],
                            [ColumnCount, SetColumnCount,
                             PropertyId::NonCustom(LonghandId::ColumnCount.into())],
                                [Column_span, SetColumn_span,
                                 PropertyId::NonCustom(LonghandId::ColumnSpan.into())],
                            [ColumnSpan, SetColumnSpan,
                             PropertyId::NonCustom(LonghandId::ColumnSpan.into())],
                            [Contain, SetContain,
                             PropertyId::NonCustom(LonghandId::Contain.into())],
                                [Container_type, SetContainer_type,
                                 PropertyId::NonCustom(LonghandId::ContainerType.into())],
                            [ContainerType, SetContainerType,
                             PropertyId::NonCustom(LonghandId::ContainerType.into())],
                            [Direction, SetDirection,
                             PropertyId::NonCustom(LonghandId::Direction.into())],
                            [Display, SetDisplay,
                             PropertyId::NonCustom(LonghandId::Display.into())],
                                [Empty_cells, SetEmpty_cells,
                                 PropertyId::NonCustom(LonghandId::EmptyCells.into())],
                            [EmptyCells, SetEmptyCells,
                             PropertyId::NonCustom(LonghandId::EmptyCells.into())],
                                [Flex_direction, SetFlex_direction,
                                 PropertyId::NonCustom(LonghandId::FlexDirection.into())],
                            [FlexDirection, SetFlexDirection,
                             PropertyId::NonCustom(LonghandId::FlexDirection.into())],
                                [Flex_wrap, SetFlex_wrap,
                                 PropertyId::NonCustom(LonghandId::FlexWrap.into())],
                            [FlexWrap, SetFlexWrap,
                             PropertyId::NonCustom(LonghandId::FlexWrap.into())],
                            [Float, SetFloat,
                             PropertyId::NonCustom(LonghandId::Float.into())],
                                [Font_language_override, SetFont_language_override,
                                 PropertyId::NonCustom(LonghandId::FontLanguageOverride.into())],
                            [FontLanguageOverride, SetFontLanguageOverride,
                             PropertyId::NonCustom(LonghandId::FontLanguageOverride.into())],
                                [Font_stretch, SetFont_stretch,
                                 PropertyId::NonCustom(LonghandId::FontStretch.into())],
                            [FontStretch, SetFontStretch,
                             PropertyId::NonCustom(LonghandId::FontStretch.into())],
                                [Font_style, SetFont_style,
                                 PropertyId::NonCustom(LonghandId::FontStyle.into())],
                            [FontStyle, SetFontStyle,
                             PropertyId::NonCustom(LonghandId::FontStyle.into())],
                                [Font_synthesis_weight, SetFont_synthesis_weight,
                                 PropertyId::NonCustom(LonghandId::FontSynthesisWeight.into())],
                            [FontSynthesisWeight, SetFontSynthesisWeight,
                             PropertyId::NonCustom(LonghandId::FontSynthesisWeight.into())],
                                [Font_variant_caps, SetFont_variant_caps,
                                 PropertyId::NonCustom(LonghandId::FontVariantCaps.into())],
                            [FontVariantCaps, SetFontVariantCaps,
                             PropertyId::NonCustom(LonghandId::FontVariantCaps.into())],
                                [Font_weight, SetFont_weight,
                                 PropertyId::NonCustom(LonghandId::FontWeight.into())],
                            [FontWeight, SetFontWeight,
                             PropertyId::NonCustom(LonghandId::FontWeight.into())],
                                [Grid_auto_flow, SetGrid_auto_flow,
                                 PropertyId::NonCustom(LonghandId::GridAutoFlow.into())],
                            [GridAutoFlow, SetGridAutoFlow,
                             PropertyId::NonCustom(LonghandId::GridAutoFlow.into())],
                                [Image_rendering, SetImage_rendering,
                                 PropertyId::NonCustom(LonghandId::ImageRendering.into())],
                            [ImageRendering, SetImageRendering,
                             PropertyId::NonCustom(LonghandId::ImageRendering.into())],
                            [Isolation, SetIsolation,
                             PropertyId::NonCustom(LonghandId::Isolation.into())],
                                [Justify_items, SetJustify_items,
                                 PropertyId::NonCustom(LonghandId::JustifyItems.into())],
                            [JustifyItems, SetJustifyItems,
                             PropertyId::NonCustom(LonghandId::JustifyItems.into())],
                                [List_style_position, SetList_style_position,
                                 PropertyId::NonCustom(LonghandId::ListStylePosition.into())],
                            [ListStylePosition, SetListStylePosition,
                             PropertyId::NonCustom(LonghandId::ListStylePosition.into())],
                                [List_style_type, SetList_style_type,
                                 PropertyId::NonCustom(LonghandId::ListStyleType.into())],
                            [ListStyleType, SetListStyleType,
                             PropertyId::NonCustom(LonghandId::ListStyleType.into())],
                                [Mix_blend_mode, SetMix_blend_mode,
                                 PropertyId::NonCustom(LonghandId::MixBlendMode.into())],
                            [MixBlendMode, SetMixBlendMode,
                             PropertyId::NonCustom(LonghandId::MixBlendMode.into())],
                                [Object_fit, SetObject_fit,
                                 PropertyId::NonCustom(LonghandId::ObjectFit.into())],
                            [ObjectFit, SetObjectFit,
                             PropertyId::NonCustom(LonghandId::ObjectFit.into())],
                            [Opacity, SetOpacity,
                             PropertyId::NonCustom(LonghandId::Opacity.into())],
                            [Order, SetOrder,
                             PropertyId::NonCustom(LonghandId::Order.into())],
                                [Outline_style, SetOutline_style,
                                 PropertyId::NonCustom(LonghandId::OutlineStyle.into())],
                            [OutlineStyle, SetOutlineStyle,
                             PropertyId::NonCustom(LonghandId::OutlineStyle.into())],
                                [Overflow_wrap, SetOverflow_wrap,
                                 PropertyId::NonCustom(LonghandId::OverflowWrap.into())],
                            [OverflowWrap, SetOverflowWrap,
                             PropertyId::NonCustom(LonghandId::OverflowWrap.into())],
                                [Word_wrap, SetWord_wrap,
                                 PropertyId::NonCustom(LonghandId::OverflowWrap.into())],
                            [WordWrap, SetWordWrap,
                             PropertyId::NonCustom(LonghandId::OverflowWrap.into())],
                                [Pointer_events, SetPointer_events,
                                 PropertyId::NonCustom(LonghandId::PointerEvents.into())],
                            [PointerEvents, SetPointerEvents,
                             PropertyId::NonCustom(LonghandId::PointerEvents.into())],
                            [Position, SetPosition,
                             PropertyId::NonCustom(LonghandId::Position.into())],
                                [Position_area, SetPosition_area,
                                 PropertyId::NonCustom(LonghandId::PositionArea.into())],
                            [PositionArea, SetPositionArea,
                             PropertyId::NonCustom(LonghandId::PositionArea.into())],
                                [Table_layout, SetTable_layout,
                                 PropertyId::NonCustom(LonghandId::TableLayout.into())],
                            [TableLayout, SetTableLayout,
                             PropertyId::NonCustom(LonghandId::TableLayout.into())],
                                [Text_align, SetText_align,
                                 PropertyId::NonCustom(LonghandId::TextAlign.into())],
                            [TextAlign, SetTextAlign,
                             PropertyId::NonCustom(LonghandId::TextAlign.into())],
                                [Text_align_last, SetText_align_last,
                                 PropertyId::NonCustom(LonghandId::TextAlignLast.into())],
                            [TextAlignLast, SetTextAlignLast,
                             PropertyId::NonCustom(LonghandId::TextAlignLast.into())],
                                [Text_decoration_line, SetText_decoration_line,
                                 PropertyId::NonCustom(LonghandId::TextDecorationLine.into())],
                            [TextDecorationLine, SetTextDecorationLine,
                             PropertyId::NonCustom(LonghandId::TextDecorationLine.into())],
                                [Text_decoration_style, SetText_decoration_style,
                                 PropertyId::NonCustom(LonghandId::TextDecorationStyle.into())],
                            [TextDecorationStyle, SetTextDecorationStyle,
                             PropertyId::NonCustom(LonghandId::TextDecorationStyle.into())],
                                [Text_justify, SetText_justify,
                                 PropertyId::NonCustom(LonghandId::TextJustify.into())],
                            [TextJustify, SetTextJustify,
                             PropertyId::NonCustom(LonghandId::TextJustify.into())],
                                [Text_rendering, SetText_rendering,
                                 PropertyId::NonCustom(LonghandId::TextRendering.into())],
                            [TextRendering, SetTextRendering,
                             PropertyId::NonCustom(LonghandId::TextRendering.into())],
                                [Text_transform, SetText_transform,
                                 PropertyId::NonCustom(LonghandId::TextTransform.into())],
                            [TextTransform, SetTextTransform,
                             PropertyId::NonCustom(LonghandId::TextTransform.into())],
                                [Text_wrap_mode, SetText_wrap_mode,
                                 PropertyId::NonCustom(LonghandId::TextWrapMode.into())],
                            [TextWrapMode, SetTextWrapMode,
                             PropertyId::NonCustom(LonghandId::TextWrapMode.into())],
                                [Transform_style, SetTransform_style,
                                 PropertyId::NonCustom(LonghandId::TransformStyle.into())],
                            [TransformStyle, SetTransformStyle,
                             PropertyId::NonCustom(LonghandId::TransformStyle.into())],
                                [Unicode_bidi, SetUnicode_bidi,
                                 PropertyId::NonCustom(LonghandId::UnicodeBidi.into())],
                            [UnicodeBidi, SetUnicodeBidi,
                             PropertyId::NonCustom(LonghandId::UnicodeBidi.into())],
                            [Visibility, SetVisibility,
                             PropertyId::NonCustom(LonghandId::Visibility.into())],
                                [White_space_collapse, SetWhite_space_collapse,
                                 PropertyId::NonCustom(LonghandId::WhiteSpaceCollapse.into())],
                            [WhiteSpaceCollapse, SetWhiteSpaceCollapse,
                             PropertyId::NonCustom(LonghandId::WhiteSpaceCollapse.into())],
                                [Word_break, SetWord_break,
                                 PropertyId::NonCustom(LonghandId::WordBreak.into())],
                            [WordBreak, SetWordBreak,
                             PropertyId::NonCustom(LonghandId::WordBreak.into())],
                                [Writing_mode, SetWriting_mode,
                                 PropertyId::NonCustom(LonghandId::WritingMode.into())],
                            [WritingMode, SetWritingMode,
                             PropertyId::NonCustom(LonghandId::WritingMode.into())],
                                [Z_index, SetZ_index,
                                 PropertyId::NonCustom(LonghandId::ZIndex.into())],
                            [ZIndex, SetZIndex,
                             PropertyId::NonCustom(LonghandId::ZIndex.into())],
                                [Align_content, SetAlign_content,
                                 PropertyId::NonCustom(LonghandId::AlignContent.into())],
                            [AlignContent, SetAlignContent,
                             PropertyId::NonCustom(LonghandId::AlignContent.into())],
                                [Justify_content, SetJustify_content,
                                 PropertyId::NonCustom(LonghandId::JustifyContent.into())],
                            [JustifyContent, SetJustifyContent,
                             PropertyId::NonCustom(LonghandId::JustifyContent.into())],
                                [Flex_grow, SetFlex_grow,
                                 PropertyId::NonCustom(LonghandId::FlexGrow.into())],
                            [FlexGrow, SetFlexGrow,
                             PropertyId::NonCustom(LonghandId::FlexGrow.into())],
                                [Flex_shrink, SetFlex_shrink,
                                 PropertyId::NonCustom(LonghandId::FlexShrink.into())],
                            [FlexShrink, SetFlexShrink,
                             PropertyId::NonCustom(LonghandId::FlexShrink.into())],
                                [Align_self, SetAlign_self,
                                 PropertyId::NonCustom(LonghandId::AlignSelf.into())],
                            [AlignSelf, SetAlignSelf,
                             PropertyId::NonCustom(LonghandId::AlignSelf.into())],
                                [Justify_self, SetJustify_self,
                                 PropertyId::NonCustom(LonghandId::JustifySelf.into())],
                            [JustifySelf, SetJustifySelf,
                             PropertyId::NonCustom(LonghandId::JustifySelf.into())],
                                [Overflow_block, SetOverflow_block,
                                 PropertyId::NonCustom(LonghandId::OverflowBlock.into())],
                            [OverflowBlock, SetOverflowBlock,
                             PropertyId::NonCustom(LonghandId::OverflowBlock.into())],
                                [Overflow_inline, SetOverflow_inline,
                                 PropertyId::NonCustom(LonghandId::OverflowInline.into())],
                            [OverflowInline, SetOverflowInline,
                             PropertyId::NonCustom(LonghandId::OverflowInline.into())],
                                [Overflow_x, SetOverflow_x,
                                 PropertyId::NonCustom(LonghandId::OverflowX.into())],
                            [OverflowX, SetOverflowX,
                             PropertyId::NonCustom(LonghandId::OverflowX.into())],
                                [Overflow_y, SetOverflow_y,
                                 PropertyId::NonCustom(LonghandId::OverflowY.into())],
                            [OverflowY, SetOverflowY,
                             PropertyId::NonCustom(LonghandId::OverflowY.into())],
                                [Border_block_end_style, SetBorder_block_end_style,
                                 PropertyId::NonCustom(LonghandId::BorderBlockEndStyle.into())],
                            [BorderBlockEndStyle, SetBorderBlockEndStyle,
                             PropertyId::NonCustom(LonghandId::BorderBlockEndStyle.into())],
                                [Border_block_start_style, SetBorder_block_start_style,
                                 PropertyId::NonCustom(LonghandId::BorderBlockStartStyle.into())],
                            [BorderBlockStartStyle, SetBorderBlockStartStyle,
                             PropertyId::NonCustom(LonghandId::BorderBlockStartStyle.into())],
                                [Border_bottom_style, SetBorder_bottom_style,
                                 PropertyId::NonCustom(LonghandId::BorderBottomStyle.into())],
                            [BorderBottomStyle, SetBorderBottomStyle,
                             PropertyId::NonCustom(LonghandId::BorderBottomStyle.into())],
                                [Border_inline_end_style, SetBorder_inline_end_style,
                                 PropertyId::NonCustom(LonghandId::BorderInlineEndStyle.into())],
                            [BorderInlineEndStyle, SetBorderInlineEndStyle,
                             PropertyId::NonCustom(LonghandId::BorderInlineEndStyle.into())],
                                [Border_inline_start_style, SetBorder_inline_start_style,
                                 PropertyId::NonCustom(LonghandId::BorderInlineStartStyle.into())],
                            [BorderInlineStartStyle, SetBorderInlineStartStyle,
                             PropertyId::NonCustom(LonghandId::BorderInlineStartStyle.into())],
                                [Border_left_style, SetBorder_left_style,
                                 PropertyId::NonCustom(LonghandId::BorderLeftStyle.into())],
                            [BorderLeftStyle, SetBorderLeftStyle,
                             PropertyId::NonCustom(LonghandId::BorderLeftStyle.into())],
                                [Border_right_style, SetBorder_right_style,
                                 PropertyId::NonCustom(LonghandId::BorderRightStyle.into())],
                            [BorderRightStyle, SetBorderRightStyle,
                             PropertyId::NonCustom(LonghandId::BorderRightStyle.into())],
                                [Border_top_style, SetBorder_top_style,
                                 PropertyId::NonCustom(LonghandId::BorderTopStyle.into())],
                            [BorderTopStyle, SetBorderTopStyle,
                             PropertyId::NonCustom(LonghandId::BorderTopStyle.into())],
                                [Animation_composition, SetAnimation_composition,
                                 PropertyId::NonCustom(LonghandId::AnimationComposition.into())],
                            [AnimationComposition, SetAnimationComposition,
                             PropertyId::NonCustom(LonghandId::AnimationComposition.into())],
                                [Animation_delay, SetAnimation_delay,
                                 PropertyId::NonCustom(LonghandId::AnimationDelay.into())],
                            [AnimationDelay, SetAnimationDelay,
                             PropertyId::NonCustom(LonghandId::AnimationDelay.into())],
                                [Animation_direction, SetAnimation_direction,
                                 PropertyId::NonCustom(LonghandId::AnimationDirection.into())],
                            [AnimationDirection, SetAnimationDirection,
                             PropertyId::NonCustom(LonghandId::AnimationDirection.into())],
                                [Animation_duration, SetAnimation_duration,
                                 PropertyId::NonCustom(LonghandId::AnimationDuration.into())],
                            [AnimationDuration, SetAnimationDuration,
                             PropertyId::NonCustom(LonghandId::AnimationDuration.into())],
                                [Animation_fill_mode, SetAnimation_fill_mode,
                                 PropertyId::NonCustom(LonghandId::AnimationFillMode.into())],
                            [AnimationFillMode, SetAnimationFillMode,
                             PropertyId::NonCustom(LonghandId::AnimationFillMode.into())],
                                [Animation_iteration_count, SetAnimation_iteration_count,
                                 PropertyId::NonCustom(LonghandId::AnimationIterationCount.into())],
                            [AnimationIterationCount, SetAnimationIterationCount,
                             PropertyId::NonCustom(LonghandId::AnimationIterationCount.into())],
                                [Animation_name, SetAnimation_name,
                                 PropertyId::NonCustom(LonghandId::AnimationName.into())],
                            [AnimationName, SetAnimationName,
                             PropertyId::NonCustom(LonghandId::AnimationName.into())],
                                [Animation_play_state, SetAnimation_play_state,
                                 PropertyId::NonCustom(LonghandId::AnimationPlayState.into())],
                            [AnimationPlayState, SetAnimationPlayState,
                             PropertyId::NonCustom(LonghandId::AnimationPlayState.into())],
                                [Animation_timeline, SetAnimation_timeline,
                                 PropertyId::NonCustom(LonghandId::AnimationTimeline.into())],
                            [AnimationTimeline, SetAnimationTimeline,
                             PropertyId::NonCustom(LonghandId::AnimationTimeline.into())],
                                [Animation_timing_function, SetAnimation_timing_function,
                                 PropertyId::NonCustom(LonghandId::AnimationTimingFunction.into())],
                            [AnimationTimingFunction, SetAnimationTimingFunction,
                             PropertyId::NonCustom(LonghandId::AnimationTimingFunction.into())],
                                [Backdrop_filter, SetBackdrop_filter,
                                 PropertyId::NonCustom(LonghandId::BackdropFilter.into())],
                            [BackdropFilter, SetBackdropFilter,
                             PropertyId::NonCustom(LonghandId::BackdropFilter.into())],
                                [Background_attachment, SetBackground_attachment,
                                 PropertyId::NonCustom(LonghandId::BackgroundAttachment.into())],
                            [BackgroundAttachment, SetBackgroundAttachment,
                             PropertyId::NonCustom(LonghandId::BackgroundAttachment.into())],
                                [Background_clip, SetBackground_clip,
                                 PropertyId::NonCustom(LonghandId::BackgroundClip.into())],
                            [BackgroundClip, SetBackgroundClip,
                             PropertyId::NonCustom(LonghandId::BackgroundClip.into())],
                                [Background_image, SetBackground_image,
                                 PropertyId::NonCustom(LonghandId::BackgroundImage.into())],
                            [BackgroundImage, SetBackgroundImage,
                             PropertyId::NonCustom(LonghandId::BackgroundImage.into())],
                                [Background_origin, SetBackground_origin,
                                 PropertyId::NonCustom(LonghandId::BackgroundOrigin.into())],
                            [BackgroundOrigin, SetBackgroundOrigin,
                             PropertyId::NonCustom(LonghandId::BackgroundOrigin.into())],
                                [Background_position_x, SetBackground_position_x,
                                 PropertyId::NonCustom(LonghandId::BackgroundPositionX.into())],
                            [BackgroundPositionX, SetBackgroundPositionX,
                             PropertyId::NonCustom(LonghandId::BackgroundPositionX.into())],
                                [Background_position_y, SetBackground_position_y,
                                 PropertyId::NonCustom(LonghandId::BackgroundPositionY.into())],
                            [BackgroundPositionY, SetBackgroundPositionY,
                             PropertyId::NonCustom(LonghandId::BackgroundPositionY.into())],
                                [Background_repeat, SetBackground_repeat,
                                 PropertyId::NonCustom(LonghandId::BackgroundRepeat.into())],
                            [BackgroundRepeat, SetBackgroundRepeat,
                             PropertyId::NonCustom(LonghandId::BackgroundRepeat.into())],
                                [Background_size, SetBackground_size,
                                 PropertyId::NonCustom(LonghandId::BackgroundSize.into())],
                            [BackgroundSize, SetBackgroundSize,
                             PropertyId::NonCustom(LonghandId::BackgroundSize.into())],
                                [Border_image_outset, SetBorder_image_outset,
                                 PropertyId::NonCustom(LonghandId::BorderImageOutset.into())],
                            [BorderImageOutset, SetBorderImageOutset,
                             PropertyId::NonCustom(LonghandId::BorderImageOutset.into())],
                                [Border_image_slice, SetBorder_image_slice,
                                 PropertyId::NonCustom(LonghandId::BorderImageSlice.into())],
                            [BorderImageSlice, SetBorderImageSlice,
                             PropertyId::NonCustom(LonghandId::BorderImageSlice.into())],
                                [Border_image_width, SetBorder_image_width,
                                 PropertyId::NonCustom(LonghandId::BorderImageWidth.into())],
                            [BorderImageWidth, SetBorderImageWidth,
                             PropertyId::NonCustom(LonghandId::BorderImageWidth.into())],
                                [Border_spacing, SetBorder_spacing,
                                 PropertyId::NonCustom(LonghandId::BorderSpacing.into())],
                            [BorderSpacing, SetBorderSpacing,
                             PropertyId::NonCustom(LonghandId::BorderSpacing.into())],
                                [Box_shadow, SetBox_shadow,
                                 PropertyId::NonCustom(LonghandId::BoxShadow.into())],
                            [BoxShadow, SetBoxShadow,
                             PropertyId::NonCustom(LonghandId::BoxShadow.into())],
                            [Clip, SetClip,
                             PropertyId::NonCustom(LonghandId::Clip.into())],
                                [Clip_path, SetClip_path,
                                 PropertyId::NonCustom(LonghandId::ClipPath.into())],
                            [ClipPath, SetClipPath,
                             PropertyId::NonCustom(LonghandId::ClipPath.into())],
                            [Color, SetColor,
                             PropertyId::NonCustom(LonghandId::Color.into())],
                                [Color_scheme, SetColor_scheme,
                                 PropertyId::NonCustom(LonghandId::ColorScheme.into())],
                            [ColorScheme, SetColorScheme,
                             PropertyId::NonCustom(LonghandId::ColorScheme.into())],
                                [Column_width, SetColumn_width,
                                 PropertyId::NonCustom(LonghandId::ColumnWidth.into())],
                            [ColumnWidth, SetColumnWidth,
                             PropertyId::NonCustom(LonghandId::ColumnWidth.into())],
                                [Container_name, SetContainer_name,
                                 PropertyId::NonCustom(LonghandId::ContainerName.into())],
                            [ContainerName, SetContainerName,
                             PropertyId::NonCustom(LonghandId::ContainerName.into())],
                            [Content, SetContent,
                             PropertyId::NonCustom(LonghandId::Content.into())],
                                [Counter_increment, SetCounter_increment,
                                 PropertyId::NonCustom(LonghandId::CounterIncrement.into())],
                            [CounterIncrement, SetCounterIncrement,
                             PropertyId::NonCustom(LonghandId::CounterIncrement.into())],
                                [Counter_reset, SetCounter_reset,
                                 PropertyId::NonCustom(LonghandId::CounterReset.into())],
                            [CounterReset, SetCounterReset,
                             PropertyId::NonCustom(LonghandId::CounterReset.into())],
                            [Cursor, SetCursor,
                             PropertyId::NonCustom(LonghandId::Cursor.into())],
                            [Filter, SetFilter,
                             PropertyId::NonCustom(LonghandId::Filter.into())],
                                [Flex_basis, SetFlex_basis,
                                 PropertyId::NonCustom(LonghandId::FlexBasis.into())],
                            [FlexBasis, SetFlexBasis,
                             PropertyId::NonCustom(LonghandId::FlexBasis.into())],
                                [Font_family, SetFont_family,
                                 PropertyId::NonCustom(LonghandId::FontFamily.into())],
                            [FontFamily, SetFontFamily,
                             PropertyId::NonCustom(LonghandId::FontFamily.into())],
                                [Font_size, SetFont_size,
                                 PropertyId::NonCustom(LonghandId::FontSize.into())],
                            [FontSize, SetFontSize,
                             PropertyId::NonCustom(LonghandId::FontSize.into())],
                                [Font_variation_settings, SetFont_variation_settings,
                                 PropertyId::NonCustom(LonghandId::FontVariationSettings.into())],
                            [FontVariationSettings, SetFontVariationSettings,
                             PropertyId::NonCustom(LonghandId::FontVariationSettings.into())],
                                [Grid_template_areas, SetGrid_template_areas,
                                 PropertyId::NonCustom(LonghandId::GridTemplateAreas.into())],
                            [GridTemplateAreas, SetGridTemplateAreas,
                             PropertyId::NonCustom(LonghandId::GridTemplateAreas.into())],
                                [Letter_spacing, SetLetter_spacing,
                                 PropertyId::NonCustom(LonghandId::LetterSpacing.into())],
                            [LetterSpacing, SetLetterSpacing,
                             PropertyId::NonCustom(LonghandId::LetterSpacing.into())],
                                [Line_height, SetLine_height,
                                 PropertyId::NonCustom(LonghandId::LineHeight.into())],
                            [LineHeight, SetLineHeight,
                             PropertyId::NonCustom(LonghandId::LineHeight.into())],
                                [Mask_image, SetMask_image,
                                 PropertyId::NonCustom(LonghandId::MaskImage.into())],
                            [MaskImage, SetMaskImage,
                             PropertyId::NonCustom(LonghandId::MaskImage.into())],
                                [Offset_path, SetOffset_path,
                                 PropertyId::NonCustom(LonghandId::OffsetPath.into())],
                            [OffsetPath, SetOffsetPath,
                             PropertyId::NonCustom(LonghandId::OffsetPath.into())],
                                [Outline_offset, SetOutline_offset,
                                 PropertyId::NonCustom(LonghandId::OutlineOffset.into())],
                            [OutlineOffset, SetOutlineOffset,
                             PropertyId::NonCustom(LonghandId::OutlineOffset.into())],
                                [Overflow_clip_margin, SetOverflow_clip_margin,
                                 PropertyId::NonCustom(LonghandId::OverflowClipMargin.into())],
                            [OverflowClipMargin, SetOverflowClipMargin,
                             PropertyId::NonCustom(LonghandId::OverflowClipMargin.into())],
                            [Perspective, SetPerspective,
                             PropertyId::NonCustom(LonghandId::Perspective.into())],
                            [Quotes, SetQuotes,
                             PropertyId::NonCustom(LonghandId::Quotes.into())],
                            [Rotate, SetRotate,
                             PropertyId::NonCustom(LonghandId::Rotate.into())],
                            [Scale, SetScale,
                             PropertyId::NonCustom(LonghandId::Scale.into())],
                                [Text_indent, SetText_indent,
                                 PropertyId::NonCustom(LonghandId::TextIndent.into())],
                            [TextIndent, SetTextIndent,
                             PropertyId::NonCustom(LonghandId::TextIndent.into())],
                                [Text_overflow, SetText_overflow,
                                 PropertyId::NonCustom(LonghandId::TextOverflow.into())],
                            [TextOverflow, SetTextOverflow,
                             PropertyId::NonCustom(LonghandId::TextOverflow.into())],
                                [Text_shadow, SetText_shadow,
                                 PropertyId::NonCustom(LonghandId::TextShadow.into())],
                            [TextShadow, SetTextShadow,
                             PropertyId::NonCustom(LonghandId::TextShadow.into())],
                            [Transform, SetTransform,
                             PropertyId::NonCustom(LonghandId::Transform.into())],
                                [Transform_origin, SetTransform_origin,
                                 PropertyId::NonCustom(LonghandId::TransformOrigin.into())],
                            [TransformOrigin, SetTransformOrigin,
                             PropertyId::NonCustom(LonghandId::TransformOrigin.into())],
                                [Transition_behavior, SetTransition_behavior,
                                 PropertyId::NonCustom(LonghandId::TransitionBehavior.into())],
                            [TransitionBehavior, SetTransitionBehavior,
                             PropertyId::NonCustom(LonghandId::TransitionBehavior.into())],
                                [Transition_delay, SetTransition_delay,
                                 PropertyId::NonCustom(LonghandId::TransitionDelay.into())],
                            [TransitionDelay, SetTransitionDelay,
                             PropertyId::NonCustom(LonghandId::TransitionDelay.into())],
                                [Transition_duration, SetTransition_duration,
                                 PropertyId::NonCustom(LonghandId::TransitionDuration.into())],
                            [TransitionDuration, SetTransitionDuration,
                             PropertyId::NonCustom(LonghandId::TransitionDuration.into())],
                                [Transition_property, SetTransition_property,
                                 PropertyId::NonCustom(LonghandId::TransitionProperty.into())],
                            [TransitionProperty, SetTransitionProperty,
                             PropertyId::NonCustom(LonghandId::TransitionProperty.into())],
                                [Transition_timing_function, SetTransition_timing_function,
                                 PropertyId::NonCustom(LonghandId::TransitionTimingFunction.into())],
                            [TransitionTimingFunction, SetTransitionTimingFunction,
                             PropertyId::NonCustom(LonghandId::TransitionTimingFunction.into())],
                            [Translate, SetTranslate,
                             PropertyId::NonCustom(LonghandId::Translate.into())],
                                [Vertical_align, SetVertical_align,
                                 PropertyId::NonCustom(LonghandId::VerticalAlign.into())],
                            [VerticalAlign, SetVerticalAlign,
                             PropertyId::NonCustom(LonghandId::VerticalAlign.into())],
                                [Will_change, SetWill_change,
                                 PropertyId::NonCustom(LonghandId::WillChange.into())],
                            [WillChange, SetWillChange,
                             PropertyId::NonCustom(LonghandId::WillChange.into())],
                                [Word_spacing, SetWord_spacing,
                                 PropertyId::NonCustom(LonghandId::WordSpacing.into())],
                            [WordSpacing, SetWordSpacing,
                             PropertyId::NonCustom(LonghandId::WordSpacing.into())],
                                [Object_position, SetObject_position,
                                 PropertyId::NonCustom(LonghandId::ObjectPosition.into())],
                            [ObjectPosition, SetObjectPosition,
                             PropertyId::NonCustom(LonghandId::ObjectPosition.into())],
                                [Perspective_origin, SetPerspective_origin,
                                 PropertyId::NonCustom(LonghandId::PerspectiveOrigin.into())],
                            [PerspectiveOrigin, SetPerspectiveOrigin,
                             PropertyId::NonCustom(LonghandId::PerspectiveOrigin.into())],
                                [Grid_template_columns, SetGrid_template_columns,
                                 PropertyId::NonCustom(LonghandId::GridTemplateColumns.into())],
                            [GridTemplateColumns, SetGridTemplateColumns,
                             PropertyId::NonCustom(LonghandId::GridTemplateColumns.into())],
                                [Grid_template_rows, SetGrid_template_rows,
                                 PropertyId::NonCustom(LonghandId::GridTemplateRows.into())],
                            [GridTemplateRows, SetGridTemplateRows,
                             PropertyId::NonCustom(LonghandId::GridTemplateRows.into())],
                                [Border_image_source, SetBorder_image_source,
                                 PropertyId::NonCustom(LonghandId::BorderImageSource.into())],
                            [BorderImageSource, SetBorderImageSource,
                             PropertyId::NonCustom(LonghandId::BorderImageSource.into())],
                                [List_style_image, SetList_style_image,
                                 PropertyId::NonCustom(LonghandId::ListStyleImage.into())],
                            [ListStyleImage, SetListStyleImage,
                             PropertyId::NonCustom(LonghandId::ListStyleImage.into())],
                                [Grid_auto_columns, SetGrid_auto_columns,
                                 PropertyId::NonCustom(LonghandId::GridAutoColumns.into())],
                            [GridAutoColumns, SetGridAutoColumns,
                             PropertyId::NonCustom(LonghandId::GridAutoColumns.into())],
                                [Grid_auto_rows, SetGrid_auto_rows,
                                 PropertyId::NonCustom(LonghandId::GridAutoRows.into())],
                            [GridAutoRows, SetGridAutoRows,
                             PropertyId::NonCustom(LonghandId::GridAutoRows.into())],
                                [Column_gap, SetColumn_gap,
                                 PropertyId::NonCustom(LonghandId::ColumnGap.into())],
                            [ColumnGap, SetColumnGap,
                             PropertyId::NonCustom(LonghandId::ColumnGap.into())],
                                [Grid_column_gap, SetGrid_column_gap,
                                 PropertyId::NonCustom(LonghandId::ColumnGap.into())],
                            [GridColumnGap, SetGridColumnGap,
                             PropertyId::NonCustom(LonghandId::ColumnGap.into())],
                                [Row_gap, SetRow_gap,
                                 PropertyId::NonCustom(LonghandId::RowGap.into())],
                            [RowGap, SetRowGap,
                             PropertyId::NonCustom(LonghandId::RowGap.into())],
                                [Grid_row_gap, SetGrid_row_gap,
                                 PropertyId::NonCustom(LonghandId::RowGap.into())],
                            [GridRowGap, SetGridRowGap,
                             PropertyId::NonCustom(LonghandId::RowGap.into())],
                                [Grid_column_end, SetGrid_column_end,
                                 PropertyId::NonCustom(LonghandId::GridColumnEnd.into())],
                            [GridColumnEnd, SetGridColumnEnd,
                             PropertyId::NonCustom(LonghandId::GridColumnEnd.into())],
                                [Grid_column_start, SetGrid_column_start,
                                 PropertyId::NonCustom(LonghandId::GridColumnStart.into())],
                            [GridColumnStart, SetGridColumnStart,
                             PropertyId::NonCustom(LonghandId::GridColumnStart.into())],
                                [Grid_row_end, SetGrid_row_end,
                                 PropertyId::NonCustom(LonghandId::GridRowEnd.into())],
                            [GridRowEnd, SetGridRowEnd,
                             PropertyId::NonCustom(LonghandId::GridRowEnd.into())],
                                [Grid_row_start, SetGrid_row_start,
                                 PropertyId::NonCustom(LonghandId::GridRowStart.into())],
                            [GridRowStart, SetGridRowStart,
                             PropertyId::NonCustom(LonghandId::GridRowStart.into())],
                                [Max_block_size, SetMax_block_size,
                                 PropertyId::NonCustom(LonghandId::MaxBlockSize.into())],
                            [MaxBlockSize, SetMaxBlockSize,
                             PropertyId::NonCustom(LonghandId::MaxBlockSize.into())],
                                [Max_height, SetMax_height,
                                 PropertyId::NonCustom(LonghandId::MaxHeight.into())],
                            [MaxHeight, SetMaxHeight,
                             PropertyId::NonCustom(LonghandId::MaxHeight.into())],
                                [Max_inline_size, SetMax_inline_size,
                                 PropertyId::NonCustom(LonghandId::MaxInlineSize.into())],
                            [MaxInlineSize, SetMaxInlineSize,
                             PropertyId::NonCustom(LonghandId::MaxInlineSize.into())],
                                [Max_width, SetMax_width,
                                 PropertyId::NonCustom(LonghandId::MaxWidth.into())],
                            [MaxWidth, SetMaxWidth,
                             PropertyId::NonCustom(LonghandId::MaxWidth.into())],
                                [Border_bottom_left_radius, SetBorder_bottom_left_radius,
                                 PropertyId::NonCustom(LonghandId::BorderBottomLeftRadius.into())],
                            [BorderBottomLeftRadius, SetBorderBottomLeftRadius,
                             PropertyId::NonCustom(LonghandId::BorderBottomLeftRadius.into())],
                                [Border_bottom_right_radius, SetBorder_bottom_right_radius,
                                 PropertyId::NonCustom(LonghandId::BorderBottomRightRadius.into())],
                            [BorderBottomRightRadius, SetBorderBottomRightRadius,
                             PropertyId::NonCustom(LonghandId::BorderBottomRightRadius.into())],
                                [Border_end_end_radius, SetBorder_end_end_radius,
                                 PropertyId::NonCustom(LonghandId::BorderEndEndRadius.into())],
                            [BorderEndEndRadius, SetBorderEndEndRadius,
                             PropertyId::NonCustom(LonghandId::BorderEndEndRadius.into())],
                                [Border_end_start_radius, SetBorder_end_start_radius,
                                 PropertyId::NonCustom(LonghandId::BorderEndStartRadius.into())],
                            [BorderEndStartRadius, SetBorderEndStartRadius,
                             PropertyId::NonCustom(LonghandId::BorderEndStartRadius.into())],
                                [Border_start_end_radius, SetBorder_start_end_radius,
                                 PropertyId::NonCustom(LonghandId::BorderStartEndRadius.into())],
                            [BorderStartEndRadius, SetBorderStartEndRadius,
                             PropertyId::NonCustom(LonghandId::BorderStartEndRadius.into())],
                                [Border_start_start_radius, SetBorder_start_start_radius,
                                 PropertyId::NonCustom(LonghandId::BorderStartStartRadius.into())],
                            [BorderStartStartRadius, SetBorderStartStartRadius,
                             PropertyId::NonCustom(LonghandId::BorderStartStartRadius.into())],
                                [Border_top_left_radius, SetBorder_top_left_radius,
                                 PropertyId::NonCustom(LonghandId::BorderTopLeftRadius.into())],
                            [BorderTopLeftRadius, SetBorderTopLeftRadius,
                             PropertyId::NonCustom(LonghandId::BorderTopLeftRadius.into())],
                                [Border_top_right_radius, SetBorder_top_right_radius,
                                 PropertyId::NonCustom(LonghandId::BorderTopRightRadius.into())],
                            [BorderTopRightRadius, SetBorderTopRightRadius,
                             PropertyId::NonCustom(LonghandId::BorderTopRightRadius.into())],
                            [Bottom, SetBottom,
                             PropertyId::NonCustom(LonghandId::Bottom.into())],
                                [Inset_block_end, SetInset_block_end,
                                 PropertyId::NonCustom(LonghandId::InsetBlockEnd.into())],
                            [InsetBlockEnd, SetInsetBlockEnd,
                             PropertyId::NonCustom(LonghandId::InsetBlockEnd.into())],
                                [Inset_block_start, SetInset_block_start,
                                 PropertyId::NonCustom(LonghandId::InsetBlockStart.into())],
                            [InsetBlockStart, SetInsetBlockStart,
                             PropertyId::NonCustom(LonghandId::InsetBlockStart.into())],
                                [Inset_inline_end, SetInset_inline_end,
                                 PropertyId::NonCustom(LonghandId::InsetInlineEnd.into())],
                            [InsetInlineEnd, SetInsetInlineEnd,
                             PropertyId::NonCustom(LonghandId::InsetInlineEnd.into())],
                                [Inset_inline_start, SetInset_inline_start,
                                 PropertyId::NonCustom(LonghandId::InsetInlineStart.into())],
                            [InsetInlineStart, SetInsetInlineStart,
                             PropertyId::NonCustom(LonghandId::InsetInlineStart.into())],
                            [Left, SetLeft,
                             PropertyId::NonCustom(LonghandId::Left.into())],
                            [Right, SetRight,
                             PropertyId::NonCustom(LonghandId::Right.into())],
                            [Top, SetTop,
                             PropertyId::NonCustom(LonghandId::Top.into())],
                                [Margin_block_end, SetMargin_block_end,
                                 PropertyId::NonCustom(LonghandId::MarginBlockEnd.into())],
                            [MarginBlockEnd, SetMarginBlockEnd,
                             PropertyId::NonCustom(LonghandId::MarginBlockEnd.into())],
                                [Margin_block_start, SetMargin_block_start,
                                 PropertyId::NonCustom(LonghandId::MarginBlockStart.into())],
                            [MarginBlockStart, SetMarginBlockStart,
                             PropertyId::NonCustom(LonghandId::MarginBlockStart.into())],
                                [Margin_bottom, SetMargin_bottom,
                                 PropertyId::NonCustom(LonghandId::MarginBottom.into())],
                            [MarginBottom, SetMarginBottom,
                             PropertyId::NonCustom(LonghandId::MarginBottom.into())],
                                [Margin_inline_end, SetMargin_inline_end,
                                 PropertyId::NonCustom(LonghandId::MarginInlineEnd.into())],
                            [MarginInlineEnd, SetMarginInlineEnd,
                             PropertyId::NonCustom(LonghandId::MarginInlineEnd.into())],
                                [Margin_inline_start, SetMargin_inline_start,
                                 PropertyId::NonCustom(LonghandId::MarginInlineStart.into())],
                            [MarginInlineStart, SetMarginInlineStart,
                             PropertyId::NonCustom(LonghandId::MarginInlineStart.into())],
                                [Margin_left, SetMargin_left,
                                 PropertyId::NonCustom(LonghandId::MarginLeft.into())],
                            [MarginLeft, SetMarginLeft,
                             PropertyId::NonCustom(LonghandId::MarginLeft.into())],
                                [Margin_right, SetMargin_right,
                                 PropertyId::NonCustom(LonghandId::MarginRight.into())],
                            [MarginRight, SetMarginRight,
                             PropertyId::NonCustom(LonghandId::MarginRight.into())],
                                [Margin_top, SetMargin_top,
                                 PropertyId::NonCustom(LonghandId::MarginTop.into())],
                            [MarginTop, SetMarginTop,
                             PropertyId::NonCustom(LonghandId::MarginTop.into())],
                                [Padding_block_end, SetPadding_block_end,
                                 PropertyId::NonCustom(LonghandId::PaddingBlockEnd.into())],
                            [PaddingBlockEnd, SetPaddingBlockEnd,
                             PropertyId::NonCustom(LonghandId::PaddingBlockEnd.into())],
                                [Padding_block_start, SetPadding_block_start,
                                 PropertyId::NonCustom(LonghandId::PaddingBlockStart.into())],
                            [PaddingBlockStart, SetPaddingBlockStart,
                             PropertyId::NonCustom(LonghandId::PaddingBlockStart.into())],
                                [Padding_bottom, SetPadding_bottom,
                                 PropertyId::NonCustom(LonghandId::PaddingBottom.into())],
                            [PaddingBottom, SetPaddingBottom,
                             PropertyId::NonCustom(LonghandId::PaddingBottom.into())],
                                [Padding_inline_end, SetPadding_inline_end,
                                 PropertyId::NonCustom(LonghandId::PaddingInlineEnd.into())],
                            [PaddingInlineEnd, SetPaddingInlineEnd,
                             PropertyId::NonCustom(LonghandId::PaddingInlineEnd.into())],
                                [Padding_inline_start, SetPadding_inline_start,
                                 PropertyId::NonCustom(LonghandId::PaddingInlineStart.into())],
                            [PaddingInlineStart, SetPaddingInlineStart,
                             PropertyId::NonCustom(LonghandId::PaddingInlineStart.into())],
                                [Padding_left, SetPadding_left,
                                 PropertyId::NonCustom(LonghandId::PaddingLeft.into())],
                            [PaddingLeft, SetPaddingLeft,
                             PropertyId::NonCustom(LonghandId::PaddingLeft.into())],
                                [Padding_right, SetPadding_right,
                                 PropertyId::NonCustom(LonghandId::PaddingRight.into())],
                            [PaddingRight, SetPaddingRight,
                             PropertyId::NonCustom(LonghandId::PaddingRight.into())],
                                [Padding_top, SetPadding_top,
                                 PropertyId::NonCustom(LonghandId::PaddingTop.into())],
                            [PaddingTop, SetPaddingTop,
                             PropertyId::NonCustom(LonghandId::PaddingTop.into())],
                                [Block_size, SetBlock_size,
                                 PropertyId::NonCustom(LonghandId::BlockSize.into())],
                            [BlockSize, SetBlockSize,
                             PropertyId::NonCustom(LonghandId::BlockSize.into())],
                            [Height, SetHeight,
                             PropertyId::NonCustom(LonghandId::Height.into())],
                                [Inline_size, SetInline_size,
                                 PropertyId::NonCustom(LonghandId::InlineSize.into())],
                            [InlineSize, SetInlineSize,
                             PropertyId::NonCustom(LonghandId::InlineSize.into())],
                                [Min_block_size, SetMin_block_size,
                                 PropertyId::NonCustom(LonghandId::MinBlockSize.into())],
                            [MinBlockSize, SetMinBlockSize,
                             PropertyId::NonCustom(LonghandId::MinBlockSize.into())],
                                [Min_height, SetMin_height,
                                 PropertyId::NonCustom(LonghandId::MinHeight.into())],
                            [MinHeight, SetMinHeight,
                             PropertyId::NonCustom(LonghandId::MinHeight.into())],
                                [Min_inline_size, SetMin_inline_size,
                                 PropertyId::NonCustom(LonghandId::MinInlineSize.into())],
                            [MinInlineSize, SetMinInlineSize,
                             PropertyId::NonCustom(LonghandId::MinInlineSize.into())],
                                [Min_width, SetMin_width,
                                 PropertyId::NonCustom(LonghandId::MinWidth.into())],
                            [MinWidth, SetMinWidth,
                             PropertyId::NonCustom(LonghandId::MinWidth.into())],
                            [Width, SetWidth,
                             PropertyId::NonCustom(LonghandId::Width.into())],
                                [Border_block_end_width, SetBorder_block_end_width,
                                 PropertyId::NonCustom(LonghandId::BorderBlockEndWidth.into())],
                            [BorderBlockEndWidth, SetBorderBlockEndWidth,
                             PropertyId::NonCustom(LonghandId::BorderBlockEndWidth.into())],
                                [Border_block_start_width, SetBorder_block_start_width,
                                 PropertyId::NonCustom(LonghandId::BorderBlockStartWidth.into())],
                            [BorderBlockStartWidth, SetBorderBlockStartWidth,
                             PropertyId::NonCustom(LonghandId::BorderBlockStartWidth.into())],
                                [Border_bottom_width, SetBorder_bottom_width,
                                 PropertyId::NonCustom(LonghandId::BorderBottomWidth.into())],
                            [BorderBottomWidth, SetBorderBottomWidth,
                             PropertyId::NonCustom(LonghandId::BorderBottomWidth.into())],
                                [Border_inline_end_width, SetBorder_inline_end_width,
                                 PropertyId::NonCustom(LonghandId::BorderInlineEndWidth.into())],
                            [BorderInlineEndWidth, SetBorderInlineEndWidth,
                             PropertyId::NonCustom(LonghandId::BorderInlineEndWidth.into())],
                                [Border_inline_start_width, SetBorder_inline_start_width,
                                 PropertyId::NonCustom(LonghandId::BorderInlineStartWidth.into())],
                            [BorderInlineStartWidth, SetBorderInlineStartWidth,
                             PropertyId::NonCustom(LonghandId::BorderInlineStartWidth.into())],
                                [Border_left_width, SetBorder_left_width,
                                 PropertyId::NonCustom(LonghandId::BorderLeftWidth.into())],
                            [BorderLeftWidth, SetBorderLeftWidth,
                             PropertyId::NonCustom(LonghandId::BorderLeftWidth.into())],
                                [Border_right_width, SetBorder_right_width,
                                 PropertyId::NonCustom(LonghandId::BorderRightWidth.into())],
                            [BorderRightWidth, SetBorderRightWidth,
                             PropertyId::NonCustom(LonghandId::BorderRightWidth.into())],
                                [Border_top_width, SetBorder_top_width,
                                 PropertyId::NonCustom(LonghandId::BorderTopWidth.into())],
                            [BorderTopWidth, SetBorderTopWidth,
                             PropertyId::NonCustom(LonghandId::BorderTopWidth.into())],
                                [Outline_width, SetOutline_width,
                                 PropertyId::NonCustom(LonghandId::OutlineWidth.into())],
                            [OutlineWidth, SetOutlineWidth,
                             PropertyId::NonCustom(LonghandId::OutlineWidth.into())],
                                [Background_color, SetBackground_color,
                                 PropertyId::NonCustom(LonghandId::BackgroundColor.into())],
                            [BackgroundColor, SetBackgroundColor,
                             PropertyId::NonCustom(LonghandId::BackgroundColor.into())],
                                [Border_block_end_color, SetBorder_block_end_color,
                                 PropertyId::NonCustom(LonghandId::BorderBlockEndColor.into())],
                            [BorderBlockEndColor, SetBorderBlockEndColor,
                             PropertyId::NonCustom(LonghandId::BorderBlockEndColor.into())],
                                [Border_block_start_color, SetBorder_block_start_color,
                                 PropertyId::NonCustom(LonghandId::BorderBlockStartColor.into())],
                            [BorderBlockStartColor, SetBorderBlockStartColor,
                             PropertyId::NonCustom(LonghandId::BorderBlockStartColor.into())],
                                [Border_bottom_color, SetBorder_bottom_color,
                                 PropertyId::NonCustom(LonghandId::BorderBottomColor.into())],
                            [BorderBottomColor, SetBorderBottomColor,
                             PropertyId::NonCustom(LonghandId::BorderBottomColor.into())],
                                [Border_inline_end_color, SetBorder_inline_end_color,
                                 PropertyId::NonCustom(LonghandId::BorderInlineEndColor.into())],
                            [BorderInlineEndColor, SetBorderInlineEndColor,
                             PropertyId::NonCustom(LonghandId::BorderInlineEndColor.into())],
                                [Border_inline_start_color, SetBorder_inline_start_color,
                                 PropertyId::NonCustom(LonghandId::BorderInlineStartColor.into())],
                            [BorderInlineStartColor, SetBorderInlineStartColor,
                             PropertyId::NonCustom(LonghandId::BorderInlineStartColor.into())],
                                [Border_left_color, SetBorder_left_color,
                                 PropertyId::NonCustom(LonghandId::BorderLeftColor.into())],
                            [BorderLeftColor, SetBorderLeftColor,
                             PropertyId::NonCustom(LonghandId::BorderLeftColor.into())],
                                [Border_right_color, SetBorder_right_color,
                                 PropertyId::NonCustom(LonghandId::BorderRightColor.into())],
                            [BorderRightColor, SetBorderRightColor,
                             PropertyId::NonCustom(LonghandId::BorderRightColor.into())],
                                [Border_top_color, SetBorder_top_color,
                                 PropertyId::NonCustom(LonghandId::BorderTopColor.into())],
                            [BorderTopColor, SetBorderTopColor,
                             PropertyId::NonCustom(LonghandId::BorderTopColor.into())],
                                [Outline_color, SetOutline_color,
                                 PropertyId::NonCustom(LonghandId::OutlineColor.into())],
                            [OutlineColor, SetOutlineColor,
                             PropertyId::NonCustom(LonghandId::OutlineColor.into())],
                                [Text_decoration_color, SetText_decoration_color,
                                 PropertyId::NonCustom(LonghandId::TextDecorationColor.into())],
                            [TextDecorationColor, SetTextDecorationColor,
                             PropertyId::NonCustom(LonghandId::TextDecorationColor.into())],
                            [Background, SetBackground,
                             PropertyId::NonCustom(ShorthandId::Background.into())],
                                [Background_position, SetBackground_position,
                                 PropertyId::NonCustom(ShorthandId::BackgroundPosition.into())],
                            [BackgroundPosition, SetBackgroundPosition,
                             PropertyId::NonCustom(ShorthandId::BackgroundPosition.into())],
                                [Border_color, SetBorder_color,
                                 PropertyId::NonCustom(ShorthandId::BorderColor.into())],
                            [BorderColor, SetBorderColor,
                             PropertyId::NonCustom(ShorthandId::BorderColor.into())],
                                [Border_style, SetBorder_style,
                                 PropertyId::NonCustom(ShorthandId::BorderStyle.into())],
                            [BorderStyle, SetBorderStyle,
                             PropertyId::NonCustom(ShorthandId::BorderStyle.into())],
                                [Border_width, SetBorder_width,
                                 PropertyId::NonCustom(ShorthandId::BorderWidth.into())],
                            [BorderWidth, SetBorderWidth,
                             PropertyId::NonCustom(ShorthandId::BorderWidth.into())],
                                [Border_top, SetBorder_top,
                                 PropertyId::NonCustom(ShorthandId::BorderTop.into())],
                            [BorderTop, SetBorderTop,
                             PropertyId::NonCustom(ShorthandId::BorderTop.into())],
                                [Border_right, SetBorder_right,
                                 PropertyId::NonCustom(ShorthandId::BorderRight.into())],
                            [BorderRight, SetBorderRight,
                             PropertyId::NonCustom(ShorthandId::BorderRight.into())],
                                [Border_bottom, SetBorder_bottom,
                                 PropertyId::NonCustom(ShorthandId::BorderBottom.into())],
                            [BorderBottom, SetBorderBottom,
                             PropertyId::NonCustom(ShorthandId::BorderBottom.into())],
                                [Border_left, SetBorder_left,
                                 PropertyId::NonCustom(ShorthandId::BorderLeft.into())],
                            [BorderLeft, SetBorderLeft,
                             PropertyId::NonCustom(ShorthandId::BorderLeft.into())],
                                [Border_block_start, SetBorder_block_start,
                                 PropertyId::NonCustom(ShorthandId::BorderBlockStart.into())],
                            [BorderBlockStart, SetBorderBlockStart,
                             PropertyId::NonCustom(ShorthandId::BorderBlockStart.into())],
                                [Border_block_end, SetBorder_block_end,
                                 PropertyId::NonCustom(ShorthandId::BorderBlockEnd.into())],
                            [BorderBlockEnd, SetBorderBlockEnd,
                             PropertyId::NonCustom(ShorthandId::BorderBlockEnd.into())],
                                [Border_inline_start, SetBorder_inline_start,
                                 PropertyId::NonCustom(ShorthandId::BorderInlineStart.into())],
                            [BorderInlineStart, SetBorderInlineStart,
                             PropertyId::NonCustom(ShorthandId::BorderInlineStart.into())],
                                [Border_inline_end, SetBorder_inline_end,
                                 PropertyId::NonCustom(ShorthandId::BorderInlineEnd.into())],
                            [BorderInlineEnd, SetBorderInlineEnd,
                             PropertyId::NonCustom(ShorthandId::BorderInlineEnd.into())],
                            [Border, SetBorder,
                             PropertyId::NonCustom(ShorthandId::Border.into())],
                                [Border_radius, SetBorder_radius,
                                 PropertyId::NonCustom(ShorthandId::BorderRadius.into())],
                            [BorderRadius, SetBorderRadius,
                             PropertyId::NonCustom(ShorthandId::BorderRadius.into())],
                                [Border_image, SetBorder_image,
                                 PropertyId::NonCustom(ShorthandId::BorderImage.into())],
                            [BorderImage, SetBorderImage,
                             PropertyId::NonCustom(ShorthandId::BorderImage.into())],
                                [Border_block_width, SetBorder_block_width,
                                 PropertyId::NonCustom(ShorthandId::BorderBlockWidth.into())],
                            [BorderBlockWidth, SetBorderBlockWidth,
                             PropertyId::NonCustom(ShorthandId::BorderBlockWidth.into())],
                                [Border_block_style, SetBorder_block_style,
                                 PropertyId::NonCustom(ShorthandId::BorderBlockStyle.into())],
                            [BorderBlockStyle, SetBorderBlockStyle,
                             PropertyId::NonCustom(ShorthandId::BorderBlockStyle.into())],
                                [Border_block_color, SetBorder_block_color,
                                 PropertyId::NonCustom(ShorthandId::BorderBlockColor.into())],
                            [BorderBlockColor, SetBorderBlockColor,
                             PropertyId::NonCustom(ShorthandId::BorderBlockColor.into())],
                                [Border_inline_width, SetBorder_inline_width,
                                 PropertyId::NonCustom(ShorthandId::BorderInlineWidth.into())],
                            [BorderInlineWidth, SetBorderInlineWidth,
                             PropertyId::NonCustom(ShorthandId::BorderInlineWidth.into())],
                                [Border_inline_style, SetBorder_inline_style,
                                 PropertyId::NonCustom(ShorthandId::BorderInlineStyle.into())],
                            [BorderInlineStyle, SetBorderInlineStyle,
                             PropertyId::NonCustom(ShorthandId::BorderInlineStyle.into())],
                                [Border_inline_color, SetBorder_inline_color,
                                 PropertyId::NonCustom(ShorthandId::BorderInlineColor.into())],
                            [BorderInlineColor, SetBorderInlineColor,
                             PropertyId::NonCustom(ShorthandId::BorderInlineColor.into())],
                                [Border_block, SetBorder_block,
                                 PropertyId::NonCustom(ShorthandId::BorderBlock.into())],
                            [BorderBlock, SetBorderBlock,
                             PropertyId::NonCustom(ShorthandId::BorderBlock.into())],
                                [Border_inline, SetBorder_inline,
                                 PropertyId::NonCustom(ShorthandId::BorderInline.into())],
                            [BorderInline, SetBorderInline,
                             PropertyId::NonCustom(ShorthandId::BorderInline.into())],
                            [Overflow, SetOverflow,
                             PropertyId::NonCustom(ShorthandId::Overflow.into())],
                            [Columns, SetColumns,
                             PropertyId::NonCustom(ShorthandId::Columns.into())],
                            [Font, SetFont,
                             PropertyId::NonCustom(ShorthandId::Font.into())],
                                [Font_variant, SetFont_variant,
                                 PropertyId::NonCustom(ShorthandId::FontVariant.into())],
                            [FontVariant, SetFontVariant,
                             PropertyId::NonCustom(ShorthandId::FontVariant.into())],
                                [White_space, SetWhite_space,
                                 PropertyId::NonCustom(ShorthandId::WhiteSpace.into())],
                            [WhiteSpace, SetWhiteSpace,
                             PropertyId::NonCustom(ShorthandId::WhiteSpace.into())],
                                [List_style, SetList_style,
                                 PropertyId::NonCustom(ShorthandId::ListStyle.into())],
                            [ListStyle, SetListStyle,
                             PropertyId::NonCustom(ShorthandId::ListStyle.into())],
                            [Margin, SetMargin,
                             PropertyId::NonCustom(ShorthandId::Margin.into())],
                                [Margin_block, SetMargin_block,
                                 PropertyId::NonCustom(ShorthandId::MarginBlock.into())],
                            [MarginBlock, SetMarginBlock,
                             PropertyId::NonCustom(ShorthandId::MarginBlock.into())],
                                [Margin_inline, SetMargin_inline,
                                 PropertyId::NonCustom(ShorthandId::MarginInline.into())],
                            [MarginInline, SetMarginInline,
                             PropertyId::NonCustom(ShorthandId::MarginInline.into())],
                            [Outline, SetOutline,
                             PropertyId::NonCustom(ShorthandId::Outline.into())],
                            [Padding, SetPadding,
                             PropertyId::NonCustom(ShorthandId::Padding.into())],
                                [Padding_block, SetPadding_block,
                                 PropertyId::NonCustom(ShorthandId::PaddingBlock.into())],
                            [PaddingBlock, SetPaddingBlock,
                             PropertyId::NonCustom(ShorthandId::PaddingBlock.into())],
                                [Padding_inline, SetPadding_inline,
                                 PropertyId::NonCustom(ShorthandId::PaddingInline.into())],
                            [PaddingInline, SetPaddingInline,
                             PropertyId::NonCustom(ShorthandId::PaddingInline.into())],
                                [Flex_flow, SetFlex_flow,
                                 PropertyId::NonCustom(ShorthandId::FlexFlow.into())],
                            [FlexFlow, SetFlexFlow,
                             PropertyId::NonCustom(ShorthandId::FlexFlow.into())],
                            [Flex, SetFlex,
                             PropertyId::NonCustom(ShorthandId::Flex.into())],
                            [Gap, SetGap,
                             PropertyId::NonCustom(ShorthandId::Gap.into())],
                                [Grid_gap, SetGrid_gap,
                                 PropertyId::NonCustom(ShorthandId::Gap.into())],
                            [GridGap, SetGridGap,
                             PropertyId::NonCustom(ShorthandId::Gap.into())],
                                [Grid_row, SetGrid_row,
                                 PropertyId::NonCustom(ShorthandId::GridRow.into())],
                            [GridRow, SetGridRow,
                             PropertyId::NonCustom(ShorthandId::GridRow.into())],
                                [Grid_column, SetGrid_column,
                                 PropertyId::NonCustom(ShorthandId::GridColumn.into())],
                            [GridColumn, SetGridColumn,
                             PropertyId::NonCustom(ShorthandId::GridColumn.into())],
                                [Grid_area, SetGrid_area,
                                 PropertyId::NonCustom(ShorthandId::GridArea.into())],
                            [GridArea, SetGridArea,
                             PropertyId::NonCustom(ShorthandId::GridArea.into())],
                                [Grid_template, SetGrid_template,
                                 PropertyId::NonCustom(ShorthandId::GridTemplate.into())],
                            [GridTemplate, SetGridTemplate,
                             PropertyId::NonCustom(ShorthandId::GridTemplate.into())],
                            [Grid, SetGrid,
                             PropertyId::NonCustom(ShorthandId::Grid.into())],
                                [Place_content, SetPlace_content,
                                 PropertyId::NonCustom(ShorthandId::PlaceContent.into())],
                            [PlaceContent, SetPlaceContent,
                             PropertyId::NonCustom(ShorthandId::PlaceContent.into())],
                                [Place_self, SetPlace_self,
                                 PropertyId::NonCustom(ShorthandId::PlaceSelf.into())],
                            [PlaceSelf, SetPlaceSelf,
                             PropertyId::NonCustom(ShorthandId::PlaceSelf.into())],
                                [Place_items, SetPlace_items,
                                 PropertyId::NonCustom(ShorthandId::PlaceItems.into())],
                            [PlaceItems, SetPlaceItems,
                             PropertyId::NonCustom(ShorthandId::PlaceItems.into())],
                            [Inset, SetInset,
                             PropertyId::NonCustom(ShorthandId::Inset.into())],
                                [Inset_block, SetInset_block,
                                 PropertyId::NonCustom(ShorthandId::InsetBlock.into())],
                            [InsetBlock, SetInsetBlock,
                             PropertyId::NonCustom(ShorthandId::InsetBlock.into())],
                                [Inset_inline, SetInset_inline,
                                 PropertyId::NonCustom(ShorthandId::InsetInline.into())],
                            [InsetInline, SetInsetInline,
                             PropertyId::NonCustom(ShorthandId::InsetInline.into())],
                                [Text_decoration, SetText_decoration,
                                 PropertyId::NonCustom(ShorthandId::TextDecoration.into())],
                            [TextDecoration, SetTextDecoration,
                             PropertyId::NonCustom(ShorthandId::TextDecoration.into())],
                            [Transition, SetTransition,
                             PropertyId::NonCustom(ShorthandId::Transition.into())],
                            [Animation, SetAnimation,
                             PropertyId::NonCustom(ShorthandId::Animation.into())],
                            [All, SetAll,
                             PropertyId::NonCustom(ShorthandId::All.into())],
        }
    }
}

/// Call the given macro with tokens like this for each longhand properties:
///
/// ```
/// { snake_case_ident }
/// ```
#[macro_export]
macro_rules! longhand_properties_idents {
    ($macro_name: ident) => {
        $macro_name! {
                { align_items }
                { aspect_ratio }
                { backface_visibility }
                { baseline_source }
                { border_collapse }
                { border_image_repeat }
                { box_sizing }
                { caption_side }
                { clear }
                { column_count }
                { column_span }
                { contain }
                { container_type }
                { direction }
                { display }
                { empty_cells }
                { flex_direction }
                { flex_wrap }
                { float }
                { font_language_override }
                { font_stretch }
                { font_style }
                { font_synthesis_weight }
                { font_variant_caps }
                { font_weight }
                { grid_auto_flow }
                { image_rendering }
                { isolation }
                { justify_items }
                { list_style_position }
                { list_style_type }
                { mix_blend_mode }
                { object_fit }
                { opacity }
                { order }
                { outline_style }
                { overflow_wrap }
                { pointer_events }
                { position }
                { position_area }
                { _servo_overflow_clip_box }
                { _servo_top_layer }
                { table_layout }
                { text_align }
                { text_align_last }
                { text_decoration_line }
                { text_decoration_style }
                { text_justify }
                { text_rendering }
                { text_transform }
                { text_wrap_mode }
                { transform_style }
                { unicode_bidi }
                { visibility }
                { white_space_collapse }
                { word_break }
                { writing_mode }
                { z_index }
                { zoom }
                { align_content }
                { justify_content }
                { flex_grow }
                { flex_shrink }
                { align_self }
                { justify_self }
                { overflow_block }
                { overflow_inline }
                { overflow_x }
                { overflow_y }
                { border_block_end_style }
                { border_block_start_style }
                { border_bottom_style }
                { border_inline_end_style }
                { border_inline_start_style }
                { border_left_style }
                { border_right_style }
                { border_top_style }
                { animation_composition }
                { animation_delay }
                { animation_direction }
                { animation_duration }
                { animation_fill_mode }
                { animation_iteration_count }
                { animation_name }
                { animation_play_state }
                { animation_timeline }
                { animation_timing_function }
                { backdrop_filter }
                { background_attachment }
                { background_clip }
                { background_image }
                { background_origin }
                { background_position_x }
                { background_position_y }
                { background_repeat }
                { background_size }
                { border_image_outset }
                { border_image_slice }
                { border_image_width }
                { border_spacing }
                { box_shadow }
                { clip }
                { clip_path }
                { color }
                { color_scheme }
                { column_width }
                { container_name }
                { content }
                { counter_increment }
                { counter_reset }
                { cursor }
                { filter }
                { flex_basis }
                { font_family }
                { font_size }
                { font_variation_settings }
                { grid_template_areas }
                { letter_spacing }
                { line_height }
                { mask_image }
                { offset_path }
                { outline_offset }
                { overflow_clip_margin }
                { perspective }
                { quotes }
                { rotate }
                { scale }
                { text_indent }
                { text_overflow }
                { text_shadow }
                { transform }
                { transform_origin }
                { transition_behavior }
                { transition_delay }
                { transition_duration }
                { transition_property }
                { transition_timing_function }
                { translate }
                { vertical_align }
                { view_transition_class }
                { view_transition_name }
                { will_change }
                { word_spacing }
                { _x_lang }
                { object_position }
                { perspective_origin }
                { grid_template_columns }
                { grid_template_rows }
                { border_image_source }
                { list_style_image }
                { grid_auto_columns }
                { grid_auto_rows }
                { column_gap }
                { row_gap }
                { grid_column_end }
                { grid_column_start }
                { grid_row_end }
                { grid_row_start }
                { max_block_size }
                { max_height }
                { max_inline_size }
                { max_width }
                { border_bottom_left_radius }
                { border_bottom_right_radius }
                { border_end_end_radius }
                { border_end_start_radius }
                { border_start_end_radius }
                { border_start_start_radius }
                { border_top_left_radius }
                { border_top_right_radius }
                { bottom }
                { inset_block_end }
                { inset_block_start }
                { inset_inline_end }
                { inset_inline_start }
                { left }
                { right }
                { top }
                { margin_block_end }
                { margin_block_start }
                { margin_bottom }
                { margin_inline_end }
                { margin_inline_start }
                { margin_left }
                { margin_right }
                { margin_top }
                { padding_block_end }
                { padding_block_start }
                { padding_bottom }
                { padding_inline_end }
                { padding_inline_start }
                { padding_left }
                { padding_right }
                { padding_top }
                { block_size }
                { height }
                { inline_size }
                { min_block_size }
                { min_height }
                { min_inline_size }
                { min_width }
                { width }
                { border_block_end_width }
                { border_block_start_width }
                { border_bottom_width }
                { border_inline_end_width }
                { border_inline_start_width }
                { border_left_width }
                { border_right_width }
                { border_top_width }
                { outline_width }
                { background_color }
                { border_block_end_color }
                { border_block_start_color }
                { border_bottom_color }
                { border_inline_end_color }
                { border_inline_start_color }
                { border_left_color }
                { border_right_color }
                { border_top_color }
                { outline_color }
                { text_decoration_color }
        }
    }
}

// Large pages generate tens of thousands of ComputedValues.
#[cfg(feature = "gecko")]
size_of_test!(ComputedValues, 248);
#[cfg(feature = "servo")]
size_of_test!(ComputedValues, 216);

// FFI relies on this.
size_of_test!(Option<Arc<ComputedValues>>, 8);

// There are two reasons for this test to fail:
//
//   * Your changes made a specified value type for a given property go
//     over the threshold. In that case, you should try to shrink it again
//     or, if not possible, mark the property as boxed in the property
//     definition.
//
//   * Your changes made a specified value type smaller, so that it no
//     longer needs to be boxed. In this case you just need to remove
//     boxed=True from the property definition. Nice job!
#[cfg(target_pointer_width = "64")]
#[allow(dead_code)] // https://github.com/rust-lang/rust/issues/96952
const BOX_THRESHOLD: usize = 24;
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::align_items::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::aspect_ratio::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::backface_visibility::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::baseline_source::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_collapse::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_image_repeat::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::box_sizing::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::caption_side::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::clear::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::column_count::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::column_span::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::contain::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::container_type::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::direction::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::display::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::empty_cells::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::flex_direction::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::flex_wrap::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::float::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_language_override::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_stretch::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_synthesis_weight::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_variant_caps::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_weight::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_auto_flow::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::image_rendering::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::isolation::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::justify_items::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::list_style_position::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::list_style_type::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::mix_blend_mode::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::object_fit::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::opacity::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::order::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::outline_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::overflow_wrap::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::pointer_events::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::position::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::position_area::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::_servo_overflow_clip_box::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::_servo_top_layer::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::table_layout::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_align::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_align_last::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_decoration_line::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_decoration_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_justify::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_rendering::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_transform::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_wrap_mode::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transform_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::unicode_bidi::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::visibility::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::white_space_collapse::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::word_break::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::writing_mode::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::z_index::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::zoom::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::align_content::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::justify_content::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::flex_grow::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::flex_shrink::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::align_self::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::justify_self::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::overflow_block::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::overflow_inline::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::overflow_x::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::overflow_y::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_block_end_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_block_start_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_bottom_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_inline_end_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_inline_start_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_left_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_right_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_top_style::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_composition::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_delay::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_direction::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_duration::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_fill_mode::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_iteration_count::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_name::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_play_state::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_timeline::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::animation_timing_function::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::backdrop_filter::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_attachment::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_clip::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_image::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_origin::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_position_x::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_position_y::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_repeat::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_image_outset::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_image_slice::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_image_width::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_spacing::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::box_shadow::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::clip::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::clip_path::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::color_scheme::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::column_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::container_name::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::content::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::counter_increment::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::counter_reset::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::cursor::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::filter::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::flex_basis::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_family::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::font_variation_settings::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_template_areas::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::letter_spacing::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::line_height::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::mask_image::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::offset_path::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::outline_offset::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::overflow_clip_margin::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::perspective::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::quotes::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::rotate::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::scale::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_indent::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_overflow::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_shadow::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transform::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transform_origin::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transition_behavior::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transition_delay::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transition_duration::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transition_property::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::transition_timing_function::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::translate::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::vertical_align::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::view_transition_class::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::view_transition_name::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::will_change::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::word_spacing::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::_x_lang::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::object_position::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::perspective_origin::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_template_columns::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_template_rows::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_image_source::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::list_style_image::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_auto_columns::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_auto_rows::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::column_gap::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::row_gap::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_column_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_column_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_row_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::grid_row_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::max_block_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::max_height::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::max_inline_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::max_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_bottom_left_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_bottom_right_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_end_end_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_end_start_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_start_end_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_start_start_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_top_left_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_top_right_radius::SpecifiedValue>() > BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::bottom::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::inset_block_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::inset_block_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::inset_inline_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::inset_inline_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::left::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::right::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::top::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_block_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_block_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_bottom::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_inline_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_inline_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_left::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_right::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::margin_top::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_block_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_block_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_bottom::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_inline_end::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_inline_start::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_left::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_right::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::padding_top::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::block_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::height::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::inline_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::min_block_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::min_height::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::min_inline_size::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::min_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_block_end_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_block_start_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_bottom_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_inline_end_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_inline_start_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_left_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_right_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_top_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::outline_width::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::background_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_block_end_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_block_start_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_bottom_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_inline_end_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_inline_start_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_left_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_right_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::border_top_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::outline_color::SpecifiedValue>() <= BOX_THRESHOLD);
#[cfg(target_pointer_width = "64")]
const_assert!(std::mem::size_of::<longhands::text_decoration_color::SpecifiedValue>() <= BOX_THRESHOLD);

pub(crate) fn restyle_damage_repaint (old: &ComputedValues, new: &ComputedValues) -> bool {
        
        let old_background = old.get_background();
        let new_background = new.get_background();
        if !std::ptr::eq(old_background, new_background) {
            if 
                old_background.background_color != new_background.background_color ||
                old_background.background_image != new_background.background_image ||
                old_background.background_position_x != new_background.background_position_x ||
                old_background.background_position_y != new_background.background_position_y ||
                old_background.background_repeat != new_background.background_repeat ||
                old_background.background_attachment != new_background.background_attachment ||
                old_background.background_clip != new_background.background_clip ||
                old_background.background_origin != new_background.background_origin ||
                old_background.background_size != new_background.background_size ||
            false {
                return true;
            }
        }
        
        let old_border = old.get_border();
        let new_border = new.get_border();
        if !std::ptr::eq(old_border, new_border) {
            if 
                old_border.border_image_source != new_border.border_image_source ||
                old_border.border_image_outset != new_border.border_image_outset ||
                old_border.border_image_repeat != new_border.border_image_repeat ||
                old_border.border_image_width != new_border.border_image_width ||
                old_border.border_image_slice != new_border.border_image_slice ||
            false {
                return true;
            }
        }
        
        let old_box = old.get_box();
        let new_box = new.get_box();
        if !std::ptr::eq(old_box, new_box) {
            if 
                old_box.isolation != new_box.isolation ||
                old_box.backface_visibility != new_box.backface_visibility ||
            false {
                return true;
            }
        }
        
        
        
        let old_effects = old.get_effects();
        let new_effects = new.get_effects();
        if !std::ptr::eq(old_effects, new_effects) {
            if 
                old_effects.opacity != new_effects.opacity ||
                old_effects.filter != new_effects.filter ||
                old_effects.mix_blend_mode != new_effects.mix_blend_mode ||
            false {
                return true;
            }
        }
        
        
        
        
        let old_inherited_text = old.get_inherited_text();
        let new_inherited_text = new.get_inherited_text();
        if !std::ptr::eq(old_inherited_text, new_inherited_text) {
            if 
                old_inherited_text.color != new_inherited_text.color ||
                old_inherited_text.text_shadow != new_inherited_text.text_shadow ||
            false {
                return true;
            }
        }
        
        let old_inherited_ui = old.get_inherited_ui();
        let new_inherited_ui = new.get_inherited_ui();
        if !std::ptr::eq(old_inherited_ui, new_inherited_ui) {
            if 
                old_inherited_ui.cursor != new_inherited_ui.cursor ||
                old_inherited_ui.pointer_events != new_inherited_ui.pointer_events ||
            false {
                return true;
            }
        }
        
        
        
        let old_outline = old.get_outline();
        let new_outline = new.get_outline();
        if !std::ptr::eq(old_outline, new_outline) {
            if 
                old_outline.outline_color != new_outline.outline_color ||
                old_outline.outline_style != new_outline.outline_style ||
                old_outline.outline_width != new_outline.outline_width ||
                old_outline.outline_offset != new_outline.outline_offset ||
            false {
                return true;
            }
        }
        
        
        
        let old_svg = old.get_svg();
        let new_svg = new.get_svg();
        if !std::ptr::eq(old_svg, new_svg) {
            if 
                old_svg.clip_path != new_svg.clip_path ||
            false {
                return true;
            }
        }
        
        
        
    false
}
pub(crate) fn restyle_damage_recalculate_overflow (old: &ComputedValues, new: &ComputedValues) -> bool {
        
        
        
        let old_box = old.get_box();
        let new_box = new.get_box();
        if !std::ptr::eq(old_box, new_box) {
            if 
                old_box.transform != new_box.transform ||
                old_box.rotate != new_box.rotate ||
                old_box.scale != new_box.scale ||
                old_box.translate != new_box.translate ||
                old_box.perspective != new_box.perspective ||
                old_box.perspective_origin != new_box.perspective_origin ||
                old_box.transform_style != new_box.transform_style ||
                old_box.transform_origin != new_box.transform_origin ||
            false {
                return true;
            }
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        let old_text = old.get_text();
        let new_text = new.get_text();
        if !std::ptr::eq(old_text, new_text) {
            if 
                old_text.text_decoration_line != new_text.text_decoration_line ||
                old_text.text_decoration_style != new_text.text_decoration_style ||
                old_text.text_decoration_color != new_text.text_decoration_color ||
            false {
                return true;
            }
        }
        
    false
}
pub(crate) fn restyle_damage_rebuild_stacking_context (old: &ComputedValues, new: &ComputedValues) -> bool {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        let old_position = old.get_position();
        let new_position = new.get_position();
        if !std::ptr::eq(old_position, new_position) {
            if 
                old_position.z_index != new_position.z_index ||
            false {
                return true;
            }
        }
        
        
        
        
    false
}
pub(crate) fn restyle_damage_rebuild_box (old: &ComputedValues, new: &ComputedValues) -> bool {
        
        
        let old_border = old.get_border();
        let new_border = new.get_border();
        if !std::ptr::eq(old_border, new_border) {
            if 
                old_border.border_top_color != new_border.border_top_color ||
                old_border.border_top_style != new_border.border_top_style ||
                old_border.border_top_width != new_border.border_top_width ||
                old_border.border_right_color != new_border.border_right_color ||
                old_border.border_right_style != new_border.border_right_style ||
                old_border.border_right_width != new_border.border_right_width ||
                old_border.border_bottom_color != new_border.border_bottom_color ||
                old_border.border_bottom_style != new_border.border_bottom_style ||
                old_border.border_bottom_width != new_border.border_bottom_width ||
                old_border.border_left_color != new_border.border_left_color ||
                old_border.border_left_style != new_border.border_left_style ||
                old_border.border_left_width != new_border.border_left_width ||
                old_border.border_top_left_radius != new_border.border_top_left_radius ||
                old_border.border_top_right_radius != new_border.border_top_right_radius ||
                old_border.border_bottom_right_radius != new_border.border_bottom_right_radius ||
                old_border.border_bottom_left_radius != new_border.border_bottom_left_radius ||
            false {
                return true;
            }
        }
        
        let old_box = old.get_box();
        let new_box = new.get_box();
        if !std::ptr::eq(old_box, new_box) {
            if 
                old_box.display != new_box.display ||
                old_box._servo_top_layer != new_box._servo_top_layer ||
                old_box.position != new_box.position ||
                old_box.float != new_box.float ||
                old_box.clear != new_box.clear ||
                old_box.vertical_align != new_box.vertical_align ||
                old_box.baseline_source != new_box.baseline_source ||
                old_box._servo_overflow_clip_box != new_box._servo_overflow_clip_box ||
                old_box.overflow_y != new_box.overflow_y ||
                old_box.overflow_x != new_box.overflow_x ||
                old_box.offset_path != new_box.offset_path ||
                old_box.contain != new_box.contain ||
                old_box.container_type != new_box.container_type ||
                old_box.container_name != new_box.container_name ||
                old_box.will_change != new_box.will_change ||
                old_box.zoom != new_box.zoom ||
            false {
                return true;
            }
        }
        
        let old_column = old.get_column();
        let new_column = new.get_column();
        if !std::ptr::eq(old_column, new_column) {
            if 
                old_column.column_width != new_column.column_width ||
                old_column.column_count != new_column.column_count ||
                old_column.column_span != new_column.column_span ||
            false {
                return true;
            }
        }
        
        let old_counters = old.get_counters();
        let new_counters = new.get_counters();
        if !std::ptr::eq(old_counters, new_counters) {
            if 
                old_counters.content != new_counters.content ||
                old_counters.counter_increment != new_counters.counter_increment ||
                old_counters.counter_reset != new_counters.counter_reset ||
            false {
                return true;
            }
        }
        
        let old_effects = old.get_effects();
        let new_effects = new.get_effects();
        if !std::ptr::eq(old_effects, new_effects) {
            if 
                old_effects.box_shadow != new_effects.box_shadow ||
                old_effects.clip != new_effects.clip ||
                old_effects.backdrop_filter != new_effects.backdrop_filter ||
            false {
                return true;
            }
        }
        
        let old_font = old.get_font();
        let new_font = new.get_font();
        if !std::ptr::eq(old_font, new_font) {
            if 
                old_font.font_family != new_font.font_family ||
                old_font.font_style != new_font.font_style ||
                old_font.font_variant_caps != new_font.font_variant_caps ||
                old_font.font_weight != new_font.font_weight ||
                old_font.font_size != new_font.font_size ||
                old_font.font_synthesis_weight != new_font.font_synthesis_weight ||
                old_font.font_stretch != new_font.font_stretch ||
                old_font.font_variation_settings != new_font.font_variation_settings ||
                old_font.font_language_override != new_font.font_language_override ||
                old_font._x_lang != new_font._x_lang ||
                old_font.line_height != new_font.line_height ||
            false {
                return true;
            }
        }
        
        let old_inherited_box = old.get_inherited_box();
        let new_inherited_box = new.get_inherited_box();
        if !std::ptr::eq(old_inherited_box, new_inherited_box) {
            if 
                old_inherited_box.visibility != new_inherited_box.visibility ||
                old_inherited_box.writing_mode != new_inherited_box.writing_mode ||
                old_inherited_box.direction != new_inherited_box.direction ||
                old_inherited_box.image_rendering != new_inherited_box.image_rendering ||
            false {
                return true;
            }
        }
        
        let old_inherited_table = old.get_inherited_table();
        let new_inherited_table = new.get_inherited_table();
        if !std::ptr::eq(old_inherited_table, new_inherited_table) {
            if 
                old_inherited_table.border_collapse != new_inherited_table.border_collapse ||
                old_inherited_table.empty_cells != new_inherited_table.empty_cells ||
                old_inherited_table.caption_side != new_inherited_table.caption_side ||
                old_inherited_table.border_spacing != new_inherited_table.border_spacing ||
            false {
                return true;
            }
        }
        
        let old_inherited_text = old.get_inherited_text();
        let new_inherited_text = new.get_inherited_text();
        if !std::ptr::eq(old_inherited_text, new_inherited_text) {
            if 
                old_inherited_text.text_transform != new_inherited_text.text_transform ||
                old_inherited_text.text_indent != new_inherited_text.text_indent ||
                old_inherited_text.overflow_wrap != new_inherited_text.overflow_wrap ||
                old_inherited_text.word_break != new_inherited_text.word_break ||
                old_inherited_text.text_justify != new_inherited_text.text_justify ||
                old_inherited_text.text_align_last != new_inherited_text.text_align_last ||
                old_inherited_text.text_align != new_inherited_text.text_align ||
                old_inherited_text.letter_spacing != new_inherited_text.letter_spacing ||
                old_inherited_text.word_spacing != new_inherited_text.word_spacing ||
                old_inherited_text.white_space_collapse != new_inherited_text.white_space_collapse ||
                old_inherited_text.text_rendering != new_inherited_text.text_rendering ||
                old_inherited_text.text_wrap_mode != new_inherited_text.text_wrap_mode ||
            false {
                return true;
            }
        }
        
        let old_inherited_ui = old.get_inherited_ui();
        let new_inherited_ui = new.get_inherited_ui();
        if !std::ptr::eq(old_inherited_ui, new_inherited_ui) {
            if 
                old_inherited_ui.color_scheme != new_inherited_ui.color_scheme ||
            false {
                return true;
            }
        }
        
        let old_list = old.get_list();
        let new_list = new.get_list();
        if !std::ptr::eq(old_list, new_list) {
            if 
                old_list.list_style_position != new_list.list_style_position ||
                old_list.list_style_type != new_list.list_style_type ||
                old_list.list_style_image != new_list.list_style_image ||
                old_list.quotes != new_list.quotes ||
            false {
                return true;
            }
        }
        
        let old_margin = old.get_margin();
        let new_margin = new.get_margin();
        if !std::ptr::eq(old_margin, new_margin) {
            if 
                old_margin.margin_top != new_margin.margin_top ||
                old_margin.margin_right != new_margin.margin_right ||
                old_margin.margin_bottom != new_margin.margin_bottom ||
                old_margin.margin_left != new_margin.margin_left ||
                old_margin.overflow_clip_margin != new_margin.overflow_clip_margin ||
            false {
                return true;
            }
        }
        
        
        let old_padding = old.get_padding();
        let new_padding = new.get_padding();
        if !std::ptr::eq(old_padding, new_padding) {
            if 
                old_padding.padding_top != new_padding.padding_top ||
                old_padding.padding_right != new_padding.padding_right ||
                old_padding.padding_bottom != new_padding.padding_bottom ||
                old_padding.padding_left != new_padding.padding_left ||
            false {
                return true;
            }
        }
        
        let old_position = old.get_position();
        let new_position = new.get_position();
        if !std::ptr::eq(old_position, new_position) {
            if 
                old_position.top != new_position.top ||
                old_position.right != new_position.right ||
                old_position.bottom != new_position.bottom ||
                old_position.left != new_position.left ||
                old_position.flex_direction != new_position.flex_direction ||
                old_position.flex_wrap != new_position.flex_wrap ||
                old_position.justify_content != new_position.justify_content ||
                old_position.align_content != new_position.align_content ||
                old_position.align_items != new_position.align_items ||
                old_position.justify_items != new_position.justify_items ||
                old_position.flex_grow != new_position.flex_grow ||
                old_position.flex_shrink != new_position.flex_shrink ||
                old_position.align_self != new_position.align_self ||
                old_position.justify_self != new_position.justify_self ||
                old_position.order != new_position.order ||
                old_position.flex_basis != new_position.flex_basis ||
                old_position.height != new_position.height ||
                old_position.min_height != new_position.min_height ||
                old_position.max_height != new_position.max_height ||
                old_position.width != new_position.width ||
                old_position.min_width != new_position.min_width ||
                old_position.max_width != new_position.max_width ||
                old_position.position_area != new_position.position_area ||
                old_position.box_sizing != new_position.box_sizing ||
                old_position.object_fit != new_position.object_fit ||
                old_position.object_position != new_position.object_position ||
                old_position.grid_row_start != new_position.grid_row_start ||
                old_position.grid_row_end != new_position.grid_row_end ||
                old_position.grid_auto_rows != new_position.grid_auto_rows ||
                old_position.grid_template_rows != new_position.grid_template_rows ||
                old_position.grid_column_start != new_position.grid_column_start ||
                old_position.grid_column_end != new_position.grid_column_end ||
                old_position.grid_auto_columns != new_position.grid_auto_columns ||
                old_position.grid_template_columns != new_position.grid_template_columns ||
                old_position.grid_auto_flow != new_position.grid_auto_flow ||
                old_position.grid_template_areas != new_position.grid_template_areas ||
                old_position.column_gap != new_position.column_gap ||
                old_position.row_gap != new_position.row_gap ||
                old_position.aspect_ratio != new_position.aspect_ratio ||
            false {
                return true;
            }
        }
        
        let old_svg = old.get_svg();
        let new_svg = new.get_svg();
        if !std::ptr::eq(old_svg, new_svg) {
            if 
                old_svg.mask_image != new_svg.mask_image ||
            false {
                return true;
            }
        }
        
        let old_table = old.get_table();
        let new_table = new.get_table();
        if !std::ptr::eq(old_table, new_table) {
            if 
                old_table.table_layout != new_table.table_layout ||
            false {
                return true;
            }
        }
        
        let old_text = old.get_text();
        let new_text = new.get_text();
        if !std::ptr::eq(old_text, new_text) {
            if 
                old_text.text_overflow != new_text.text_overflow ||
                old_text.unicode_bidi != new_text.unicode_bidi ||
            false {
                return true;
            }
        }
        
        let old_ui = old.get_ui();
        let new_ui = new.get_ui();
        if !std::ptr::eq(old_ui, new_ui) {
            if 
                old_ui.transition_duration != new_ui.transition_duration ||
                old_ui.transition_timing_function != new_ui.transition_timing_function ||
                old_ui.transition_property != new_ui.transition_property ||
                old_ui.transition_delay != new_ui.transition_delay ||
                old_ui.transition_behavior != new_ui.transition_behavior ||
                old_ui.animation_name != new_ui.animation_name ||
                old_ui.animation_duration != new_ui.animation_duration ||
                old_ui.animation_timing_function != new_ui.animation_timing_function ||
                old_ui.animation_iteration_count != new_ui.animation_iteration_count ||
                old_ui.animation_direction != new_ui.animation_direction ||
                old_ui.animation_play_state != new_ui.animation_play_state ||
                old_ui.animation_fill_mode != new_ui.animation_fill_mode ||
                old_ui.animation_composition != new_ui.animation_composition ||
                old_ui.animation_delay != new_ui.animation_delay ||
                old_ui.animation_timeline != new_ui.animation_timeline ||
                old_ui.view_transition_name != new_ui.view_transition_name ||
                old_ui.view_transition_class != new_ui.view_transition_class ||
            false {
                return true;
            }
        }
    false
}
